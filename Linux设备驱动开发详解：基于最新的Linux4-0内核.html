<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第1章 Linux设备驱动概述Linux设备驱动作用： 对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。 驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应">
<meta name="keywords" content="暂时无">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux设备驱动开发详解：基于最新的Linux4.0内核">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/Linux设备驱动开发详解：基于最新的Linux4-0内核.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:description" content="第1章 Linux设备驱动概述Linux设备驱动作用： 对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。 驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-06_20-02-51.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-08_22-29-27.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-09_01-50-17.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-09_02-04-32.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-09_02-42-08.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-09_03-39-00.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-11_12-19-25.png">
<meta property="og:updated_time" content="2019-03-12T13:33:40.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux设备驱动开发详解：基于最新的Linux4.0内核">
<meta name="twitter:description" content="第1章 Linux设备驱动概述Linux设备驱动作用： 对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。 驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应">
<meta name="twitter:image" content="d:/MyBlog/图片/Snipaste_2019-03-06_20-02-51.png">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/Linux设备驱动开发详解：基于最新的Linux4-0内核.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux设备驱动开发详解：基于最新的Linux4.0内核 | Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/Linux设备驱动开发详解：基于最新的Linux4-0内核.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux设备驱动开发详解：基于最新的Linux4.0内核
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-06 18:39:46" itemprop="dateCreated datePublished" datetime="2019-03-06T18:39:46+08:00">2019-03-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-12 21:33:40" itemprop="dateModified" datetime="2019-03-12T21:33:40+08:00">2019-03-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第1章-Linux设备驱动概述"><a href="#第1章-Linux设备驱动概述" class="headerlink" title="第1章 Linux设备驱动概述"></a>第1章 Linux设备驱动概述</h1><h2 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h2><p><strong>作用：</strong></p>
<p>对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具<br>体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的<br>映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。</p>
<p>驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应用软件工程师之间的<br>沟通</p>
<p><strong>角色：</strong> </p>
<ul>
<li>作为一个程序员, 你能够对你的驱动作出你自己的选择, 并且在所需的编程时间和结果的<br>灵活性之间, 选择一个可接受的平衡 ，而一个驱动程序的角色是提供机制, 而不是策略。</li>
<li>大部分的编程问题其实可以<br>划分为 2 部分:” 提供什么能力”(机制) 和 “如何使用这些能力”(策略). 如果这两方面<br>由程序的不同部分来表达, 或者甚至由不同的程序共同表达, 软件包是非常容易开发和适<br>应特殊的需求. </li>
<li>在编写驱动时, 程序员应当特别注意这个基础的概念: 编写内核代码来存取硬件, 不能强加特别的策略给用户, 因为不同的用户有不同的需求. 驱动应当做到使硬件可用, 将<br>所有关于如何使用硬件的事情留给应用程序. 一个驱动, 这样, 就是灵活的, 如果它提供<br>了对硬件能力的存取, 没有增加约束. 然而, 有时必须作出一些策略的决定. 例如, 一个<br>数字 I/O 驱动也许只提供对硬件的字符存取, 以便避免额外的代码处理单个位. （驱动负责机制（提供什么能力），而策略（如何使用这些能力）应交于应用。驱动不应强加策略。）</li>
<li>驱动: 是一个存在于应用程序和实际设备间的软件层. 驱<br>动的这种特权的角色允许驱动程序员严密地选择设备应该如何表现: 不同的驱动可以提供<br>不同的能力, 甚至是同一个设备. 实际的驱动设计应当是在许多不同考虑中的平衡. </li>
</ul>
<h2 id="内核划分"><a href="#内核划分" class="headerlink" title="内核划分"></a>内核划分</h2><p><strong>内核的角色可以划分成下列几个部分 ：</strong></p>
<ul>
<li><p><strong>进程管理</strong> </p>
<p>内核负责创建和销毁进程, 并处理它们与外部世界的联系(输入和输出). 不同进程<br>间通讯(通过信号, 管道, 或者进程间通讯原语)对整个系统功能来说是基本的, 也<br>由内核处理. 另外, 调度器, 控制进程如何共享 CPU, 是进程管理的一部分. 更通<br>常地, 内核的进程管理活动实现了多个进程在一个单个或者几个 CPU 之上的抽象.</p>
</li>
<li><p><strong>内存管理</strong></p>
<p>计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的. 内核为<br>所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间. 内核的不同部<br>分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更<br>复杂的功能.<br>文件系统<br>Unix 在很大程度上基于</p>
</li>
<li><p><strong>文件系统的概念</strong></p>
<p>几乎 Unix 中的任何东西都可看作一个<br>文件. 内核在非结构化的硬件之上建立了一个结构化的文件系统, 结果是文件的抽<br>象非常多地在整个系统中应用. 另外, Linux 支持多个文件系统类型, 就是说, 物<br>理介质上不同的数据组织方式. 例如, 磁盘可被格式化成标准 Linux 的 ext3 文<br>件系统, 普遍使用的 FAT 文件系统, 或者其他几个文件系统.</p>
</li>
<li><p><strong>设备控制</strong></p>
<p>几乎每个系统操作最终都映射到一个物理设备上. 除了处理器, 内存和非常少的别<br>的实体之外, 全部中的任何设备控制操作都由特定于要寻址的设备相关的代码来进<br>行. 这些代码称为设备驱动. 内核中必须嵌入系统中出现的每个外设的驱动, 从硬<br>盘驱动到键盘和磁带驱动器. 内核功能的这个方面是本书中的我们主要感兴趣的地<br>方. </p>
</li>
<li><p><strong>网络</strong></p>
<p>网络必须由操作系统来管理, 因为大部分网络操作不是特定于某一个进程: 进入系<br>统的报文是异步事件. 报文在某一个进程接手之前必须被收集, 识别, 分发. 系统<br>负责在程序和网络接口之间递送数据报文, 它必须根据程序的网络活动来控制程序<br>的执行. 另外, 所有的路由和地址解析问题都在内核中实现. </p>
</li>
</ul>
<h2 id="设备的分类及特点"><a href="#设备的分类及特点" class="headerlink" title="设备的分类及特点"></a>设备的分类及特点</h2><p>以 Linux 的将设备区分为 3 种基本设备类型.  </p>
<p><strong>字符设备</strong></p>
<p>字符( char ) 设备是一种可以当作一个字节流来存取的设备( 如同一个文<br>件 )。这样的驱动常常至少实现 open, close, read, 和 write 系统调用。文本控制台( /dev/console )和串口( /dev/ttyS0 及<br>其友 )是字符设备的例子，因为它们很好地展现了流的抽象。 字符设备通过文件系<br>统结点来存取， 例如 /dev/tty1 和 /dev/lp0。</p>
<p><strong>块设备</strong></p>
<p>如同字符设备, 块设备通过位于 /dev 目录的文件系统结点来存取. 一个块设备<br>(例如一个磁盘)应该是可以驻有一个文件系统的. 在大部分的 Unix 系统, 一个块<br>设备只能处理这样的 I/O 操作, 传送一个或多个长度经常是 512 字节( 或一个更<br>大的 2 的幂的数 )的整块. Linux, 相反, 允许应用程序读写一个块设备象一个字<br>符设备一样 – 它允许一次传送任意数目的字节. 结果就是, 块和字符设备的区别<br>仅仅在内核在内部管理数据的方式上, 并且因此在内核/驱动的软件接口上不同.<br>如同一个字符设备, 每个块设备都通过一个文件系统结点被存取的, 它们之间的区<br>别对用户是透明的. 块驱动和字符驱动相比, 与内核的接口完全不同.</p>
<p><strong>网络接口</strong></p>
<p>任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设<br>备. 通常, 一个接口是一个硬件设备, 但是它也可能是一个纯粹的软件设备, 比如<br>环回接口. 一个网络接口负责发送和接收数据报文, 在内核网络子系统的驱动下,<br>不必知道单个事务是如何映射到实际的被发送的报文上的. 很多网络连接( 特别那<br>些使用 TCP 的)是面向流的, 但是网络设备却常常设计成处理报文的发送和接收.<br>一个网络驱动对单个连接一无所知; 它只处理报文. </p>
<h2 id="Linux设备驱动与整个软硬件系统的关系"><a href="#Linux设备驱动与整个软硬件系统的关系" class="headerlink" title="Linux设备驱动与整个软硬件系统的关系"></a>Linux设备驱动与整个软硬件系统的关系</h2><p>除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open（）、write（）、read（）、close（）等即可访问字符设备和块设备。所有字符<br>设备和块设备都统一呈现给用户。</p>
<p>Linux的块设备有两种访问方法：</p>
<ul>
<li>一种是类似dd命令对应的原始块设<br>备，如“/dev/sdb1”等；</li>
<li>另外一种方法是在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径<br>如“/home/barry/hello.txt”的形式进行访问。</li>
</ul>
<p>在Linux中，针对NOR、NAND等提供了独立的内存技术设备<br>（Memory Technology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡<br>能力的文件系统。针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文<br>件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-06_20-02-51.png" alt="Snipaste_2019-03-06_20-02-51"></p>
<p>字符设备与块设备都被映射到Linux文件系统。可通过文件系统的系统调用接口（open（）、write（）、read（）、close（））来访问</p>
<p>字符设备，块设备与存技术设备子系统则通过虚拟文件系统（VFS）对其进行抽象。</p>
<h1 id="第2章：Linux内核模块程序结构"><a href="#第2章：Linux内核模块程序结构" class="headerlink" title="第2章：Linux内核模块程序结构"></a>第2章：Linux内核模块程序结构</h1><h2 id="Linux内核模块简介"><a href="#Linux内核模块简介" class="headerlink" title="Linux内核模块简介"></a>Linux内核模块简介</h2><p><strong>我们是怎样把需要的部分都包含在内</strong><br><strong>核中呢？</strong></p>
<ul>
<li><p>一种方法：是把所有需要的功能都编译到Linux内核中。这会导致两个问题。</p>
<p>（1）一是生成的内核会很大。</p>
<p>（2）二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核</p>
</li>
<li><p>另一种：机制可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时<br>候，其对应的代码被动态地加载到内核中，这种机制被称为模块（Module）.模块具有这样的特点。</p>
<p>（1）模块本身不被编译入内核映像，从而控制了内核的大小。</p>
<p>（2）模块一旦被加载，它就和内核中的其他部分完全一样。</p>
</li>
</ul>
<h2 id="Linux内核模块程序结构"><a href="#Linux内核模块程序结构" class="headerlink" title="Linux内核模块程序结构"></a>Linux内核模块程序结构</h2><p>一个Linux内核模块主要由如下几个部分组成</p>
<p>一个Linux内核模块主要由如下几个部分组成。</p>
<p><strong>（1）模块加载函数</strong></p>
<p>当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相<br>关初始化工作。</p>
<p><strong>（2）模块卸载函数</strong></p>
<p>当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功<br>能。</p>
<p><strong>（3）模块许可证声明</strong></p>
<p>许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到<br>内核被污染（Kernel Tainted）的警告。</p>
<p>在Linux内核模块领域，可接受的LICENSE包括“GPL”、“GPL v2”、“GPL and additional rights”、“Dual<br>BSD/GPL”、“Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary”，这<br>个在学术界和法律界都有争议）。<br>大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以<br>MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。</p>
<p><strong>（4）模块参数（可选）</strong></p>
<p>模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。</p>
<p><strong>（5）模块导出符号（可选）</strong></p>
<p>内核模块可以导出的符号（symbol，对应于内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的<br>变量或函数。</p>
<p><strong>（6）模块作者等信息声明（可选）</strong></p>
<h2 id="内核模块函数详解"><a href="#内核模块函数详解" class="headerlink" title="内核模块函数详解"></a>内核模块函数详解</h2><h3 id="模块加载函数"><a href="#模块加载函数" class="headerlink" title="模块加载函数"></a>模块加载函数</h3><p>Linux内核模块加载函数一般以__init标识声明， 典型的模块加载函数的形式如代码清单4.2所示。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单4.2 内核模块加载函数</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="keyword">int</span> _ _<span class="function">init <span class="title">initialization_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 初始化代码 */</span></span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> module_init(initialization_function);</span><br></pre></td></tr></table></figure>
<p>在Linux内核中， 可以使用request_module（const char*fmt， …） 函数加载内核模块， 驱动开发人员可<br>以通过调用下列代码： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_module(module_name);</span><br></pre></td></tr></table></figure>
<p>在Linux中， 所有标识为__init的函数如果直接编译进入内核， 成为内核镜像的一部分， 在连接的时候<br>都会放在.init.text这个区段内。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ _init     _ _attribute_ _ ((_ _section_ _ (<span class="meta-string">".init.text"</span>)))</span></span><br></pre></td></tr></table></figure>
<h3 id="模块卸载函数"><a href="#模块卸载函数" class="headerlink" title="模块卸载函数"></a>模块卸载函数</h3><p>Linux内核模块加载函数一般以__exit标识声明 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _ _<span class="function"><span class="built_in">exit</span> <span class="title">cleanup_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* 释放代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure>
<h3 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h3><p>我们可以用“module_param（参数名， 参数类型， 参数读/写权限） ”为模块定义一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *book_name = <span class="string">"dissecting Linux Device Driver"</span>;</span><br><span class="line">module_param(book_name, charp, S_IRUGO);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> book_num = <span class="number">4000</span>;</span><br><span class="line">module_param(book_num, <span class="keyword">int</span>, S_IRUGO);</span><br></pre></td></tr></table></figure>
<h3 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h3><p>Linux的“/proc/kallsyms”文件对应着内核符号表， 它记录了符号以及符号所在的内存地址。<br>模块可以使用如下宏导出符号到内核符号表中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名);</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名);</span><br></pre></td></tr></table></figure>
<p>导出的符号可以被其他模块使用， 只需使用前声明一下即可。 </p>
<h3 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h3><p>在Linux内核模块中， 我们可以用MODULE_AUTHOR、 MODULE_DESCRIPTION、<br>MODULE_VERSION、 MODULE_DEVICE_TABLE、 MODULE_ALIAS分别声明模块的作者、 描述、 版<br>本、 设备表和别名，  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCRIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure>
<h1 id="第2章：字符设备驱动"><a href="#第2章：字符设备驱动" class="headerlink" title="第2章：字符设备驱动"></a>第2章：字符设备驱动</h1><h2 id="Linux字符设备驱动结构"><a href="#Linux字符设备驱动结构" class="headerlink" title="Linux字符设备驱动结构"></a>Linux字符设备驱动结构</h2><h3 id="cdev结构体"><a href="#cdev结构体" class="headerlink" title="cdev结构体"></a>cdev结构体</h3><p>在Linux内核中， 使用cdev结构体描述一个字符设备 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;</span><br><span class="line">	struct kobject kobj; /* 内嵌的kobject对象 */</span><br><span class="line">	struct module *owner; /* 所属模块*/</span><br><span class="line">	struct file_operations *ops; /* 文件操作结构体*/</span><br><span class="line">	struct list_head list;</span><br><span class="line">	dev_t dev; /* 设备号*/</span><br><span class="line">	unsigned int count;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>成员dev_t</strong></p>
<p>cdev结构体的dev_t成员定义了设备号， 为32位， 其中12位为主设备号， 20位为次设备号。 使用下列<br>宏可以从dev_t获得主设备号和次设备号： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="keyword">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="keyword">dev_t</span> dev)</span><br></pre></td></tr></table></figure>
<p>而使用下列宏则可以通过主设备号和次设备号生成dev_t： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MKDEV(<span class="keyword">int</span> major, <span class="keyword">int</span> minor)</span><br></pre></td></tr></table></figure>
<p><strong>成员file_operations</strong></p>
<p>cdev结构体的另一个重要成员file_operations定义了字符设备驱动提供给虚拟文件系统的接口函数 </p>
<p>Linux内核提供了一组函数以用于操作cdev结构体： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *, struct file_operations *)</span></span>;</span><br><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_put</span><span class="params">(struct cdev *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *, <span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>cdev_init（） 函数用于初始化cdev的成员， 并建立cdev和file_operations之间的连接 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops; <span class="comment">/* 将传入的文件操作结构体指针赋值给cdev的ops*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>cdev_alloc（ ） 函数用于动态申请一个cdev内存 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> = <span class="title">kzalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">cdev</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">    	&#123;</span><br><span class="line">			INIT_LIST_HEAD(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">			kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cdev_add（ ） 函数和cdev_del（ ） 函数分别向系统添加和删除一个cdev， 完成字符设备的注册和注<br>销。 对cdev_add（ ） 的调用通常发生在字符设备驱动模块加载函数中， 而对cdev_del（ ） 函数的调用则通<br>常发生在字符设备驱动模块卸载函数中。 </p>
</li>
</ul>
<h3 id="分配和释放设备号"><a href="#分配和释放设备号" class="headerlink" title="分配和释放设备号"></a>分配和释放设备号</h3><p>在调用cdev_add（） 函数向系统注册字符设备之前， 应首先调用register_chrdev_region（） 或<br>alloc_chrdev_region（） 函数向系统申请设备号， 这两个函数的原型为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>register_chrdev_region（） 函数用于已知起始设备的设备号的情况， 而alloc_chrdev_region（） 用于设<br>备号未知， 向系统动态申请未被占用的设备号的情况， 函数调用成功之后， 会把得到的设备号放入第一个<br>参数dev中。 alloc_chrdev_region（） 相比于register_chrdev_region（） 的优点在于它会自动避开设备号重复<br>的冲突。 </p>
<p>相应地， 在调用cdev_del（） 函数从系统注销字符设备之后， unregister_chrdev_region（） 应该被调用<br>以释放原先申请的设备号， 这个函数的原型为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h3><p>file_operations结构体中的成员函数是字符设备驱动程序设计的主体内容， 这些函数实际会在应用程序<br>进行Linux的open（） 、 write（） 、 read（） 、 close（） 等系统调用时最终被内核调用。 file_operations结构<br>体目前已经比较庞大 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_operations结构体</span></span><br><span class="line"><span class="number">1</span>struct file_operations &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line">	<span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">	<span class="keyword">loff_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>file_operations结构体中的主要成员进行分析 :</p>
<p>略</p>
<h2 id="Linux字符设备驱动的组成"><a href="#Linux字符设备驱动的组成" class="headerlink" title="Linux字符设备驱动的组成"></a>Linux字符设备驱动的组成</h2><p><strong>1.字符设备驱动模块加载与卸载函数</strong>    </p>
<p>在字符设备驱动模块加载函数中应该实现设备号的申请和cdev的注册， 而在卸载函数中应实现设备号<br>的释放和cdev的注销。 </p>
<p>Linux内核的编码习惯是为设备定义一个设备相关的结构体， 该结构体包含设备所涉及的cdev、 私有<br>数据及锁等信息。 常见的设备结构体、 模块加载和卸载函数形式 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 代码6.5 设备结构体</span><br><span class="line">struct xxx_dev_t &#123;</span><br><span class="line"> 	struct cdev cdev;</span><br><span class="line">	 ...</span><br><span class="line">&#125; xxx_dev;</span><br><span class="line">/* 设备驱动模块加载函数</span><br><span class="line">static int _ _init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	 ...</span><br><span class="line">	cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); /* 初始化cdev */</span><br><span class="line">	 xxx_dev.cdev.owner = THIS_MODULE;</span><br><span class="line">/* 获取字符设备号*/</span><br><span class="line">	if (xxx_major) </span><br><span class="line">	&#123;</span><br><span class="line">		register_chrdev_region(xxx_dev_no, 1, DEV_NAME);</span><br><span class="line">	&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, 1); /* 注册设备*/</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 设备驱动模块卸载函数*/</span><br><span class="line">static void _ _exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	unregister_chrdev_region(xxx_dev_no, 1); /* 释放占用的设备号*/</span><br><span class="line">	cdev_del(&amp;xxx_dev.cdev); /* 注销设备*/</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.字符设备驱动的file_operations结构体中的成员函数</strong> </p>
<p>ile_operations结构体中的成员函数是字符设备驱动与内核虚拟文件系统的接口， 是用户空间对Linux<br>进行系统调用最终的落实者。 大多数字符设备驱动会实现read（） 、 write（） 和ioctl（） 函数， 常见的字<br>符设备驱动的这3个函数的形式 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">	.write = xxx_write,</span><br><span class="line">	.unlocked_ioctl= xxx_ioctl,</span><br><span class="line">	...</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">/* 读设备*/</span></span><br><span class="line"><span class="keyword">ssize_t</span> xxx_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,<span class="keyword">loff_t</span>*f_pos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_to_user(buf, ..., ...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写设备*/</span></span><br><span class="line"><span class="keyword">ssize_t</span> xxx_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *f_pos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_from_user(..., buf, ...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ioctl函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">xxx_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,	<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">case</span> XXX_CMD1:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> XXX_CMD2:</span><br><span class="line">			...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* 不能支持的命令 */</span></span><br><span class="line">		<span class="keyword">return</span> - ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备驱动的读函数中， filp是文件结构体指针， buf是用户空间内存的地址， 该地址在内核空间不宜直<br>接读写， count是要读的字节数， f_pos是读的位置相对于文件开头的偏移。</p>
<p>设备驱动的写函数中， filp是文件结构体指针， buf是用户空间内存的地址， 该地址在内核空间不宜直<br>接读写， count是要写的字节数， f_pos是写的位置相对于文件开头的偏移。</p>
<p>由于用户空间不能直接访问内核空间的内存， 因此借助了函数copy_from_user（） 完成用户空间缓冲<br>区到内核空间的复制， 以及copy_to_user（） 完成内核空间到用户空间缓冲区的复制， 见代码第6行和第14<br>行。</p>
<p>完成内核空间和用户空间内存复制的copy_from_user（） 和copy_to_user（） 的原型分别为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> _ _user *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> _ _user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述函数均返回不能被复制的字节数， 因此， 如果完全复制成功， 返回值为0。 如果复制失败， 则返<br>回负值。 </p>
<p>如果要复制的内存是简单类型， 如char、 int、 long等， 则可以使用简单的put_user（） 和<br>get_user（） ， 如： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val; <span class="comment">/* 内核空间整型变量</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">get_user(val, (int *) arg); /* 用户→内核， arg是用户空间的地址 */</span></span><br><span class="line">...</span><br><span class="line">put_user(val, (<span class="keyword">int</span> *) arg); <span class="comment">/* 内核→用户， arg是用户空间的地址 */</span></span><br></pre></td></tr></table></figure>
<p>在字符设备驱动中， 需要定义一个file_operations的实例， 并将具体设备驱动的函数赋值给<br>file_operations的成员 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">	.write = xxx_write,</span><br><span class="line">	.unlocked_ioctl= xxx_ioctl,</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述xxx_fops在代码清单6.5的cdev_init（&amp;xxx_dev.cdev， &amp;xxx_fops） 的语句中建立与cdev的连接。 </p>
<p>图6.1所示为字符设备驱动的结构、 字符设备驱动与字符设备以及字符设备驱动与用户空间访问该设<br>备的程序之间的关系。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-08_22-29-27.png" alt="Snipaste_2019-03-08_22-29-27"></p>
<p>个人理解：由图可知，内核的所有操作都是基于cdv结构体操作。其中的重中之重为dev_t，file_operations()成员以及加载和卸载函数。</p>
<p>dev_t：定义了设备号， 为32位， 其中12位为主设备号， 20位为次设备号。</p>
<p>file_operations():定义了字符设备驱动提供给虚拟文件系统的接口函数 ，该函数结构体为Linux内核提供了一组函数以用于操作cdev结构体。</p>
<p>加载及卸载函数：应该实现设备号的申请和cdev的注册及现设备号<br>的释放和cdev的注销。</p>
<p>而用户则通过Linux系统调用file_operations()定义的字符设备驱动提供给虚拟文件系统的接口函数 来实现底层的内核操作。</p>
<p>总结这个图是我见过的最精辟的，非常容易理解，有的则用一堆的结构体及函数来表示，看的头晕。</p>
<h2 id="第三章：驱动编写"><a href="#第三章：驱动编写" class="headerlink" title="第三章：驱动编写"></a>第三章：驱动编写</h2><h3 id="1-头文件、-宏及设备结构体"><a href="#1-头文件、-宏及设备结构体" class="headerlink" title="1.头文件、 宏及设备结构体"></a>1.头文件、 宏及设备结构体</h3><p>在globalmem字符设备驱动中， 应包含它要使用的头文件， 并定义globalmem设备结构体及相关宏。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1， 增加头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dev_major;</span><br></pre></td></tr></table></figure>
<h3 id="2-加载与卸载设备驱动"><a href="#2-加载与卸载设备驱动" class="headerlink" title="2.加载与卸载设备驱动"></a>2.加载与卸载设备驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	dev_major = register_chrdev(<span class="number">0</span>, <span class="string">"hello_dev"</span>, &amp;hello_fops);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	unregister_chrdev(dev_major, <span class="string">"hello_dev"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载和卸载的入口函数</span></span><br><span class="line">module_init(hello_drv_init);</span><br><span class="line">module_exit(hello_drv_exit);</span><br></pre></td></tr></table></figure>
<h3 id="3-添加GPL认证"><a href="#3-添加GPL认证" class="headerlink" title="3.添加GPL认证"></a>3.添加GPL认证</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>最简单的一个驱动实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  1， 增加头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dev_major;</span><br><span class="line">   <span class="comment">//3， 实现模块加载和卸载的入口函数</span></span><br><span class="line"><span class="comment">//函数的原形：一定要是返回值为int， 参数为void</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	dev_major = register_chrdev(<span class="number">0</span>, <span class="string">"hello_dev"</span>, &amp;hello_fops);<span class="comment">//加载设备号</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的原形：一定要是返回值为void， 参数为void</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	unregister_chrdev(dev_major, <span class="string">"hello_dev"</span>);<span class="comment">//卸载设备号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(hello_drv_init);</span><br><span class="line">module_exit(hello_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>装载和卸载模块命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># insmod  hello_drv.ko</span></span><br><span class="line"><span class="meta"># lsmod——显示已载入系统的模块</span></span><br><span class="line"><span class="meta"># rmmod hello_drv</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_01-50-17.png" alt="Snipaste_2019-03-09_01-50-17"></p>
<p>实际情况应该在装载及卸载时都打印出：——-^_^—–hello_dev—</p>
<p>注：lsmod——显示已载入系统的模块</p>
<p>​    申请主设备号是否成功：cat  /proc/devices</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_02-04-32.png" alt="Snipaste_2019-03-09_02-04-32"></p>
<p>​    </p>
<p><strong>函数讲解</strong></p>
<p>register_chrdev()</p>
<p>register_chrdev函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">const</span> struct file_operations *fops)</span></span></span><br></pre></td></tr></table></figure>
<p>* register_chrdev() -为字符设备注册一个主号码。</p>
<p>* @major:用于动态分配的主要设备号或0</p>
<p>* @name:这一系列设备的名称</p>
<p>* @fops:与此设备相关联的文件操作</p>
<p>*如果@major == 0，这个函数将动态分配一个main并返回它的号码。(静态注册主设备号)</p>
<p>*如果@major &gt; 0，此函数将尝试使用给定的设备保留设备，主要数字，将返回零成功。(动态注册主设备号)</p>
<h3 id="4-创建字符设备文件节点"><a href="#4-创建字符设备文件节点" class="headerlink" title="4. 创建字符设备文件节点"></a><strong>4. 创建字符设备文件节点</strong></h3><p>但是上面的驱动还是不完整的驱动，无法给用户使用的。</p>
<p>驱动为用户空间提供字符设备文件(设备文件/设备节点)：用户才能通过操作文件来操作驱动</p>
<p><strong>创建设备文件节点的两种方法</strong></p>
<p>1， 手动创建–mknod命令</p>
<p>mknod 文件名  类型  主设备号  次设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：</span></span><br><span class="line">	mknod  /dev/hello_dev  c  <span class="number">257</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_02-42-08.png" alt="Snipaste_2019-03-09_02-42-08"></p>
<p>2， 代码中自动创建–驱动装载就创建，卸载就直接删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类--将设备归类</span></span><br><span class="line"><span class="comment">//参数1--类是又哪个模块创建的，一般直接填THIS_MODULE</span></span><br><span class="line"><span class="comment">//参数2--类的名字，一般自定义</span></span><br><span class="line">class_create(owner,name)</span><br><span class="line">==》 struct class *class_create(struct <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">//在该类中创建某个设备</span></span><br><span class="line"><span class="comment">//参数1--哪个类别中</span></span><br><span class="line"><span class="comment">//参数2--当前创建的设备对象的父类，一般直接填NULL</span></span><br><span class="line"><span class="comment">//参数3--设备文件的设备号</span></span><br><span class="line"><span class="comment">//参数4--设备的私有数据--一般直接填NULL</span></span><br><span class="line"><span class="comment">//参数5--设备节点的名字</span></span><br><span class="line">device_create(struct class * cls,struct device * parent,<span class="keyword">dev_t</span> devt,<span class="keyword">void</span> * drvdata,<span class="keyword">const</span> <span class="keyword">char</span> * fmt,...)</span><br></pre></td></tr></table></figure>
<p><strong>在上阶程序优化static int __init hello_drv_init(void)函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1-向系统申请/注册主设备号--就是id，整数</span></span><br><span class="line">        <span class="comment">//参数1--指定的大于0主设备号--最大是12bit， 一般选256以上，或者直接填0， 表示动态系统分配</span></span><br><span class="line">        <span class="comment">//参数2--设备的名字--一般自定义</span></span><br><span class="line">        <span class="comment">//参数3--为应用空间提供的文件操作接口</span></span><br><span class="line">        <span class="comment">//返回值;正确为0， 错误为负数</span></span><br><span class="line">        ret = register_chrdev(dev_major, <span class="string">"hello_dev"</span>, &amp;hello_fops);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2- 创建类--将设备归类</span></span><br><span class="line">        <span class="comment">//参数1--类是又哪个模块创建的，一般直接填THIS_MODULE</span></span><br><span class="line">        <span class="comment">//参数2--类的名字，一般自定义</span></span><br><span class="line">        <span class="comment">// 实际是创建了 /sys/class/led_cls</span></span><br><span class="line">        led_cls = class_create(THIS_MODULE, <span class="string">"led_cls"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在该类中创建某个设备文件--/dev/hello0</span></span><br><span class="line">        <span class="comment">//参数1--哪个类别中</span></span><br><span class="line">        <span class="comment">//参数2--当前创建的设备对象的父类，一般直接填NULL</span></span><br><span class="line">        <span class="comment">//参数3--设备文件的设备号</span></span><br><span class="line">        <span class="comment">//参数4--设备的私有数据--一般直接填NULL</span></span><br><span class="line">        <span class="comment">//参数5--设备节点的名字</span></span><br><span class="line">        led_dev = device_create(led_cls, <span class="literal">NULL</span>, MKDEV(dev_major, <span class="number">0</span>), <span class="literal">NULL</span>,  <span class="string">"%s%d"</span>, led_dev_name, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//模块加载函数正确的时候一定返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_03-39-00.png" alt="Snipaste_2019-03-09_03-39-00"></p>
<p>结果：加载驱动后，会在/sys/class/led_cls目录下建立led_dev文件节点。</p>
<h3 id="5-实现应用调用驱动文件io的方式"><a href="#5-实现应用调用驱动文件io的方式" class="headerlink" title="5.实现应用调用驱动文件io的方式"></a>5.实现应用调用驱动文件io的方式</h3><p>该部分为会为各户提供各种文件io接口（供应用APP系统调用实现底层操作）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.文件操作对象---为用户提供各种文件io接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_drv_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 read(fd, buf, size);</span></span><br><span class="line"><span class="keyword">ssize_t</span> hello_drv_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *fpos)</span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> hello_drv_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *fpos)</span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_drv_close</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span></span><br><span class="line">	.open = hello_drv_open,</span><br><span class="line">	.read = hello_drv_read,</span><br><span class="line">	.write = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一个完整的字符设备驱动程序"><a href="#一个完整的字符设备驱动程序" class="headerlink" title="一个完整的字符设备驱动程序"></a>一个完整的字符设备驱动程序</h3><p> //  1， 增加头文件</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/device.h&gt;</p>
<p>#include &lt;asm/io.h&gt;</p>
<p>static struct device <em>led_dev;<br>static char </em>led_dev_name = “led_dev”;<br>static struct class *led_cls;<br>static unsigned int dev_major;</p>
<p>//2.文件操作对象—为用户提供各种文件io接口</p>
<p>int hello_drv_open(struct inode <em>inode, struct file </em>filp)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);</p>
<p>​    return 0;<br>}</p>
<p>//应用 read(fd, buf, size);<br>ssize_t hello_drv_read(struct file <em>filp, char __user </em>buf, size_t count, loff_t *fpos)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}</p>
<p>ssize_t hello_drv_write(struct file <em>filp, const char __user </em>buf, size_t count, loff_t *fpos)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}</p>
<p>int hello_drv_close(struct inode <em>inode, struct file </em>filp)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}<br>//文件操作对象—为用户提供各种文件io接口<br>const struct file_operations hello_fops = {<br>    .open = hello_drv_open,<br>    .read = hello_drv_read,<br>    .write = hello_drv_write,<br>    .release = hello_drv_close,</p>
<p>};</p>
<p>   //3， 实现模块加载和卸载的入口函数<br>//函数的原形：一定要是返回值为int， 参数为void<br>static int <strong>init hello_drv_init(void)<br>{<br>    printk(“——-^_^—–%s—\n”, </strong>FUNCTION__);</p>
<p>​    int ret;</p>
<p>​    //1-向系统申请/注册主设备号–就是id，整数<br>​    //参数1–指定的大于0主设备号–最大是12bit， 一般选256以上，或者直接填0， 表示动态系统分配<br>​    //参数2–设备的名字–一般自定义<br>​    //参数3–为应用空间提供的文件操作接口<br>​    //返回值;正确为0， 错误为负数<br>​    ret = register_chrdev(dev_major, “hello_dev”, &amp;hello_fops);</p>
<p>​    // 2- 创建类–将设备归类<br>​    //参数1–类是又哪个模块创建的，一般直接填THIS_MODULE<br>​    //参数2–类的名字，一般自定义<br>​    // 实际是创建了 /sys/class/led_cls<br>​    led_cls = class_create(THIS_MODULE, “led_cls”);<br>​<br>​    //3-在该类中创建某个设备文件–/dev/hello0<br>​    //参数1–哪个类别中<br>​    //参数2–当前创建的设备对象的父类，一般直接填NULL<br>​    //参数3–设备文件的设备号<br>​    //参数4–设备的私有数据–一般直接填NULL<br>​    //参数5–设备节点的名字<br>​    led_dev = device_create(led_cls, NULL, MKDEV(dev_major, 0), NULL,  “%s%d”, led_dev_name, 0);<br>​    //模块加载函数正确的时候一定返回0<br>​    return 0;</p>
<p>}<br>//函数的原形：一定要是返回值为void， 参数为void<br>static void hello_drv_exit(void)<br>{<br>    printk(“——-^_^—–%s—\n”);<br>    unregister_chrdev(dev_major, “hello_dev”);<br>}</p>
<p>module_init(hello_drv_init);<br>module_exit(hello_drv_exit);<br>MODULE_LICENSE(“GPL”);</p>
<p>碰见的一些问题：</p>
<p><strong>（1）问题:</strong></p>
<p>译模块出错：insmod: ERROR: could not insert module module.ko: Invalid parameters</p>
<p>选择错误头文件路径</p>
<p>解决：</p>
<p>uname -r查看当前运行的内核版本</p>
<p>ubuntu下内核路径：cd  /usr /src/</p>
<p><strong>（2）问题：</strong></p>
<p>Linux中终端显示的当前目录的绝对路径太长</p>
<p>解决：</p>
<p>只显示当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>找到位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$color_prompt&quot; = yes ]; then</span><br><span class="line">    PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &apos;</span><br><span class="line">else</span><br><span class="line">    PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>将这两个小写的w换成大写W，然后source ~/.bashrc即可</p>
<h2 id="第四章：平台总线"><a href="#第四章：平台总线" class="headerlink" title="第四章：平台总线"></a>第四章：平台总线</h2><p>平台总线简述：略</p>
<h3 id="小节一：I2C设备驱动"><a href="#小节一：I2C设备驱动" class="headerlink" title="小节一：I2C设备驱动"></a>小节一：I2C设备驱动</h3><h4 id="i2c协议说明"><a href="#i2c协议说明" class="headerlink" title="i2c协议说明"></a>i2c协议说明</h4><p>略</p>
<h4 id="Linux-I2C体系结构"><a href="#Linux-I2C体系结构" class="headerlink" title="Linux I2C体系结构"></a>Linux I2C体系结构</h4><p>查考：<a href="https://www.cnblogs.com/pingfandfy/p/5822813.html" target="_blank" rel="noopener">Linux操作系统的I2C驱动</a></p>
<p>Linux I2C体系结构分为3个组成部分：I2C核心 ，I2C总线驱动 ，I2C设备驱动 。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-11_12-19-25.png" alt="Snipaste_2019-03-11_12-19-25"></p>
<ul>
<li><p><strong>I2C核心</strong> </p>
<p>I2C核心为上层提供统一的接口和提供I2C总线驱动和设备驱动的注册、注销方法，I2C通信方法（即Algorithm） 上层的与具<br>体适配器无关的代码以及探测设备、 检测设备地址的上层代码等 </p>
</li>
<li><p><strong>I2C总线驱动</strong> </p>
<p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。I2C总线驱动主要包含了I2C适配器数据结构i2c_adapter、I2C适配器的algorithm数据结构i2c_algorithm和控制I2C适配器产生通信信号的函数。经由I2C总线驱动的代码，我们可以控制I2C适配器以主控方式产生开始位、停止位、读写周期，以及以从设备方式被读写、产生ACK等。</p>
</li>
<li><p><strong>I2C设备驱动</strong> </p>
<p>I2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在首CPU控制的I2C适配器上，通过I2C适配器与CPU交换数据。I2C设备驱动主要包含了数据结构i2c_driver和i2c_client，我们需要根据具体设备实现其中的成员函数。</p>
</li>
</ul>
<h4 id="Linux-I2C-驱动编程"><a href="#Linux-I2C-驱动编程" class="headerlink" title="Linux I2C 驱动编程"></a>Linux I2C 驱动编程</h4><h5 id="Linux-I2C适配器驱动"><a href="#Linux-I2C适配器驱动" class="headerlink" title="Linux I2C适配器驱动"></a>Linux I2C适配器驱动</h5><p>I2C适配器驱动的注册与注销 </p>
<p>I2C总线的通信方法 </p>
<h3 id="SPI设备驱动"><a href="#SPI设备驱动" class="headerlink" title="SPI设备驱动"></a>SPI设备驱动</h3><h3 id="PCI设备驱动"><a href="#PCI设备驱动" class="headerlink" title="PCI设备驱动"></a>PCI设备驱动</h3><h2 id="第五章：块设备"><a href="#第五章：块设备" class="headerlink" title="第五章：块设备"></a>第五章：块设备</h2><p>略</p>
<h2 id="第六章：网络设备"><a href="#第六章：网络设备" class="headerlink" title="第六章：网络设备"></a>第六章：网络设备</h2><p>略</p>
<p>## </p>
<h2 id="第七章：设备模型（补充）"><a href="#第七章：设备模型（补充）" class="headerlink" title="第七章：设备模型（补充）"></a>第七章：设备模型（补充）</h2>
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/嵌入式Linux网络编程.html" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/面试常见问题.html" rel="prev" title="面试常见问题">
                面试常见问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-Linux设备驱动概述"><span class="nav-number">1.</span> <span class="nav-text">第1章 Linux设备驱动概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux设备驱动"><span class="nav-number">1.1.</span> <span class="nav-text">Linux设备驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核划分"><span class="nav-number">1.2.</span> <span class="nav-text">内核划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备的分类及特点"><span class="nav-number">1.3.</span> <span class="nav-text">设备的分类及特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux设备驱动与整个软硬件系统的关系"><span class="nav-number">1.4.</span> <span class="nav-text">Linux设备驱动与整个软硬件系统的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章：Linux内核模块程序结构"><span class="nav-number">2.</span> <span class="nav-text">第2章：Linux内核模块程序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux内核模块简介"><span class="nav-number">2.1.</span> <span class="nav-text">Linux内核模块简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux内核模块程序结构"><span class="nav-number">2.2.</span> <span class="nav-text">Linux内核模块程序结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核模块函数详解"><span class="nav-number">2.3.</span> <span class="nav-text">内核模块函数详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块加载函数"><span class="nav-number">2.3.1.</span> <span class="nav-text">模块加载函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块卸载函数"><span class="nav-number">2.3.2.</span> <span class="nav-text">模块卸载函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块参数"><span class="nav-number">2.3.3.</span> <span class="nav-text">模块参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出符号"><span class="nav-number">2.3.4.</span> <span class="nav-text">导出符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块声明与描述"><span class="nav-number">2.3.5.</span> <span class="nav-text">模块声明与描述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章：字符设备驱动"><span class="nav-number">3.</span> <span class="nav-text">第2章：字符设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux字符设备驱动结构"><span class="nav-number">3.1.</span> <span class="nav-text">Linux字符设备驱动结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cdev结构体"><span class="nav-number">3.1.1.</span> <span class="nav-text">cdev结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配和释放设备号"><span class="nav-number">3.1.2.</span> <span class="nav-text">分配和释放设备号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file-operations结构体"><span class="nav-number">3.1.3.</span> <span class="nav-text">file_operations结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux字符设备驱动的组成"><span class="nav-number">3.2.</span> <span class="nav-text">Linux字符设备驱动的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章：驱动编写"><span class="nav-number">3.3.</span> <span class="nav-text">第三章：驱动编写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-头文件、-宏及设备结构体"><span class="nav-number">3.3.1.</span> <span class="nav-text">1.头文件、 宏及设备结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-加载与卸载设备驱动"><span class="nav-number">3.3.2.</span> <span class="nav-text">2.加载与卸载设备驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-添加GPL认证"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.添加GPL认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-创建字符设备文件节点"><span class="nav-number">3.3.4.</span> <span class="nav-text">4. 创建字符设备文件节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-实现应用调用驱动文件io的方式"><span class="nav-number">3.3.5.</span> <span class="nav-text">5.实现应用调用驱动文件io的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个完整的字符设备驱动程序"><span class="nav-number">3.3.6.</span> <span class="nav-text">一个完整的字符设备驱动程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章：平台总线"><span class="nav-number">3.4.</span> <span class="nav-text">第四章：平台总线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小节一：I2C设备驱动"><span class="nav-number">3.4.1.</span> <span class="nav-text">小节一：I2C设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c协议说明"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">i2c协议说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-I2C体系结构"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">Linux I2C体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-I2C-驱动编程"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">Linux I2C 驱动编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux-I2C适配器驱动"><span class="nav-number">3.4.1.3.1.</span> <span class="nav-text">Linux I2C适配器驱动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI设备驱动"><span class="nav-number">3.4.2.</span> <span class="nav-text">SPI设备驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCI设备驱动"><span class="nav-number">3.4.3.</span> <span class="nav-text">PCI设备驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章：块设备"><span class="nav-number">3.5.</span> <span class="nav-text">第五章：块设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章：网络设备"><span class="nav-number">3.6.</span> <span class="nav-text">第六章：网络设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章：设备模型（补充）"><span class="nav-number">3.7.</span> <span class="nav-text">第七章：设备模型（补充）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
