<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="序本章节主要讲解Linux下如何对文件操作，包括两部分： 文件I/O和标准I/O 他们有什么区别，该部分将使用一个专门都一下节去讲解。">
<meta name="keywords" content="暂时无">
<meta property="og:type" content="article">
<meta property="og:title" content="unix下输入与输出(I&#x2F;0)">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:description" content="序本章节主要讲解Linux下如何对文件操作，包括两部分： 文件I/O和标准I/O 他们有什么区别，该部分将使用一个专门都一下节去讲解。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-28_11-57-29.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-28_12-42-29.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-28_16-34-56.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-28_16-49-15.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-28_19-16-14.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-19-47.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-20-03.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-22-18.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-24-15.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-31-44.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-39-29.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-39-57.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-58-15.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_17-58-41.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_18-13-27.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_18-13-40.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_18-16-07.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_18-17-55.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_18-18-05.png">
<meta property="og:updated_time" content="2019-03-03T17:26:44.052Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="unix下输入与输出(I&#x2F;0)">
<meta name="twitter:description" content="序本章节主要讲解Linux下如何对文件操作，包括两部分： 文件I/O和标准I/O 他们有什么区别，该部分将使用一个专门都一下节去讲解。">
<meta name="twitter:image" content="d:/MyBlog/图片/Snipaste_2019-02-28_11-57-29.png">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>unix下输入与输出(I/0) | Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">unix下输入与输出(I/0)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 11:31:17" itemprop="dateCreated datePublished" datetime="2019-02-28T11:31:17+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-04 01:26:44" itemprop="dateModified" datetime="2019-03-04T01:26:44+08:00">2019-03-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本章节主要讲解Linux下如何对文件操作，包括两部分：</p>
<p>文件I/O和标准I/O</p>
<p>他们有什么区别，该部分将使用一个专门都一下节去讲解。</p>
<a id="more"></a>
<h1 id="第一节：文件I-O和标准I-O的比较"><a href="#第一节：文件I-O和标准I-O的比较" class="headerlink" title="第一节：文件I/O和标准I/O的比较"></a>第一节：文件I/O和标准I/O的比较</h1><p>来源说明</p>
<p>作者：zqixiao_09 </p>
<p>原文地址：<a href="https://blog.csdn.net/zqixiao_09/article/details/50444465" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50444465</a> </p>
<h2 id="什么是文件I-O和标准I-O"><a href="#什么是文件I-O和标准I-O" class="headerlink" title="什么是文件I/O和标准I/O"></a>什么是文件I/O和标准I/O</h2><p>文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。</p>
<p>标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。</p>
<ul>
<li>全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 </li>
<li>行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 </li>
<li>不带缓存：stderr就是了。</li>
</ul>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><ul>
<li><p>文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。</p>
</li>
<li><p>通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。</p>
</li>
<li><p>文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。</p>
<p><em>注：Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。</em></p>
</li>
</ul>
<h2 id="文件I-O和标准I-O使用的函数比较"><a href="#文件I-O和标准I-O使用的函数比较" class="headerlink" title="文件I/O和标准I/O使用的函数比较"></a>文件I/O和标准I/O使用的函数比较</h2><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_11-57-29.png" alt="Snipaste_2019-02-28_11-57-29"></p>
<h3 id="fopen与open比较"><a href="#fopen与open比较" class="headerlink" title="fopen与open比较"></a>fopen与open比较</h3><p><strong>标准I/O使用fopen函数打开一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span> *mod)</span><br></pre></td></tr></table></figure>
<ul>
<li>path：文件名。</li>
<li>mod：用于指定文件打开的模式的字符串，比如”r”,”w”,”w+”,”a”等等，可以加上字母b用以指定以二进制模式打开。</li>
<li>返回值：如果成功打开，返回一个FILE文件指针，如果失败返回NULL。（这里的文件指针并不是指向实际的文 件，而是一个关于文件信息的数据包，其中包括文件使用的缓冲区信息。）</li>
</ul>
<p><strong>文件IO使用open函数用于打开一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd=open(<span class="keyword">char</span> *name,<span class="keyword">int</span> how);</span><br></pre></td></tr></table></figure>
<ul>
<li>name：文件名字符串</li>
<li>how指定打开的模式：O_RDONLY(只读),O_WRONLY(只写）,O_RDWR （可读可写)。（其他模式请man 2 open）。</li>
<li>返回值：成功返回一个正整数称为文件描述符，这与标准I/O显著不同，失败的话返回-1，与标准I/O返回NULL也是不同的。</li>
</ul>
<h3 id="fclose与close比较"><a href="#fclose与close比较" class="headerlink" title="fclose与close比较"></a>fclose与close比较</h3><p>标准I/O使用fclose关闭文件，将文件指针传入即可，如果成功关闭，返回0，否则返回EOF</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fclose(fp)!=<span class="number">0</span>)  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error in closing file"</span>);</span><br></pre></td></tr></table></figure>
<p>文件IO使用close用于关闭open打开的文件，与fclose类似，只不过当错误发生时返回的是-1，而不是EOF，成功关闭同样是返回0。</p>
<h3 id="读文件比较：getc-fscanf-fgets和read"><a href="#读文件比较：getc-fscanf-fgets和read" class="headerlink" title="读文件比较：getc,fscanf,fgets和read"></a>读文件比较：getc,fscanf,fgets和read</h3><p><strong>标 准I/O中进行文件读取</strong></p>
<ul>
<li>可以使用 <strong>getc</strong>，一个字符一个字符的读取，也可以使用gets（读取标准io读入的）</li>
<li>fgets以字符串单位进行读取（读到遇 到的第一个换行字符的后面）</li>
</ul>
<p>gets（接受一个参数，文件指针）不判断目标数组是否能够容纳读入的字符，可能导致存储溢出(不建议使用），而fgets使用三个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数和gets一样，用于存储输入的地址，第二个参数为整数，表示输入字符串的最大长度，最后一个参数就是文件指针，指向要读取的文件。</p>
<ul>
<li>最 后是fscanf，与scanf类似，只不过增加了一个参数用于指定操作的文件，比如fscanf(fp,”%s”,words)</li>
</ul>
<p><strong>文件I/O中进行文件读取</strong></p>
<p>文件IO中使用read函数用于读取open函数打开的文件，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> numread=read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> qty);</span><br></pre></td></tr></table></figure>
<p>其中fd就是open返回的文件描述符，buf用于存储数据的目的缓冲区，而qty指定要读取的字节数。如果成功读取，就返回读取的字节数目（小于等于qty）</p>
<h3 id="判断文件结尾比较"><a href="#判断文件结尾比较" class="headerlink" title="判断文件结尾比较"></a>判断文件结尾比较</h3><p>如果尝试读取达到文件结尾，标准IO的getc会返回特殊值EOF，而fgets碰到EOF会返回NULL,而对于unix的read函数，情况有所不 同。read读取qty指定的字节数，最终读取的数据可能没有你所要求的那么多（qty），而当读到结尾再要读的话，read函数将返回0.</p>
<h3 id="写文件比较：putc-fputs-fprintf和write"><a href="#写文件比较：putc-fputs-fprintf和write" class="headerlink" title="写文件比较：putc,fputs,fprintf和write"></a>写文件比较：putc,fputs,fprintf和write</h3><p><strong>标准I/O中进行文件写入</strong></p>
<p>使用putc写入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putc(ch,fp);</span><br><span class="line"><span class="comment">//第一个参数是字符，第二个是文件指针。</span></span><br></pre></td></tr></table></figure>
<p>使用fputs写入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(buf,fp);</span><br><span class="line"><span class="comment">//仅仅是第一个参数换成了字符串地址。</span></span><br></pre></td></tr></table></figure>
<p>使用fprintf写入字符</p>
<p>fprintf与printf类似，增加了一个参数用于指定写入的文件，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello %s.\n"</span>,<span class="string">"dennis"</span>);</span><br></pre></td></tr></table></figure>
<p>切记fscanf和fprintf将FILE指针作为第一个参数，而putc,fputs则是作为第二个参数。</p>
<p><strong>文件I/O中进行文件写入</strong></p>
<p>在文件IO中提供write函数用于写入文件，原型与read类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result=write(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf ,<span class="keyword">size_t</span> amt);</span><br></pre></td></tr></table></figure>
<p>fd：文件描述符</p>
<p>buf：是将要写入的内存数据</p>
<p>amt：是要写的字节数。</p>
<p>返回值：如果写入成功返回写入的字节数，通过result与amt的比较可以判断是否写入正常，如果写入失败返回-1</p>
<h3 id="随机存取比较：fseek-、ftell-和lseek"><a href="#随机存取比较：fseek-、ftell-和lseek" class="headerlink" title="随机存取比较：fseek()、ftell()和lseek()"></a>随机存取比较：fseek()、ftell()和lseek()</h3><p><strong>标准I/O中进行随机存取</strong></p>
<p>标准I/O使用fseek和ftell用于文件的随机存取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fseek函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数：是文件指针</p>
<p>第二个参数：是一个long类型的偏移量（offset），表示从起始点开始移动的距离。</p>
<p>第三个参数：是用于指定起始点的模式，stdio.h指定了下列模式常量：SEEK_SET ：文件开始处， SEEK_CUR ：当前位置<br>，    SEEK_END： 文件结尾处</p>
<p>看几个调用例子： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_SET); <span class="comment">//找到文件的开始处 </span></span><br><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END); <span class="comment">//定位到文件结尾处 </span></span><br><span class="line">fseek(fp,<span class="number">2L</span>,SEEK_CUR); <span class="comment">//文件当前位置向前移动2个字节数</span></span><br></pre></td></tr></table></figure>
<p>而ftell函数用于返回文件的当前位置，返回类型是一个long类型，比如下面的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END);<span class="comment">//定位到结尾 </span></span><br><span class="line"><span class="keyword">long</span> last=ftell(fp); <span class="comment">//返回当前位置</span></span><br></pre></td></tr></table></figure>
<p>那么此时的last就是文件指针fp指向的文件的字节数。</p>
<p><strong>文件I/O中进行随机存取</strong></p>
<p>与标准I/O类似，unix系统提供了lseek来完成fseek的功能，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型如下：</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p>fildes:是文件描述符</p>
<p>offset:也是偏移量</p>
<p>whence:同样是指定起始点模式</p>
<p>唯一的不同是lseek有返回值，如果成功就 返回指针变化前的位置，否则返回-1。whence的取值与fseek相同：SEEK_SET,SEEK_CUR,SEEK_END，但也可以用整数 0,1,2相应代替。</p>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>上面我们一直在讨论文件I/O与标准I/O的区别，其实可以这样说，文件I/O是系统调用、标准I/O是库函数，看下面这张图：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_12-42-29.png" alt="Snipaste_2019-02-28_12-42-29"></p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>操作系统负责管理和分配所有的计算机资源。为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用。通过这组接口用户程序可以使用操作系统内核提供的各种功能。例如分配内存、创建进程、实现进程之间的通信等。</p>
<p>   为什么不允许程序直接访问计算机资源？答案是不安全。单片机开发中，由于不需要操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，程序访问资源的方式都发生了改变。操作系统基本上都支持多任务，即同时可以运行多个程序。如果允许程序直接访问系统资源，肯定会带来很多问题。因此，所有软硬件资源的管理和分配都有操作系统负责。程序要获取资源（如分配内存，读写串口）必须由操作系统来完成，即用户程序向操作系统发出服务请求，操作系统收到请求后执行相关的代码来处理。</p>
<p>   用户程序向操作系统提出请求的接口就是系统调用。所有的操作系统都会提供系统调用接口，只不过不同的操作系统提供的系统调用接口各不相同。Linux 系统调用接口非常精简，它继承了Unix 系统调用中最基本的和最有用的部分。这些系统调用按照功能大致可分为<strong>进程控制、进程间通信、文件系统控制、存储管理、网络管理、套接字控制、用户管理等几类。</strong></p>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>库函数可以说是对系统调用的一种封装，因为系统调用是面对的是操作系统，系统包括Linux、Windows等，如果直接系统调用，会影响程序的移植性，所以这里使用了库函数，比如说C库，这样只要系统中安装了C库，就都可以使用这些函数，比如printf()  scanf()等，C库相当于对系统函数进行了翻译，使我们的APP可以调用这些函数；</p>
<h4 id="用户编程接口API"><a href="#用户编程接口API" class="headerlink" title="用户编程接口API"></a>用户编程接口API</h4><p> 前面提到利用系统调用接口程序可以访问各种资源，但在实际开发中程序并不直接使用系统调用接口，而是使用用户编程接口（API）。为什么不直接使用系统调用接口呢？</p>
<p>原因如下：</p>
<p>1）系统调用接口功能非常简单，无法满足程序的需求。</p>
<p>2）不同操作系统的系统调用接口不兼容，程序移植时工作量大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户编程接口通俗的解释就是各种库（最重要的就是C库）中的函数。为了提高开发效率，C库中实现了很多函数。这些函数实现了常用的功能，供程序员调用。这样一来，程序员不需要自己编写这些代码，直接调用库函数就可以实现基本功能，提高了代码的复用率。使用用户编程接口还有一个好处：程序具有良好的可移植性。几乎所有的操作系统上都实现了C库，所以程序通常只需要重新编译一下就可以在其他操作系统下运行。</span><br><span class="line"></span><br><span class="line">用户编程接口（API）在实现时，通常都要依赖系统调用接口。例如，创建进程的API函数fork()对应于内核空间的sys_fork()系统调用。很多API函数西亚我哦通过多个系统调用来完成其功能。还有一些API函数不要调用任何系统调用。</span><br><span class="line"></span><br><span class="line"> 在Linux 中用户编程接口（API）遵循了在Unix中最流行的应用编程界面标准——POSIX标准。POSIX标准是由IEEE和ISO/IEC共同开发的标准系统。该标准基于当时想用的Unix 实践和经验，描述了操作系统的系统调用编程接口（实际上就是API），用于保证应用程序可以在源代码一级商多种操作系统上运行。这些系统调用编程接口主要是通过C库（libc )实现的。</span><br></pre></td></tr></table></figure>
<h2 id="一句话理解文件I-O和标准I-O"><a href="#一句话理解文件I-O和标准I-O" class="headerlink" title="一句话理解文件I/O和标准I/O"></a>一句话理解文件I/O和标准I/O</h2><ul>
<li>文件I/O更接近于底层硬件的I/O。其使用是通过是系统调用实现的。</li>
<li>标准I/O可以说是对文件I/O的一种封装，是基于库函数。</li>
<li>文件I/O多针对于操作系统而标准I/O多针对于应用程序</li>
</ul>
<h1 id="第二节：文件I-O"><a href="#第二节：文件I-O" class="headerlink" title="第二节：文件I/O"></a>第二节：文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX 系统文件 I/ O 函数的操作有—— 打开 文件、 读 文件、 写 文件 等。 UNIX 系统 中的 大多数 文件 I/ O 只需 用到 5 个 函数： open、 read、 write、 lseek 以及 close。</p>
<p>本章 描述 的 函数 经常 被称为 不带 缓冲 的 I/ O，术语 不带 缓冲 指的 是 每个 read 和 write 都 调用 内核 中的 一个 系统 调用。</p>
<p>只要 涉及 在 多个 进程 间 共享 资源， 原子 操作 的 概念 就 变得 非常 重要。 我们将 通过 文件 I/ O 和 open 函数 的 参数 来 讨论 此 概念。</p>
<p>本章 还将 进一步 讨论 在 多个 进程 间 如何 共享 文件， 以及 所 涉及 的 内核 有关 数据 结构。 在 描述 了 这些 特征 后， 将 说明 dup、 fcntl、 sync、 fsync 和 ioctl 函数。</p>
<h2 id="文件-描述-符"><a href="#文件-描述-符" class="headerlink" title="文件 描述 符"></a>文件 描述 符</h2><p>对于 内核 而言， 所有 打开 的 文件 都 通过 文件 描述 符 引用。 文件 描述 符 是 一个 非 负 整数。 当 打开 一个 现有 文件 或 创建 一个 新 文件 时， 内核 向 进程 返回 一个 文件 描述 符。当 读、 写 一个 文件 时， 使用 open 或 creat 返回 的 文件 描述 符 标识 该 文件， 将其 作为 参数 传送 给 read 或 write。</p>
<p>按照 惯例， UNIX 系统 shell 把 文件 描述 符 0 与 进程 的 标准 输入 关联， 文件 描述 符 1 与 标准 输出 关联， 文件 描述 符 2 与 标准 错误 关联。</p>
<p>文件 描述 符 的 变化 范围是 0 ～ OPEN_ MAX- 1（ 见图 2- 11）。 早期 的 UNIX 系统 实现 采用 的 上 限值 是 19（ 允许 每个 进程 最多 打开 20 个 文件）， 但 现在 很多 系统 将其 上限 值 增加 至 63。</p>
<h2 id="文件的打开和关闭及-创建"><a href="#文件的打开和关闭及-创建" class="headerlink" title="文件的打开和关闭及 创建"></a>文件的打开和关闭及 创建</h2><h3 id="函数-open"><a href="#函数-open" class="headerlink" title="函数 open"></a>函数 open</h3><p>调用 open 或 openat 函数 可以 打开 或 创建 一个 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>pathname ：</strong>是待打开/创建文件的路径名（如 C:/cpp/a.cpp）。</p>
<p><strong>oflag ：</strong>用于指定文件的打开/创建模式。</p>
<p>这个参数可由以下常量（定义于 fcntl.h）通过逻辑或构成。打开/创建文件时，至少得使用下述三个常量中的一个。</p>
<ul>
<li>O_RDONLY　　只读模式</li>
<li>O_WRONLY　　只写模式</li>
<li>O_RDWR　　读写模式</li>
</ul>
<p>以下常量是选用的：</p>
<ul>
<li>O_APPEND　　每次写操作都写入文件的末尾</li>
<li>O_CREAT　　如果指定文件不存在，则创建这个文件</li>
<li>O_EXCL　　如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li>
<li>O_TRUNC　　如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li>
<li>O_NOCTTY　　如果路径名指向终端设备，不要把这个设备用作控制终端。</li>
<li>O_NONBLOCK　　如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）</li>
</ul>
<p>以下三个常量同样是选用的，它们用于同步输入输出</p>
<ul>
<li>O_DSYNC　　等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。</li>
<li>O_RSYNC　　read 等待所有写入同一区域的写操作完成后再进行</li>
<li>O_SYNC　　等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li>
</ul>
<p><strong>第三个参数（…）</strong>仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。</p>
<p><strong>返回值：</strong>成功则返回文件描述符，否则返回 -1，open 返回的文件描述符一定是最小的未被使用的描述符。</p>
<p>函数 creat</p>
<p>也可 调用 creat 函数 创建 一个 新 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; fcntl. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *path, mode_ t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 值： 若 成功， 返回 为 只 写 打开 的 文件 描述 符； 若 出错， 返回 − 1 注意，</p>
<p> 此 函数 等效 于： open( path, O_ WRONLY ｜ O_ CREAT ｜ O_ TRUNC, mode)。 因此现在很少有使用creat()函数来创建新文件;</p>
<h3 id="函数-close"><a href="#函数-close" class="headerlink" title="函数 close"></a>函数 close</h3><p>调用 close 函数可以关闭 一个已打开的文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line">int close (int fd)；</span><br></pre></td></tr></table></figure>
<p> 返回 值： 若 成功， 返回 0； 若 出错， 返回 − 1 </p>
<p>关闭 一个 文件 时 还会 释放 该 进程 加在 该 文件 上 的 所有 记录 锁。 </p>
<p> 当 一个 进程 终止 时， 内核 自动 关闭 它 所有 的 打开 文件。 很多 程序 都 利用 了 这一 功能 而 不显 式 地 用 close 关闭 打开 文件。 </p>
<h3 id="实例：文件的打开与关闭"><a href="#实例：文件的打开与关闭" class="headerlink" title="实例：文件的打开与关闭"></a>实例：文件的打开与关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd；</span><br><span class="line">   <span class="keyword">if</span>((fd=open(“test.txt”,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>)&lt;<span class="number">0</span>);</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fail tpo open"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      	close(fd);</span><br><span class="line"> 	 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h3 id="函数-read"><a href="#函数-read" class="headerlink" title="函数 read"></a>函数 read</h3><p>调用 read 函数 从 打开 文件 中 读 数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回读到的字节数，若已到文件末尾则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:读取数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要读取的字节数</span></span><br></pre></td></tr></table></figure>
<p> 　　有几种情况可使实际读到的字节数少于要求读的字节数：</p>
<p>　　1）读普通文件时，在读到要求字节数之前就已经达到了文件末端。例如，若在到达文件末端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0（文件末端）。</p>
<p>　　2）当从终端设备读时，通常一次最多读一行。</p>
<p>　　3）当从网络读时，网络中的缓存机构可能造成返回值小于所要求读的字结束。</p>
<p>　　4）当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</p>
<p>　　5）当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。</p>
<p>　　6）当某一个信号造成中断，而已经读取了部分数据。</p>
<h3 id="函数-write"><a href="#函数-write" class="headerlink" title="函数 write"></a>函数 write</h3><p>write函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nb　write函数定义如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure>
<h3 id="实例：使用-read-和-write-函数-复制-一个-文件。"><a href="#实例：使用-read-和-write-函数-复制-一个-文件。" class="headerlink" title="实例：使用 read 和 write 函数 复制 一个 文件。"></a>实例：使用 read 和 write 函数 复制 一个 文件。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: copy_file.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd,to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断入参</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s fromfile tofile !\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">if</span>( (from_fd = open(argv[<span class="number">1</span>],O_RDONLY | O_CREAT ))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s Error!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建目的文件</span></span><br><span class="line">    <span class="keyword">if</span>( (to_fd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT))==<span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s error! \n"</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//测得文件大小</span></span><br><span class="line">    file_len=lseek(from_fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(from_fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from file size is %d!\n"</span>,file_len);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//进行文件拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(from_fd, buffer, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(to_fd, buffer, ret );</span><br><span class="line">        file_len = ret;</span><br><span class="line">        bzero( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"there are %d buyes data left without copy!\n"</span>,file_len);</span><br><span class="line">    close(from_fd);</span><br><span class="line">    close(to_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lseek文件定位"><a href="#lseek文件定位" class="headerlink" title="lseek文件定位"></a>lseek文件定位</h2><p>lseek函数对文件当位置进行定位。它只能对可定位（可随机 访问）文件操作。管道，套接字和大部分字符设备文件不支持该类操作。</p>
<p> 函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p> <strong>函数功能：</strong> lseek系统调用用来移动读写指针的位置</p>
<p><strong>参数说明：</strong></p>
<p>fd:要操作的文件</p>
<p>  offset：相对whence移动的位移数，允许负值</p>
<p>  whence：起始指针，它有三个取值</p>
<ul>
<li><p>SEEK_SET 从文件开始处计算偏移量</p>
</li>
<li><p>​         SEEK_CUR 从文件指针的当前位置开始计算偏移</p>
</li>
<li><p>SEEK_END 从文件结尾处开始计算偏移量</p>
<p>文件指针值等于当前指针值加上offset的值。     </p>
</li>
</ul>
<p><strong>返回值：</strong>调用成功时范围当前的读写位置，也就是距离文件开始处多少字节，若 有错误返回-1</p>
<p><strong>常见用法：</strong></p>
<ul>
<li>将文件读写指针移动到文件开头：lseek(int fildes, 0, SEEK_SET);</li>
<li>将文件读写指针移动到文件结尾：lseek(int fildes, 0, SEEK_END);</li>
<li>获取文件读写指针当前的位置：lseek(int fikdes, 0, SEEK_CUR);</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>  readfd, writefd;  </span><br><span class="line">    <span class="keyword">long</span> filelen=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span>  ret=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];  </span><br><span class="line">    <span class="keyword">char</span> *ptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*打开源文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((readfd=open(<span class="string">"test.txt"</span>, O_RDONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">      <span class="comment">/*创建目的文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((writefd=open(<span class="string">"dest.txt"</span>, O_WRONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*测得文件大小*/</span>  </span><br><span class="line">    filelen= lseek(readfd,<span class="number">0L</span>,SEEK_END);  </span><br><span class="line">    lseek(readfd,<span class="number">0L</span>,SEEK_SET);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read file size is %d\n"</span>,filelen);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进行文件拷贝*/</span>  </span><br><span class="line">    <span class="keyword">while</span>(ret)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret= read(readfd, buffer, BUFFER_SIZE);  </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read Error\n"</span>);   </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);          </span><br><span class="line">        &#125;  </span><br><span class="line">        write(writefd, buffer, ret);  </span><br><span class="line">        filelen-=ret;  </span><br><span class="line">        bzero(buffer,BUFFER_SIZE);  </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    close(readfd);   </span><br><span class="line">    close(writefd);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考实例：</strong></p>
<p><a href="https://www.cnblogs.com/mickole/p/3182033.html" target="_blank" rel="noopener">利用lseek()创建空洞文件</a></p>
<p><a href="https://www.cnblogs.com/zxysmalleyes/p/5321207.html" target="_blank" rel="noopener">用lseek拼接两个文件</a></p>
<h1 id="第三节：内核数据结构分析"><a href="#第三节：内核数据结构分析" class="headerlink" title="第三节：内核数据结构分析"></a>第三节：内核数据结构分析</h1><p>UNIX 系统 支持 在 不同 进程 间 共享 打开 文件。进程间的这种 共享是如何进行的，为此 先 介绍 内核 用于 所有 I/ O 的 数据 结构。 </p>
<p>内核 使用 3 种数 据 结构 表示 打开 文件， 它们 之间 的 关系 决定了 在 文件 共享 方面 一个 进程 对 另一个 进程 可能 产生 的 影响。 </p>
<p>（1）每个 进程 在 进程表 中 都有 一个 记录 项（文件表项）， 记录 项 中 包含 一张 打开 文件 描述 符 表， 可将 其 视为 一个 矢量， 每个 描述 符 占用 一项。 与 每个 文件 描述 符 相 关联 的 是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a． 文件 描述 符 标志（ close_ on_ exec， 参见 图 3- 7 和 3. 14 节）；</span><br><span class="line"></span><br><span class="line">b． 指向 一个 文件 表项 的 指针。</span><br></pre></td></tr></table></figure>
<p>（2） 内核 为所 有打 开 文件 维持 一张 文件 表。 每个 文件 表项 包含：</p>
<p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等， 关于 这些 标志 的 更多 信息 参见 3. 14 节）；</p>
<p> b． 当前 文件 偏移量； </p>
<p>c． 指向 该 文件 v 节点 表项 的 指针。</p>
<p> （3） 每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。 v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。 对于 大多数 文件， v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。 这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。 例如， i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等（ 4. 14 节 较 详细 地说 明了 典型 UNIX 系统 文件 系统， 并将 更多 地 介绍 i 节点）。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-34-56.png" alt="Snipaste_2019-02-28_16-34-56"></p>
<p>个人梳理：</p>
<ul>
<li><p>1.每个进程都会有一个进程表项，进程表项中包含一个文件描述符表，每个描述符占有一项，每个描述符对应一个指针。该指针指向文件表项。</p>
</li>
<li><p>2.内核会为所有的打开的文件创建 一张 文件表项。 每个文件表项包含：     </p>
<p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等）。</p>
<p>b． 当前 文件 偏移量；</p>
<p> c． 指向 该 文件 v 节点 表项 的 指针。</p>
</li>
<li><p>3.每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。</p>
<p>v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。</p>
<p>v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。</p>
<p> i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等。</p>
</li>
</ul>
<p>注：这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。</p>
<p>注意， 文件 描述 符 标志 和 文件 状态 标志 在作 用 范围 方面 的 区别， 前者 只用于 一个 进程 的 一个 描述 符， 而后 者 则应 用于 指向 该给 定 文件 表项 的 任何 进程 中的 所有 描述 符。</p>
<p><strong>两个 独立 进程 各自 打开 了 同一 文件</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-49-15.png" alt="Snipaste_2019-02-28_16-49-15"></p>
<p>第一个 进程 在 文件 描述 符 3 上 打开 该 文件， 而 另一个 进程 在 文件 描述 符 4 上 打开 该 文件。 打开 该 文件 的 两个 进程 都 获得 各自 的 一个 文件 表项， 但是对于一个 给定 的 文件只有 一个 v 节点表项。（为什么会创建有两个表项，而不指向欧安同意文件表项） 之所以 每个 进程 都 获得 自己的 文件 表项， 是因为 这可 以使 每个 进程 都有 它自己 的 对 该 文件 的 当前 偏移量。</p>
<h2 id="文件操作的进一步说明"><a href="#文件操作的进一步说明" class="headerlink" title="文件操作的进一步说明"></a>文件操作的进一步说明</h2><p>给出 了 这些 数据 结构 后， 现在 对 前面 所述 的 操作 进一步 说明。</p>
<ul>
<li>write：在 完成 每个 write 后， 在 文件 表项 中的 当前 文件 偏移量 即 增加 所 写入 的 字节数。 如果 这 导致 当前 文件 偏移量 超出 了 当前 文件 长度， 则 将 i 节点 表项 中的 当前 文件 长度 设置 为 当前 文件 偏移量（ 也就是 该文 件 加长 了）。</li>
<li>open：如果 用 O_ APPEND 标志 打开 一个 文件， 则 相应 标志 也 被 设置 到 文件 表项 的 文件 状态 标志 中。 每次 对这 种 具有 追加 写 标志 的 文件 执行 写 操作 时， 文件 表项 中的 当前 文件 偏移量 首先 会被 设置 为 i 节点 表项 中的 文件 长度。 这就 使得 每次 写入 的 数据 都 追加 到 文件 的 当前 尾端 处。</li>
<li>lseek：若 一个 文件 用 lseek 定位 到 文件 当前 的 尾端， 则 文件 表项 中的 当前 文件 偏移量 被 设置 为 i 节点 表项 中的 当前 文件 长度 </li>
</ul>
<p>注：lseek 函数 只 修改 文件 表项 中的 当前 文件 偏移量， 不进 行 任何 I/ O 操作。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>上面所秒述 的一切是对于多个进程读取同一文件的过程。 每个进程都有它自己的文件表项， 其中也有它自己 的当前文件偏移量。 但是，当多个进程写同一 文件时， 则可能产生预想不到的结果。 为了避免这种情况， 需要 理解原子操作的概念。</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="追加数据到-一个-文件"><a href="#追加数据到-一个-文件" class="headerlink" title="追加数据到 一个 文件"></a>追加数据到 一个 文件</h4><p>早期 的 UNIX 系统 版本 并不 支持 open 的 O_ APPEND 选项， 所以 程序 被 编写 成 下列 形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek( fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) 　 　 　 　 　 　<span class="comment">/* position to EOF*/</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (write( fd, buf, <span class="number">100</span>) != <span class="number">100</span>) 　 　<span class="comment">/* and write*/</span> </span><br><span class="line">	&#125;   </span><br><span class="line">        <span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" write error"</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" lseek error"</span>)</span></span>;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个参数表示偏移量，字母L表示long 型，就是让编译器知道0是long型的</span></span><br><span class="line"><span class="comment">其中 int whence 为下列其中一种:（SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2）.</span></span><br><span class="line"><span class="comment">	SEEK_SET 代表读写位置指向文件头</span></span><br><span class="line"><span class="comment">　　SEEK_CUR 代表目前的读写位置</span></span><br><span class="line"><span class="comment">　　SEEK_END 代表读写位置指向文件尾</span></span><br><span class="line"><span class="comment">这里的1和SEEK-CUR 是同一个意思。</span></span><br></pre></td></tr></table></figure>
<p>对 单个 进程 而言， 这段 程序 能 正常 工作， 但 若有 多个 进程 同时 使用 这种 方法 将 数据 追加 写到 同一 文件， 则 会 产生 问题.</p>
<h4 id="进程A和B对同一文件写操作"><a href="#进程A和B对同一文件写操作" class="headerlink" title="进程A和B对同一文件写操作"></a>进程A和B对同一文件写操作</h4><p>此时， 各 数据 结构 之间 的关系上节图 3- 8 中 所示。 每个 进程 都有 它自己 的 文件 表项， 但是 共享 一个 v 节点 表项。</p>
<ul>
<li>此时如果进程 A 调用了lseek， 它将进程 A 的 该文件当前偏移量设置为1500 字节</li>
<li>然后 内核 切换 进程， 进程 B 运行。 进程 B 执行 lseek， 也 将其 对 该 文件 的 当前 偏移量 设置 为 1 500 字节（ 当前 文件尾 端 处）。 然后 B 调用 write， 它将 B 的 该文 件 当前 文件 偏移量 增加 至 1 600。</li>
<li>然后， 内核 又 进行 进程 切换， 使 进程 A 恢复 运行。 当 A 调用 write 时， 就会从其当前文件偏移量（ 1 500） 处 开始 将 数据 写入 到 文件。</li>
</ul>
<p>这样 也就 覆盖 了 进程 B 刚才 写入 到 该文 件 中的 数据。</p>
<p><strong>问题 出在 逻辑 操作“ 先 定位 到 文件 尾端， 然后 写”， 它 使用 了 两个 分开 的 函数函调用。</strong> </p>
<p>解决问题 的 方法 是 使 这 两个 操作 对于 其他 进程 而言 成为 一个 原子 操作。 如果任何要求 多于 一个 函数 调用 的 操作 不 是 原子 操作， 则在 两个 函数 调用 之间， 内核 有可能 会 临时 挂起 进程（ 正如 我们 前面 所 假定 的）。 </p>
<p>UNIX 系统 为 这样 的 操作 提供 了 一种 原子 操作 方法， 即在 打开 文件 时 设置 O_ APPEND 标志（O_APPEND：每次写操作都写入文件的末尾）。  这样做 使得 内核 在 每次 写 操作 之前， 都将 进程 的 当前 偏移量 设置 到 该 文件 的 尾端 处， 于是 在 每次 写 之前 就不 再 需要 调用 lseek。</p>
<p><strong>原子操作：</strong>顾名思义，就是说像原子一样不可再细分不可被中途打断。一个操作是原子操作，意思就是说这个操作是以原子的方式被执行，要一口气执行完，执行过程不能够被OS的其他行为打断，是一个整体的过程，在其执行过程中，OS的其它行为是插不进来的。</p>
<h3 id="文件锁fctnl"><a href="#文件锁fctnl" class="headerlink" title="文件锁fctnl"></a>文件锁fctnl</h3><p>如何实现原子操作，这里就要用到文件锁fctnl().</p>
<p>该部分讨论文件在已经共享的情况下如何操作，也就是多个程序在操作同以稳健的情况下。，LInux中通常使用文件上锁的方法，来解决共享资源的竞争。</p>
<p>文件锁包括建议性锁（lockf（））和强制性锁（fcntl（））。fcntl不仅可以施加建议性锁还可以施加强制性锁，同时还能对为见额某一记录上锁，依旧是记录锁。</p>
<p>记录锁分为读取锁和写入锁。</p>
<p>略。。。</p>
<h2 id="重定向dup和dup2函数"><a href="#重定向dup和dup2函数" class="headerlink" title="重定向dup和dup2函数"></a>重定向dup和dup2函数</h2><p>函数dup和dup2提供了<strong>复制文件描述符的功能</strong>。</p>
<p>他们通常用于stdin,stdout或进程的stderr的重定向。一般来说，普通输出函数（如：printf），默认是将某信息写入到文件描述符为1的文件中，普通输入函数都默认从文件描述符为0的文件中读取数据。因此重定向操作实际上是关闭某个标准输入输出设备（文件描述符为0、1、2），而将另一个打开的普通文件的文件描述符设置为0、1、2.</p>
<ul>
<li>输入重定向：关闭标准输入设备，打开（或复制）某普通文件，使其文件描述符为0.</li>
<li>输出重定向：关闭标准输出设备，打开（或复制）某普通文件，使其文件描述符为1.    </li>
<li>错误输出重定向：关闭标准错误输入设备，打开（或复制）某普通文件，使其文件描述符为2.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">( <span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由 dup 返回 的 新 文件 描述 符 一定 是 当前 可用 文件 描述 符 中的 最小 数值。</p>
<p> 对于 dup2， 可 以用 fd2 参数 指定 新 描述 符 的 值。 如果 fd2 已经 打开， 则 先 将其 关闭。 如若 fd 等于 fd2， 则 dup2 返回 fd2， 而 不 关闭 它。 否则， fd2 的 FD_ CLOEXEC 文件 描述 符 标志 就被 清除， 这样 fd2 在 进程 调用 exec 时 是 打开 状态。</p>
<p>这些 函数 返回 的 新 文件 描述 符 与 参数 fd 共享 同一个 文件 表项</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_19-16-14.png" alt="Snipaste_2019-02-28_19-16-14"></p>
<h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于函数dup 允许你复制一个oldfd文件描述符。存入一个已存在的文件描述符，它就会返回一个与该描述符“相同”的新的文件描述符。即这两个描述符共享相同的内部结构，共享所有的锁定，读写位置和各项权限或flags等等。例如：对一个文件描述符进行了lseek操作，另一个文件描述符的读写位置也会随之改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd,newfd;</span><br><span class="line">        <span class="keyword">char</span> *bufFD=<span class="string">"Advanced Programming! write by fd\n"</span>;</span><br><span class="line">        <span class="keyword">char</span> *bufNewFD=<span class="string">"Advanced Programming! write by NewFD\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开始复制了</span></span><br><span class="line">        newfd = dup(fd);</span><br><span class="line">        <span class="comment">//使用fd写</span></span><br><span class="line">        write(fd,bufFD,<span class="built_in">strlen</span>(bufFD));</span><br><span class="line">        close(fd);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用newfd写</span></span><br><span class="line">        write(newfd,bufNewFD,<span class="built_in">strlen</span>(bufNewFD));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(close(newfd)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出：</span></span><br><span class="line"><span class="comment">	查看test.txt文件，里面有两段字符串：</span></span><br><span class="line"><span class="comment">	：Advanced Programming! write by fd</span></span><br><span class="line"><span class="comment">	：Advanced Programming! write by newfd</span></span><br></pre></td></tr></table></figure>
<pre><code>可以看出，对fd或newfd进行读写操作时对同一个文件操作，不会覆盖前面文件（共享读写位置）而且还可以看到fd关闭后，对newfd没有影响，使用newfd还可以操作打开的文件。
</code></pre><h3 id="dup2函数（该函数不是很懂）"><a href="#dup2函数（该函数不是很懂）" class="headerlink" title="dup2函数（该函数不是很懂）"></a>dup2函数（该函数不是很懂）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dup2 函数定义在 &lt;unistd.h&gt; 中，函数原形为：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2 )</span></span></span><br></pre></td></tr></table></figure>
<p> 返回值：如成功则返回新的文件描述符，否则出错返回-1. </p>
<p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。</p>
<p>若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等等.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> refd;</span><br><span class="line">        <span class="keyword">char</span> *buf=<span class="string">"Advanced Programming!\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        refd = dup2(fd,fileno(<span class="built_in">stdout</span>));</span><br><span class="line">        <span class="keyword">if</span>(refd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"redirect standard out error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写数据，本应该写入到stdout的信息重定向而写入到目标文件中（test.txt）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dup2的返回值：%d\n"</span>,refd);</span><br><span class="line">        write(fileno(<span class="built_in">stdout</span>),buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，可以看到以下内容</span></span><br><span class="line"><span class="comment">Advanced Programming!</span></span><br><span class="line"><span class="comment">dup2的返回值：1</span></span><br></pre></td></tr></table></figure>
<h1 id="第四节：标准I-O"><a href="#第四节：标准I-O" class="headerlink" title="第四节：标准I/O"></a>第四节：标准I/O</h1><p>标准 I/ O 的 由来</p>
<ul>
<li>标准 I/ O 指的 是 ANSI C 中 定义 的 用于 I/ O 操作 的 一系列 函数。 </li>
<li>只要 操作系统 中 安装 了 C 库， 标准 I/ O 函数 就可以 调用。即: 如果 程序 中 使 用的 是 标准 I/ O 函数， 那么 源 代码 不需要 修改 就可 以在 其他 操作系统 下 编译 运行， 具有 更好 的 可移植性。 </li>
<li>使用 标准 I/ O 可以 减少 系统 调用 的 次数， 提高 系统 效率。 标准 I/ O 函数 在 执行 时 也会 用到 系统 调用。 </li>
</ul>
<h2 id="流-和-FILE-对象"><a href="#流-和-FILE-对象" class="headerlink" title="流 和 FILE 对象"></a>流 和 FILE 对象</h2><p>标准 I/ O 的 核心 对象 就是 流。 当 用 标准 I/ O 打开 一个 文件 时， 就会 创建 一个 FILE 结构 体文件描述符，我们 把 这个 FILE 结构 体 形象 地 称为 流。然后 该文 件 描述 符 就用 于 后续 的 I/ O 操作。</p>
<p>标准 I/ O 文件 流 可用 于 单 字节 或 多 字节（“ 宽”） 字符 集。 流的 定向（ stream’ s orientation） 决定了 所 读、 写的 字符 是 单字 节 还是 多 字节 的。</p>
<p>标准 I/ O 函数 都 基于 流进 行 各种 操作。 标准 I/ O 中的 流的 缓冲 类型 有 以下 三种。 </p>
<p>（1） 全 缓冲： 在 这种 情况下， 当 填满 标准 I/ O 缓冲区 后才 进行 实际 I/ O 操作。 对于 存放 在 磁盘 上 的 普通 文件 用 标准 I/ O 打开 时 默认 是 全 缓冲 的。 当 缓冲区 已满 或 执行 flush 操作 时 才会 进行 磁盘 操作。</p>
<p> （2） 行 缓冲： 在 这种 情况下， 当 在 输入 和 输出 中 遇到 换行符 时 执行 I/ O 操作。 标准 输 入流 和 标准 输出 流 就是 使用 行 缓冲 的 典型 例子。 </p>
<p>（3） 无 缓冲： 不对 I/ O 操作 进行 缓冲， 即在 对流 的 读写 时会 立刻 操作 实际 的 文件。 标准 出错 流 是 不带 缓冲 的， 这就 使得 出错 信息 可以 立刻 显示 在 终端 上， 而 不管 输出 的 内容 是否 包含 换行符。</p>
<p>标准 I/ O 库 提供 缓冲 的 目的 是 尽可能 减少 使用 read 和 write 调用 的 次数。 它 也对 每个 I/ O 流 自动 地 进行 缓冲 管理， 从而 避免 了 应用 程序 需要 考虑 这一点 所带 来的 麻烦。 遗憾的是， 标准 I/ O 库 最 令人 迷惑 的 也是 它的 缓冲。</p>
<h2 id="标准输入-输出和标准错误"><a href="#标准输入-输出和标准错误" class="headerlink" title="标准输入,输出和标准错误"></a>标准输入,输出和标准错误</h2><p> 对 一个 进程 预 定义 了 3 个 流， 并且 这 3 个 流 可以 自动 地 被 进程 使用， 它们 是： 标准 输入、 标准输出和标准错误。 这些 流 文件 描述 符 STDIN_ FILENO、 STDOUT_ FILENO 和 STDERR_ FILENO 所。</p>
<p> 这 3 个 标准 I/ O 流通 过 预定 义 文件 指针 stdin、 stdout 和 stderr 加以 引用。 这 3 个 文件 指针 定义 在 头 文件&lt; stdio. h&gt; 中。</p>
<h2 id="标准-I-O-编程"><a href="#标准-I-O-编程" class="headerlink" title="标准 I/ O 编程"></a>标准 I/ O 编程</h2><h3 id="流的-打开"><a href="#流的-打开" class="headerlink" title="流的 打开"></a>流的 打开</h3><p>使用 标准 I/ O 打开 文件 的 函数 有 fopen()、 fdopen() 和 freopen()。</p>
<p> 它们 可以 以 不同 的 模式 打开 文件， 都 返回 一个 指向 FILE 的 指针， 该 指针 指向 对应 的 I/ O 流。 此后， 对 文件 的 读写 都是 通过 这个 FILE 指针 来 进行。</p>
<ul>
<li><p>fopen() 可以 指定 打开 文件 的 路径 和 模式，</p>
</li>
<li><p>fdopen() 可以 指定 打开 的 文件 描述 符 和 模式，</p>
</li>
<li><p>freopen() 除 可指 定 打开 的 文件、 模式 外， 还可 指定 特定 的 I/ O 流。</p>
<p>fopen() 函数 格式 如表 1. 1 所示。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-19-47.png" alt="Snipaste_2019-03-01_17-19-47"></p>
</li>
</ul>
<p>其中， mode 用于 指定 打开 文件 的 方式。 表 1. 2 说明了 fopen() 中 mode 的 各种 取值。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-20-03.png" alt="Snipaste_2019-03-01_17-20-03"></p>
<h3 id="流的-关闭"><a href="#流的-关闭" class="headerlink" title="流的 关闭"></a>流的 关闭</h3><p>关闭 流的 函数 为 fclose()， 该 函数 将 流的 缓冲区 内 的 数据 全部 写入 文件 中， 并 释放 相关 资源。 fclose() 函数 格式 如表 1. 3 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-22-18.png" alt="Snipaste_2019-03-01_17-22-18"></p>
<h3 id="错误-处理"><a href="#错误-处理" class="headerlink" title="错误 处理"></a>错误 处理</h3><p>标准 I/ O 函数 执行 时 如果 出现 错误， 会把 错误 码 保存 在 errno 中。 程序员 可以 通过 相应 的 函数 打印 错误 信息。</p>
<p>方发一</p>
<p>错误 处理 相关 函数 perror 如表 1. 4 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-24-15.png" alt="Snipaste_2019-03-01_17-24-15"></p>
<p>错误 处理 相关 函数 strerror 如表 1. 5 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-31-44.png" alt="Snipaste_2019-03-01_17-31-44"></p>
<h3 id="实例：打开关闭文件和错误处理"><a href="#实例：打开关闭文件和错误处理" class="headerlink" title="实例：打开关闭文件和错误处理"></a>实例：打开关闭文件和错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp; <span class="comment">// 定义流 指针 </span></span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>） <span class="comment">//NULL是系统定义的宏， 其值为0</span></span><br><span class="line">    &#123; </span><br><span class="line">        perror（＂ fail to fopen＂）; <span class="comment">// 输出 错误 信息 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose（ fp）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果文件1.txt不存在，程序执行时会打印如下信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *fp; </span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>（＂ fail to fopen: %s\ n＂, strerror（ errno））; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    fclose（ fp）;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果 文件 1. txt 不存在， 程序 执行 时会 打印 如下 信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure>
<h3 id="流的读写"><a href="#流的读写" class="headerlink" title="流的读写"></a>流的读写</h3><h4 id="1-字符-节）输入-输出"><a href="#1-字符-节）输入-输出" class="headerlink" title="1.字符(节）输入/输出"></a>1.字符(节）输入/输出</h4><p>一次 读 或 写 一个 字符， 如果 流 是 带 缓冲 的， 则 标准 I/ O 函数 处理 所有 缓冲。</p>
<p><strong>读取</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-29.png" alt="Snipaste_2019-03-01_17-39-29"></p>
<p>getc() 和 fgetc ()从 指 定的 流 中 读取 一个 字符（ 节）， getchar() 从 stdin 中 读取 一个 字符（ 节）。</p>
<p><strong>输出</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-57.png" alt="Snipaste_2019-03-01_17-39-57"></p>
<p>putc() 和 fputc() 向 指 定的 流 输出 一个 字符（ 节）， putchar() 向 stdout 输出 一个 字符（ 节）。 </p>
<p><strong>实例</strong></p>
<p>下面 这个 实例 结合 fputc() 和 fgetc()， 循环 从 标准 输入 读取 任意 个 字符 并将 其中 的 数字 输出 到 标准 输出。</p>
<p>华清远见嵌入式学院; 曾宏安; 冯利美. 嵌入式应用程序设计综合教程 (高等院校嵌入式人才培养规划教材) (Kindle 位置 217-218). 人民邮电出版社. Kindle 版本. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fput. c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">    <span class="keyword">int</span> c; </span><br><span class="line">    <span class="keyword">while</span>（ <span class="number">1</span> ） </span><br><span class="line">    &#123;	</span><br><span class="line">        c = fgetc（ <span class="built_in">stdin</span>）; <span class="comment">// 从 键盘 读取 一个 字符 </span></span><br><span class="line">        <span class="keyword">if</span> （（ c &gt;= <span class="string">'0'</span>） &amp;&amp; （c &lt;= <span class="string">'9'</span>）） fputc（ c, <span class="built_in">stdout</span>）; <span class="comment">// 若 输入 的 是 数字，输出 		if （c == '\n'） break; // 若 遇到 换行符， 跳出 循环</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行 结果 如下。 $ ./a. out abc98io# 4/ wm 984</span></span><br></pre></td></tr></table></figure>
<h4 id="2-行输入-输出"><a href="#2-行输入-输出" class="headerlink" title="2.行输入/输出"></a>2.行输入/输出</h4><p>行 输入/ 输出 函数 一次 操作 一行。如果 想要 一次 读 或 写 一行， 则 使用 fgets 和 fputs。 每 行都 以 一个 换行符 终止。 当 调用 fgets 时， 应 说明 能 处理 的 最大 行长。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-15.png" alt="Snipaste_2019-03-01_17-58-15"></p>
<p>gets 函数 容易 造成 缓冲区 溢出， 不 推荐 大家 使用。 fgets 从 指 定的 流 中 读取 一个 字符串， 当 遇到\ n 或 读取 了 size- 1 个 字符 后 返回。 注意， fgets 不能 保证 每次 都能 读出 一行。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-41.png" alt="Snipaste_2019-03-01_17-58-41"></p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 以 fgets() 为例 计算 一个 文本 文件 的 行数。 /*fgets. c*/ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; string. h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> main（ <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]） </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[ <span class="number">128</span>];</span><br><span class="line">    FILE *fp; <span class="keyword">if</span> （argc &lt; <span class="number">2</span>） </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>（＂ Usage : %s &lt; file&gt;\ n＂, argv[ <span class="number">0</span>]）;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> （（ fp = fopen（ argv[ <span class="number">1</span>], ＂r＂）） == <span class="literal">NULL</span>） </span><br><span class="line">	&#123; </span><br><span class="line">		perror（＂ fail to fopen＂）;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>（ fgets（ buf, <span class="number">128</span>, fp） != <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> （buf[ <span class="built_in">strlen</span>（ buf）- <span class="number">1</span>] == <span class="string">'\n'</span>） </span><br><span class="line">    	line++;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>（＂ The line of %s is %d\ n＂, argv[ <span class="number">1</span>], line）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行 该 程序， 结果 如下。 $ ./a. out test. txt The line of test. txt is 64</span></span><br></pre></td></tr></table></figure>
<h4 id="3-指定大小为单位读写文件"><a href="#3-指定大小为单位读写文件" class="headerlink" title="3.指定大小为单位读写文件"></a>3.指定大小为单位读写文件</h4><p>在 文件 流 被打 开 之后， 可 对 文件 流 按指 定 大小 为 单位 进行 读写 操作。fread 和 fwrite 函数 支持 这种 类型 的 I/ O。 每次 I/ O 操作 读 或 写 某种 数量 的 对象， 而每 个 对象 具有 指定 的 长度。 这 两个 函数 常 用于 从 二进制 文件 中 每次 读 或 写 一个 结构。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-27.png" alt="Snipaste_2019-03-01_18-13-27"></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-40.png" alt="Snipaste_2019-03-01_18-13-40"></p>
<h3 id="流的定位"><a href="#流的定位" class="headerlink" title="流的定位"></a>流的定位</h3><p>每个 打开 的 流 内部 都有 一个 当前 读写 位置。 流 在 打开 时， 当前 读写 位置 为 0， 表示 文件 的 开始 位置。 每 读写 一次 后， 当前 读写 位置 自动 增加 实际 读写 的 大小。 在 读写 流 之间 可 先 对流 进行 定位， 即 移动 到 指定 的 位置 再 操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-16-07.png" alt="Snipaste_2019-03-01_18-16-07"></p>
<h3 id="格式化-输入-输出"><a href="#格式化-输入-输出" class="headerlink" title="格式化 输入 输出"></a>格式化 输入 输出</h3><p>格式化 输入/ 输出 函数 可以 指定 输入/ 输出 的 具体 格式， 包括 读者 已经 非常 熟悉 的 printf()、 scanf() 等 函数。</p>
<p><strong>格式化输入</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-17-55.png" alt="Snipaste_2019-03-01_18-17-55"></p>
<p><strong>格式化输出</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-18-05.png" alt="Snipaste_2019-03-01_18-18-05"></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/数据结构.html" rel="next" title="数据结构">
                <i class="fa fa-chevron-left"></i> 数据结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/进程与线程.html" rel="prev" title="进程与线程">
                进程与线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序"><span class="nav-number">1.</span> <span class="nav-text">序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第一节：文件I-O和标准I-O的比较"><span class="nav-number">2.</span> <span class="nav-text">第一节：文件I/O和标准I/O的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是文件I-O和标准I-O"><span class="nav-number">2.1.</span> <span class="nav-text">什么是文件I/O和标准I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二者的区别"><span class="nav-number">2.2.</span> <span class="nav-text">二者的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件I-O和标准I-O使用的函数比较"><span class="nav-number">2.3.</span> <span class="nav-text">文件I/O和标准I/O使用的函数比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fopen与open比较"><span class="nav-number">2.3.1.</span> <span class="nav-text">fopen与open比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fclose与close比较"><span class="nav-number">2.3.2.</span> <span class="nav-text">fclose与close比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读文件比较：getc-fscanf-fgets和read"><span class="nav-number">2.3.3.</span> <span class="nav-text">读文件比较：getc,fscanf,fgets和read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断文件结尾比较"><span class="nav-number">2.3.4.</span> <span class="nav-text">判断文件结尾比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写文件比较：putc-fputs-fprintf和write"><span class="nav-number">2.3.5.</span> <span class="nav-text">写文件比较：putc,fputs,fprintf和write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机存取比较：fseek-、ftell-和lseek"><span class="nav-number">2.3.6.</span> <span class="nav-text">随机存取比较：fseek()、ftell()和lseek()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用与库函数"><span class="nav-number">2.3.7.</span> <span class="nav-text">系统调用与库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用"><span class="nav-number">2.3.7.1.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#库函数"><span class="nav-number">2.3.7.2.</span> <span class="nav-text">库函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户编程接口API"><span class="nav-number">2.3.7.3.</span> <span class="nav-text">用户编程接口API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一句话理解文件I-O和标准I-O"><span class="nav-number">2.4.</span> <span class="nav-text">一句话理解文件I/O和标准I/O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二节：文件I-O"><span class="nav-number">3.</span> <span class="nav-text">第二节：文件I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">3.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件-描述-符"><span class="nav-number">3.2.</span> <span class="nav-text">文件 描述 符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的打开和关闭及-创建"><span class="nav-number">3.3.</span> <span class="nav-text">文件的打开和关闭及 创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-open"><span class="nav-number">3.3.1.</span> <span class="nav-text">函数 open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-close"><span class="nav-number">3.3.2.</span> <span class="nav-text">函数 close</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例：文件的打开与关闭"><span class="nav-number">3.3.3.</span> <span class="nav-text">实例：文件的打开与关闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的读写"><span class="nav-number">3.4.</span> <span class="nav-text">文件的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-read"><span class="nav-number">3.4.1.</span> <span class="nav-text">函数 read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-write"><span class="nav-number">3.4.2.</span> <span class="nav-text">函数 write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例：使用-read-和-write-函数-复制-一个-文件。"><span class="nav-number">3.4.3.</span> <span class="nav-text">实例：使用 read 和 write 函数 复制 一个 文件。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lseek文件定位"><span class="nav-number">3.5.</span> <span class="nav-text">lseek文件定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三节：内核数据结构分析"><span class="nav-number">4.</span> <span class="nav-text">第三节：内核数据结构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作的进一步说明"><span class="nav-number">4.1.</span> <span class="nav-text">文件操作的进一步说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子操作"><span class="nav-number">4.2.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例分析"><span class="nav-number">4.2.1.</span> <span class="nav-text">实例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#追加数据到-一个-文件"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">追加数据到 一个 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程A和B对同一文件写操作"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">进程A和B对同一文件写操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件锁fctnl"><span class="nav-number">4.2.2.</span> <span class="nav-text">文件锁fctnl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定向dup和dup2函数"><span class="nav-number">4.3.</span> <span class="nav-text">重定向dup和dup2函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dup函数"><span class="nav-number">4.3.1.</span> <span class="nav-text">dup函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dup2函数（该函数不是很懂）"><span class="nav-number">4.3.2.</span> <span class="nav-text">dup2函数（该函数不是很懂）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四节：标准I-O"><span class="nav-number">5.</span> <span class="nav-text">第四节：标准I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#流-和-FILE-对象"><span class="nav-number">5.1.</span> <span class="nav-text">流 和 FILE 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准输入-输出和标准错误"><span class="nav-number">5.2.</span> <span class="nav-text">标准输入,输出和标准错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准-I-O-编程"><span class="nav-number">5.3.</span> <span class="nav-text">标准 I/ O 编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流的-打开"><span class="nav-number">5.3.1.</span> <span class="nav-text">流的 打开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流的-关闭"><span class="nav-number">5.3.2.</span> <span class="nav-text">流的 关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误-处理"><span class="nav-number">5.3.3.</span> <span class="nav-text">错误 处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例：打开关闭文件和错误处理"><span class="nav-number">5.3.4.</span> <span class="nav-text">实例：打开关闭文件和错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流的读写"><span class="nav-number">5.3.5.</span> <span class="nav-text">流的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-字符-节）输入-输出"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">1.字符(节）输入/输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-行输入-输出"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">2.行输入/输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-指定大小为单位读写文件"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">3.指定大小为单位读写文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流的定位"><span class="nav-number">5.3.6.</span> <span class="nav-text">流的定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化-输入-输出"><span class="nav-number">5.3.7.</span> <span class="nav-text">格式化 输入 输出</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
