<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="暂时无">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeff">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/index.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jeff">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-19-cs.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog（重要保留）-2018-12-19-cs.html" itemprop="url">
                  cs
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-12-19 02:58:59" itemprop="dateCreated datePublished" datetime="2022-12-19T02:58:59+08:00">2022-12-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-19 02:59:46" itemprop="dateModified" datetime="2018-12-19T02:59:46+08:00">2018-12-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。</p>
<p>另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。</p>
<p>谢谢！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/重要说明.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/重要说明.html" itemprop="url">
                  重要说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-28 21:37:19" itemprop="dateCreated datePublished" datetime="2019-12-28T21:37:19+08:00">2019-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-23 16:32:34" itemprop="dateModified" datetime="2019-02-23T16:32:34+08:00">2019-02-23</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。</p>
<p>博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/进程与线程.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/进程与线程.html" itemprop="url">
                  进程与线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 19:08:20" itemprop="dateCreated datePublished" datetime="2019-03-01T19:08:20+08:00">2019-03-01</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/unix下输入与输出-I-0.html" itemprop="url">
                  unix下输入与输出(I/0)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 11:31:17" itemprop="dateCreated datePublished" datetime="2019-02-28T11:31:17+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-01 18:58:47" itemprop="dateModified" datetime="2019-03-01T18:58:47+08:00">2019-03-01</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本章节主要讲解Linux下如何对文件操作，包括两部分：</p>
<p>文件I/O和标准I/O</p>
<p>他们有什么区别，该部分将使用一个专门都一下节去讲解。</p>
<h1 id="第一节：文件I-O和标准I-O的比较"><a href="#第一节：文件I-O和标准I-O的比较" class="headerlink" title="第一节：文件I/O和标准I/O的比较"></a>第一节：文件I/O和标准I/O的比较</h1><p>来源说明</p>
<p>作者：zqixiao_09 </p>
<p>原文地址：<a href="https://blog.csdn.net/zqixiao_09/article/details/50444465" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50444465</a> </p>
<h2 id="什么是文件I-O和标准I-O"><a href="#什么是文件I-O和标准I-O" class="headerlink" title="什么是文件I/O和标准I/O"></a>什么是文件I/O和标准I/O</h2><p>文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。</p>
<p>标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。</p>
<ul>
<li>全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 </li>
<li>行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 </li>
<li>不带缓存：stderr就是了。</li>
</ul>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><ul>
<li><p>文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。</p>
</li>
<li><p>通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。</p>
</li>
<li><p>文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。</p>
<p><em>注：Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。</em></p>
</li>
</ul>
<h2 id="文件I-O和标准I-O使用的函数比较"><a href="#文件I-O和标准I-O使用的函数比较" class="headerlink" title="文件I/O和标准I/O使用的函数比较"></a>文件I/O和标准I/O使用的函数比较</h2><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_11-57-29.png" alt="Snipaste_2019-02-28_11-57-29"></p>
<h3 id="fopen与open比较"><a href="#fopen与open比较" class="headerlink" title="fopen与open比较"></a>fopen与open比较</h3><p><strong>标准I/O使用fopen函数打开一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span> *mod)</span><br></pre></td></tr></table></figure>
<ul>
<li>path：文件名。</li>
<li>mod：用于指定文件打开的模式的字符串，比如”r”,”w”,”w+”,”a”等等，可以加上字母b用以指定以二进制模式打开。</li>
<li>返回值：如果成功打开，返回一个FILE文件指针，如果失败返回NULL。（这里的文件指针并不是指向实际的文 件，而是一个关于文件信息的数据包，其中包括文件使用的缓冲区信息。）</li>
</ul>
<p><strong>文件IO使用open函数用于打开一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd=open(<span class="keyword">char</span> *name,<span class="keyword">int</span> how);</span><br></pre></td></tr></table></figure>
<ul>
<li>name：文件名字符串</li>
<li>how指定打开的模式：O_RDONLY(只读),O_WRONLY(只写）,O_RDWR （可读可写)。（其他模式请man 2 open）。</li>
<li>返回值：成功返回一个正整数称为文件描述符，这与标准I/O显著不同，失败的话返回-1，与标准I/O返回NULL也是不同的。</li>
</ul>
<h3 id="fclose与close比较"><a href="#fclose与close比较" class="headerlink" title="fclose与close比较"></a>fclose与close比较</h3><p>标准I/O使用fclose关闭文件，将文件指针传入即可，如果成功关闭，返回0，否则返回EOF</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fclose(fp)!=<span class="number">0</span>)  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error in closing file"</span>);</span><br></pre></td></tr></table></figure>
<p>文件IO使用close用于关闭open打开的文件，与fclose类似，只不过当错误发生时返回的是-1，而不是EOF，成功关闭同样是返回0。</p>
<h3 id="读文件比较：getc-fscanf-fgets和read"><a href="#读文件比较：getc-fscanf-fgets和read" class="headerlink" title="读文件比较：getc,fscanf,fgets和read"></a>读文件比较：getc,fscanf,fgets和read</h3><p><strong>标 准I/O中进行文件读取</strong></p>
<ul>
<li>可以使用 <strong>getc</strong>，一个字符一个字符的读取，也可以使用gets（读取标准io读入的）</li>
<li>fgets以字符串单位进行读取（读到遇 到的第一个换行字符的后面）</li>
</ul>
<p>gets（接受一个参数，文件指针）不判断目标数组是否能够容纳读入的字符，可能导致存储溢出(不建议使用），而fgets使用三个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数和gets一样，用于存储输入的地址，第二个参数为整数，表示输入字符串的最大长度，最后一个参数就是文件指针，指向要读取的文件。</p>
<ul>
<li>最 后是fscanf，与scanf类似，只不过增加了一个参数用于指定操作的文件，比如fscanf(fp,”%s”,words)</li>
</ul>
<p><strong>文件I/O中进行文件读取</strong></p>
<p>文件IO中使用read函数用于读取open函数打开的文件，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> numread=read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> qty);</span><br></pre></td></tr></table></figure>
<p>其中fd就是open返回的文件描述符，buf用于存储数据的目的缓冲区，而qty指定要读取的字节数。如果成功读取，就返回读取的字节数目（小于等于qty）</p>
<h3 id="判断文件结尾比较"><a href="#判断文件结尾比较" class="headerlink" title="判断文件结尾比较"></a>判断文件结尾比较</h3><p>如果尝试读取达到文件结尾，标准IO的getc会返回特殊值EOF，而fgets碰到EOF会返回NULL,而对于unix的read函数，情况有所不 同。read读取qty指定的字节数，最终读取的数据可能没有你所要求的那么多（qty），而当读到结尾再要读的话，read函数将返回0.</p>
<h3 id="写文件比较：putc-fputs-fprintf和write"><a href="#写文件比较：putc-fputs-fprintf和write" class="headerlink" title="写文件比较：putc,fputs,fprintf和write"></a>写文件比较：putc,fputs,fprintf和write</h3><p><strong>标准I/O中进行文件写入</strong></p>
<p>使用putc写入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putc(ch,fp);</span><br><span class="line"><span class="comment">//第一个参数是字符，第二个是文件指针。</span></span><br></pre></td></tr></table></figure>
<p>使用fputs写入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(buf,fp);</span><br><span class="line"><span class="comment">//仅仅是第一个参数换成了字符串地址。</span></span><br></pre></td></tr></table></figure>
<p>使用fprintf写入字符</p>
<p>fprintf与printf类似，增加了一个参数用于指定写入的文件，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello %s.\n"</span>,<span class="string">"dennis"</span>);</span><br></pre></td></tr></table></figure>
<p>切记fscanf和fprintf将FILE指针作为第一个参数，而putc,fputs则是作为第二个参数。</p>
<p><strong>文件I/O中进行文件写入</strong></p>
<p>在文件IO中提供write函数用于写入文件，原型与read类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result=write(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf ,<span class="keyword">size_t</span> amt);</span><br></pre></td></tr></table></figure>
<p>fd：文件描述符</p>
<p>buf：是将要写入的内存数据</p>
<p>amt：是要写的字节数。</p>
<p>返回值：如果写入成功返回写入的字节数，通过result与amt的比较可以判断是否写入正常，如果写入失败返回-1</p>
<h3 id="随机存取比较：fseek-、ftell-和lseek"><a href="#随机存取比较：fseek-、ftell-和lseek" class="headerlink" title="随机存取比较：fseek()、ftell()和lseek()"></a>随机存取比较：fseek()、ftell()和lseek()</h3><p><strong>标准I/O中进行随机存取</strong></p>
<p>标准I/O使用fseek和ftell用于文件的随机存取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fseek函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数：是文件指针</p>
<p>第二个参数：是一个long类型的偏移量（offset），表示从起始点开始移动的距离。</p>
<p>第三个参数：是用于指定起始点的模式，stdio.h指定了下列模式常量：SEEK_SET ：文件开始处， SEEK_CUR ：当前位置<br>，    SEEK_END： 文件结尾处</p>
<p>看几个调用例子： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_SET); <span class="comment">//找到文件的开始处 </span></span><br><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END); <span class="comment">//定位到文件结尾处 </span></span><br><span class="line">fseek(fp,<span class="number">2L</span>,SEEK_CUR); <span class="comment">//文件当前位置向前移动2个字节数</span></span><br></pre></td></tr></table></figure>
<p>而ftell函数用于返回文件的当前位置，返回类型是一个long类型，比如下面的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END);<span class="comment">//定位到结尾 </span></span><br><span class="line"><span class="keyword">long</span> last=ftell(fp); <span class="comment">//返回当前位置</span></span><br></pre></td></tr></table></figure>
<p>那么此时的last就是文件指针fp指向的文件的字节数。</p>
<p><strong>文件I/O中进行随机存取</strong></p>
<p>与标准I/O类似，unix系统提供了lseek来完成fseek的功能，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型如下：</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p>fildes:是文件描述符</p>
<p>offset:也是偏移量</p>
<p>whence:同样是指定起始点模式</p>
<p>唯一的不同是lseek有返回值，如果成功就 返回指针变化前的位置，否则返回-1。whence的取值与fseek相同：SEEK_SET,SEEK_CUR,SEEK_END，但也可以用整数 0,1,2相应代替。</p>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>上面我们一直在讨论文件I/O与标准I/O的区别，其实可以这样说，文件I/O是系统调用、标准I/O是库函数，看下面这张图：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_12-42-29.png" alt="Snipaste_2019-02-28_12-42-29"></p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>操作系统负责管理和分配所有的计算机资源。为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用。通过这组接口用户程序可以使用操作系统内核提供的各种功能。例如分配内存、创建进程、实现进程之间的通信等。</p>
<p>   为什么不允许程序直接访问计算机资源？答案是不安全。单片机开发中，由于不需要操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，程序访问资源的方式都发生了改变。操作系统基本上都支持多任务，即同时可以运行多个程序。如果允许程序直接访问系统资源，肯定会带来很多问题。因此，所有软硬件资源的管理和分配都有操作系统负责。程序要获取资源（如分配内存，读写串口）必须由操作系统来完成，即用户程序向操作系统发出服务请求，操作系统收到请求后执行相关的代码来处理。</p>
<p>   用户程序向操作系统提出请求的接口就是系统调用。所有的操作系统都会提供系统调用接口，只不过不同的操作系统提供的系统调用接口各不相同。Linux 系统调用接口非常精简，它继承了Unix 系统调用中最基本的和最有用的部分。这些系统调用按照功能大致可分为<strong>进程控制、进程间通信、文件系统控制、存储管理、网络管理、套接字控制、用户管理等几类。</strong></p>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>库函数可以说是对系统调用的一种封装，因为系统调用是面对的是操作系统，系统包括Linux、Windows等，如果直接系统调用，会影响程序的移植性，所以这里使用了库函数，比如说C库，这样只要系统中安装了C库，就都可以使用这些函数，比如printf()  scanf()等，C库相当于对系统函数进行了翻译，使我们的APP可以调用这些函数；</p>
<h4 id="用户编程接口API"><a href="#用户编程接口API" class="headerlink" title="用户编程接口API"></a>用户编程接口API</h4><p> 前面提到利用系统调用接口程序可以访问各种资源，但在实际开发中程序并不直接使用系统调用接口，而是使用用户编程接口（API）。为什么不直接使用系统调用接口呢？</p>
<p>原因如下：</p>
<p>1）系统调用接口功能非常简单，无法满足程序的需求。</p>
<p>2）不同操作系统的系统调用接口不兼容，程序移植时工作量大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户编程接口通俗的解释就是各种库（最重要的就是C库）中的函数。为了提高开发效率，C库中实现了很多函数。这些函数实现了常用的功能，供程序员调用。这样一来，程序员不需要自己编写这些代码，直接调用库函数就可以实现基本功能，提高了代码的复用率。使用用户编程接口还有一个好处：程序具有良好的可移植性。几乎所有的操作系统上都实现了C库，所以程序通常只需要重新编译一下就可以在其他操作系统下运行。</span><br><span class="line"></span><br><span class="line">用户编程接口（API）在实现时，通常都要依赖系统调用接口。例如，创建进程的API函数fork()对应于内核空间的sys_fork()系统调用。很多API函数西亚我哦通过多个系统调用来完成其功能。还有一些API函数不要调用任何系统调用。</span><br><span class="line"></span><br><span class="line"> 在Linux 中用户编程接口（API）遵循了在Unix中最流行的应用编程界面标准——POSIX标准。POSIX标准是由IEEE和ISO/IEC共同开发的标准系统。该标准基于当时想用的Unix 实践和经验，描述了操作系统的系统调用编程接口（实际上就是API），用于保证应用程序可以在源代码一级商多种操作系统上运行。这些系统调用编程接口主要是通过C库（libc )实现的。</span><br></pre></td></tr></table></figure>
<h2 id="一句话理解文件I-O和标准I-O"><a href="#一句话理解文件I-O和标准I-O" class="headerlink" title="一句话理解文件I/O和标准I/O"></a>一句话理解文件I/O和标准I/O</h2><ul>
<li>文件I/O更接近于底层硬件的I/O。其使用是通过是系统调用实现的。</li>
<li>标准I/O可以说是对文件I/O的一种封装，是基于库函数。</li>
<li>文件I/O多针对于操作系统而标准I/O多针对于应用程序</li>
</ul>
<h1 id="第二节：文件I-O"><a href="#第二节：文件I-O" class="headerlink" title="第二节：文件I/O"></a>第二节：文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX 系统文件 I/ O 函数的操作有—— 打开 文件、 读 文件、 写 文件 等。 UNIX 系统 中的 大多数 文件 I/ O 只需 用到 5 个 函数： open、 read、 write、 lseek 以及 close。</p>
<p>本章 描述 的 函数 经常 被称为 不带 缓冲 的 I/ O，术语 不带 缓冲 指的 是 每个 read 和 write 都 调用 内核 中的 一个 系统 调用。</p>
<p>只要 涉及 在 多个 进程 间 共享 资源， 原子 操作 的 概念 就 变得 非常 重要。 我们将 通过 文件 I/ O 和 open 函数 的 参数 来 讨论 此 概念。</p>
<p>本章 还将 进一步 讨论 在 多个 进程 间 如何 共享 文件， 以及 所 涉及 的 内核 有关 数据 结构。 在 描述 了 这些 特征 后， 将 说明 dup、 fcntl、 sync、 fsync 和 ioctl 函数。</p>
<h2 id="文件-描述-符"><a href="#文件-描述-符" class="headerlink" title="文件 描述 符"></a>文件 描述 符</h2><p>对于 内核 而言， 所有 打开 的 文件 都 通过 文件 描述 符 引用。 文件 描述 符 是 一个 非 负 整数。 当 打开 一个 现有 文件 或 创建 一个 新 文件 时， 内核 向 进程 返回 一个 文件 描述 符。当 读、 写 一个 文件 时， 使用 open 或 creat 返回 的 文件 描述 符 标识 该 文件， 将其 作为 参数 传送 给 read 或 write。</p>
<p>按照 惯例， UNIX 系统 shell 把 文件 描述 符 0 与 进程 的 标准 输入 关联， 文件 描述 符 1 与 标准 输出 关联， 文件 描述 符 2 与 标准 错误 关联。</p>
<p>文件 描述 符 的 变化 范围是 0 ～ OPEN_ MAX- 1（ 见图 2- 11）。 早期 的 UNIX 系统 实现 采用 的 上 限值 是 19（ 允许 每个 进程 最多 打开 20 个 文件）， 但 现在 很多 系统 将其 上限 值 增加 至 63。</p>
<h2 id="文件的打开和关闭及-创建"><a href="#文件的打开和关闭及-创建" class="headerlink" title="文件的打开和关闭及 创建"></a>文件的打开和关闭及 创建</h2><h3 id="函数-open"><a href="#函数-open" class="headerlink" title="函数 open"></a>函数 open</h3><p>调用 open 或 openat 函数 可以 打开 或 创建 一个 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>pathname ：</strong>是待打开/创建文件的路径名（如 C:/cpp/a.cpp）。</p>
<p><strong>oflag ：</strong>用于指定文件的打开/创建模式。</p>
<p>这个参数可由以下常量（定义于 fcntl.h）通过逻辑或构成。打开/创建文件时，至少得使用下述三个常量中的一个。</p>
<ul>
<li>O_RDONLY　　只读模式</li>
<li>O_WRONLY　　只写模式</li>
<li>O_RDWR　　读写模式</li>
</ul>
<p>以下常量是选用的：</p>
<ul>
<li>O_APPEND　　每次写操作都写入文件的末尾</li>
<li>O_CREAT　　如果指定文件不存在，则创建这个文件</li>
<li>O_EXCL　　如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li>
<li>O_TRUNC　　如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li>
<li>O_NOCTTY　　如果路径名指向终端设备，不要把这个设备用作控制终端。</li>
<li>O_NONBLOCK　　如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）</li>
</ul>
<p>以下三个常量同样是选用的，它们用于同步输入输出</p>
<ul>
<li>O_DSYNC　　等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。</li>
<li>O_RSYNC　　read 等待所有写入同一区域的写操作完成后再进行</li>
<li>O_SYNC　　等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li>
</ul>
<p><strong>第三个参数（…）</strong>仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。</p>
<p><strong>返回值：</strong>成功则返回文件描述符，否则返回 -1，open 返回的文件描述符一定是最小的未被使用的描述符。</p>
<p>函数 creat</p>
<p>也可 调用 creat 函数 创建 一个 新 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; fcntl. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *path, mode_ t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 值： 若 成功， 返回 为 只 写 打开 的 文件 描述 符； 若 出错， 返回 − 1 注意，</p>
<p> 此 函数 等效 于： open( path, O_ WRONLY ｜ O_ CREAT ｜ O_ TRUNC, mode)。 因此现在很少有使用creat()函数来创建新文件;</p>
<h3 id="函数-close"><a href="#函数-close" class="headerlink" title="函数 close"></a>函数 close</h3><p>调用 close 函数可以关闭 一个已打开的文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line">int close (int fd)；</span><br></pre></td></tr></table></figure>
<p> 返回 值： 若 成功， 返回 0； 若 出错， 返回 − 1 </p>
<p>关闭 一个 文件 时 还会 释放 该 进程 加在 该 文件 上 的 所有 记录 锁。 </p>
<p> 当 一个 进程 终止 时， 内核 自动 关闭 它 所有 的 打开 文件。 很多 程序 都 利用 了 这一 功能 而 不显 式 地 用 close 关闭 打开 文件。 </p>
<h3 id="实例：文件的打开与关闭"><a href="#实例：文件的打开与关闭" class="headerlink" title="实例：文件的打开与关闭"></a>实例：文件的打开与关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd；</span><br><span class="line">   <span class="keyword">if</span>((fd=open(“test.txt”,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>)&lt;<span class="number">0</span>);</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fail tpo open"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      	close(fd);</span><br><span class="line"> 	 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h3 id="函数-read"><a href="#函数-read" class="headerlink" title="函数 read"></a>函数 read</h3><p>调用 read 函数 从 打开 文件 中 读 数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回读到的字节数，若已到文件末尾则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:读取数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要读取的字节数</span></span><br></pre></td></tr></table></figure>
<p> 　　有几种情况可使实际读到的字节数少于要求读的字节数：</p>
<p>　　1）读普通文件时，在读到要求字节数之前就已经达到了文件末端。例如，若在到达文件末端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0（文件末端）。</p>
<p>　　2）当从终端设备读时，通常一次最多读一行。</p>
<p>　　3）当从网络读时，网络中的缓存机构可能造成返回值小于所要求读的字结束。</p>
<p>　　4）当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</p>
<p>　　5）当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。</p>
<p>　　6）当某一个信号造成中断，而已经读取了部分数据。</p>
<h3 id="函数-write"><a href="#函数-write" class="headerlink" title="函数 write"></a>函数 write</h3><p>write函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nb　write函数定义如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure>
<h3 id="实例：使用-read-和-write-函数-复制-一个-文件。"><a href="#实例：使用-read-和-write-函数-复制-一个-文件。" class="headerlink" title="实例：使用 read 和 write 函数 复制 一个 文件。"></a>实例：使用 read 和 write 函数 复制 一个 文件。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: copy_file.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd,to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断入参</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s fromfile tofile !\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">if</span>( (from_fd = open(argv[<span class="number">1</span>],O_RDONLY | O_CREAT ))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s Error!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建目的文件</span></span><br><span class="line">    <span class="keyword">if</span>( (to_fd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT))==<span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s error! \n"</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//测得文件大小</span></span><br><span class="line">    file_len=lseek(from_fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(from_fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from file size is %d!\n"</span>,file_len);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//进行文件拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(from_fd, buffer, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(to_fd, buffer, ret );</span><br><span class="line">        file_len = ret;</span><br><span class="line">        bzero( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"there are %d buyes data left without copy!\n"</span>,file_len);</span><br><span class="line">    close(from_fd);</span><br><span class="line">    close(to_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lseek文件定位"><a href="#lseek文件定位" class="headerlink" title="lseek文件定位"></a>lseek文件定位</h2><p>lseek函数对文件当位置进行定位。它只能对可定位（可随机 访问）文件操作。管道，套接字和大部分字符设备文件不支持该类操作。</p>
<p> 函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p> <strong>函数功能：</strong> lseek系统调用用来移动读写指针的位置</p>
<p><strong>参数说明：</strong></p>
<p>fd:要操作的文件</p>
<p>  offset：相对whence移动的位移数，允许负值</p>
<p>  whence：起始指针，它有三个取值</p>
<ul>
<li><p>SEEK_SET 从文件开始处计算偏移量</p>
</li>
<li><p>​         SEEK_CUR 从文件指针的当前位置开始计算偏移</p>
</li>
<li><p>SEEK_END 从文件结尾处开始计算偏移量</p>
<p>文件指针值等于当前指针值加上offset的值。     </p>
</li>
</ul>
<p><strong>返回值：</strong>调用成功时范围当前的读写位置，也就是距离文件开始处多少字节，若 有错误返回-1</p>
<p><strong>常见用法：</strong></p>
<ul>
<li>将文件读写指针移动到文件开头：lseek(int fildes, 0, SEEK_SET);</li>
<li>将文件读写指针移动到文件结尾：lseek(int fildes, 0, SEEK_END);</li>
<li>获取文件读写指针当前的位置：lseek(int fikdes, 0, SEEK_CUR);</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>  readfd, writefd;  </span><br><span class="line">    <span class="keyword">long</span> filelen=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span>  ret=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];  </span><br><span class="line">    <span class="keyword">char</span> *ptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*打开源文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((readfd=open(<span class="string">"test.txt"</span>, O_RDONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">      <span class="comment">/*创建目的文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((writefd=open(<span class="string">"dest.txt"</span>, O_WRONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*测得文件大小*/</span>  </span><br><span class="line">    filelen= lseek(readfd,<span class="number">0L</span>,SEEK_END);  </span><br><span class="line">    lseek(readfd,<span class="number">0L</span>,SEEK_SET);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read file size is %d\n"</span>,filelen);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进行文件拷贝*/</span>  </span><br><span class="line">    <span class="keyword">while</span>(ret)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret= read(readfd, buffer, BUFFER_SIZE);  </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read Error\n"</span>);   </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);          </span><br><span class="line">        &#125;  </span><br><span class="line">        write(writefd, buffer, ret);  </span><br><span class="line">        filelen-=ret;  </span><br><span class="line">        bzero(buffer,BUFFER_SIZE);  </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    close(readfd);   </span><br><span class="line">    close(writefd);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考实例：</strong></p>
<p><a href="https://www.cnblogs.com/mickole/p/3182033.html" target="_blank" rel="noopener">利用lseek()创建空洞文件</a></p>
<p><a href="https://www.cnblogs.com/zxysmalleyes/p/5321207.html" target="_blank" rel="noopener">用lseek拼接两个文件</a></p>
<h1 id="第三节：内核数据结构分析"><a href="#第三节：内核数据结构分析" class="headerlink" title="第三节：内核数据结构分析"></a>第三节：内核数据结构分析</h1><p>UNIX 系统 支持 在 不同 进程 间 共享 打开 文件。进程间的这种 共享是如何进行的，为此 先 介绍 内核 用于 所有 I/ O 的 数据 结构。 </p>
<p>内核 使用 3 种数 据 结构 表示 打开 文件， 它们 之间 的 关系 决定了 在 文件 共享 方面 一个 进程 对 另一个 进程 可能 产生 的 影响。 </p>
<p>（1）每个 进程 在 进程表 中 都有 一个 记录 项（文件表项）， 记录 项 中 包含 一张 打开 文件 描述 符 表， 可将 其 视为 一个 矢量， 每个 描述 符 占用 一项。 与 每个 文件 描述 符 相 关联 的 是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a． 文件 描述 符 标志（ close_ on_ exec， 参见 图 3- 7 和 3. 14 节）；</span><br><span class="line"></span><br><span class="line">b． 指向 一个 文件 表项 的 指针。</span><br></pre></td></tr></table></figure>
<p>（2） 内核 为所 有打 开 文件 维持 一张 文件 表。 每个 文件 表项 包含：</p>
<p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等， 关于 这些 标志 的 更多 信息 参见 3. 14 节）；</p>
<p> b． 当前 文件 偏移量； </p>
<p>c． 指向 该 文件 v 节点 表项 的 指针。</p>
<p> （3） 每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。 v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。 对于 大多数 文件， v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。 这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。 例如， i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等（ 4. 14 节 较 详细 地说 明了 典型 UNIX 系统 文件 系统， 并将 更多 地 介绍 i 节点）。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-34-56.png" alt="Snipaste_2019-02-28_16-34-56"></p>
<p>个人梳理：</p>
<ul>
<li><p>1.每个进程都会有一个进程表项，进程表项中包含一个文件描述符表，每个描述符占有一项，每个描述符对应一个指针。该指针指向文件表项。</p>
</li>
<li><p>2.内核会为所有的打开的文件创建 一张 文件表项。 每个文件表项包含：     </p>
<p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等）。</p>
<p>b． 当前 文件 偏移量；</p>
<p> c． 指向 该 文件 v 节点 表项 的 指针。</p>
</li>
<li><p>3.每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。</p>
<p>v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。</p>
<p>v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。</p>
<p> i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等。</p>
</li>
</ul>
<p>注：这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。</p>
<p>注意， 文件 描述 符 标志 和 文件 状态 标志 在作 用 范围 方面 的 区别， 前者 只用于 一个 进程 的 一个 描述 符， 而后 者 则应 用于 指向 该给 定 文件 表项 的 任何 进程 中的 所有 描述 符。</p>
<p><strong>两个 独立 进程 各自 打开 了 同一 文件</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-49-15.png" alt="Snipaste_2019-02-28_16-49-15"></p>
<p>第一个 进程 在 文件 描述 符 3 上 打开 该 文件， 而 另一个 进程 在 文件 描述 符 4 上 打开 该 文件。 打开 该 文件 的 两个 进程 都 获得 各自 的 一个 文件 表项， 但是对于一个 给定 的 文件只有 一个 v 节点表项。（为什么会创建有两个表项，而不指向欧安同意文件表项） 之所以 每个 进程 都 获得 自己的 文件 表项， 是因为 这可 以使 每个 进程 都有 它自己 的 对 该 文件 的 当前 偏移量。</p>
<h2 id="文件操作的进一步说明"><a href="#文件操作的进一步说明" class="headerlink" title="文件操作的进一步说明"></a>文件操作的进一步说明</h2><p>给出 了 这些 数据 结构 后， 现在 对 前面 所述 的 操作 进一步 说明。</p>
<ul>
<li>write：在 完成 每个 write 后， 在 文件 表项 中的 当前 文件 偏移量 即 增加 所 写入 的 字节数。 如果 这 导致 当前 文件 偏移量 超出 了 当前 文件 长度， 则 将 i 节点 表项 中的 当前 文件 长度 设置 为 当前 文件 偏移量（ 也就是 该文 件 加长 了）。</li>
<li>open：如果 用 O_ APPEND 标志 打开 一个 文件， 则 相应 标志 也 被 设置 到 文件 表项 的 文件 状态 标志 中。 每次 对这 种 具有 追加 写 标志 的 文件 执行 写 操作 时， 文件 表项 中的 当前 文件 偏移量 首先 会被 设置 为 i 节点 表项 中的 文件 长度。 这就 使得 每次 写入 的 数据 都 追加 到 文件 的 当前 尾端 处。</li>
<li>lseek：若 一个 文件 用 lseek 定位 到 文件 当前 的 尾端， 则 文件 表项 中的 当前 文件 偏移量 被 设置 为 i 节点 表项 中的 当前 文件 长度 </li>
</ul>
<p>注：lseek 函数 只 修改 文件 表项 中的 当前 文件 偏移量， 不进 行 任何 I/ O 操作。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>上面所秒述 的一切是对于多个进程读取同一文件的过程。 每个进程都有它自己的文件表项， 其中也有它自己 的当前文件偏移量。 但是，当多个进程写同一 文件时， 则可能产生预想不到的结果。 为了避免这种情况， 需要 理解原子操作的概念。</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="追加数据到-一个-文件"><a href="#追加数据到-一个-文件" class="headerlink" title="追加数据到 一个 文件"></a>追加数据到 一个 文件</h4><p>早期 的 UNIX 系统 版本 并不 支持 open 的 O_ APPEND 选项， 所以 程序 被 编写 成 下列 形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek( fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) 　 　 　 　 　 　<span class="comment">/* position to EOF*/</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (write( fd, buf, <span class="number">100</span>) != <span class="number">100</span>) 　 　<span class="comment">/* and write*/</span> </span><br><span class="line">	&#125;   </span><br><span class="line">        <span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" write error"</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" lseek error"</span>)</span></span>;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个参数表示偏移量，字母L表示long 型，就是让编译器知道0是long型的</span></span><br><span class="line"><span class="comment">其中 int whence 为下列其中一种:（SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2）.</span></span><br><span class="line"><span class="comment">	SEEK_SET 代表读写位置指向文件头</span></span><br><span class="line"><span class="comment">　　SEEK_CUR 代表目前的读写位置</span></span><br><span class="line"><span class="comment">　　SEEK_END 代表读写位置指向文件尾</span></span><br><span class="line"><span class="comment">这里的1和SEEK-CUR 是同一个意思。</span></span><br></pre></td></tr></table></figure>
<p>对 单个 进程 而言， 这段 程序 能 正常 工作， 但 若有 多个 进程 同时 使用 这种 方法 将 数据 追加 写到 同一 文件， 则 会 产生 问题.</p>
<h4 id="进程A和B对同一文件写操作"><a href="#进程A和B对同一文件写操作" class="headerlink" title="进程A和B对同一文件写操作"></a>进程A和B对同一文件写操作</h4><p>此时， 各 数据 结构 之间 的关系上节图 3- 8 中 所示。 每个 进程 都有 它自己 的 文件 表项， 但是 共享 一个 v 节点 表项。</p>
<ul>
<li>此时如果进程 A 调用了lseek， 它将进程 A 的 该文件当前偏移量设置为1500 字节</li>
<li>然后 内核 切换 进程， 进程 B 运行。 进程 B 执行 lseek， 也 将其 对 该 文件 的 当前 偏移量 设置 为 1 500 字节（ 当前 文件尾 端 处）。 然后 B 调用 write， 它将 B 的 该文 件 当前 文件 偏移量 增加 至 1 600。</li>
<li>然后， 内核 又 进行 进程 切换， 使 进程 A 恢复 运行。 当 A 调用 write 时， 就会从其当前文件偏移量（ 1 500） 处 开始 将 数据 写入 到 文件。</li>
</ul>
<p>这样 也就 覆盖 了 进程 B 刚才 写入 到 该文 件 中的 数据。</p>
<p><strong>问题 出在 逻辑 操作“ 先 定位 到 文件 尾端， 然后 写”， 它 使用 了 两个 分开 的 函数函调用。</strong> </p>
<p>解决问题 的 方法 是 使 这 两个 操作 对于 其他 进程 而言 成为 一个 原子 操作。 如果任何要求 多于 一个 函数 调用 的 操作 不 是 原子 操作， 则在 两个 函数 调用 之间， 内核 有可能 会 临时 挂起 进程（ 正如 我们 前面 所 假定 的）。 </p>
<p>UNIX 系统 为 这样 的 操作 提供 了 一种 原子 操作 方法， 即在 打开 文件 时 设置 O_ APPEND 标志（O_APPEND：每次写操作都写入文件的末尾）。  这样做 使得 内核 在 每次 写 操作 之前， 都将 进程 的 当前 偏移量 设置 到 该 文件 的 尾端 处， 于是 在 每次 写 之前 就不 再 需要 调用 lseek。</p>
<p><strong>原子操作：</strong>顾名思义，就是说像原子一样不可再细分不可被中途打断。一个操作是原子操作，意思就是说这个操作是以原子的方式被执行，要一口气执行完，执行过程不能够被OS的其他行为打断，是一个整体的过程，在其执行过程中，OS的其它行为是插不进来的。</p>
<h3 id="文件锁fctnl"><a href="#文件锁fctnl" class="headerlink" title="文件锁fctnl"></a>文件锁fctnl</h3><p>如何实现原子操作，这里就要用到文件锁fctnl().</p>
<p>该部分讨论文件在已经共享的情况下如何操作，也就是多个程序在操作同以稳健的情况下。，LInux中通常使用文件上锁的方法，来解决共享资源的竞争。</p>
<p>文件锁包括建议性锁（lockf（））和强制性锁（fcntl（））。fcntl不仅可以施加建议性锁还可以施加强制性锁，同时还能对为见额某一记录上锁，依旧是记录锁。</p>
<p>记录锁分为读取锁和写入锁。</p>
<p>略。。。</p>
<h2 id="重定向dup和dup2函数"><a href="#重定向dup和dup2函数" class="headerlink" title="重定向dup和dup2函数"></a>重定向dup和dup2函数</h2><p>函数dup和dup2提供了<strong>复制文件描述符的功能</strong>。</p>
<p>他们通常用于stdin,stdout或进程的stderr的重定向。一般来说，普通输出函数（如：printf），默认是将某信息写入到文件描述符为1的文件中，普通输入函数都默认从文件描述符为0的文件中读取数据。因此重定向操作实际上是关闭某个标准输入输出设备（文件描述符为0、1、2），而将另一个打开的普通文件的文件描述符设置为0、1、2.</p>
<ul>
<li>输入重定向：关闭标准输入设备，打开（或复制）某普通文件，使其文件描述符为0.</li>
<li>输出重定向：关闭标准输出设备，打开（或复制）某普通文件，使其文件描述符为1.    </li>
<li>错误输出重定向：关闭标准错误输入设备，打开（或复制）某普通文件，使其文件描述符为2.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">( <span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由 dup 返回 的 新 文件 描述 符 一定 是 当前 可用 文件 描述 符 中的 最小 数值。</p>
<p> 对于 dup2， 可 以用 fd2 参数 指定 新 描述 符 的 值。 如果 fd2 已经 打开， 则 先 将其 关闭。 如若 fd 等于 fd2， 则 dup2 返回 fd2， 而 不 关闭 它。 否则， fd2 的 FD_ CLOEXEC 文件 描述 符 标志 就被 清除， 这样 fd2 在 进程 调用 exec 时 是 打开 状态。</p>
<p>这些 函数 返回 的 新 文件 描述 符 与 参数 fd 共享 同一个 文件 表项</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_19-16-14.png" alt="Snipaste_2019-02-28_19-16-14"></p>
<h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于函数dup 允许你复制一个oldfd文件描述符。存入一个已存在的文件描述符，它就会返回一个与该描述符“相同”的新的文件描述符。即这两个描述符共享相同的内部结构，共享所有的锁定，读写位置和各项权限或flags等等。例如：对一个文件描述符进行了lseek操作，另一个文件描述符的读写位置也会随之改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd,newfd;</span><br><span class="line">        <span class="keyword">char</span> *bufFD=<span class="string">"Advanced Programming! write by fd\n"</span>;</span><br><span class="line">        <span class="keyword">char</span> *bufNewFD=<span class="string">"Advanced Programming! write by NewFD\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开始复制了</span></span><br><span class="line">        newfd = dup(fd);</span><br><span class="line">        <span class="comment">//使用fd写</span></span><br><span class="line">        write(fd,bufFD,<span class="built_in">strlen</span>(bufFD));</span><br><span class="line">        close(fd);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用newfd写</span></span><br><span class="line">        write(newfd,bufNewFD,<span class="built_in">strlen</span>(bufNewFD));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(close(newfd)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出：</span></span><br><span class="line"><span class="comment">	查看test.txt文件，里面有两段字符串：</span></span><br><span class="line"><span class="comment">	：Advanced Programming! write by fd</span></span><br><span class="line"><span class="comment">	：Advanced Programming! write by newfd</span></span><br></pre></td></tr></table></figure>
<pre><code>可以看出，对fd或newfd进行读写操作时对同一个文件操作，不会覆盖前面文件（共享读写位置）而且还可以看到fd关闭后，对newfd没有影响，使用newfd还可以操作打开的文件。
</code></pre><h3 id="dup2函数（该函数不是很懂）"><a href="#dup2函数（该函数不是很懂）" class="headerlink" title="dup2函数（该函数不是很懂）"></a>dup2函数（该函数不是很懂）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dup2 函数定义在 &lt;unistd.h&gt; 中，函数原形为：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2 )</span></span></span><br></pre></td></tr></table></figure>
<p> 返回值：如成功则返回新的文件描述符，否则出错返回-1. </p>
<p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。</p>
<p>若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等等.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> refd;</span><br><span class="line">        <span class="keyword">char</span> *buf=<span class="string">"Advanced Programming!\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        refd = dup2(fd,fileno(<span class="built_in">stdout</span>));</span><br><span class="line">        <span class="keyword">if</span>(refd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"redirect standard out error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写数据，本应该写入到stdout的信息重定向而写入到目标文件中（test.txt）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dup2的返回值：%d\n"</span>,refd);</span><br><span class="line">        write(fileno(<span class="built_in">stdout</span>),buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，可以看到以下内容</span></span><br><span class="line"><span class="comment">Advanced Programming!</span></span><br><span class="line"><span class="comment">dup2的返回值：1</span></span><br></pre></td></tr></table></figure>
<h1 id="第四节：标准I-O"><a href="#第四节：标准I-O" class="headerlink" title="第四节：标准I/O"></a>第四节：标准I/O</h1><p>标准 I/ O 的 由来</p>
<ul>
<li>标准 I/ O 指的 是 ANSI C 中 定义 的 用于 I/ O 操作 的 一系列 函数。 </li>
<li>只要 操作系统 中 安装 了 C 库， 标准 I/ O 函数 就可以 调用。即: 如果 程序 中 使 用的 是 标准 I/ O 函数， 那么 源 代码 不需要 修改 就可 以在 其他 操作系统 下 编译 运行， 具有 更好 的 可移植性。 </li>
<li>使用 标准 I/ O 可以 减少 系统 调用 的 次数， 提高 系统 效率。 标准 I/ O 函数 在 执行 时 也会 用到 系统 调用。 </li>
</ul>
<h2 id="流-和-FILE-对象"><a href="#流-和-FILE-对象" class="headerlink" title="流 和 FILE 对象"></a>流 和 FILE 对象</h2><p>标准 I/ O 的 核心 对象 就是 流。 当 用 标准 I/ O 打开 一个 文件 时， 就会 创建 一个 FILE 结构 体文件描述符，我们 把 这个 FILE 结构 体 形象 地 称为 流。然后 该文 件 描述 符 就用 于 后续 的 I/ O 操作。</p>
<p>标准 I/ O 文件 流 可用 于 单 字节 或 多 字节（“ 宽”） 字符 集。 流的 定向（ stream’ s orientation） 决定了 所 读、 写的 字符 是 单字 节 还是 多 字节 的。</p>
<p>标准 I/ O 函数 都 基于 流进 行 各种 操作。 标准 I/ O 中的 流的 缓冲 类型 有 以下 三种。 </p>
<p>（1） 全 缓冲： 在 这种 情况下， 当 填满 标准 I/ O 缓冲区 后才 进行 实际 I/ O 操作。 对于 存放 在 磁盘 上 的 普通 文件 用 标准 I/ O 打开 时 默认 是 全 缓冲 的。 当 缓冲区 已满 或 执行 flush 操作 时 才会 进行 磁盘 操作。</p>
<p> （2） 行 缓冲： 在 这种 情况下， 当 在 输入 和 输出 中 遇到 换行符 时 执行 I/ O 操作。 标准 输 入流 和 标准 输出 流 就是 使用 行 缓冲 的 典型 例子。 </p>
<p>（3） 无 缓冲： 不对 I/ O 操作 进行 缓冲， 即在 对流 的 读写 时会 立刻 操作 实际 的 文件。 标准 出错 流 是 不带 缓冲 的， 这就 使得 出错 信息 可以 立刻 显示 在 终端 上， 而 不管 输出 的 内容 是否 包含 换行符。</p>
<p>标准 I/ O 库 提供 缓冲 的 目的 是 尽可能 减少 使用 read 和 write 调用 的 次数。 它 也对 每个 I/ O 流 自动 地 进行 缓冲 管理， 从而 避免 了 应用 程序 需要 考虑 这一点 所带 来的 麻烦。 遗憾的是， 标准 I/ O 库 最 令人 迷惑 的 也是 它的 缓冲。</p>
<h2 id="标准输入-输出和标准错误"><a href="#标准输入-输出和标准错误" class="headerlink" title="标准输入,输出和标准错误"></a>标准输入,输出和标准错误</h2><p> 对 一个 进程 预 定义 了 3 个 流， 并且 这 3 个 流 可以 自动 地 被 进程 使用， 它们 是： 标准 输入、 标准输出和标准错误。 这些 流 文件 描述 符 STDIN_ FILENO、 STDOUT_ FILENO 和 STDERR_ FILENO 所。</p>
<p> 这 3 个 标准 I/ O 流通 过 预定 义 文件 指针 stdin、 stdout 和 stderr 加以 引用。 这 3 个 文件 指针 定义 在 头 文件&lt; stdio. h&gt; 中。</p>
<h2 id="标准-I-O-编程"><a href="#标准-I-O-编程" class="headerlink" title="标准 I/ O 编程"></a>标准 I/ O 编程</h2><h3 id="流的-打开"><a href="#流的-打开" class="headerlink" title="流的 打开"></a>流的 打开</h3><p>使用 标准 I/ O 打开 文件 的 函数 有 fopen()、 fdopen() 和 freopen()。</p>
<p> 它们 可以 以 不同 的 模式 打开 文件， 都 返回 一个 指向 FILE 的 指针， 该 指针 指向 对应 的 I/ O 流。 此后， 对 文件 的 读写 都是 通过 这个 FILE 指针 来 进行。</p>
<ul>
<li><p>fopen() 可以 指定 打开 文件 的 路径 和 模式，</p>
</li>
<li><p>fdopen() 可以 指定 打开 的 文件 描述 符 和 模式，</p>
</li>
<li><p>freopen() 除 可指 定 打开 的 文件、 模式 外， 还可 指定 特定 的 I/ O 流。</p>
<p>fopen() 函数 格式 如表 1. 1 所示。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-19-47.png" alt="Snipaste_2019-03-01_17-19-47"></p>
</li>
</ul>
<p>其中， mode 用于 指定 打开 文件 的 方式。 表 1. 2 说明了 fopen() 中 mode 的 各种 取值。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-20-03.png" alt="Snipaste_2019-03-01_17-20-03"></p>
<h3 id="流的-关闭"><a href="#流的-关闭" class="headerlink" title="流的 关闭"></a>流的 关闭</h3><p>关闭 流的 函数 为 fclose()， 该 函数 将 流的 缓冲区 内 的 数据 全部 写入 文件 中， 并 释放 相关 资源。 fclose() 函数 格式 如表 1. 3 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-22-18.png" alt="Snipaste_2019-03-01_17-22-18"></p>
<h3 id="错误-处理"><a href="#错误-处理" class="headerlink" title="错误 处理"></a>错误 处理</h3><p>标准 I/ O 函数 执行 时 如果 出现 错误， 会把 错误 码 保存 在 errno 中。 程序员 可以 通过 相应 的 函数 打印 错误 信息。</p>
<p>方发一</p>
<p>错误 处理 相关 函数 perror 如表 1. 4 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-24-15.png" alt="Snipaste_2019-03-01_17-24-15"></p>
<p>错误 处理 相关 函数 strerror 如表 1. 5 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-31-44.png" alt="Snipaste_2019-03-01_17-31-44"></p>
<h3 id="实例：打开关闭文件和错误处理"><a href="#实例：打开关闭文件和错误处理" class="headerlink" title="实例：打开关闭文件和错误处理"></a>实例：打开关闭文件和错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp; <span class="comment">// 定义流 指针 </span></span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>） <span class="comment">//NULL是系统定义的宏， 其值为0</span></span><br><span class="line">    &#123; </span><br><span class="line">        perror（＂ fail to fopen＂）; <span class="comment">// 输出 错误 信息 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose（ fp）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果文件1.txt不存在，程序执行时会打印如下信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *fp; </span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>（＂ fail to fopen: %s\ n＂, strerror（ errno））; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    fclose（ fp）;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果 文件 1. txt 不存在， 程序 执行 时会 打印 如下 信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure>
<h3 id="流的读写"><a href="#流的读写" class="headerlink" title="流的读写"></a>流的读写</h3><h4 id="1-字符-节）输入-输出"><a href="#1-字符-节）输入-输出" class="headerlink" title="1.字符(节）输入/输出"></a>1.字符(节）输入/输出</h4><p>一次 读 或 写 一个 字符， 如果 流 是 带 缓冲 的， 则 标准 I/ O 函数 处理 所有 缓冲。</p>
<p><strong>读取</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-29.png" alt="Snipaste_2019-03-01_17-39-29"></p>
<p>getc() 和 fgetc ()从 指 定的 流 中 读取 一个 字符（ 节）， getchar() 从 stdin 中 读取 一个 字符（ 节）。</p>
<p><strong>输出</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-57.png" alt="Snipaste_2019-03-01_17-39-57"></p>
<p>putc() 和 fputc() 向 指 定的 流 输出 一个 字符（ 节）， putchar() 向 stdout 输出 一个 字符（ 节）。 </p>
<p><strong>实例</strong></p>
<p>下面 这个 实例 结合 fputc() 和 fgetc()， 循环 从 标准 输入 读取 任意 个 字符 并将 其中 的 数字 输出 到 标准 输出。</p>
<p>华清远见嵌入式学院; 曾宏安; 冯利美. 嵌入式应用程序设计综合教程 (高等院校嵌入式人才培养规划教材) (Kindle 位置 217-218). 人民邮电出版社. Kindle 版本. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fput. c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">    <span class="keyword">int</span> c; </span><br><span class="line">    <span class="keyword">while</span>（ <span class="number">1</span> ） </span><br><span class="line">    &#123;	</span><br><span class="line">        c = fgetc（ <span class="built_in">stdin</span>）; <span class="comment">// 从 键盘 读取 一个 字符 </span></span><br><span class="line">        <span class="keyword">if</span> （（ c &gt;= <span class="string">'0'</span>） &amp;&amp; （c &lt;= <span class="string">'9'</span>）） fputc（ c, <span class="built_in">stdout</span>）; <span class="comment">// 若 输入 的 是 数字，输出 		if （c == '\n'） break; // 若 遇到 换行符， 跳出 循环</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行 结果 如下。 $ ./a. out abc98io# 4/ wm 984</span></span><br></pre></td></tr></table></figure>
<h4 id="2-行输入-输出"><a href="#2-行输入-输出" class="headerlink" title="2.行输入/输出"></a>2.行输入/输出</h4><p>行 输入/ 输出 函数 一次 操作 一行。如果 想要 一次 读 或 写 一行， 则 使用 fgets 和 fputs。 每 行都 以 一个 换行符 终止。 当 调用 fgets 时， 应 说明 能 处理 的 最大 行长。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-15.png" alt="Snipaste_2019-03-01_17-58-15"></p>
<p>gets 函数 容易 造成 缓冲区 溢出， 不 推荐 大家 使用。 fgets 从 指 定的 流 中 读取 一个 字符串， 当 遇到\ n 或 读取 了 size- 1 个 字符 后 返回。 注意， fgets 不能 保证 每次 都能 读出 一行。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-41.png" alt="Snipaste_2019-03-01_17-58-41"></p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 以 fgets() 为例 计算 一个 文本 文件 的 行数。 /*fgets. c*/ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; string. h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> main（ <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]） </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[ <span class="number">128</span>];</span><br><span class="line">    FILE *fp; <span class="keyword">if</span> （argc &lt; <span class="number">2</span>） </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>（＂ Usage : %s &lt; file&gt;\ n＂, argv[ <span class="number">0</span>]）;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> （（ fp = fopen（ argv[ <span class="number">1</span>], ＂r＂）） == <span class="literal">NULL</span>） </span><br><span class="line">	&#123; </span><br><span class="line">		perror（＂ fail to fopen＂）;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>（ fgets（ buf, <span class="number">128</span>, fp） != <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> （buf[ <span class="built_in">strlen</span>（ buf）- <span class="number">1</span>] == <span class="string">'\n'</span>） </span><br><span class="line">    	line++;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>（＂ The line of %s is %d\ n＂, argv[ <span class="number">1</span>], line）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行 该 程序， 结果 如下。 $ ./a. out test. txt The line of test. txt is 64</span></span><br></pre></td></tr></table></figure>
<h4 id="3-指定大小为单位读写文件"><a href="#3-指定大小为单位读写文件" class="headerlink" title="3.指定大小为单位读写文件"></a>3.指定大小为单位读写文件</h4><p>在 文件 流 被打 开 之后， 可 对 文件 流 按指 定 大小 为 单位 进行 读写 操作。fread 和 fwrite 函数 支持 这种 类型 的 I/ O。 每次 I/ O 操作 读 或 写 某种 数量 的 对象， 而每 个 对象 具有 指定 的 长度。 这 两个 函数 常 用于 从 二进制 文件 中 每次 读 或 写 一个 结构。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-27.png" alt="Snipaste_2019-03-01_18-13-27"></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-40.png" alt="Snipaste_2019-03-01_18-13-40"></p>
<h3 id="流的定位"><a href="#流的定位" class="headerlink" title="流的定位"></a>流的定位</h3><p>每个 打开 的 流 内部 都有 一个 当前 读写 位置。 流 在 打开 时， 当前 读写 位置 为 0， 表示 文件 的 开始 位置。 每 读写 一次 后， 当前 读写 位置 自动 增加 实际 读写 的 大小。 在 读写 流 之间 可 先 对流 进行 定位， 即 移动 到 指定 的 位置 再 操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-16-07.png" alt="Snipaste_2019-03-01_18-16-07"></p>
<h3 id="格式化-输入-输出"><a href="#格式化-输入-输出" class="headerlink" title="格式化 输入 输出"></a>格式化 输入 输出</h3><p>格式化 输入/ 输出 函数 可以 指定 输入/ 输出 的 具体 格式， 包括 读者 已经 非常 熟悉 的 printf()、 scanf() 等 函数。</p>
<p><strong>格式化输入</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-17-55.png" alt="Snipaste_2019-03-01_18-17-55"></p>
<p><strong>格式化输出</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-18-05.png" alt="Snipaste_2019-03-01_18-18-05"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/数据结构.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/数据结构.html" itemprop="url">
                  数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-27 12:41:05" itemprop="dateCreated datePublished" datetime="2019-02-27T12:41:05+08:00">2019-02-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-28 11:31:49" itemprop="dateModified" datetime="2019-02-28T11:31:49+08:00">2019-02-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章：数据结构基数"><a href="#第一章：数据结构基数" class="headerlink" title="第一章：数据结构基数"></a>第一章：数据结构基数</h1><h2 id="第一节：数据与c"><a href="#第一节：数据与c" class="headerlink" title="第一节：数据与c"></a>第一节：数据与c</h2><h2 id="第二节：数组和指针"><a href="#第二节：数组和指针" class="headerlink" title="第二节：数组和指针"></a>第二节：数组和指针</h2><h2 id="第三节：结构体"><a href="#第三节：结构体" class="headerlink" title="第三节：结构体"></a>第三节：结构体</h2><h2 id="第四节：其他结构"><a href="#第四节：其他结构" class="headerlink" title="第四节：其他结构"></a>第四节：其他结构</h2><h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><p>联合（union） 是一种数据类型， 它能在同一个内存空间中储存不同的数据类型（不是同时储存） 。 其典型的用法是， 设计一种表以储存既无规律、 事先也不知道顺序的混合类型。 使用联合类型的数组， 其中的联合都大小相等， 每个联合可以储存各种数据类型。 </p>
<h4 id="创建联合体"><a href="#创建联合体" class="headerlink" title="创建联合体"></a>创建联合体</h4><p>创建联合和创建结构的方式相同， 需要一个联合模板和联合变量。 可以用一个步骤定义联合， 也可以用联合标记分两步定义。 下面是一个带标记的联合模板： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold &#123;</span><br><span class="line"><span class="keyword">int</span> digit;</span><br><span class="line"><span class="keyword">double</span> bigfl;</span><br><span class="line"><span class="keyword">char</span> letter;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h4 id="定义（声明）联合体变量"><a href="#定义（声明）联合体变量" class="headerlink" title="定义（声明）联合体变量"></a>定义（声明）联合体变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit; <span class="comment">// hold类型的联合变量</span></span><br><span class="line"><span class="keyword">union</span> hold save[<span class="number">10</span>]; <span class="comment">// 内含10个联合变量的数组</span></span><br><span class="line"><span class="keyword">union</span> hold * pu; <span class="comment">// 指向hold类型联合变量的指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第1个声明创建了一个单独的联合变量fit。 编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。 在本例中， 占用空间最大的是 double类型的数据。 在我们的系统中， double类型占64位， 即8字节。 </li>
<li>第2个声明创建了一个数组save， 内含10个元素， 每个元素都是8字节。</li>
<li>第3个声明创建了一个指针， 该指针变量储存hold类型联合变量的地址。</li>
</ul>
<h4 id="初始化联合体"><a href="#初始化联合体" class="headerlink" title="初始化联合体"></a>初始化联合体</h4><p>需要注意的是， 联合只能储存一个值， 这与结构不同。</p>
<p> 有 3 种初始化的方法： 把一个联合初始化为另一个同类型的联合； 初始化联合的第1个元素； 或者根据C99标准， 使用指定初始化器：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold valA;</span><br><span class="line">valA.letter = <span class="string">'R'</span>;</span><br><span class="line"><span class="keyword">union</span> hold valB = valA; <span class="comment">// 用另一个联合来初始化</span></span><br><span class="line"><span class="keyword">union</span> hold valC = &#123;<span class="number">88</span>&#125;; <span class="comment">// 初始化联合的digit 成员</span></span><br><span class="line"><span class="keyword">union</span> hold valD = &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure>
<h4 id="使用联体"><a href="#使用联体" class="headerlink" title="使用联体"></a>使用联体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit.digit = <span class="number">23</span>; <span class="comment">//把 23 储存在 fit， 占2字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>; <span class="comment">// 清除23， 储存 2.0， 占8字节</span></span><br><span class="line">fit.letter = <span class="string">'h'</span>; <span class="comment">// 清除2.0， 储存h， 占1字节</span></span><br></pre></td></tr></table></figure>
<p>点运算符表示正在使用哪种数据类型。 在联合中， 一次只储存一个值。即使有足够的空间， 也不能同时储存一个char类型值和一个int类型值。 </p>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>略</p>
<h3 id="枚举（不懂）"><a href="#枚举（不懂）" class="headerlink" title="枚举（不懂）"></a>枚举（不懂）</h3><p>可以用枚举类型（enumerated type） 声明符号名称来表示整型常量。 使<br>用enum关键字， 可以创建一个新“类型”并指定它可具有的值（实际上， enum<br>常量是int类型， 因此， 只要能使用int类型的地方就可以使用枚举类型） 。 枚<br>举类型的目的是提高程序的可读性。 它的语法与结构的语法相同。</p>
<h4 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br></pre></td></tr></table></figure>
<p>第1个声明创建了spetrum作为标记名， 允许把enum spetrum作为一个类型名使用。 第2个声明使color作为该类型的变量。 第1个声明中花括号内的标<br>识符枚举了spectrum变量可能有的值。 因此， color 可能的值是 red、orange、 yellow 等。 这些符号常量被称为枚举符（enumerator） 。  </p>
<h4 id="枚举的使用（没懂）"><a href="#枚举的使用（没懂）" class="headerlink" title="枚举的使用（没懂）"></a>枚举的使用（没懂）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow)</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++)</span><br><span class="line">...;</span><br></pre></td></tr></table></figure>
<p>虽然枚举符（如red和blue） 是int类型， 但是枚举变量可以是任意整数类型， 前提是该整数类型可以储存枚举常量。 例如， spectrum的枚举符范围是<br>0～5， 所以编译器可以用unsigned char来表示color变量。 </p>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><h1 id="第二章：高级数据结构"><a href="#第二章：高级数据结构" class="headerlink" title="第二章：高级数据结构"></a>第二章：高级数据结构</h1><h2 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h2><p>计算机用户已经开发出的一些数据形式比我们提到过的数组和简单结构更有效地解决特定的问题。 这些形式包括队列、 二叉树、 堆、 哈希表和图表。 许多这样的形式都由链式结构（linked structure） 组成。 通<br>常， 每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。 这些指针把一个结构和另一个结构链接起来， 并提供一种路径能遍历整个彼此链接的结构。 </p>
<p>图14.3演示了一个二叉树结构， 每个单独的结构（或节点） 都和它下面的两个结构（或节点） 相连。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-27_12-56-40.png" alt="Snipaste_2019-02-27_12-56-40"></p>
<p>图14.3中显示的分级或树状的结构是否比数组高效？ 考虑一个有10级节点的树的情况。 它有210-1（或1023） 个节点， 可以储存1023个单词。 如果<br>这些单词以某种规则排列， 那么可以从最顶层开始， 逐级向下移动查找单词， 最多只需移动9次便可找到任意单词。 如果把这些单词都放在一个数组中， 最多要查找1023个元素才能找出所需的单词 。</p>
<h2 id="联合简介"><a href="#联合简介" class="headerlink" title="联合简介"></a>联合简介</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="typedef简介"><a href="#typedef简介" class="headerlink" title="typedef简介"></a>typedef简介</h2><h2 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h2><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/C指针：基本概念、核心技术及最佳实践.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/C指针：基本概念、核心技术及最佳实践.html" itemprop="url">
                  C指针：基本概念、核心技术及最佳实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-21 18:18:47" itemprop="dateCreated datePublished" datetime="2019-02-21T18:18:47+08:00">2019-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-23 16:24:51" itemprop="dateModified" datetime="2019-02-23T16:24:51+08:00">2019-02-23</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/C指针：基本概念、核心技术及最佳实践.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/第一节.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/第一节.html" itemprop="url">
                  C primer Plus
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-20 20:38:47" itemprop="dateCreated datePublished" datetime="2019-02-20T20:38:47+08:00">2019-02-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-28 11:31:49" itemprop="dateModified" datetime="2019-02-28T11:31:49+08:00">2019-02-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第一章：基数知识"><a href="#第一章：基数知识" class="headerlink" title="第一章：基数知识"></a>第一章：基数知识</h1><h2 id="第一节：数据和C"><a href="#第一节：数据和C" class="headerlink" title="第一节：数据和C"></a>第一节：数据和C</h2><h3 id="strlen和sizeof"><a href="#strlen和sizeof" class="headerlink" title="strlen和sizeof"></a>strlen和sizeof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>]=<span class="string">"wu"</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"strlen= %d,sizeof=%d;"</span> , <span class="built_in">strlen</span>(name) , <span class="keyword">sizeof</span>(name));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">返回值为：<span class="built_in">strlen</span>= <span class="number">2</span>,<span class="keyword">sizeof</span>=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">sizeof</span> 运算符， 它以字节为单位给出对象的大小。 <span class="built_in">strlen</span>()函数给出字符串中的字符长度。</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/第一节.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/linux环境配置.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux环境配置.html" itemprop="url">
                  linux环境配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-29 17:01:14" itemprop="dateCreated datePublished" datetime="2018-12-29T17:01:14+08:00">2018-12-29</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/1-移植U-Boot.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1-移植U-Boot.html" itemprop="url">
                  1.移植U-Boot
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 22:52:31" itemprop="dateCreated datePublished" datetime="2018-12-28T22:52:31+08:00">2018-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-03 11:41:44" itemprop="dateModified" datetime="2019-01-03T11:41:44+08:00">2019-01-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/第二阶段/" itemprop="url" rel="index"><span itemprop="name">第二阶段</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="移植-U-Boot"><a href="#移植-U-Boot" class="headerlink" title="移植 U-Boot"></a>移植 U-Boot</h2><h3 id="Bootloader-简介"><a href="#Bootloader-简介" class="headerlink" title="Bootloader 简介"></a>Bootloader 简介</h3><p>#### </p>
<h4 id="Bootload是什么"><a href="#Bootload是什么" class="headerlink" title="Bootload是什么"></a>Bootload是什么</h4><p>Bootloader是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备（关闭WATCHDOG、改变系统时钟、初始化存储控制器）、建立内存空间的映射表，将更多的代码复制到内存中等，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。 <em>它能将操作系统内核复制到内存中运行，我们将这段程序称为 Bootloader。</em></p>
<p>①Bootloader 就是这么一小段程序，它在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统</p>
<p>②我们还可以增强 Bootloader 的功能，比如增加网络功能、从 PC 上通过串口或网络下载文件、烧写文件、将 Flash 上压缩的文件解压后再运行等。</p>
<p>③Bootloader是基于特定硬件平台来实现的。因此，不可能有一个 Bootloader 支持所有的CPU、所有的电路板。即使是支持 CPU 架构比较多的 U-Boot，也不是一拿来就可以使用的，需要进行一些移植</p>
<h4 id="Bootloader是如何启动"><a href="#Bootloader是如何启动" class="headerlink" title="Bootloader是如何启动"></a>Bootloader是如何启动</h4><p>CPU 上电后，会从某个地址开始执行。比如 MIPS 结构的 CPU 会从 0xBFC00000 取第一条指令，而 ARM 结构的 CPU 则从地址 0x0000000 开始。嵌入式开发板中，需要把存储器件 ROM 或 Flash 等映射到这个地址，Bootloader 就存放在这个地址开始处，这样一上电就可以执行。<strong><em>(即将Bootloader 存放在0x0000000 这个地址开始处。这样一上电就可以执行Bootloader)</em></strong> </p>
<p>在开发时，通常可以使用各种命令操作 Bootloader，一般通过串口来连接 PC 和开发板，可以在串口上输入各种命令、观察运行结果等。</p>
<p>Bootloader 可以分为以下两种操作模式（Operation Mode）。<br>​    （1）启动加载（Boot loading）模式。<br>​    上电后，Bootloader 从板子上的某个固态存储设备上将操作系统加载到 RAM 中运行，整个过程并没有用户的介入。产品发布时，Bootloader 工作在这种模式下。<br>​    （2）下载（Downloading）模式。<br>​    在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（比如内核映象、文件系统映象），将它们直接放在内存运行或是烧入Flash 类固态存储设备中。<br>​    板子与主机间传输文件时，可以使用串口的 xmodem/ymodem/zmodem 协议，它们使用简单，只是速度比较慢；还可以使用网络通过 tftp、nfs 协议来传输，这时，主机上要开启 tftp、nfs 服务；还有其他方法，比如 USB 等。</p>
<h4 id="Bootloader-在linux中的分区"><a href="#Bootloader-在linux中的分区" class="headerlink" title="Bootloader 在linux中的分区"></a>Bootloader 在linux中的分区</h4><p>嵌入式 Linux 系统从软件的角度通常可以分为以下 4 个层次。</p>
<p>（1）引导加载程序。</p>
<p>包括固化在固件（firmware）中的 boot 代码（可选）和 Bootloader两大部分。有些 CPU 在运行 Bootloader 之前先运行一段固化的程序（固件，firmware），比如 x86结构的 CPU 就是先运行 BIOS 中的固件，然后才运行硬盘第一个分区（MBR）中的 Bootloader。在大多嵌入式系统中并没有固件，Bootloader 是上电后执行的第一程序。</p>
<p>（2）Linux 内核。</p>
<p>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由 Bootloader 传递给它的。</p>
<p>（3）文件系统。</p>
<p>包括根文件系统和建立于 Flash 内存设备之上的文件系统。里面包含了 Linux 系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux 的控制界面的 shell 程序、动态连接的程序运行时需要的 glibc 或 uClibc 库等。</p>
<p>（4）用户应用程序。<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间 可能还会包括一个嵌入式图形用户界面。常用的嵌入式 GUI 有：Qtopia 和 MiniGUI 等。 </p>
<p>嵌入系统的典型分区结构如下</p>
<p><img src="D:\MyBlog\图片\Snipaste_2018-12-28_23-39-14.png" alt="Snipaste_2018-12-28_23-39-14"></p>
<p><strong>“Boot parameters（参数）”</strong>分区中存放一些可设置的参数，比如 IP 地址、串口波特率、要传递给内核的命令行参数等。</p>
<p>正常启动过程中，Bootloader 首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会挂接（mount）根文件系统（“Root filesystem”），启动文件系统中的应用程序。</p>
<h4 id="Bootload启动步骤"><a href="#Bootload启动步骤" class="headerlink" title="Bootload启动步骤"></a>Bootload启动步骤</h4><p>汇编阶段 </p>
<ol>
<li><p>设置为SVC模式，关闭中断,MMU,看门狗</p>
</li>
<li><p>基本硬件设备初始化（初始化时钟，串口，flash,内存等）</p>
</li>
<li><p>自搬移到内存</p>
</li>
<li><p>设置好栈 跳转到C语言阶段 </p>
<p>C语言阶段</p>
</li>
<li><p>大部分硬件初始化</p>
</li>
<li><p>搬移内核到内存后，运行内核</p>
</li>
</ol>
<h4 id="常用-Bootloader-介绍"><a href="#常用-Bootloader-介绍" class="headerlink" title="常用 Bootloader 介绍"></a>常用 Bootloader 介绍</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-29_00-42-38.png" alt="Snipaste_2018-12-29_00-42-38"></p>
<p>本次使用的 S3C2410 开发板使用的Bootloader为U-Boot 。<br>​    U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p>
<h3 id="U-Boot-分析与移植"><a href="#U-Boot-分析与移植" class="headerlink" title="U-Boot 分析与移植"></a>U-Boot 分析与移植</h3><h4 id="U-Boot-简介"><a href="#U-Boot-简介" class="headerlink" title="U-Boot 简介"></a>U-Boot 简介</h4><p>U-Boot，全称为 Universal Boot Loader，即通用 Bootloader，是遵循 GPL 条款的开放源代码项目。</p>
<p><strong>U-Boot 有如下特性</strong></p>
<p>• 开放源码。</p>
<p>• 支持多种嵌入式操作系统内核，如 Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS。</p>
<p>• 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS、XScale。</p>
<p>• 较高的可靠性和稳定性。</p>
<p>• 高度灵活的功能设置，适合 U-Boot 调试、操作系统不同引导要求、产品发布等。</p>
<p>• 丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等。</p>
<p>• 较为丰富的开发调试文档与强大的网络技术支持。</p>
<p>• 支持 NFS 挂载、RAMDISK（压缩或非压缩）形式的根文件系统。</p>
<p>• 支持 NFS 挂载、从 Flash 中引导压缩或非压缩系统内核。</p>
<p>• 可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对 Linux 支持最为强劲。</p>
<p>• 支持目标板环境变量多种存储方式，如 Flash、NVRAM、EEPROM。</p>
<p>• CRC32 校验，可校验 Flash 中内核、RAMDISK 镜像文件是否完好。</p>
<p>• 上电自检功能：SDRAM、Flash 大小自动检测，SDRAM 故障检测，CPU 型号 。                            </p>
<p>• 上电自特殊功能：XIP 内核引导 。</p>
<h4 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h4><p>源码为U-Boot-1.1.6  版本。从 sourceforge 网站下载 U-Boot-1.1.6.tar.bz2后解压即得到全部源码。</p>
<p>U-Boot-1.1.6 根目录下共有 26 个子目录，可以分为 4 类。</p>
<p>（1）平台相关的或开发板相关的。<br>​    （2）通用的函数。<br>​    （3）通用的设备驱动程序。<br>​    （4）U-Boot 工具、示例程序、文档 。</p>
<p>这 26 个子目录的功能与作用如表  </p>
<p>详细参考：嵌入式Linux应用开发完全手册的15.2.2 U-Boot 源码结构部分</p>
<h4 id="U-Boot-的配置、编译、连接"><a href="#U-Boot-的配置、编译、连接" class="headerlink" title="U-Boot 的配置、编译、连接"></a>U-Boot 的配置、编译、连接</h4><p>要想了解对于某款开发板，使用哪些文件、哪个文件首先执行、可执行文件占用内存的情况，最好的方法就是阅读它的 Makefile。</p>
<p>如果要使用开发板 board/&lt;board_name&gt;，就先执行“make &lt;board_name&gt;_config”命令进行配置，然后执行“make all”，就可以生成如下 3个文件。</p>
<p>• U-Boot.bin：二进制可执行文件，它就是可以直接烧入 ROM、NOR Flash 的文件。<br>​    • U-Boot：ELF 格式的可执行文件。<br>​    • U-Boot.srec：Motorola S-Record 格式的可执行文件。</p>
<p>例如：S3C2410 的开发板，执行“make smdk2410_config”、“make all”后生成的 U-Boot.bin可以烧入 NOR Flash 中运行</p>
<h5 id="U-Boot-的配置"><a href="#U-Boot-的配置" class="headerlink" title="U-Boot 的配置"></a>U-Boot 的配置</h5><p>(1). S3C2410 的开发板，执行“make smdk2410_config”</p>
<p>在顶层 Makefile 中可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRCTREE := $(CURDIR) </span><br><span class="line">……</span><br><span class="line">MKCONFIG := $(SRCTREE)/mkconfig </span><br><span class="line">……</span><br><span class="line">smdk2410_config : unconfig </span><br><span class="line">	  @$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>则其中的 MKCONFIG 就是根目录下的 mkconfig文件。$(@:_config=)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。</p>
<p>所以“make smdk2410fi”实际上就是执行如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>补充：在 mkconfig 文件开头第 6 行给出了它的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span> # Parameters: Target Architecture CPU Board [VENDOR][SOC]</span><br></pre></td></tr></table></figure>
<p>对于 S3C2410、S3C2440，它们被称为 SoC(System on Chip)，上面除 CPU 外，还集成了包括 UART、USB 控制器、NAND Flash 控制器等设备（称为片内外设）。S3C2410/S3C2440 中的 CPU 为 ARM920T。</p>
<p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p>
<h5 id="U-Boot-的编译、连接"><a href="#U-Boot-的编译、连接" class="headerlink" title="U-Boot 的编译、连接"></a>U-Boot 的编译、连接</h5><p>配置完后，执行“make all”即可编译</p>
<p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p>
<h5 id="U-Boot-的使用"><a href="#U-Boot-的使用" class="headerlink" title="U-Boot 的使用"></a>U-Boot 的使用</h5><p>U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p>
<p>我们知道u-boot，可以运行可是命令，以及支持串口下载、网络下载等功能以方便开发中调式。但这篇文章中并不介绍u-boot 的用法。后续会补充详细 的u-boot常用命令以及开发中如何使用串口和网络下载功能。以及u-boot的实际使用操作。</p>
<h2 id="移植linux内核"><a href="#移植linux内核" class="headerlink" title="移植linux内核"></a>移植linux内核</h2><p>这部分我们主要了解熟悉linux内核。知道如何给内核打补丁，配置内核及编译内核等内容。</p>
<p>准备：</p>
<p>内核源码：2.6.22.6.tar.bz2</p>
<p>补丁文件：patch-2.6.22.bz2</p>
<h3 id="内核源码结构分析及Makefile分析"><a href="#内核源码结构分析及Makefile分析" class="headerlink" title="内核源码结构分析及Makefile分析"></a>内核源码结构分析及Makefile分析</h3><h4 id="内核源码结构分析"><a href="#内核源码结构分析" class="headerlink" title="内核源码结构分析"></a>内核源码结构分析</h4><p>略</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html" itemprop="url">
                  在Linux下写一个简单的驱动程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 23:12:10" itemprop="dateCreated datePublished" datetime="2018-12-26T23:12:10+08:00">2018-12-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-27 00:46:47" itemprop="dateModified" datetime="2018-12-27T00:46:47+08:00">2018-12-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
