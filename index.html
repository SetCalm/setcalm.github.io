<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="暂时无">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeff">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/index.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jeff">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-19-cs.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog（重要保留）-2018-12-19-cs.html" itemprop="url">
                  cs
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-12-19 02:58:59" itemprop="dateCreated datePublished" datetime="2022-12-19T02:58:59+08:00">2022-12-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-19 02:59:46" itemprop="dateModified" datetime="2018-12-19T02:59:46+08:00">2018-12-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。</p>
<p>另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。</p>
<p>谢谢！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/重要说明.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/重要说明.html" itemprop="url">
                  重要说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-28 21:37:19" itemprop="dateCreated datePublished" datetime="2019-12-28T21:37:19+08:00">2019-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-23 16:32:34" itemprop="dateModified" datetime="2019-02-23T16:32:34+08:00">2019-02-23</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。</p>
<p>博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/字节长度问题.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/字节长度问题.html" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 11:44:50" itemprop="dateCreated datePublished" datetime="2019-06-21T11:44:50+08:00">2019-06-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 11:36:11" itemprop="dateModified" datetime="2019-04-18T11:36:11+08:00">2019-04-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字节长度问题</p>
<p>在单片机开发使用中经常要考虑到实际开发中的各种数据类型的长度问题（特别是在那种超小存储空间的单片机中，一不小心就溢出了）</p>
<p>8位单片机中数据类型：<a href="https://www.jianshu.com/p/feb4277e2a66" target="_blank" rel="noopener">https://www.jianshu.com/p/feb4277e2a66</a></p>
<p>8 位单片机中各种类型数据结构的长度（简单）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节（byte）</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1</td>
</tr>
<tr>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>表1：8 位单片机中各种类型数据结构的长度（详细）</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">占用字节（byte）</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">1</td>
<td>0～255</td>
</tr>
<tr>
<td style="text-align:left">signed char</td>
<td style="text-align:left">1</td>
<td>-128～+127</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">1</td>
<td>0～255</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned short int</td>
<td style="text-align:left">2</td>
<td>0～65535</td>
</tr>
<tr>
<td style="text-align:left">signed short int</td>
<td style="text-align:left">2</td>
<td>-32768～+32767</td>
</tr>
<tr>
<td style="text-align:left">short int</td>
<td style="text-align:left">2</td>
<td>-32768～+32767</td>
</tr>
<tr>
<td style="text-align:left">unsigned shor</td>
<td style="text-align:left">2</td>
<td>0～65535</td>
</tr>
<tr>
<td style="text-align:left">signed short</td>
<td style="text-align:left">2</td>
<td>-32768～+32767</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">2</td>
<td>-32768～+32767</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">2</td>
<td>0～65535</td>
</tr>
<tr>
<td style="text-align:left">signed int</td>
<td style="text-align:left">2</td>
<td>-32768～+32767</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">2</td>
<td>-32768～+32767</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned long int</td>
<td style="text-align:left">4</td>
<td>0～4294967295</td>
</tr>
<tr>
<td style="text-align:left">signed long int</td>
<td style="text-align:left">4</td>
<td>-2147483648～+2147483647</td>
</tr>
<tr>
<td style="text-align:left">long int</td>
<td style="text-align:left">4</td>
<td>-2147483648～+2147483647</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">4</td>
<td>0～4294967295</td>
</tr>
<tr>
<td style="text-align:left">signed long</td>
<td style="text-align:left">4</td>
<td>-2147483648～+2147483647</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">4</td>
<td>-2147483648～+2147483647</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">4</td>
<td>±1.75494E-38～±3.402823E+38</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">4</td>
<td>±1.75494E-38～±3.402823E+38</td>
</tr>
</tbody>
</table>
<p>补充：1byte=8bit</p>
<p>bit                         1位       0，1<br>sbit                       1位       0，1<br>sfr                        1字节   0-255<br>sfr16                     2字节0～65535</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/软件定时器的实现.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/软件定时器的实现.html" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 11:44:45" itemprop="dateCreated datePublished" datetime="2019-06-21T11:44:45+08:00">2019-06-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-30 17:55:02" itemprop="dateModified" datetime="2019-05-30T17:55:02+08:00">2019-05-30</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>软件定时器的实现</p>
<p>1.首先推荐一个大神的博客：</p>
<p><strong>一种嵌入式系统软件定时器的实现：以STM32为例：</strong><a href="https://blog.csdn.net/qq_26904271/article/details/83833168" target="_blank" rel="noopener">https://blog.csdn.net/qq_26904271/article/details/83833168</a></p>
<p>该博客有详细介绍软件定时器的实现过程及原理。</p>
<p>2.另一位大神的博客</p>
<p><strong>高效软件定时器的设计：</strong><a href="https://blog.csdn.net/wbwwf8685/article/details/51859286：" target="_blank" rel="noopener">https://blog.csdn.net/wbwwf8685/article/details/51859286：</a></p>
<p>该博客介绍了代码如何把软件定时器注册到链表中。</p>
<p>最后自己写了个最最简单的软件定时器。（最主要的就是简单，任何MCU都能使用。）</p>
<p>1.首先需要一个定时器提供滴答时钟。用于给软件计时的基准时钟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SoftwareTimer_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//T8N</span></span><br><span class="line">	<span class="comment">//时钟源周期为1000000/（16000000/2）= 0.125u</span></span><br><span class="line">	<span class="comment">//500us/0.125us =（255-T8N+1） ×16（预分频比） </span></span><br><span class="line">    T8NC = <span class="number">0x03</span>;	<span class="comment">//设置T8N为定时器模式，分频比为1:16</span></span><br><span class="line">    T8N = <span class="number">6</span>;		<span class="comment">//设定时器初值，2ms</span></span><br><span class="line">    T8NPRE = <span class="number">1</span>;		<span class="comment">//使能预分频器</span></span><br><span class="line">    T8NIE = <span class="number">1</span>;		<span class="comment">//使能T8N定时器中断</span></span><br><span class="line">    T8NEN = <span class="number">1</span>;		<span class="comment">//打开T8NEN定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr</span><span class="params">(<span class="keyword">void</span>)</span> interrupt</span>&#123;		<span class="comment">//500us定时</span></span><br><span class="line">    <span class="keyword">if</span>(T8NIE&amp;&amp;T8NIF)&#123;<span class="comment">//进入T8N定时器中断</span></span><br><span class="line">        T8NIF = <span class="number">0</span>;     <span class="comment">//清T8N中断标志</span></span><br><span class="line">        T8N = T8N + <span class="number">6</span>;<span class="comment">//重载T8N初值，加上进入中断时间	</span></span><br><span class="line">		cnt_500us++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//任务定时  (500us*n范围内任务：n&lt;=255,精度500us)</span></span><br><span class="line">		timer11++;</span><br><span class="line">		timer12++;</span><br><span class="line">		timer13++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(cnt_500us=<span class="number">20</span>)<span class="comment">//10ms</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//任务定时  (1ms*n范围内任务：n&lt;=255,精度1ms)</span></span><br><span class="line">			timer21++;</span><br><span class="line">			timer22++;</span><br><span class="line">			timer23++;			</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    task_umpire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该部分函数使用了一个基本计数器作为基准时钟，每500us中断一次。创建了6个软定时时钟。其中重点函数为task_umpire();</p>
<p>2.如何使用创建好的6 个软定时时钟。</p>
<p>上面6 个基准时钟还是没法用的，首先需要一个函数判断何时到达设置的定时时间，该函数就是：task_umpire();.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPL_BIT(value,bit) ((value)^=(1&lt;&lt;(bit)))	  <span class="comment">//取反指定位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BIT(value,bit) ((value)|=(1&lt;&lt;(bit)))		<span class="comment">//置位指定位</span></span></span><br><span class="line"><span class="comment">//#define CLR_BIT(value,bit) ((value)&amp;=~(1&lt;&lt;(bit)))		//清零指定位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR_BIT(value,bit) ((value)&amp;=~(1&lt;&lt;(bit)))		<span class="comment">//清零指定位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BIT(value,bit)	((value) &amp; (1&lt;&lt;(bit)))		<span class="comment">//读取指定位</span></span></span><br><span class="line"><span class="comment">//任务时间到达判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_umpire</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	<span class="keyword">if</span>(timer11==<span class="number">100</span>)	<span class="comment">//500us*100=50ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		SET_BIT(task_priority,<span class="number">0</span>);	<span class="comment">//第0位置一，任务一第一优先级。</span></span><br><span class="line">		timer11=<span class="number">0</span>;				<span class="comment">//任务重新定时</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer12==<span class="number">200</span>)	<span class="comment">//500us*200=100ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">1</span>);	</span><br><span class="line">		timer12=<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer13==<span class="number">250</span>)	<span class="comment">//500us*250=125ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">2</span>);</span><br><span class="line">		timer13=<span class="number">0</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer21==<span class="number">100</span>)	<span class="comment">//10ms*100=1000ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">3</span>);	</span><br><span class="line">		timer21=<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer22==<span class="number">200</span>)	<span class="comment">//10ms*200=2000ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">4</span>);		</span><br><span class="line">		timer22=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer23==<span class="number">250</span>)	<span class="comment">//10ms*250=2500ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">5</span>);		</span><br><span class="line">		timer23=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数技巧在</p>
<p>a.定时器的原理：</p>
<p>以timer11为例：timer11每基本计时器中断一次（500us）计数加一，timer11==100；即定时500*100=50ms</p>
<p>b.task_priority优先级</p>
<p>首先task_priority设置为unsigned int形式，它用于保存定时器到达的标志。</p>
<table>
<thead>
<tr>
<th>task_priority</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>timer</td>
<td></td>
<td></td>
<td>time23</td>
<td>timer22</td>
<td>timer12</td>
<td>timer13</td>
<td>timer12</td>
<td>timer11</td>
</tr>
</tbody>
</table>
<p>当timer11时间到达task_priority的0 位 置1，使用到SET_BIT(task_priority,0);</p>
<p>c;软件计时器给到相应的task_priority位后，把.timer11=0清0 ，重新开始计数。</p>
<p>3.然后任务主体部分</p>
<p>既然软件定时器已经完成，那么我们该如何根据定时器时间去执行任务，这里需要void task_processing(void)函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_processing</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//taske1_functions();</span></span><br><span class="line">		CLR_BIT(task_priority,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//taske2_functions();</span></span><br><span class="line">		CLR_BIT(task_priority,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">2</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//taske3_functions();</span></span><br><span class="line">		CLR_BIT(task_priority,<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">3</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//taske4_functions();</span></span><br><span class="line">		CLR_BIT(task_priority,<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">4</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//taske5_functions();</span></span><br><span class="line">		CLR_BIT(task_priority,<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">5</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//taske6_functions();</span></span><br><span class="line">		CLR_BIT(task_priority,<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a. 既然task_priority保存有每个计时器的状态，那默我们只需获取task_priority的每位状态即可，这里使用到了GET_BIT(task_priority,0)函数。</p>
<p>b.注意每次执行完后CLR_BIT(task_priority,0);把该为清0；避免再次进入。</p>
<p>缺点：该函数只能依照顺序轮询判断是否到达定时时间，执行相应的任务，并无优先级概念。无法做到：当3,5任务到达时，正在执行3任务三时，任务1时间也到达，无法先执行1，而是先执行5 后再执行1。无法做到最重要的任务最先执行。</p>
<p>4.优化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_processing</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		task_priority_cnt++;</span><br><span class="line">		<span class="keyword">switch</span>(task_priority_cnt)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">0</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task1_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">0</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;<span class="comment">//每次执行后该位清0；重新开始循环，保证在执行该任务时进入新的高优先级定时任务能优先执行。</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">1</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task2_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">1</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">2</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task3_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">2</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">3</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task4_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">3</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">4</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task5_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">4</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">5</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task6_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">5</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//task_functions();//其他不重要但执行频繁的函数。</span></span><br><span class="line">			task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此：实现了任务的优先级，在task_priority bit位前面的永远都是优先执行。</p>
<p>使用者直接把该函数void task_processing(void)放在main()里面即可。</p>
<p>每个任务函数只需把task1_functions();函数置换即可。</p>
<p>最后上完整的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPL_BIT(value,bit) ((value)^=(1&lt;&lt;(bit)))		<span class="comment">//取反指定位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BIT(value,bit) ((value)|=(1&lt;&lt;(bit)))		<span class="comment">//置位指定位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR_BIT(value,bit) ((value)&amp;=~(1&lt;&lt;(bit)))		<span class="comment">//清零指定位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BIT(value,bit)	((value) &amp; (1&lt;&lt;(bit)))		<span class="comment">//读取指定位	</span></span></span><br><span class="line"><span class="comment">//计数器及任务管理</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		cnt_500us=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		cnt_1ms=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		timer11=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		timer12=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		timer13=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		timer21=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		timer22=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		timer23=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>		task_priority=<span class="number">0</span>;	</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>		task_priority_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SoftwareTimer_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_umpire</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_processing</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SoftwareTimer_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//T8N</span></span><br><span class="line">	<span class="comment">//时钟源周期为1000000/（16000000/2）= 0.125u</span></span><br><span class="line">	<span class="comment">//500us/0.125us =（255-T8N+1） ×16（预分频比） </span></span><br><span class="line">    T8NC = <span class="number">0x03</span>;	<span class="comment">//设置T8N为定时器模式，分频比为1:16</span></span><br><span class="line">    T8N = <span class="number">6</span>;		<span class="comment">//设定时器初值，2ms</span></span><br><span class="line">    T8NPRE = <span class="number">1</span>;		<span class="comment">//使能预分频器</span></span><br><span class="line">    T8NIE = <span class="number">1</span>;		<span class="comment">//使能T8N定时器中断</span></span><br><span class="line">    T8NEN = <span class="number">1</span>;		<span class="comment">//打开T8NEN定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr</span><span class="params">(<span class="keyword">void</span>)</span> interrupt</span>&#123;		<span class="comment">//500us定时</span></span><br><span class="line">    <span class="keyword">if</span>(T8NIE&amp;&amp;T8NIF)&#123;<span class="comment">//进入T8N定时器中断</span></span><br><span class="line">        T8NIF = <span class="number">0</span>;     <span class="comment">//清T8N中断标志</span></span><br><span class="line">        T8N = T8N + <span class="number">6</span>;<span class="comment">//重载T8N初值，加上进入中断时间		</span></span><br><span class="line">		cnt_500us++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//任务定时  (500us*n范围内任务：n&lt;=255,精度500us)</span></span><br><span class="line">		timer11++;</span><br><span class="line">		timer12++;</span><br><span class="line">		timer13++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(cnt_500us==<span class="number">20</span>)<span class="comment">//10ms</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//任务定时  (1ms*n范围内任务：n&lt;=255,精度1ms)</span></span><br><span class="line">			timer21++;</span><br><span class="line">			timer22++;</span><br><span class="line">			timer23++;			</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	task_umpire();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务时间到达判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_umpire</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">	<span class="keyword">if</span>(timer11==<span class="number">100</span>)	<span class="comment">//500us*100=50ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">0</span>);	<span class="comment">//第0位置一，任务一第一优先级。</span></span><br><span class="line">		timer11=<span class="number">0</span>;				<span class="comment">//任务重新定时</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer12==<span class="number">200</span>)	<span class="comment">//500us*200=100ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">1</span>);	</span><br><span class="line">		timer12=<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer13==<span class="number">250</span>)	<span class="comment">//500us*250=125ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">2</span>);</span><br><span class="line">		timer13=<span class="number">0</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer21==<span class="number">100</span>)	<span class="comment">//10ms*100=1000ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">3</span>);	</span><br><span class="line">		timer21=<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer22==<span class="number">200</span>)	<span class="comment">//10ms*200=2000ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">4</span>);		</span><br><span class="line">		timer22=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(timer23==<span class="number">250</span>)	<span class="comment">//10ms*250=2500ms,</span></span><br><span class="line">	&#123;</span><br><span class="line">		SET_BIT(task_priority,<span class="number">5</span>);		</span><br><span class="line">		timer23=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_processing</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		task_priority_cnt++;</span><br><span class="line">		<span class="keyword">switch</span>(task_priority_cnt)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">0</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task1_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">0</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;<span class="comment">//每次执行后该位清0；重新开始循环，保证高优先级定时任务能优先执行。</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">1</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task2_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">1</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">2</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task3_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">2</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">3</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task4_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">3</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">4</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task5_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">4</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			<span class="keyword">if</span>(GET_BIT(task_priority,<span class="number">5</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//task6_functions();</span></span><br><span class="line">					CLR_BIT(task_priority,<span class="number">5</span>);</span><br><span class="line">					task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//task_functions();//其他优先级不重要但执行频繁的函数。</span></span><br><span class="line">			task_priority_cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SoftwareTimer_Init();</span><br><span class="line">	<span class="comment">//添加初始化函数...</span></span><br><span class="line"></span><br><span class="line">	task_processing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不到200行的代码，实现一个软定时且能够进行优先级判断且没有使用到C语言的高级用法简单易懂，最重要的是该代码任何MCU都能使用。</p>
<p>注意：每个任务最好不大于该软定时器中使用到的一次中断时间（这里是500us）</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/软件实现双边沿检测.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/软件实现双边沿检测.html" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 11:44:45" itemprop="dateCreated datePublished" datetime="2019-06-21T11:44:45+08:00">2019-06-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 15:54:51" itemprop="dateModified" datetime="2019-04-17T15:54:51+08:00">2019-04-17</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>双边缘检测（软件实现方法）</p>
<p>由于某开发需要使用上升沿后下降沿触发，软件都完成了，却发现该MCU只能上升或下降沿触发不能双边缘检测。只能在心里骂几句mmb。但软件还是要写的，不能半途而废。用尽一切办法无能为力，最后网上找到使用软件实现方法。</p>
<p>本来理想方法是程序初始化为上升沿触发，触发后进入中断然后在中断中判断触发方式（如果是上升沿触发下次改为上升沿触发，反之亦然），但是改变后中断使能为会置0， 在中断中中断使能重新置1，触发方式又会恢复原来。故不行</p>
<p>总之一切方法后发现无法在运行中改变触发方式，该思路只能作罢。</p>
<p>后来在网上寻找到解决方法。（软件实现双边缘检测方法）<a href="https://zhidao.baidu.com/question/310934714.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/310934714.html</a></p>
<p>原理如下：如果是用软件的方式来检测，那道理就简单了。用查询方式：只要将要检测的信号接到某个输入端口的某个位，在程序中反复读取该位的输入，一旦遇到“上次是0此次是1”的情况，就说明检测到了上升沿，遇到“上次是1此次是0”的情况，就说明检测到了下降沿。</p>
<p>程序实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">**********************************************************/</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay1ms</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> ElectricalLevel_Flag=<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************************************************************</span></span><br><span class="line"><span class="comment">//                              主程序                                              </span></span><br><span class="line"><span class="comment">//*************************************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">    OSCP = <span class="number">0x55</span>;</span><br><span class="line">	OSCC = <span class="number">0xC0</span>;			<span class="comment">//切换到高速时钟（2MHz）</span></span><br><span class="line">    <span class="keyword">while</span> (!SW_HS);			<span class="comment">//等待高速时钟切换完成</span></span><br><span class="line"></span><br><span class="line">	ANS0= <span class="number">0x01</span>;				<span class="comment">//注意要设置PA0为数字端口（PA0）</span></span><br><span class="line">	PAT5=<span class="number">0</span>;					<span class="comment">//设置PA5端口为输出口</span></span><br><span class="line">    PAT0 = <span class="number">1</span>;				<span class="comment">//设置PA0(PINT0)端口为输入口</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;     </span><br><span class="line">        <span class="comment">//改if语句为首次检测到高电平时进入语句把PA5拉低1ms，然后拉高，然后下次检测低电平（通过下个if实现）</span></span><br><span class="line">		<span class="keyword">if</span>(PA0==ElectricalLevel_Flag)</span><br><span class="line">		&#123;		</span><br><span class="line">			PA5=<span class="number">0</span>;</span><br><span class="line">			Delay1ms();</span><br><span class="line">			PA5=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(ElectricalLevel_Flag==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ElectricalLevel_Flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ElectricalLevel_Flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************************************************************</span></span><br><span class="line"><span class="comment">//                               延时子程序                                              </span></span><br><span class="line"><span class="comment">//*****************************************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay1ms</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> Dcount;</span><br><span class="line">    Dcount = <span class="number">0x53</span>;  <span class="comment">//若设主频2MHz，指令周期1us</span></span><br><span class="line">    <span class="keyword">while</span>(Dcount--);  <span class="comment">//循环1次12us（含12条指令），计数值计算为1000/12=83(0x53)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终波形如下：</p>
<p><img src="E:\0.jeff\博客\" alt=")SAAE)W2}8({ZAM0X`VPFT0">SAAE)W2}8({ZAM0X`VPFT0.png)</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/单片机开发之按键的一些心得.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/单片机开发之按键的一些心得.html" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 11:37:48 / 修改时间：11:37:21" itemprop="dateCreated datePublished" datetime="2019-06-21T11:37:48+08:00">2019-06-21</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单片机开发之按键的一些心得</p>
<p>1.本例程实验软定时器计数消抖，避免使用常见的delay();</p>
<p>2.本例程使用轮询查询电平的方法判断按键。</p>
<p>该方法优点：可以同时分辨①：抬起状态，②：按下状态，③抬起瞬间，④按下瞬间。如此你就能把按键玩的出神入化。</p>
<p>下面开始讲解</p>
<p>首先需要一个软件定时器，该部分使用到一个硬件定时器：参考-软件定时器的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该部分看mcu不同实现方法不同</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>	delay_500us_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SoftwareTimer_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;	</span><br><span class="line">	<span class="comment">//T8N</span></span><br><span class="line">	<span class="comment">//时钟源周期为1000000/（16000000/2）= 0.125u</span></span><br><span class="line">	<span class="comment">//500us/0.125us =（255-T8N+1） ×16（预分频比） </span></span><br><span class="line">    T8NC = <span class="number">0x03</span>;	<span class="comment">//设置T8N为定时器模式，分频比为1:16</span></span><br><span class="line">    T8N = <span class="number">6</span>;		<span class="comment">//设定时器初值，2ms</span></span><br><span class="line">    T8NPRE = <span class="number">1</span>;		<span class="comment">//使能预分频器</span></span><br><span class="line">    T8NIF = <span class="number">0</span>;     <span class="comment">//清T8N中断标志</span></span><br><span class="line">    T8NIE = <span class="number">1</span>;		<span class="comment">//使能T8N定时器中断</span></span><br><span class="line">    T8NEN = <span class="number">1</span>;		<span class="comment">//打开T8NEN定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isr</span><span class="params">(<span class="keyword">void</span>)</span> interrupt</span>&#123;		<span class="comment">//500us定时</span></span><br><span class="line">    <span class="keyword">if</span>(T8NIE&amp;&amp;T8NIF)&#123;<span class="comment">//进入T8N定时器中断</span></span><br><span class="line">        T8NIF = <span class="number">0</span>;     <span class="comment">//清T8N中断标志</span></span><br><span class="line">        T8N = T8N + <span class="number">6</span>;<span class="comment">//重载T8N初值，加上进入中断时间	</span></span><br><span class="line">        delay_500us_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面实现了一个计数500us计数变量。下面就开始使用该变量在按键处理去实现定时功能</p>
<p>按键处理功能实现部分</p>
<p>a.头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sbit key_flag_old；		<span class="comment">//用于保存上个状态的电平，赋值时高电平赋值1，低电平赋值0。</span></span><br><span class="line">sbit key_flag_cur；		<span class="comment">//用于保存当前状态的电平</span></span><br><span class="line">sbit key_on；			<span class="comment">//用于记录按下还是没按下</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> keyup_always_cnt=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Key_Process</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//按键处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按键KEY处理</span></span><br><span class="line">	key_flag_cur = KEY; <span class="comment">//读取当前按键的状态</span></span><br><span class="line">	<span class="keyword">if</span>(key_flag_cur != key_flag_old) <span class="comment">//按键按下或者松开检测，按下时，状态一直为1，松开时为0</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_on = !key_on;<span class="comment">//①按下是key_on=1,②抬起key_on=0;</span></span><br><span class="line">		key_flag_old = key_flag_cur;<span class="comment">//把当前状态给旧的状态，以免重复运行该判断</span></span><br><span class="line">        <span class="keyword">if</span>(!KEY)<span class="comment">//③按下瞬间,这里默认低电平按下</span></span><br><span class="line">		&#123;</span><br><span class="line">              key_press_process();<span class="comment">//按下按键的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>(KEY)<span class="comment">//④抬起瞬间</span></span><br><span class="line">		&#123;</span><br><span class="line">              key_lift_process();<span class="comment">//抬起按键的操作</span></span><br><span class="line">        &#125;        </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span>(key_on) <span class="comment">//按下计数:单次和长按都可判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_always_cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	<span class="keyword">if</span>(key_always_cnt &gt;= <span class="number">6000</span>)<span class="comment">//0.5MS*2000ms=1s;</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_always_process();<span class="comment">//长按按键的操作</span></span><br><span class="line">		key_continuous_cnt=<span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!key_on &amp;&amp; key_always_cnt&gt;<span class="number">0</span>&amp;&amp;key_always_cnt&lt;<span class="number">100</span>) <span class="comment">//按键松开时候进行检测，如果一直按着执行长按，这里也可以写1，可用于消抖</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_once_process();<span class="comment">//单次按键的函数操作</span></span><br><span class="line">		key_always_cnt = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>最后补充：面试时有个面试官问过有关按键问题：假如有A~Z按键，要判断按键按下，抬起，长按，点按，且点按，和长判断时间不同。使用面向对象思想封装一个函数实现该功能。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/C语言位操作宏定义.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/C语言位操作宏定义.html" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 11:06:57 / 修改时间：11:05:13" itemprop="dateCreated datePublished" datetime="2019-06-21T11:06:57+08:00">2019-06-21</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C语言的一些经典的宏定义</p>
<p>参考：<a href="https://blog.csdn.net/badmer/article/details/52141568?utm_source=blogxgwz3" target="_blank" rel="noopener">https://blog.csdn.net/badmer/article/details/52141568?utm_source=blogxgwz3</a></p>
<p>#define CPL_BIT(value,bit) ((value)^=(1&lt;&lt;(bit)))        //取反指定位</p>
<p>#define SET_BIT(value,bit) ((value)|=(1&lt;&lt;(bit)))        //置位指定位</p>
<p>#define CLR_BIT(value,bit) ((value)&amp;=~(1&lt;&lt;(bit)))     //清零指定位</p>
<p>#define GET_BIT(value,bit)    ((value) &amp; (1&lt;&lt;(bit)))    //读取指定位    </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/面试常见问题.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/面试常见问题.html" itemprop="url">
                  面试常见问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-12 11:01:34 / 修改时间：12:47:35" itemprop="dateCreated datePublished" datetime="2019-06-12T11:01:34+08:00">2019-06-12</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Static与Const的区别"><a href="#1-Static与Const的区别" class="headerlink" title="1.Static与Const的区别"></a>1.<a href="https://www.cnblogs.com/Jinfeng1213/p/8597446.html" target="_blank" rel="noopener">Static与Const的区别</a></h1><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>static作用：“改变生命周期” 或者 “改变作用域”</strong>：程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。</p>
<p><strong>1. static局部变量:</strong> 将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中</p>
<p><strong>静态局部变量有以下特点</strong>：</p>
<p>该变量在全局数据区分配内存；</p>
<p>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 　　</p>
<p>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</p>
<p>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</p>
<p><strong>定义静态函数的好处</strong>：</p>
<p>静态函数不能被其它文件所用；</p>
<p>其它文件中可以定义相同名字的函数，不会发生冲突；</p>
<p><strong>2. static全局变量</strong>: 表示一个变量在当前文件的全局内可访问    </p>
<p><strong>静态全局变量有以下特点：</strong></p>
<p>该变量在全局数据区分配内存；</p>
<p>未经初始化的静态全局变量会被程序自动初始化为0（ 在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为0）；</p>
<p>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</p>
<p>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量</p>
<p><strong>定义静态全局变量好处：</strong></p>
<p>静态全局变量不能被其它文件所用；</p>
<p>其它文件中可以定义相同名字的变量，不会发生冲突；　</p>
<p><strong>全局变量和全局静态变量的区别</strong>
　　</p>
<p>全局变量是不显式用static修饰的全局变量，但全局变量默认是动态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。
　</p>
<p>全局静态变量是显式用static修饰的全局变量，作用域是所在的文件，其他的文件即使用extern声明也不能使用。
　</p>
<p><strong>3. static 函数 表示一个函数只能在当前文件中被访问</strong></p>
<p><strong>4. static 类成员变量 表示这个成员为全类所共有</strong></p>
<p><strong>5.static 类</strong>成员函数 表示这个函数为全类所共有，而且只能访问静态成员变量</p>
<p>详细解释：<a href="https://www.cnblogs.com/heyonggang/p/3198431.html" target="_blank" rel="noopener">static用法详解</a></p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ol>
<li>const 常量：定义时就初始化，以后不能更改。</li>
<li>const 形参：func(const int a){};该形参在函数里不能改变</li>
<li>const修饰类成员函数：该函数对成员变量只能进行只读操作</li>
</ol>
<h3 id="static关键字的作用："><a href="#static关键字的作用：" class="headerlink" title="static关键字的作用："></a>static关键字的作用：</h3><p>（1）函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； </p>
<p>（2）在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问； </p>
<p>（3）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； </p>
<p>（4）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p>
<h3 id="const关键字的作用："><a href="#const关键字的作用：" class="headerlink" title="const关键字的作用："></a>const关键字的作用：</h3><p>（1）阻止一个变量被改变 </p>
<p>（2）声明常量指针和指针常量 </p>
<p>（3）const修饰形参，表明它是一个输入参数，在函数内部不能改变其值； </p>
<p>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；</p>
<p>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。</p>
<h2 id="2-Linux下C程序的存储空间布局"><a href="#2-Linux下C程序的存储空间布局" class="headerlink" title="2.Linux下C程序的存储空间布局"></a><a href="https://www.cnblogs.com/LUO77/p/5853534.html" target="_blank" rel="noopener">2.Linux下C程序的存储空间布局</a></h2><p>一个程序本质上都是由 BSS 段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</p>
<ul>
<li>BSS段(未初始化数据区)：在采用段式内存管理的架构中，BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。</li>
<li>数据段：在采用段式内存管理的架构中，数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>代码段：在采用段式内存管理的架构中，代码段（text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，<strong>并且内存区域属于只读</strong>。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>
<p><img src="D:\MyBlog\image\Snipaste_2019-06-12_12-41-57.png" alt="Snipaste_2019-06-12_12-41-57"></p>
<p>text段和data段在编译时已经分配了空间，而<strong>BSS段并不占用可执行文件的大小，它是由链接器来获取内存的</strong>。<br>    bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。<br>    data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。</p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。<strong>包含数据段和BSS段的整个区段此时通常称为数据区。</strong></p>
<p>  <strong>可执行程序在运行时又会多出两个区域：栈区和堆区。
</strong>    </p>
<p><strong>（4）栈区：由编译器自动释放，存放函数的参数值、局部变量等。</strong>每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的 函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容 量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<p> <strong>（5）堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。</strong>堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/Linux设备驱动开发详解：基于最新的Linux4-0内核.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Linux设备驱动开发详解：基于最新的Linux4-0内核.html" itemprop="url">
                  Linux设备驱动开发详解：基于最新的Linux4.0内核
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-06 18:39:46" itemprop="dateCreated datePublished" datetime="2019-03-06T18:39:46+08:00">2019-03-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-12 21:33:40" itemprop="dateModified" datetime="2019-03-12T21:33:40+08:00">2019-03-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第1章-Linux设备驱动概述"><a href="#第1章-Linux设备驱动概述" class="headerlink" title="第1章 Linux设备驱动概述"></a>第1章 Linux设备驱动概述</h1><h2 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h2><p><strong>作用：</strong></p>
<p>对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具<br>体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的<br>映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。</p>
<p>驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应用软件工程师之间的<br>沟通</p>
<p><strong>角色：</strong> </p>
<ul>
<li>作为一个程序员, 你能够对你的驱动作出你自己的选择, 并且在所需的编程时间和结果的<br>灵活性之间, 选择一个可接受的平衡 ，而一个驱动程序的角色是提供机制, 而不是策略。</li>
<li>大部分的编程问题其实可以<br>划分为 2 部分:” 提供什么能力”(机制) 和 “如何使用这些能力”(策略). 如果这两方面<br>由程序的不同部分来表达, 或者甚至由不同的程序共同表达, 软件包是非常容易开发和适<br>应特殊的需求. </li>
<li>在编写驱动时, 程序员应当特别注意这个基础的概念: 编写内核代码来存取硬件, 不能强加特别的策略给用户, 因为不同的用户有不同的需求. 驱动应当做到使硬件可用, 将<br>所有关于如何使用硬件的事情留给应用程序. 一个驱动, 这样, 就是灵活的, 如果它提供<br>了对硬件能力的存取, 没有增加约束. 然而, 有时必须作出一些策略的决定. 例如, 一个<br>数字 I/O 驱动也许只提供对硬件的字符存取, 以便避免额外的代码处理单个位. （驱动负责机制（提供什么能力），而策略（如何使用这些能力）应交于应用。驱动不应强加策略。）</li>
<li>驱动: 是一个存在于应用程序和实际设备间的软件层. 驱<br>动的这种特权的角色允许驱动程序员严密地选择设备应该如何表现: 不同的驱动可以提供<br>不同的能力, 甚至是同一个设备. 实际的驱动设计应当是在许多不同考虑中的平衡. </li>
</ul>
<h2 id="内核划分"><a href="#内核划分" class="headerlink" title="内核划分"></a>内核划分</h2><p><strong>内核的角色可以划分成下列几个部分 ：</strong></p>
<ul>
<li><p><strong>进程管理</strong> </p>
<p>内核负责创建和销毁进程, 并处理它们与外部世界的联系(输入和输出). 不同进程<br>间通讯(通过信号, 管道, 或者进程间通讯原语)对整个系统功能来说是基本的, 也<br>由内核处理. 另外, 调度器, 控制进程如何共享 CPU, 是进程管理的一部分. 更通<br>常地, 内核的进程管理活动实现了多个进程在一个单个或者几个 CPU 之上的抽象.</p>
</li>
<li><p><strong>内存管理</strong></p>
<p>计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的. 内核为<br>所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间. 内核的不同部<br>分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更<br>复杂的功能.<br>文件系统<br>Unix 在很大程度上基于</p>
</li>
<li><p><strong>文件系统的概念</strong></p>
<p>几乎 Unix 中的任何东西都可看作一个<br>文件. 内核在非结构化的硬件之上建立了一个结构化的文件系统, 结果是文件的抽<br>象非常多地在整个系统中应用. 另外, Linux 支持多个文件系统类型, 就是说, 物<br>理介质上不同的数据组织方式. 例如, 磁盘可被格式化成标准 Linux 的 ext3 文<br>件系统, 普遍使用的 FAT 文件系统, 或者其他几个文件系统.</p>
</li>
<li><p><strong>设备控制</strong></p>
<p>几乎每个系统操作最终都映射到一个物理设备上. 除了处理器, 内存和非常少的别<br>的实体之外, 全部中的任何设备控制操作都由特定于要寻址的设备相关的代码来进<br>行. 这些代码称为设备驱动. 内核中必须嵌入系统中出现的每个外设的驱动, 从硬<br>盘驱动到键盘和磁带驱动器. 内核功能的这个方面是本书中的我们主要感兴趣的地<br>方. </p>
</li>
<li><p><strong>网络</strong></p>
<p>网络必须由操作系统来管理, 因为大部分网络操作不是特定于某一个进程: 进入系<br>统的报文是异步事件. 报文在某一个进程接手之前必须被收集, 识别, 分发. 系统<br>负责在程序和网络接口之间递送数据报文, 它必须根据程序的网络活动来控制程序<br>的执行. 另外, 所有的路由和地址解析问题都在内核中实现. </p>
</li>
</ul>
<h2 id="设备的分类及特点"><a href="#设备的分类及特点" class="headerlink" title="设备的分类及特点"></a>设备的分类及特点</h2><p>以 Linux 的将设备区分为 3 种基本设备类型.  </p>
<p><strong>字符设备</strong></p>
<p>字符( char ) 设备是一种可以当作一个字节流来存取的设备( 如同一个文<br>件 )。这样的驱动常常至少实现 open, close, read, 和 write 系统调用。文本控制台( /dev/console )和串口( /dev/ttyS0 及<br>其友 )是字符设备的例子，因为它们很好地展现了流的抽象。 字符设备通过文件系<br>统结点来存取， 例如 /dev/tty1 和 /dev/lp0。</p>
<p><strong>块设备</strong></p>
<p>如同字符设备, 块设备通过位于 /dev 目录的文件系统结点来存取. 一个块设备<br>(例如一个磁盘)应该是可以驻有一个文件系统的. 在大部分的 Unix 系统, 一个块<br>设备只能处理这样的 I/O 操作, 传送一个或多个长度经常是 512 字节( 或一个更<br>大的 2 的幂的数 )的整块. Linux, 相反, 允许应用程序读写一个块设备象一个字<br>符设备一样 – 它允许一次传送任意数目的字节. 结果就是, 块和字符设备的区别<br>仅仅在内核在内部管理数据的方式上, 并且因此在内核/驱动的软件接口上不同.<br>如同一个字符设备, 每个块设备都通过一个文件系统结点被存取的, 它们之间的区<br>别对用户是透明的. 块驱动和字符驱动相比, 与内核的接口完全不同.</p>
<p><strong>网络接口</strong></p>
<p>任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设<br>备. 通常, 一个接口是一个硬件设备, 但是它也可能是一个纯粹的软件设备, 比如<br>环回接口. 一个网络接口负责发送和接收数据报文, 在内核网络子系统的驱动下,<br>不必知道单个事务是如何映射到实际的被发送的报文上的. 很多网络连接( 特别那<br>些使用 TCP 的)是面向流的, 但是网络设备却常常设计成处理报文的发送和接收.<br>一个网络驱动对单个连接一无所知; 它只处理报文. </p>
<h2 id="Linux设备驱动与整个软硬件系统的关系"><a href="#Linux设备驱动与整个软硬件系统的关系" class="headerlink" title="Linux设备驱动与整个软硬件系统的关系"></a>Linux设备驱动与整个软硬件系统的关系</h2><p>除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open（）、write（）、read（）、close（）等即可访问字符设备和块设备。所有字符<br>设备和块设备都统一呈现给用户。</p>
<p>Linux的块设备有两种访问方法：</p>
<ul>
<li>一种是类似dd命令对应的原始块设<br>备，如“/dev/sdb1”等；</li>
<li>另外一种方法是在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径<br>如“/home/barry/hello.txt”的形式进行访问。</li>
</ul>
<p>在Linux中，针对NOR、NAND等提供了独立的内存技术设备<br>（Memory Technology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡<br>能力的文件系统。针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文<br>件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-06_20-02-51.png" alt="Snipaste_2019-03-06_20-02-51"></p>
<p>字符设备与块设备都被映射到Linux文件系统。可通过文件系统的系统调用接口（open（）、write（）、read（）、close（））来访问</p>
<p>字符设备，块设备与存技术设备子系统则通过虚拟文件系统（VFS）对其进行抽象。</p>
<h1 id="第2章：Linux内核模块程序结构"><a href="#第2章：Linux内核模块程序结构" class="headerlink" title="第2章：Linux内核模块程序结构"></a>第2章：Linux内核模块程序结构</h1><h2 id="Linux内核模块简介"><a href="#Linux内核模块简介" class="headerlink" title="Linux内核模块简介"></a>Linux内核模块简介</h2><p><strong>我们是怎样把需要的部分都包含在内</strong><br><strong>核中呢？</strong></p>
<ul>
<li><p>一种方法：是把所有需要的功能都编译到Linux内核中。这会导致两个问题。</p>
<p>（1）一是生成的内核会很大。</p>
<p>（2）二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核</p>
</li>
<li><p>另一种：机制可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时<br>候，其对应的代码被动态地加载到内核中，这种机制被称为模块（Module）.模块具有这样的特点。</p>
<p>（1）模块本身不被编译入内核映像，从而控制了内核的大小。</p>
<p>（2）模块一旦被加载，它就和内核中的其他部分完全一样。</p>
</li>
</ul>
<h2 id="Linux内核模块程序结构"><a href="#Linux内核模块程序结构" class="headerlink" title="Linux内核模块程序结构"></a>Linux内核模块程序结构</h2><p>一个Linux内核模块主要由如下几个部分组成</p>
<p>一个Linux内核模块主要由如下几个部分组成。</p>
<p><strong>（1）模块加载函数</strong></p>
<p>当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相<br>关初始化工作。</p>
<p><strong>（2）模块卸载函数</strong></p>
<p>当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功<br>能。</p>
<p><strong>（3）模块许可证声明</strong></p>
<p>许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到<br>内核被污染（Kernel Tainted）的警告。</p>
<p>在Linux内核模块领域，可接受的LICENSE包括“GPL”、“GPL v2”、“GPL and additional rights”、“Dual<br>BSD/GPL”、“Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary”，这<br>个在学术界和法律界都有争议）。<br>大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以<br>MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。</p>
<p><strong>（4）模块参数（可选）</strong></p>
<p>模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。</p>
<p><strong>（5）模块导出符号（可选）</strong></p>
<p>内核模块可以导出的符号（symbol，对应于内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的<br>变量或函数。</p>
<p><strong>（6）模块作者等信息声明（可选）</strong></p>
<h2 id="内核模块函数详解"><a href="#内核模块函数详解" class="headerlink" title="内核模块函数详解"></a>内核模块函数详解</h2><h3 id="模块加载函数"><a href="#模块加载函数" class="headerlink" title="模块加载函数"></a>模块加载函数</h3><p>Linux内核模块加载函数一般以__init标识声明， 典型的模块加载函数的形式如代码清单4.2所示。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单4.2 内核模块加载函数</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="keyword">int</span> _ _<span class="function">init <span class="title">initialization_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 初始化代码 */</span></span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> module_init(initialization_function);</span><br></pre></td></tr></table></figure>
<p>在Linux内核中， 可以使用request_module（const char*fmt， …） 函数加载内核模块， 驱动开发人员可<br>以通过调用下列代码： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_module(module_name);</span><br></pre></td></tr></table></figure>
<p>在Linux中， 所有标识为__init的函数如果直接编译进入内核， 成为内核镜像的一部分， 在连接的时候<br>都会放在.init.text这个区段内。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ _init     _ _attribute_ _ ((_ _section_ _ (<span class="meta-string">".init.text"</span>)))</span></span><br></pre></td></tr></table></figure>
<h3 id="模块卸载函数"><a href="#模块卸载函数" class="headerlink" title="模块卸载函数"></a>模块卸载函数</h3><p>Linux内核模块加载函数一般以__exit标识声明 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _ _<span class="function"><span class="built_in">exit</span> <span class="title">cleanup_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* 释放代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure>
<h3 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h3><p>我们可以用“module_param（参数名， 参数类型， 参数读/写权限） ”为模块定义一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *book_name = <span class="string">"dissecting Linux Device Driver"</span>;</span><br><span class="line">module_param(book_name, charp, S_IRUGO);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> book_num = <span class="number">4000</span>;</span><br><span class="line">module_param(book_num, <span class="keyword">int</span>, S_IRUGO);</span><br></pre></td></tr></table></figure>
<h3 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h3><p>Linux的“/proc/kallsyms”文件对应着内核符号表， 它记录了符号以及符号所在的内存地址。<br>模块可以使用如下宏导出符号到内核符号表中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名);</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名);</span><br></pre></td></tr></table></figure>
<p>导出的符号可以被其他模块使用， 只需使用前声明一下即可。 </p>
<h3 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h3><p>在Linux内核模块中， 我们可以用MODULE_AUTHOR、 MODULE_DESCRIPTION、<br>MODULE_VERSION、 MODULE_DEVICE_TABLE、 MODULE_ALIAS分别声明模块的作者、 描述、 版<br>本、 设备表和别名，  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCRIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure>
<h1 id="第2章：字符设备驱动"><a href="#第2章：字符设备驱动" class="headerlink" title="第2章：字符设备驱动"></a>第2章：字符设备驱动</h1><h2 id="Linux字符设备驱动结构"><a href="#Linux字符设备驱动结构" class="headerlink" title="Linux字符设备驱动结构"></a>Linux字符设备驱动结构</h2><h3 id="cdev结构体"><a href="#cdev结构体" class="headerlink" title="cdev结构体"></a>cdev结构体</h3><p>在Linux内核中， 使用cdev结构体描述一个字符设备 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;</span><br><span class="line">	struct kobject kobj; /* 内嵌的kobject对象 */</span><br><span class="line">	struct module *owner; /* 所属模块*/</span><br><span class="line">	struct file_operations *ops; /* 文件操作结构体*/</span><br><span class="line">	struct list_head list;</span><br><span class="line">	dev_t dev; /* 设备号*/</span><br><span class="line">	unsigned int count;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>成员dev_t</strong></p>
<p>cdev结构体的dev_t成员定义了设备号， 为32位， 其中12位为主设备号， 20位为次设备号。 使用下列<br>宏可以从dev_t获得主设备号和次设备号： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="keyword">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="keyword">dev_t</span> dev)</span><br></pre></td></tr></table></figure>
<p>而使用下列宏则可以通过主设备号和次设备号生成dev_t： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MKDEV(<span class="keyword">int</span> major, <span class="keyword">int</span> minor)</span><br></pre></td></tr></table></figure>
<p><strong>成员file_operations</strong></p>
<p>cdev结构体的另一个重要成员file_operations定义了字符设备驱动提供给虚拟文件系统的接口函数 </p>
<p>Linux内核提供了一组函数以用于操作cdev结构体： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *, struct file_operations *)</span></span>;</span><br><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_put</span><span class="params">(struct cdev *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *, <span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>cdev_init（） 函数用于初始化cdev的成员， 并建立cdev和file_operations之间的连接 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops; <span class="comment">/* 将传入的文件操作结构体指针赋值给cdev的ops*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>cdev_alloc（ ） 函数用于动态申请一个cdev内存 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> = <span class="title">kzalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">cdev</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">    	&#123;</span><br><span class="line">			INIT_LIST_HEAD(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">			kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cdev_add（ ） 函数和cdev_del（ ） 函数分别向系统添加和删除一个cdev， 完成字符设备的注册和注<br>销。 对cdev_add（ ） 的调用通常发生在字符设备驱动模块加载函数中， 而对cdev_del（ ） 函数的调用则通<br>常发生在字符设备驱动模块卸载函数中。 </p>
</li>
</ul>
<h3 id="分配和释放设备号"><a href="#分配和释放设备号" class="headerlink" title="分配和释放设备号"></a>分配和释放设备号</h3><p>在调用cdev_add（） 函数向系统注册字符设备之前， 应首先调用register_chrdev_region（） 或<br>alloc_chrdev_region（） 函数向系统申请设备号， 这两个函数的原型为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>register_chrdev_region（） 函数用于已知起始设备的设备号的情况， 而alloc_chrdev_region（） 用于设<br>备号未知， 向系统动态申请未被占用的设备号的情况， 函数调用成功之后， 会把得到的设备号放入第一个<br>参数dev中。 alloc_chrdev_region（） 相比于register_chrdev_region（） 的优点在于它会自动避开设备号重复<br>的冲突。 </p>
<p>相应地， 在调用cdev_del（） 函数从系统注销字符设备之后， unregister_chrdev_region（） 应该被调用<br>以释放原先申请的设备号， 这个函数的原型为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h3><p>file_operations结构体中的成员函数是字符设备驱动程序设计的主体内容， 这些函数实际会在应用程序<br>进行Linux的open（） 、 write（） 、 read（） 、 close（） 等系统调用时最终被内核调用。 file_operations结构<br>体目前已经比较庞大 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_operations结构体</span></span><br><span class="line"><span class="number">1</span>struct file_operations &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line">	<span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">	<span class="keyword">loff_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>file_operations结构体中的主要成员进行分析 :</p>
<p>略</p>
<h2 id="Linux字符设备驱动的组成"><a href="#Linux字符设备驱动的组成" class="headerlink" title="Linux字符设备驱动的组成"></a>Linux字符设备驱动的组成</h2><p><strong>1.字符设备驱动模块加载与卸载函数</strong>    </p>
<p>在字符设备驱动模块加载函数中应该实现设备号的申请和cdev的注册， 而在卸载函数中应实现设备号<br>的释放和cdev的注销。 </p>
<p>Linux内核的编码习惯是为设备定义一个设备相关的结构体， 该结构体包含设备所涉及的cdev、 私有<br>数据及锁等信息。 常见的设备结构体、 模块加载和卸载函数形式 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 代码6.5 设备结构体</span><br><span class="line">struct xxx_dev_t &#123;</span><br><span class="line"> 	struct cdev cdev;</span><br><span class="line">	 ...</span><br><span class="line">&#125; xxx_dev;</span><br><span class="line">/* 设备驱动模块加载函数</span><br><span class="line">static int _ _init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	 ...</span><br><span class="line">	cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); /* 初始化cdev */</span><br><span class="line">	 xxx_dev.cdev.owner = THIS_MODULE;</span><br><span class="line">/* 获取字符设备号*/</span><br><span class="line">	if (xxx_major) </span><br><span class="line">	&#123;</span><br><span class="line">		register_chrdev_region(xxx_dev_no, 1, DEV_NAME);</span><br><span class="line">	&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, 1); /* 注册设备*/</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 设备驱动模块卸载函数*/</span><br><span class="line">static void _ _exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	unregister_chrdev_region(xxx_dev_no, 1); /* 释放占用的设备号*/</span><br><span class="line">	cdev_del(&amp;xxx_dev.cdev); /* 注销设备*/</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.字符设备驱动的file_operations结构体中的成员函数</strong> </p>
<p>ile_operations结构体中的成员函数是字符设备驱动与内核虚拟文件系统的接口， 是用户空间对Linux<br>进行系统调用最终的落实者。 大多数字符设备驱动会实现read（） 、 write（） 和ioctl（） 函数， 常见的字<br>符设备驱动的这3个函数的形式 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">	.write = xxx_write,</span><br><span class="line">	.unlocked_ioctl= xxx_ioctl,</span><br><span class="line">	...</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">/* 读设备*/</span></span><br><span class="line"><span class="keyword">ssize_t</span> xxx_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,<span class="keyword">loff_t</span>*f_pos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_to_user(buf, ..., ...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写设备*/</span></span><br><span class="line"><span class="keyword">ssize_t</span> xxx_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *f_pos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_from_user(..., buf, ...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ioctl函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">xxx_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,	<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">case</span> XXX_CMD1:</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> XXX_CMD2:</span><br><span class="line">			...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* 不能支持的命令 */</span></span><br><span class="line">		<span class="keyword">return</span> - ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备驱动的读函数中， filp是文件结构体指针， buf是用户空间内存的地址， 该地址在内核空间不宜直<br>接读写， count是要读的字节数， f_pos是读的位置相对于文件开头的偏移。</p>
<p>设备驱动的写函数中， filp是文件结构体指针， buf是用户空间内存的地址， 该地址在内核空间不宜直<br>接读写， count是要写的字节数， f_pos是写的位置相对于文件开头的偏移。</p>
<p>由于用户空间不能直接访问内核空间的内存， 因此借助了函数copy_from_user（） 完成用户空间缓冲<br>区到内核空间的复制， 以及copy_to_user（） 完成内核空间到用户空间缓冲区的复制， 见代码第6行和第14<br>行。</p>
<p>完成内核空间和用户空间内存复制的copy_from_user（） 和copy_to_user（） 的原型分别为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> _ _user *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> _ _user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述函数均返回不能被复制的字节数， 因此， 如果完全复制成功， 返回值为0。 如果复制失败， 则返<br>回负值。 </p>
<p>如果要复制的内存是简单类型， 如char、 int、 long等， 则可以使用简单的put_user（） 和<br>get_user（） ， 如： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val; <span class="comment">/* 内核空间整型变量</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">get_user(val, (int *) arg); /* 用户→内核， arg是用户空间的地址 */</span></span><br><span class="line">...</span><br><span class="line">put_user(val, (<span class="keyword">int</span> *) arg); <span class="comment">/* 内核→用户， arg是用户空间的地址 */</span></span><br></pre></td></tr></table></figure>
<p>在字符设备驱动中， 需要定义一个file_operations的实例， 并将具体设备驱动的函数赋值给<br>file_operations的成员 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.read = xxx_read,</span><br><span class="line">	.write = xxx_write,</span><br><span class="line">	.unlocked_ioctl= xxx_ioctl,</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述xxx_fops在代码清单6.5的cdev_init（&amp;xxx_dev.cdev， &amp;xxx_fops） 的语句中建立与cdev的连接。 </p>
<p>图6.1所示为字符设备驱动的结构、 字符设备驱动与字符设备以及字符设备驱动与用户空间访问该设<br>备的程序之间的关系。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-08_22-29-27.png" alt="Snipaste_2019-03-08_22-29-27"></p>
<p>个人理解：由图可知，内核的所有操作都是基于cdv结构体操作。其中的重中之重为dev_t，file_operations()成员以及加载和卸载函数。</p>
<p>dev_t：定义了设备号， 为32位， 其中12位为主设备号， 20位为次设备号。</p>
<p>file_operations():定义了字符设备驱动提供给虚拟文件系统的接口函数 ，该函数结构体为Linux内核提供了一组函数以用于操作cdev结构体。</p>
<p>加载及卸载函数：应该实现设备号的申请和cdev的注册及现设备号<br>的释放和cdev的注销。</p>
<p>而用户则通过Linux系统调用file_operations()定义的字符设备驱动提供给虚拟文件系统的接口函数 来实现底层的内核操作。</p>
<p>总结这个图是我见过的最精辟的，非常容易理解，有的则用一堆的结构体及函数来表示，看的头晕。</p>
<h2 id="第三章：驱动编写"><a href="#第三章：驱动编写" class="headerlink" title="第三章：驱动编写"></a>第三章：驱动编写</h2><h3 id="1-头文件、-宏及设备结构体"><a href="#1-头文件、-宏及设备结构体" class="headerlink" title="1.头文件、 宏及设备结构体"></a>1.头文件、 宏及设备结构体</h3><p>在globalmem字符设备驱动中， 应包含它要使用的头文件， 并定义globalmem设备结构体及相关宏。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1， 增加头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dev_major;</span><br></pre></td></tr></table></figure>
<h3 id="2-加载与卸载设备驱动"><a href="#2-加载与卸载设备驱动" class="headerlink" title="2.加载与卸载设备驱动"></a>2.加载与卸载设备驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	dev_major = register_chrdev(<span class="number">0</span>, <span class="string">"hello_dev"</span>, &amp;hello_fops);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	unregister_chrdev(dev_major, <span class="string">"hello_dev"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载和卸载的入口函数</span></span><br><span class="line">module_init(hello_drv_init);</span><br><span class="line">module_exit(hello_drv_exit);</span><br></pre></td></tr></table></figure>
<h3 id="3-添加GPL认证"><a href="#3-添加GPL认证" class="headerlink" title="3.添加GPL认证"></a>3.添加GPL认证</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>最简单的一个驱动实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  1， 增加头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dev_major;</span><br><span class="line">   <span class="comment">//3， 实现模块加载和卸载的入口函数</span></span><br><span class="line"><span class="comment">//函数的原形：一定要是返回值为int， 参数为void</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	dev_major = register_chrdev(<span class="number">0</span>, <span class="string">"hello_dev"</span>, &amp;hello_fops);<span class="comment">//加载设备号</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的原形：一定要是返回值为void， 参数为void</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	unregister_chrdev(dev_major, <span class="string">"hello_dev"</span>);<span class="comment">//卸载设备号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(hello_drv_init);</span><br><span class="line">module_exit(hello_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>装载和卸载模块命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># insmod  hello_drv.ko</span></span><br><span class="line"><span class="meta"># lsmod——显示已载入系统的模块</span></span><br><span class="line"><span class="meta"># rmmod hello_drv</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_01-50-17.png" alt="Snipaste_2019-03-09_01-50-17"></p>
<p>实际情况应该在装载及卸载时都打印出：——-^_^—–hello_dev—</p>
<p>注：lsmod——显示已载入系统的模块</p>
<p>​    申请主设备号是否成功：cat  /proc/devices</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_02-04-32.png" alt="Snipaste_2019-03-09_02-04-32"></p>
<p>​    </p>
<p><strong>函数讲解</strong></p>
<p>register_chrdev()</p>
<p>register_chrdev函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">const</span> struct file_operations *fops)</span></span></span><br></pre></td></tr></table></figure>
<p>* register_chrdev() -为字符设备注册一个主号码。</p>
<p>* @major:用于动态分配的主要设备号或0</p>
<p>* @name:这一系列设备的名称</p>
<p>* @fops:与此设备相关联的文件操作</p>
<p>*如果@major == 0，这个函数将动态分配一个main并返回它的号码。(静态注册主设备号)</p>
<p>*如果@major &gt; 0，此函数将尝试使用给定的设备保留设备，主要数字，将返回零成功。(动态注册主设备号)</p>
<h3 id="4-创建字符设备文件节点"><a href="#4-创建字符设备文件节点" class="headerlink" title="4. 创建字符设备文件节点"></a><strong>4. 创建字符设备文件节点</strong></h3><p>但是上面的驱动还是不完整的驱动，无法给用户使用的。</p>
<p>驱动为用户空间提供字符设备文件(设备文件/设备节点)：用户才能通过操作文件来操作驱动</p>
<p><strong>创建设备文件节点的两种方法</strong></p>
<p>1， 手动创建–mknod命令</p>
<p>mknod 文件名  类型  主设备号  次设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：</span></span><br><span class="line">	mknod  /dev/hello_dev  c  <span class="number">257</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_02-42-08.png" alt="Snipaste_2019-03-09_02-42-08"></p>
<p>2， 代码中自动创建–驱动装载就创建，卸载就直接删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类--将设备归类</span></span><br><span class="line"><span class="comment">//参数1--类是又哪个模块创建的，一般直接填THIS_MODULE</span></span><br><span class="line"><span class="comment">//参数2--类的名字，一般自定义</span></span><br><span class="line">class_create(owner,name)</span><br><span class="line">==》 struct class *class_create(struct <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">//在该类中创建某个设备</span></span><br><span class="line"><span class="comment">//参数1--哪个类别中</span></span><br><span class="line"><span class="comment">//参数2--当前创建的设备对象的父类，一般直接填NULL</span></span><br><span class="line"><span class="comment">//参数3--设备文件的设备号</span></span><br><span class="line"><span class="comment">//参数4--设备的私有数据--一般直接填NULL</span></span><br><span class="line"><span class="comment">//参数5--设备节点的名字</span></span><br><span class="line">device_create(struct class * cls,struct device * parent,<span class="keyword">dev_t</span> devt,<span class="keyword">void</span> * drvdata,<span class="keyword">const</span> <span class="keyword">char</span> * fmt,...)</span><br></pre></td></tr></table></figure>
<p><strong>在上阶程序优化static int __init hello_drv_init(void)函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1-向系统申请/注册主设备号--就是id，整数</span></span><br><span class="line">        <span class="comment">//参数1--指定的大于0主设备号--最大是12bit， 一般选256以上，或者直接填0， 表示动态系统分配</span></span><br><span class="line">        <span class="comment">//参数2--设备的名字--一般自定义</span></span><br><span class="line">        <span class="comment">//参数3--为应用空间提供的文件操作接口</span></span><br><span class="line">        <span class="comment">//返回值;正确为0， 错误为负数</span></span><br><span class="line">        ret = register_chrdev(dev_major, <span class="string">"hello_dev"</span>, &amp;hello_fops);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2- 创建类--将设备归类</span></span><br><span class="line">        <span class="comment">//参数1--类是又哪个模块创建的，一般直接填THIS_MODULE</span></span><br><span class="line">        <span class="comment">//参数2--类的名字，一般自定义</span></span><br><span class="line">        <span class="comment">// 实际是创建了 /sys/class/led_cls</span></span><br><span class="line">        led_cls = class_create(THIS_MODULE, <span class="string">"led_cls"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在该类中创建某个设备文件--/dev/hello0</span></span><br><span class="line">        <span class="comment">//参数1--哪个类别中</span></span><br><span class="line">        <span class="comment">//参数2--当前创建的设备对象的父类，一般直接填NULL</span></span><br><span class="line">        <span class="comment">//参数3--设备文件的设备号</span></span><br><span class="line">        <span class="comment">//参数4--设备的私有数据--一般直接填NULL</span></span><br><span class="line">        <span class="comment">//参数5--设备节点的名字</span></span><br><span class="line">        led_dev = device_create(led_cls, <span class="literal">NULL</span>, MKDEV(dev_major, <span class="number">0</span>), <span class="literal">NULL</span>,  <span class="string">"%s%d"</span>, led_dev_name, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//模块加载函数正确的时候一定返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_03-39-00.png" alt="Snipaste_2019-03-09_03-39-00"></p>
<p>结果：加载驱动后，会在/sys/class/led_cls目录下建立led_dev文件节点。</p>
<h3 id="5-实现应用调用驱动文件io的方式"><a href="#5-实现应用调用驱动文件io的方式" class="headerlink" title="5.实现应用调用驱动文件io的方式"></a>5.实现应用调用驱动文件io的方式</h3><p>该部分为会为各户提供各种文件io接口（供应用APP系统调用实现底层操作）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.文件操作对象---为用户提供各种文件io接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_drv_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 read(fd, buf, size);</span></span><br><span class="line"><span class="keyword">ssize_t</span> hello_drv_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *fpos)</span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> hello_drv_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *fpos)</span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_drv_close</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span></span><br><span class="line">	.open = hello_drv_open,</span><br><span class="line">	.read = hello_drv_read,</span><br><span class="line">	.write = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一个完整的字符设备驱动程序"><a href="#一个完整的字符设备驱动程序" class="headerlink" title="一个完整的字符设备驱动程序"></a>一个完整的字符设备驱动程序</h3><p> //  1， 增加头文件</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/fs.h&gt;</p>
<p>#include &lt;linux/device.h&gt;</p>
<p>#include &lt;asm/io.h&gt;</p>
<p>static struct device <em>led_dev;<br>static char </em>led_dev_name = “led_dev”;<br>static struct class *led_cls;<br>static unsigned int dev_major;</p>
<p>//2.文件操作对象—为用户提供各种文件io接口</p>
<p>int hello_drv_open(struct inode <em>inode, struct file </em>filp)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);</p>
<p>​    return 0;<br>}</p>
<p>//应用 read(fd, buf, size);<br>ssize_t hello_drv_read(struct file <em>filp, char __user </em>buf, size_t count, loff_t *fpos)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}</p>
<p>ssize_t hello_drv_write(struct file <em>filp, const char __user </em>buf, size_t count, loff_t *fpos)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}</p>
<p>int hello_drv_close(struct inode <em>inode, struct file </em>filp)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}<br>//文件操作对象—为用户提供各种文件io接口<br>const struct file_operations hello_fops = {<br>    .open = hello_drv_open,<br>    .read = hello_drv_read,<br>    .write = hello_drv_write,<br>    .release = hello_drv_close,</p>
<p>};</p>
<p>   //3， 实现模块加载和卸载的入口函数<br>//函数的原形：一定要是返回值为int， 参数为void<br>static int <strong>init hello_drv_init(void)<br>{<br>    printk(“——-^_^—–%s—\n”, </strong>FUNCTION__);</p>
<p>​    int ret;</p>
<p>​    //1-向系统申请/注册主设备号–就是id，整数<br>​    //参数1–指定的大于0主设备号–最大是12bit， 一般选256以上，或者直接填0， 表示动态系统分配<br>​    //参数2–设备的名字–一般自定义<br>​    //参数3–为应用空间提供的文件操作接口<br>​    //返回值;正确为0， 错误为负数<br>​    ret = register_chrdev(dev_major, “hello_dev”, &amp;hello_fops);</p>
<p>​    // 2- 创建类–将设备归类<br>​    //参数1–类是又哪个模块创建的，一般直接填THIS_MODULE<br>​    //参数2–类的名字，一般自定义<br>​    // 实际是创建了 /sys/class/led_cls<br>​    led_cls = class_create(THIS_MODULE, “led_cls”);<br>​<br>​    //3-在该类中创建某个设备文件–/dev/hello0<br>​    //参数1–哪个类别中<br>​    //参数2–当前创建的设备对象的父类，一般直接填NULL<br>​    //参数3–设备文件的设备号<br>​    //参数4–设备的私有数据–一般直接填NULL<br>​    //参数5–设备节点的名字<br>​    led_dev = device_create(led_cls, NULL, MKDEV(dev_major, 0), NULL,  “%s%d”, led_dev_name, 0);<br>​    //模块加载函数正确的时候一定返回0<br>​    return 0;</p>
<p>}<br>//函数的原形：一定要是返回值为void， 参数为void<br>static void hello_drv_exit(void)<br>{<br>    printk(“——-^_^—–%s—\n”);<br>    unregister_chrdev(dev_major, “hello_dev”);<br>}</p>
<p>module_init(hello_drv_init);<br>module_exit(hello_drv_exit);<br>MODULE_LICENSE(“GPL”);</p>
<p>碰见的一些问题：</p>
<p><strong>（1）问题:</strong></p>
<p>译模块出错：insmod: ERROR: could not insert module module.ko: Invalid parameters</p>
<p>选择错误头文件路径</p>
<p>解决：</p>
<p>uname -r查看当前运行的内核版本</p>
<p>ubuntu下内核路径：cd  /usr /src/</p>
<p><strong>（2）问题：</strong></p>
<p>Linux中终端显示的当前目录的绝对路径太长</p>
<p>解决：</p>
<p>只显示当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>找到位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$color_prompt&quot; = yes ]; then</span><br><span class="line">    PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &apos;</span><br><span class="line">else</span><br><span class="line">    PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>将这两个小写的w换成大写W，然后source ~/.bashrc即可</p>
<h2 id="第四章：平台总线"><a href="#第四章：平台总线" class="headerlink" title="第四章：平台总线"></a>第四章：平台总线</h2><p>平台总线简述：略</p>
<h3 id="小节一：I2C设备驱动"><a href="#小节一：I2C设备驱动" class="headerlink" title="小节一：I2C设备驱动"></a>小节一：I2C设备驱动</h3><h4 id="i2c协议说明"><a href="#i2c协议说明" class="headerlink" title="i2c协议说明"></a>i2c协议说明</h4><p>略</p>
<h4 id="Linux-I2C体系结构"><a href="#Linux-I2C体系结构" class="headerlink" title="Linux I2C体系结构"></a>Linux I2C体系结构</h4><p>查考：<a href="https://www.cnblogs.com/pingfandfy/p/5822813.html" target="_blank" rel="noopener">Linux操作系统的I2C驱动</a></p>
<p>Linux I2C体系结构分为3个组成部分：I2C核心 ，I2C总线驱动 ，I2C设备驱动 。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-11_12-19-25.png" alt="Snipaste_2019-03-11_12-19-25"></p>
<ul>
<li><p><strong>I2C核心</strong> </p>
<p>I2C核心为上层提供统一的接口和提供I2C总线驱动和设备驱动的注册、注销方法，I2C通信方法（即Algorithm） 上层的与具<br>体适配器无关的代码以及探测设备、 检测设备地址的上层代码等 </p>
</li>
<li><p><strong>I2C总线驱动</strong> </p>
<p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。I2C总线驱动主要包含了I2C适配器数据结构i2c_adapter、I2C适配器的algorithm数据结构i2c_algorithm和控制I2C适配器产生通信信号的函数。经由I2C总线驱动的代码，我们可以控制I2C适配器以主控方式产生开始位、停止位、读写周期，以及以从设备方式被读写、产生ACK等。</p>
</li>
<li><p><strong>I2C设备驱动</strong> </p>
<p>I2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在首CPU控制的I2C适配器上，通过I2C适配器与CPU交换数据。I2C设备驱动主要包含了数据结构i2c_driver和i2c_client，我们需要根据具体设备实现其中的成员函数。</p>
</li>
</ul>
<h4 id="Linux-I2C-驱动编程"><a href="#Linux-I2C-驱动编程" class="headerlink" title="Linux I2C 驱动编程"></a>Linux I2C 驱动编程</h4><h5 id="Linux-I2C适配器驱动"><a href="#Linux-I2C适配器驱动" class="headerlink" title="Linux I2C适配器驱动"></a>Linux I2C适配器驱动</h5><p>I2C适配器驱动的注册与注销 </p>
<p>I2C总线的通信方法 </p>
<h3 id="SPI设备驱动"><a href="#SPI设备驱动" class="headerlink" title="SPI设备驱动"></a>SPI设备驱动</h3><h3 id="PCI设备驱动"><a href="#PCI设备驱动" class="headerlink" title="PCI设备驱动"></a>PCI设备驱动</h3><h2 id="第五章：块设备"><a href="#第五章：块设备" class="headerlink" title="第五章：块设备"></a>第五章：块设备</h2><p>略</p>
<h2 id="第六章：网络设备"><a href="#第六章：网络设备" class="headerlink" title="第六章：网络设备"></a>第六章：网络设备</h2><p>略</p>
<p>## </p>
<h2 id="第七章：设备模型（补充）"><a href="#第七章：设备模型（补充）" class="headerlink" title="第七章：设备模型（补充）"></a>第七章：设备模型（补充）</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/嵌入式Linux网络编程.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/嵌入式Linux网络编程.html" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-04 13:07:52" itemprop="dateCreated datePublished" datetime="2019-03-04T13:07:52+08:00">2019-03-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-05 22:25:24" itemprop="dateModified" datetime="2019-03-05T22:25:24+08:00">2019-03-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="嵌入式-Linux-网络编程"><a href="#嵌入式-Linux-网络编程" class="headerlink" title="嵌入式 Linux 网络编程"></a>嵌入式 Linux 网络编程</h1><h2 id="第一章：TCP-IP-协议简介"><a href="#第一章：TCP-IP-协议简介" class="headerlink" title="第一章：TCP/IP 协议简介"></a>第一章：TCP/IP 协议简介</h2><h3 id="TCP-IP-协议概述"><a href="#TCP-IP-协议概述" class="headerlink" title="TCP/IP 协议概述"></a>TCP/IP 协议概述</h3><h4 id="OSI-参考模型及-TCP-IP-参考模型"><a href="#OSI-参考模型及-TCP-IP-参考模型" class="headerlink" title="OSI 参考模型及 TCP/IP 参考模型"></a>OSI 参考模型及 TCP/IP 参考模型</h4><p>OSI 协议参考模型是基于国际标准化组织（ISO）的建议发展起来的，从上<br>到下共分为 7 层：应用层、表示层、会话层、传输 层、 网络层、<br>数据链路层及物理层。这个 7 层的协议模型虽然规 定得非常细<br>致和完善，但在实际中却得不到广泛的应用，其重 要的原因之<br>一就在于它过于复杂。但它仍是此后很多协议模型 的基础，这<br>种分层架构的思想在很多领域都得到了广泛的应 用。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/嵌入式Linux网络编程.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
