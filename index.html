<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="暂时无">
<meta property="og:type" content="website">
<meta property="og:title" content="Jeff">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/index.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jeff">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-19-cs.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog（重要保留）-2018-12-19-cs.html" itemprop="url">
                  cs
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-12-19 02:58:59" itemprop="dateCreated datePublished" datetime="2022-12-19T02:58:59+08:00">2022-12-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-19 02:59:46" itemprop="dateModified" datetime="2018-12-19T02:59:46+08:00">2018-12-19</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。</p>
<p>另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。</p>
<p>谢谢！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/重要说明.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/重要说明.html" itemprop="url">
                  重要说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-28 21:37:19" itemprop="dateCreated datePublished" datetime="2019-12-28T21:37:19+08:00">2019-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-23 16:32:34" itemprop="dateModified" datetime="2019-02-23T16:32:34+08:00">2019-02-23</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。</p>
<p>博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/进程与线程.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/进程与线程.html" itemprop="url">
                  进程与线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 19:08:20" itemprop="dateCreated datePublished" datetime="2019-03-01T19:08:20+08:00">2019-03-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-04 01:15:56" itemprop="dateModified" datetime="2019-03-04T01:15:56+08:00">2019-03-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章：Linux-多任务-编程"><a href="#第一章：Linux-多任务-编程" class="headerlink" title="第一章：Linux 多任务 编程"></a>第一章：Linux 多任务 编程</h1><p> 本章 主要 内容： </p>
<p>简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。</p>
<h2 id="Linux下多任务简介"><a href="#Linux下多任务简介" class="headerlink" title="Linux下多任务简介"></a>Linux下多任务简介</h2><p><strong>什么叫多任务系统？</strong></p>
<p>多任务是指用户可以同一时间内运行多个应用程序，每个应用程序被称作一个任务。</p>
<p>多任务 操作系统 使用 某种 调度 策略 支持 多个 任务 并发 执行。由于 任务 会 频繁 地 切换 执行， 因此 给用户 多个 任务 同时 运行 的 感觉。</p>
<p><strong>任务定义:</strong></p>
<p>任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。</p>
<p><strong>进程定义:</strong></p>
<p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的最小单元。</p>
<p><strong>线程定义:</strong></p>
<p>线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以成为轻量级进程。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。通常一个任务是一个程序的一次执行，一个任务包含一个或多个完成独立功能的子任务，这个独立的子任务就是进程或线程。例如，一个杀毒软件的一次运行是一个任务，目的是从各种病毒的侵害中保护计算机系统，这个任务包含多个独立功能的子任务(进程或线程)，包括实时监控功能、定时查杀功能、防火墙功能及用户交互功能等。任务、进程和线程之间的关系如图3.1所示</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_19-41-09.png" alt="Snipaste_2019-03-01_19-41-09"></p>
<p>总结： ①一个操作系统可以执行多个任务（多个应用程序），一个任务指一个程序的一次执行。</p>
<p>​        ②一个任务包含一个或多个完成独立功能的子任务</p>
<p>​        ③子任务就是进程（一个）或线程（一个或多个）</p>
<p>一个任务为一个程序,一个程序由多个进程，每个进程又会有多个线程。而操作系统能运行多个程序（任务）。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程的基本概念</strong></p>
<p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的基本单元。一次任务的运行可以并发激活多个进程，这些进程相互合作来完成该任务的一个最终目标。</p>
<p>进程具有并发性、动态性、交互性、独立性和异步性等主要特性。</p>
<p>进程和程序是有本质区别的：①程序是静态的一段代码，是一些保存在非易失性存储器的指令的有序集合，没有任何执行的概念；②而进程是一个动态的概念，它是程序执行的过程，包括动态创建、调度和消亡的整个过程，它是程序执行和资源管理的最小单位。</p>
<p><strong>Linux下的进程结构</strong></p>
<p>进程不但包括程序的指令和数据，而且包括程序计数器和处理器的所有寄存器及存储临时数据的进程堆栈，因此，正在执行的进程包括处理器当前的一切活动。</p>
<p>因为linux是一个多任务多进程的操作系统，所以其他的进程必须等到系统将处理器使用权分配给自己之后才能运行。当正在运行的进程等待其他的系统资源时，linux内核将取得处理器的控制权，并将处理器分配给其他正在等待的进程，他按照内核中的调度算法决定将处理器分配给哪一个进程，也就是说，内核不会让处理器闲着。</p>
<p>内核将所有进程存放在双向循环链表（进程链表）中，其中链表的头是 init_task 描述符。链表的每一项都是类型为 task_struct，称为进程描述符的结构，该结构包含了一个进程相关的所有信息，定义&lt;include/linux/sched.h&gt;文件中。task_struct内核结构比较大，它能完整的描述一个进程，如进程的状态、进程的基本信息、进程标识符、内存相关信息、父进程相关信息、与进程相关的终端信息、当前工作目录、打开的文件信息、所接收的信号信息等。</p>
<p>下面详细讲解task_struct结构中最为重要的两个域：state（进程状态）和pid（进程标识符）</p>
<p>（1）进程状态</p>
<p>Linux中的进程有以下几种状态。</p>
<p>● 运行状态（TASK_RUNNING）:进程当前正在运行，或者正在运行队列中等待调度。</p>
<p>● 可中断的阻塞状态（TASK_INTERRUPTIBLE）：进程处于阻塞(睡眠)状态，正在等待某些事件发生或能够占用某些资源。处在这种状态下的进程可以被信号中断。接收到信号或被显式的唤醒呼叫（如调用 wake_up 系列宏:wake_up、wake_up_interruptible等）唤醒之后，进程将转变为 TASK_RUNNING 状态。</p>
<p>● 不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）:此进程状态类似于可中断的阻塞状态（TASK_INTERRUPTIBLE），只是它不会处理信号，把信号传递到这种状态下的进程不能改变它的状态。在一些特定的情况下（进程必须等待，直到某些不能被中断的事件发生），这种状态是很有用的。只有在它所等待的事件发生时，进程才被显示的唤醒呼叫唤醒。</p>
<p>● 可终止的阻塞状态（TASK_KILLABLE）:该状态的运行机制类似于TASK_UNINTERRUPTIBLE，只不过处在该状态下的进程可以响应致命信号。它可以替代有效但可能无法终止的不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）,以及易于唤醒但安全性欠佳的可中断的阻塞状态TASK_INTERRUPTIBLE）。</p>
<p>● 暂停状态（TASK_STOPPED）:进程的执行被暂停，当进程收到 SIGSTOP、SIGSTP、SIGTTIN、SIGTTOU等信号时，就会进入暂停状态。</p>
<p>● 跟踪状态（TASK_TRACED）:进程的执行被调试器暂停。当一个进程被另一个监控时（如调试器使用ptrace()系统调用监控测试程序），任何信号都可以把这个进程置于跟踪状态。</p>
<p>● 僵尸状态（EXIT_ZOMBIE）:进程运行结束，父进程尚未使用 wait 函数族(如调用 waitpid()函数)等系统调用来“收尸”，即等待父进程销毁它。处在该状态下的进程“尸体”已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的推出状态等信息供其他进程收集。</p>
<p>● 僵尸撤销状态（EXIT_DEAD）:这是最终状态，父进程调用 wait 函数族“收尸”后，进程彻底由系统删除。</p>
<p>它们之间的转换关系如图2所示：<img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-03-41.png" alt="Snipaste_2019-03-01_20-03-41"></p>
<p>进程可以使用 set_task_state 和 set_current_state 宏来改变指定进程的状态信息和当前进程的状态</p>
<p>（2）进程标识符</p>
<p>Linux内核通过唯一的进程标识符 PID 来标识每个进程(就和文件描述符一样)。PID存放在进程描述符的 pid 字段中，新创建的 PID 通常是前一个进程的 PID 加1，不过PID的值有上限（最大值=PID_MAX_DEFAULT-1，通常为32767），可以查看/proc/sys/kernel/pid_max 来确定该系统的进程数上限。</p>
<p>当系统启动后，内核通常作为某一个进程的代表。一个指向task_struct的宏current用来记录正在运行的进程。current经常作为进程描述符结构指针的形式出现在内核代码中，例如，current-&gt;pid 表示处理器正在执行的进程的PID。当系统需要查看所有的进程时，则调用for_each_process()宏，这将比系统搜索数组的速度要快的多。</p>
<p>在Linux中获得当前进程号的（PID）和父进程号（PPID）的系统调用函数分别为 getpid() 和 getppid()。</p>
<p><strong>进程的创建、执行、终止</strong></p>
<p>（1）进程的创建和执行</p>
<p>Linux 中进程的创建很特别，它把上述的步骤分解到两个单独的函数中去执行：fork()函数和exec函数族。</p>
<ul>
<li>首先，fork()函数通过复制当前进程创建一个子进程(注意此时资源还没有被复制过来，去了解一下写时复制页技术吧)，子进程于父进程的区别仅仅在于不同的PID、PPID和某些资源及统计量。</li>
<li>exec函数族负责读取可执行文件并将其载入地址空间开始运行。</li>
</ul>
<p>（2）进程的终止</p>
<p>进程终结也需要很多繁琐的工作，系统必须保证回收进程所占用的资源，并通知父进程。</p>
<ul>
<li>Linux首先把终止的进程设置为僵尸状态，这时，进程无法投入运行，它的存在只为父进程提供信息，申请死亡。</li>
<li>父进程得到信息后，开始调用 wait 函数族，最后终止子进程，子进程占用的所有资源被全部释放。</li>
</ul>
<p><strong>进程的内存结构</strong></p>
<p>Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该地址空间是大小为 4GB的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统</p>
<p>效果（用户不能直接访问物理地址），而且，更重要的是，用户程序可以使用比实际物理内存更大的地址空间。</p>
<p>4GB的进程地址空间会被分成两个部分：用户空间与内核空间。用户地址空间是从0到3GB(0xC000 0000),内核地址空间占据从3GB到4GB。</p>
<ul>
<li><p>用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。只有用户进程使用系统调用（代表用户进程在内核态执行）时可以访问到内核空间。每当进程切换时，用户空间就跟着变化;而内核空间由内核负责映射，它不会跟着进程改变，是固定的。</p>
</li>
<li><p>内核空间地址有自己对应的页表，用户进程各自有不同的页表。每个进程的用户空间都是完全独立、互不相干的。</p>
</li>
</ul>
<p>  <strong>进程的虚拟内存空间如图3所示，其中用户空间包括以下几个功能区域：</strong></p>
<ul>
<li><p>只读段: 包含程序代码(.init和.text)和只读数据(.rodata)。</p>
</li>
<li><p>数据段: 存放的是全局变量和静态变量。其中可读可写数据段(.data)存放已初始化的全局变量和静态变量，BSS数据段(.bss)存放未初始化的全局变量和静态变量。</p>
</li>
<li><p>堆: 由系统自动分配释放，存放函数的参数值、局部变量的值、返回地址等。</p>
</li>
<li><p>堆栈: 存放动态分配的数据，一般由程序员动态分配和释放。若程序员不释放，程序结束时可能由操作系统回收。</p>
</li>
<li><p>共享库的内存映射区域: 这是Linux动态链接器和其他共享代码库代码的映射区域。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-33-26.png" alt="Snipaste_2019-03-01_20-33-26"></p>
</li>
</ul>
<p>由于在Linux系统中每一个进程都会有/proc文件系统下与之对应的一个目录（如将init进程的相关信息在/proc/1 目录下的文件中描述），因此通过 proc 文件系统可以查看某个进程的地址空间的映射情况。例如，运行一个应用程序,如果它的进程号为13703,则输入“ cat /proc/13703/maps”命令，可以查看该进程的内存映射情况。</p>
<h2 id="进程控制符"><a href="#进程控制符" class="headerlink" title="进程控制符"></a>进程控制符</h2><p>进程控制符（PID），英文全称为Process Identifier。也常被称为进程标识符。顾名思义，它是各进程的身份标识,程序一运行系统就会自动分配给进程一个非 负 整型 表示 的 唯一 进程 ID 。 因为进程 ID标识符总是唯一的， 常将其用作其他标识符的一部分以保证其唯一性。 例如， 应用程序有时就把进程ID作为名字的一部分来创建一个唯一的文件名。</p>
<p>PID代表了各进程的进程ID,也就是说,PID就是各进程的身份标识。只要运行一程序，系统会自动分配一个标识，不过PID只是暂时唯一的，在进程中止后，这个号码就会被回收，并可能被分配给另一个新进程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>前面已经讲到，进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆栈段，这就造成了进程在进行切换等动作时需要较复杂的上下文切换等动作。为了进一步减少处理机的空闲时间，支持多处理器及减少上下文切换开销，进程在演化中出现了另一个概念—线程。</p>
<ul>
<li>线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以称为轻量级线程。</li>
<li>线程可以对进程的内存空间和资源分配进行访问，并与同一进程中的其他线程共享。因此，线程的上下文切换的开销比创建进程小得多。</li>
</ul>
<p>一个进程可以拥有多个线程，每个线程必须有一个父进程。线程不拥有系统资源，它只具有运行时所必须的一些数据结构，如堆栈/寄存器与线程控制块(TCB)，线程与其父进程的其他进程共享该进程所拥有的全部资源。要注意的是，由于线程共享了进程的资源和地址空间，因此，任何线程对系统资源的操作都会给其他进程带来影响。由此可知，多线程中的同步是一个非常重要的问题。在多线程系统中，进程与线程的关系如图</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-37-47.png" alt="Snipaste_2019-03-01_20-37-47"></p>
<h1 id="第二章：进程"><a href="#第二章：进程" class="headerlink" title="第二章：进程"></a>第二章：进程</h1><h2 id="第一节：创建新进程"><a href="#第一节：创建新进程" class="headerlink" title="第一节：创建新进程"></a>第一节：创建新进程</h2><h3 id="函数fork（创建）"><a href="#函数fork（创建）" class="headerlink" title="函数fork（创建）"></a>函数fork（创建）</h3><p>一个现有的进程可以调用fork函数创建一个新进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt;</span></span></span><br><span class="line"><span class="function">pid_ t <span class="title">fork</span><span class="params">( <span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 值： 子 进程 返回 0， 父 进程 返回 的是子进程的PID； 若 出错， 返回 − 1</p>
<p>由 fork 创建 的 新 进程 被称为 子 进程（ child process）。 fork 函数 被 调用 一次， 但 返回 两次。 两次 返回 的 区 别是 子 进程 的 返回 值 是 0， 而 父 进程 的 返回 值 则是 新建 子 进程 的 进程 ID。</p>
<p>将 子 进程 ID 返回 给 父 进程 的 理由 是： 因为 一个 进程 的 子 进程 可以 有 多个， 并且 没有 一个 函数 使 一个 进程 可以 获得 其 所有 子 进程 的 进程 ID。 fork 使 子 进程 得到 返回 值 0 的 理由 是： 一个 进程 只会 有一个 父 进程， 所以 子 进程 总是 可以 调用 getppid 以 获得 其父 进程 的 进程 ID（ 进程 ID 0 总是 由 内核 交换 进程 使用， 所以 一个 子 进程 的 进程 ID 不可 能为 0）。(这句话好拗口)</p>
<p>子 进程 和 父 进程 继续 执行 fork 调用 之后 的 指令。 子 进程 是 父 进程 的 副本。 例如， 子 进程 获得 父 进程 数据 空间、 堆 和 栈 的 副本。 注意， 这是 子 进程 所 拥有 的 副本。 父 进程 和 子 进程 并不 共享 这些 存储 空间 部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">pid_t</span> ret;</span><br><span class="line">	ret=fork();</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_23-43-25.png" alt="Snipaste_2019-03-01_23-43-25"></p>
<p>分析：子进程的返回值为ret=0，父进程的返回值ret为子进程的pid。且子进程和父进程都为7,因此可见父，子进程不资源共享，子进程只是简单的对父进程复制。子 进程 获得 父 进程 数据 空间、 堆 和 栈 的 副本。</p>
<h3 id="函数-vfork（创建）"><a href="#函数-vfork（创建）" class="headerlink" title="函数 vfork（创建）"></a>函数 vfork（创建）</h3><p>函数 的 调用 序列 和 返回 值 与 fork 相同， 但 两者 的 语义 不同。</p>
<p> vfork 函数 用于 创建 一个 新 进程， 而 该 新 进程 的 目的 是 exec 一个 新 程序（。 vfork 与 fork 一样 都 创建 一个 子 进程， 但是 它 并不 将 父 进程 的 地址 空间 完全 复制 到 子 进程 中， 因为 子 进程 会 立即 调用 exec（ 或 exit）， 于是 也就 不会 引用 该地 址 空间。 不过 在 子 进程 调用 exec 或 exit 之前， 它在 父 进程 的 空间 中 运行。 这种 优化 工作 方式 在 某些 UNIX 系统 的 实现 中 提高 了 效率， 但如 果子 进程 修改 数据（ 除了 用于 存放 vfork 返回 值 的 变量）、 进行 函数 调用、 或者 没有 调用 exec 或 exit 就 返回 都 可能 会 带来 未知 的 结果。</p>
<p>vfork 和 fork 之间 的 另一个 区别 是： vfork 保证 子 进程 先 运行， 在 它 调用 exec 或 exit 之后 父 进程 才可 能被 调度 运行， 当子 进程 调用 这 两个 函数 中的 任意 一个 时， 父 进程 会 恢复 运行。（ 如果 在 调用 这 两个 函数 之前 子 进程 依赖于 父 进程 的 进一步 动作， 则 会 导致 死锁。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">pid_t</span> ret;</span><br><span class="line">	ret=vfork();</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-28-17.png" alt="Snipaste_2019-03-02_00-28-17"></p>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h3><p>提及 用 fork 函数 创建 新的 子 进程 后， 子 进程 往往 要 调用 一种 exec 函数 以 执行 另一个 程序。 当 进程 调用 一种 exec 函数 时， 该 进程 执行 的 程序 完全 替换 为 新 程序， 而 新 程序 则从 其 main 函数 开始 执行。 因为 调用 exec 并不 创建 新 进程， 所以 前后 的 进程 ID 并未 改变。 exec 只是 用 磁盘 上 的 一个 新 程序 替换 了 当前 进程 的 正文 段、 数据 段、 堆 段 和 栈 段。</p>
<p>略</p>
<p>函数 exit（退出）</p>
<p>进程 有 5 种 正常 终止 及 3 种 异常 终止 方式。 5 种 正常 终止 方式 具体 如下。</p>
<ul>
<li>（1） 在 main 函数 内 执行 return 语句， 这 等效 于 调用 exit。 </li>
<li>（2） 调用 exit 函数。  其 操作 包括 调用 各 终止 处理 程序， 然后 关闭 所有 标准 I/ O 流 等。</li>
<li>（3） 调用_ exit 或_ Exit 函数 </li>
<li>（4） 进程 的 最后 一个 线程 在 其 启动 例程 中 执行 return 语句。 但是， 该 线程 的 返回 值 不用 作 进程 的 返回 值。 当 最后 一个 线程 从其 启动 例程 返回 时， 该 进程 以 终止 状态 0 返回。</li>
<li><p>（5） 进程 的 最后 一个 线程 调用 pthread_ exit 函数。 </p>
<p>3 种 异常 终止 具体 如下。</p>
<p>（1） 调用 abort。 它 产生 SIGABRT 信号， 这是 下一 种 异常 终止 的 一种 特例。</p>
<p>（2） 当 进程 接收 到 某些 信号 时。 信号 可由 进程 自身（ 如 调用 abort 函数）、 其他 进程 或 内核 产生。 例如， 若 进程 引用 地址 空间 之外 的 存储 单元、 或者 除以 0， 内核 就 会为 该 进程 产生 相应 的 信号。</p>
<p>（3） 最后 一个 线程 对“ 取消”（ cancellation） 请求 作出 响应。 默认 情况下，“ 取消” 以 延迟 方式 发生： 一个 线程 要求 取消 另一个 线程， 若干 时间 之后， 目标 线程 终止。</p>
</li>
</ul>
<p><strong>exit() 和_ exit() 函数 说明。</strong></p>
<p>exit() 和_ exit() 函数 都是 用来 终止 进程 的。 当 程序 执行 到 exit() 或_ exit() 时， 进程 会 无条件 地 停止 剩下 的 所有 操作， 清除 各种 数据 结构， 并 终止 本 进程 的 运行。 但是， 这 两个 函数 还是 有区别 的， 这 两个 函数 的 调用 过程 如图</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-53-30.png" alt="Snipaste_2019-03-02_00-53-30"></p>
<p>从 图 3. 5 中 可以 看出，_ exit() 函数 的 作用 是 直接 使 进程 停止 运行， 清除 其 使用 的 内存 空间， 并 清除 其 在内 核 中的 各种 数据 结构； exit() 函数 则在 这些 基础上 做了 一些 包装， 在 执行 退出 之前 加了 若干 道 工序。 exit() 函数 与_ exit() 函数 最大 的 区别 就在于 exit() 函数 在 终止 当前 进程 之前 要 检查 该 进程 打开 了 哪些 文件， 并把 文件 缓冲区 中的 内容 写回 文件， 就是 图中 的“ 清理 I/ O 缓冲” 一项。</p>
<p><strong>exit() 和_ exit() 函数 语法。</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-56-22.png" alt="Snipaste_2019-03-02_00-56-22"></p>
<h3 id="函数-wait-和-waitpid（阻塞）"><a href="#函数-wait-和-waitpid（阻塞）" class="headerlink" title="函数 wait 和 waitpid（阻塞）"></a>函数 wait 和 waitpid（阻塞）</h3><p><strong>wait() 和 waitpid() 函数 说明</strong>。</p>
<p> wait() 函数 用于 使 父 进程（ 也就是 调用 wait() 的 进程） 阻塞， 直到 一个 子 进程 结束 或者 该 进程 接到 了 一个 指定 的 信号 为止。 如果 该 父 进程 没有 子 进程 或者 他的 子 进程 已经 结束， 则 wait() 会 立即 返回- 1。 </p>
<p>waitpid() 的 作用 和 wait() 一样， 但它 并不 一定 等待 第一个 终止 的 子 进程。 waitpid() 有若 干 选项， 可 提供 一个 非 阻塞 版本 的 wait() 功能。 实际上 wait() 函数 只是 waitpid() 函数 的 一个 特例， 在 Linux 内部 实现 wait() 函数 时 直接 调用 的 就是 waitpid() 函数。 </p>
<p> <strong>wait() 和 waitpid() 函数 格式 说明。</strong> </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-59-51.png" alt="Snipaste_2019-03-02_00-59-51"></p>
<p><strong>waitpid() 函数 的 语法 规范。</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_01-00-39.png" alt="Snipaste_2019-03-02_01-00-39"></p>
<h2 id="第二节：守护进程"><a href="#第二节：守护进程" class="headerlink" title="第二节：守护进程"></a>第二节：守护进程</h2><p>守护进程（ daemon） 是生存期长的一种进程。 它们 常常在系统引导装入时启动， 仅在系统关闭时才终止。 因为它们没有控制终端， 所以说它们是在后台运行 的。 UNIX系统有很多守护进程， 它们执行日常事务 活动。</p>
<h3 id="编写守护进程"><a href="#编写守护进程" class="headerlink" title="编写守护进程"></a>编写守护进程</h3><p>编写守护进程看似复杂，但实际上也是遵循一个特定的流程。下面就分5个步骤来讲解怎样创建一个简单的守护进程。</p>
<p><strong>1．创建子进程，父进程退出</strong></p>
<p>这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在shell 终端里造成一种程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在shell 终端里则可以执行其<br>他的命令，从而在形式上做到了与控制终端的脱离。</p>
<p>父进程创建了子进程之后退出，父进程会先于子进程退出，会造成子进程没有父进程，从<br>而变成一个孤儿进程。在Linux 中，每当系统发现一个孤儿进程，就会自动由1 号进程（也就是init 进程）<br>收养它，这样，原先的子进程就会变成init 进程的子进程了。</p>
<p>其关键代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/*父进程退出*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2．在子进程中创建新会话</strong></p>
<p>这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用<br>的是系统函数setsid()，在具体介绍setsid()之前，读者首先要了解两个概念：进程组和会话期。</p>
<p><strong>进程组：</strong>进程组是一个或多个进程的集合。进程组由进程组 ID 来惟一标识。除了进程号（PID）之外，进程组ID<br>也是一个进程的必备属性。</p>
<p>每个进程组都有一个组长进程，其组长进程的进程号等于进程组 ID。且该进程ID 不会因组长进程的退出而受到影响。</p>
<p><strong>会话期：</strong> 会话组是一个或多个进程组的集合。通常，一个会话开 始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期，它们之间的关系如图7.6 所示。<br>接下来就可以具体介绍 setsid()的相关内容。<br>（1）setsid()函数作用。<br>setsid()函数用于创建一个新的会话，并担任该会话组的组长。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_23-36-05.png" alt="Snipaste_2019-03-02_23-36-05"></p>
<p><strong>(a) 调用</strong><br><strong>setsid()有下面的3 个作用。</strong></p>
<ul>
<li>让进程摆脱原会话的控制。</li>
<li>让进程摆脱原进程组的控制。</li>
<li>让进程摆脱原控制终端的控制</li>
</ul>
<p><em>那么，在创建守护进程时为什么要调用setsid()函数呢？</em></p>
<p>在创建守护进程的第一步，调用fork()函数来创建子进程后再令父进程退出时。由于在调用fork()函数时，子进程全盘复制了父进程的会<br>话期、进程组和控制终端等，虽然父进程退出了，但原先的会话期、进程组和控制终端等并没有改变，因<br>此，还不是真正意义上的独立，而setsid()函数能够使进程完全独立出来，从而脱离所有其他进程的控制。</p>
<p><strong>(b) setsid()函数格式</strong></p>
<p>当进程是会话的领头进程时setsid()调用失败并返回（-1）。setsid()调用成功后，返回新的会话的ID，调用setsid函数的进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，进程同时与控制终端脱离。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_23-38-38.png" alt="Snipaste_2019-03-02_23-38-38"></p>
<p><strong>3．改变当前目录为根目录</strong></p>
<p>这一步也是必要的步骤。使用fork()创建的子进程继承了父进程的当前工作目录。由于在进程运行过程中，<br>当前目录所在的文件系统（比如“/mnt/usb”等）是不能卸载的，这对以后的使用会造成诸多的麻烦（比<br>如系统由于某种原因要进入单用户模式）。因此，通常的做法是让“/”作为守护进程的当前工作目录，这<br>样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变<br>工作目录的常见函数是chdir()。</p>
<p><strong>4．重设文件权限掩码</strong></p>
<p>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有一个文件权限掩码是050，它就屏蔽了文件组拥<br>有者的可读与可执行权限。由于使用fork()函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为 0，可以大大增强该守护进程的灵活性。<br>设置文件权限掩码的函数是umask()。在这里，通常的使用方法为umask(0)。</p>
<p><strong>5．关闭文件描述符</strong></p>
<p>同文件权限掩码一样，用fork()函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打<br>开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法<br>被卸载。<br>在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守<br>护进程，守护进程中用常规方法（如printf()）输出的字符也不可能在终端上显示出来。所以，文件描述符<br>为0、1 和2 的3 个文件（常说的输入、输出和报错这3 个文件）已经失去了存在的价值，也应被关闭。<br>通常按如下方式关闭文件描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXFILE; i++)</span><br><span class="line">&#123;</span><br><span class="line">close(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：第一步让字进程称为孤儿进程，第二步：调用setsid函数使子进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，从而使子进程同时与控制终端脱离。后面主要用于释放从父进程继承过来的紫瑶及从设参数。（第三步。释放子从父进程继承的当前工作目录。第四步：重设文件权限掩码0为umask(0，大大增强该守护进程的灵活性。第五步：关闭文件描述符。如过子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但是不关闭的它们一样消耗系统资源，而且可能导致所在的文件系统无法<br>被卸载。</p>
<p>这样，一个简单的守护进程就建立起来了，创建守护进程的 流程图如图</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-00-11.png" alt="Snipaste_2019-03-03_00-00-11"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid; </span><br><span class="line">	<span class="keyword">int</span> i, fd; </span><br><span class="line">	<span class="keyword">char</span> *buf= <span class="string">"This is a Daemon\n"</span>;</span><br><span class="line">	pid = fork(); <span class="comment">/* 第一步 */</span> </span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" Error fork\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* 父 进程 退出 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">	setsid(); <span class="comment">/*第 二步*/</span> </span><br><span class="line">	chdir(<span class="string">"/tmp"</span>); <span class="comment">/*第三步*/</span> </span><br><span class="line">	umask(<span class="number">0</span>); <span class="comment">/*第四 步*/</span> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; getdtablesize(); i++) <span class="comment">/*第五 步*/</span> </span><br><span class="line">	&#123; </span><br><span class="line">		close(i);</span><br><span class="line">	&#125; <span class="comment">/*这时 创建 完 守护 进程， 以下 开始 正式 进入 守护 进程 工作*/</span> </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span>((fd = open(<span class="string">"daemon. log"</span>, O_CREAT|O_WRONLY|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Open file error\n"</span>); </span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">		&#125; </span><br><span class="line">			write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">			close(fd);</span><br><span class="line">			sleep(<span class="number">2</span>); </span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="守护进程调式"><a href="#守护进程调式" class="headerlink" title="守护进程调式"></a>守护进程调式</h3><p>由于守护进程完全脱离了控制终端，因此，不能像其<br>他普通进程一样将错误信息输出到控制终端来通知程序员，即使使用gdb 也无法正常调试。那么，守护进<br>程的进程要如何调试呢？一种通用的办法是使用syslog 服务，将程序中的出错信息输入到系统日志文件中</p>
<p>略</p>
<h3 id="实例1：编写多进程程序"><a href="#实例1：编写多进程程序" class="headerlink" title="实例1：编写多进程程序"></a>实例1：编写多进程程序</h3><p>1．实验目的<br>通过编写多进程程序，使读者熟练掌握fork()、exec()、wait()和waitpid()等函数的使用，进一步理解在Linux<br>中多进程编程的步骤。<br>2．实验内容<br>该实验有3 个进程，其中一个为父进程，其余两个是该父进程创建的子进程，其中一个子进程运行“ls -l”<br>指令，另一个子进程在暂停5s 之后异常退出，父进程先用阻塞方式等待第一个子进程的结束，然后用非阻<br>塞方式等待另一个子进程的退出，待收集到第二个子进程结束的信息，父进程就返回。<br>3．实验步骤<br>（1）画出该实验流程图。<br>该实验流程图如图 7.8 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-09-06.png" alt="Snipaste_2019-03-03_00-09-06"></p>
<p>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//略</span></span><br></pre></td></tr></table></figure>
<h3 id="实例2：创建守护进程"><a href="#实例2：创建守护进程" class="headerlink" title="实例2：创建守护进程"></a>实例2：创建守护进程</h3><p>先建立起一个守护进程，然后在该守护进程中新建一个子进程，该子进程暂停10s，<br>然后自动退出，并由守护进程收集子进程退出的消息。在这里， 子进程和<br>守护进程的退出消息都在系统日志文件（ 例如<br>“/var/log/messages”，日志文件的全路径名因版本的不同可能会有所不同）<br>中输出。子进程退出后，守护进程循环暂停，其间隔时间为10s。<br>3．实验步骤<br>（1）画出该实验流程图。<br>该程序流程图如图 7.9 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-14-10.png" alt="Snipaste_2019-03-03_00-14-10"></p>
<p>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<h2 id="第三节：进程间通信"><a href="#第三节：进程间通信" class="headerlink" title="第三节：进程间通信"></a>第三节：进程间通信</h2><p>进程是一个程序的一次执行。这里所说的进程一般是指运行在用户态的进程，<br>而由于处于用户态的不同进程之间是彼此隔离的，它们必须通过某种方式来进<br>行通信。本章就是讲述如何建立这些不同的通话方式。</p>
<p>Linux 下的进程通信手段基本上是从UNIX 平台上的进程通信手段继承而来的。而对UNIX 发展做出重大<br>贡献的两大主力AT&amp;T 的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）。</p>
<ul>
<li><p>前者（AT&amp;T 的贝尔实验室）是对UNIX 早期的进程间通信手段进行了系统的改进和扩充，形成了<br>“system V IPC”，其通信进程主要局限在单个计算机内；</p>
</li>
<li><p>后者（BSD）则跳过了该限制，形成了基于套接口（socket）<br>的进程间通信机制。</p>
<p><strong>Linux则把两者的优势都继承了下来，如图所示。</strong></p>
</li>
</ul>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-48-00.png" alt="Snipaste_2019-03-03_00-48-00"></p>
<p>UNIX 进程间通信（IPC）方式：包括管道、FIFO 以及信号。</p>
<p>System V 进程间通信（IPC）包括：System V 消息队列、System V 信号量以及System V 共享内存<br>区。</p>
<p> Posix 进程间通信（IPC）包括：Posix 消息队列、Posix 信号量以及Posix 共享内存区。</p>
<p>现在在Linux 中使用较多的进程间通信方式主要有以下几种。</p>
<p><strong>（1）管道（Pipe）及有名管道（named pipe）：</strong>管道可用于具有亲缘关系进程间的通信，有名管道，除具<br>有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
<p><strong>（2）信号（Signal）：</strong>信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知<br>进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一样的。</p>
<p><strong>（3）消息队列（Messge Queue）：</strong>消息队列是消息的链接表，包括Posix 消息队列SystemV 消息队列。<br>它克服了前两种通信方式中信息量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中<br>添加新消息；对消息队列有读权限的进程则可以从消息队列中读取消息。</p>
<p><strong>（4）共享内存（Shared memory）：</strong>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块<br>内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种通信方式需要依靠某种同步<br>机制，如互斥锁和信号量等。</p>
<p><strong>（5）信号量（Semaphore）：</strong>主要作为进程之间以及同一进程的不同线程之间的同步和互斥手段。</p>
<p><strong>（6）套接字（Socket）：</strong>这是一种更为一般的进程间通信机制，它可用于网络中不同机器之间的进程间通<br>信，应用非常广泛。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><h4 id="管道概述"><a href="#管道概述" class="headerlink" title="管道概述"></a>管道概述</h4><p>管道是Linux中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和有名管道。 </p>
<p> <strong>无名管道</strong></p>
<p>无名管道是Linux中管道通信的一种原始方法， 如图 4. 2（ a） 所示， 它具有如下特点。</p>
<ul>
<li>它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）。</li>
<li>它是一个半双工的通信模式，具有固定的读端和写端。</li>
<li>管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的read()和write()等函数。但<br>是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中。</li>
</ul>
<p>有名管道 </p>
<p>有名管道（ FIFO）是对无名管道的一种改进，如图 4.2（ b）所示， 它具有 如下特点。 </p>
<p>（1）它可以使互不相关的两个进程实现彼此通信。</p>
<p>（2）该 管道可以通过路径名来指出，并且在文件系统中是可见 的。在建立 了管道之后，两个进程就可以把它当作普通文件一样进行读写操作，使用 非常方便。 </p>
<p>（3）FIFO严格地遵循先进先出规则，对管道及FIFO的读总是从开始处返回 数据， 对它们的写则把数据添加到末尾。 有名管道不支持如 lseek() 等文件 定位操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-37-18.png" alt="Snipaste_2019-03-03_01-37-18"></p>
<h4 id="无名管道系统编程"><a href="#无名管道系统编程" class="headerlink" title="无名管道系统编程"></a>无名管道系统编程</h4><h5 id="无名管道创建与关闭说明"><a href="#无名管道创建与关闭说明" class="headerlink" title="无名管道创建与关闭说明"></a>无名管道创建与关闭说明</h5><p>无名管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fds[0]和fds[1]，其中fds[0]<br>固定用于读管道，而fd[1]固定用于写管道，如图8.3 所示，这样就构成了一个半双工的通道。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-40-33.png" alt="Snipaste_2019-03-03_01-40-33"></p>
<p>管道关闭时只需将这两个文件描述符关闭即可，可使用普通的close()函数逐个关闭各个文件描述符。</p>
<p><em>注意：</em>当一个管道共享多对文件描述符时，若将其中的一对读写文件描述符都删除，则该<br>管道就失效。</p>
<h5 id="无名管道创建函数pipe"><a href="#无名管道创建函数pipe" class="headerlink" title="无名管道创建函数pipe()"></a>无名管道创建函数pipe()</h5><p>创建管道可以通过调用pipe()来实现，表8.1 列出了pipe()函数的语法要点。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-44-13.png" alt="Snipaste_2019-03-03_01-44-13"></p>
<h5 id="无名管道读写说明"><a href="#无名管道读写说明" class="headerlink" title="无名管道读写说明"></a>无名管道读写说明</h5><p>用pipe()函数创建的管道两端处于一个进程中，由于管道是主要用于在不同进程间通信的，因此这在实际<br>应用中没有太大意义。实际上，通常先是创建一个管道，再通过fork()函数创建一子进程，该子进程会继承<br>父进程所创建的管道，这时，父子进程管道的文件描述符对应关系如图8.4 所示。</p>
<p>此时的关系看似非常复杂，实际上却已经给不同进程之间的读写创造了很好的条件。父子进程分别拥有自己的读写通道，为了实现父子进程之间的读写，只需把无关的读端或写端的文件描述符关闭即可。例如在<br>图8.5 中将父进程的写端fd[1]和子进程的读端fd[0]关闭。此时，父子进程之间就建立起了一条“子进程写“同样，也可以关闭父进程的fd[0]和子进程的fd[1]，这样就可以建立一条“父进程写入子进程读取”的通<br>道。另外，父进程还可以创建多个子进程，各个子进程都继承了相应的fd[0]和fd[1]，这时，只需要关闭<br>相应端口就可以建立其各子进程之间的通道。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_16-13-53.png" alt="Snipaste_2019-03-03_16-13-53"></p>
<p>总结：首先在父进程创建pipe()管道，然后fork()子进程，子进程会继承父进程的pipe()管道，</p>
<p>管道fd[0]为读端,fd[1]为写端。</p>
<p>父进程读入子进程写：将父进程的写端fd[1]和子进程的读端fd[0]关闭即可</p>
<p>父进程写入子进程读：将关闭父进程的读端fd[0]和子进程的写端fd[1]即可</p>
<h5 id="无名管道使用实例"><a href="#无名管道使用实例" class="headerlink" title="无名管道使用实例"></a>无名管道使用实例</h5><p>首先创建管道，之后父进程使用fork()函数创建子进程，之后通过关闭父进程的读描述符和子<br>进程的写描述符，建立起它们之间的父进程写入子进程读管道通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_DATA_LEN 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">char</span> buf[MAX_DATA_LEN];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> data[] = <span class="string">"Pipe Test Program"</span>;</span><br><span class="line">	<span class="keyword">int</span> real_read, real_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span>*)buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建管道 */</span></span><br><span class="line">	<span class="keyword">if</span> (pipe(pipe_fd) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 创建一子进程 */</span></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 子进程关闭写描述符，并通过使子进程暂停3s 等待父进程已关闭相应的读描述符 */</span></span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		sleep(DELAY_TIME * <span class="number">3</span>);</span><br><span class="line">		<span class="comment">/* 子进程读取管道内容 */</span></span><br><span class="line">		<span class="keyword">if</span> ((real_read = read(pipe_fd[<span class="number">0</span>], buf, MAX_DATA_LEN)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d bytes read from the pipe is '%s'\n"</span>, real_read, buf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 关闭子进程读描述符 */</span></span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 父进程关闭读描述符，并通过使父进程暂停1s 等待子进程已关闭相应的写描述符 */</span></span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		sleep(DELAY_TIME);</span><br><span class="line">		<span class="keyword">if</span>((real_write = write(pipe_fd[<span class="number">1</span>], data, <span class="built_in">strlen</span>(data))) != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Parent wrote %d bytes : '%s'\n"</span>, real_write, data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*关闭父进程写描述符*/</span></span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">/*收集子进程退出信息*/</span></span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_16-39-41.png" alt="Snipaste_2019-03-03_16-39-41"></p>
<ul>
<li>只有在管道的读端存在时，向管道写入数据才有意义（故上面父进程延时后1s写，子进程3S后读，从而保证管道有写入数据）。否则，向管道写入数据的进程将收到内核<br>传来的SIGPIPE 信号（通常为Broken pipe 错误）。</li>
<li>向管道写入数据时，Linux 将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读取管道缓冲区中的数据，那么写操作将会一直阻塞。</li>
<li>父子进程在运行时，它们的先后次序并不能保证，因此，在这里为了保证父子进程已经关闭了相<br>应的文件描述符，可在两个进程中调用sleep()函数，当然这种调用不是很好的解决方法，在后面<br>学到进程之间的同步与互斥机制。</li>
</ul>
<h4 id="有名管道-FIFO-编程"><a href="#有名管道-FIFO-编程" class="headerlink" title="有名管道(FIFO)编程"></a>有名管道(FIFO)编程</h4><h5 id="有名管道说明"><a href="#有名管道说明" class="headerlink" title="有名管道说明"></a>有名管道说明</h5><p>无名管道它只能用于具有亲缘关系的进程之间，这就大大地限制了管道的使用。有名管道的出现突破了这种限制，它可以使互不相关的两个进程实现彼此通信。该管道可以通过路径名来指出，<br>并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当作普通文件一样进行读写操作，<br>使用非常方便。</p>
<p>不过值得注意的是，FIFO 是严格地遵循先进先出规则的，对管道及FIFO 的读总是从开始<br>处返回数据，对它们的写则把数据添加到末尾，它们不支持如lseek()等文件定位操作。</p>
<p>有名管道的创建可以使用函数mkfifo()，该函数类似文件中的open()操作，可以指定管道的路径和打开的<br>模式。在创建管道成功之后，就可以使用open()、read()和write()这些函数了。</p>
<p>与普通文件的开发设置一样，对于为读而打开的管道可在open()中设置O_RDONLY，对于为写而打开的管道可在open()中设置O_WRONLY，<br>在这里与普通文件不同的是阻塞问题。由于普通文件的读写时不会出现阻塞问题，而在管道的读写中却有<br>阻塞的可能，这里的非阻塞标志可以在open()函数中设定为O_NONBLOCK。下面分别对阻塞打开和非阻<br>塞打开的读写进行讨论。</p>
<p><strong>对于读进程</strong></p>
<ul>
<li>若该管道是阻塞打开，且当前FIFO 内没有数据，则对读进程而言将一直阻塞到有数据写入。</li>
<li>若该管道是非阻塞打开，则不论FIFO 内是否有数据，读进程都会立即执行读操作。即如果FIFO<br>内没有数据，则读函数将立刻返回0。</li>
</ul>
<p><strong>对于写进程</strong></p>
<ul>
<li>若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。</li>
<li>若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。</li>
</ul>
<h5 id="mkfifo-函数格式"><a href="#mkfifo-函数格式" class="headerlink" title="mkfifo()函数格式"></a>mkfifo()函数格式</h5><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_17-13-26.png" alt="Snipaste_2019-03-03_17-13-26"></p>
<h5 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h5><p>实例包含了两个程序，一个用于读管道，另一个用于写管道。其中在读管道的程序里创建管道，并<br>且作为main()函数里的参数由用户输入要写入的内容。读管道的程序会读出用户写入到管道的内容，这两<br>个程序采用的是阻塞式读写管道模式。</p>
<p>写管道的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_write.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/tmp/myfifo"</span> <span class="comment">/* 有名管道文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF <span class="comment">/*定义在于limits.h 中*/</span></span></span><br><span class="line">i</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> <span class="comment">/*参数为即将写入的字符串*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">int</span> nwrite;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage: ./fifo_write string\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%s"</span>, buff);</span><br><span class="line">	<span class="comment">/* 以只写阻塞方式打开FIFO 管道 */</span></span><br><span class="line">	fd = open(MYFIFO, O_WRONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   	<span class="comment">/*向管道中写入字符串*/</span></span><br><span class="line">	<span class="keyword">if</span> ((nwrite = write(fd, buff, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Write '%s' to FIFO\n"</span>, buff);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读管道程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_read.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/tmp/myfifo"</span> <span class="comment">/* 有名管道文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF <span class="comment">/*定义在于limits.h 中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> nread;</span><br><span class="line">	<span class="comment">/* 判断有名管道是否已存在，若尚未创建，则以相应的权限创建*/</span></span><br><span class="line">	<span class="keyword">if</span> (access(MYFIFO, F_OK) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((mkfifo(MYFIFO, <span class="number">0666</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Cannot create fifo file\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 以只读阻塞方式打开有名管道 */</span></span><br><span class="line">	fd = open(MYFIFO, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, buff, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Read '%s' from FIFO\n"</span>, buff);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-06-52.png" alt="Snipaste_2019-03-03_18-06-52"></p>
<h3 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。信号可以直接进行<strong>用户空间进程和内核进程之间的交互</strong>，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。它可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它为止；如果一个<br>信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</p>
<p>信号值在32 之前的则有不同的名称，而信号值在32 以后的都是用“SIGRTMIN”或<br>“SIGRTMAX”开头的，这就是两类典型的信号。前者是从UNIX 系统中继承下来的信号，为不可靠<br>信号（也称为非实时信号）；后者是为了解决前面“不可靠信号”的问题而进行了更改和扩充的信号，<br>称为“可靠信号”（也称为实时信号）。</p>
<p>一个完整的信号生命周期可以分为3 个重要阶段，这3 个阶段由4 个重要事件来刻画的：信号产生、<br>信号在进程中注册、信号在进程中注销、执行信号处理函数，如图8.6 所示。相邻两个事件的时间<br>间隔构成信号生命周期的一个阶段。要注意这里的信号处理有多种方式，一般是由内核完成的，当<br>然也可以由用户进程来完成，故在此没有明确画出</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-12-38.png" alt="Snipaste_2019-03-03_18-12-38"></p>
<p>一个不可靠信号的处理过程是这样的：如果发现该信号已经在进程中注册，那么就忽略该信号。<br>因此，若前一个信号还未注销又产生了相同的信号就会产生信号丢失。而当可靠信号发送给一个进<br>程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号就不会丢失。所有可靠信<br>号都支持排队，而所有不可靠信号都不支持排队。</p>
<p>信号事件的产生有硬件来源（ 比如按下了键盘或者其他硬件故障）和软件来源，常用的信号相关函数 有 kill()、 raise()、 alarm()、 setitimer() 和 sigqueue() 等， 软件来源还包括一些非法 运算等操作。</p>
<p><strong>用户进程对信号的响应（处理）可以有3 种方式。</strong></p>
<ul>
<li>忽略信号，即对信号不做任何处理，但是有两个信号不能忽略，即SIGKILL 及SIGSTOP。</li>
<li>捕捉信号，定义信号处理函数，当信号发生时，执行相应的自定义处理函数。</li>
<li>执行缺省操作，Linux 对每种信号都规定了默认操作。</li>
</ul>
<p>Linux 中的大多数信号是提供给内核的，表8.6 列出了Linux 中最为常见信号的含义及其默认操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-23-38.png" alt="Snipaste_2019-03-03_18-23-38"></p>
<h4 id="信号发送与捕捉"><a href="#信号发送与捕捉" class="headerlink" title="信号发送与捕捉"></a>信号发送与捕捉</h4><p>发送信号的函数主要有 kill()、raise()、alarm()以及pause()</p>
<h5 id="kill-和raise"><a href="#kill-和raise" class="headerlink" title="kill()和raise()"></a>kill()和raise()</h5><p><strong>函数说明</strong></p>
<p>kill()函数同读者熟知的kill 系统命令一样，可以发送信号给进程或进程组（实际上，kill 系统命令只是kill()<br>函数的一个用户接口）。这里需要注意的是，它不仅可以中止进程（实际上发出SIGKILL 信号），也可以向<br>进程发送其他信号。</p>
<p>与kill()函数所不同的是，raise()函数允许进程向自身发送信号。</p>
<p><strong>kill()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-11-22.png" alt="Snipaste_2019-03-03_19-11-22"></p>
<p><strong>raise()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-13-57.png" alt="Snipaste_2019-03-03_19-13-57"></p>
<h5 id="实例kill-raise-c"><a href="#实例kill-raise-c" class="headerlink" title="实例kill_raise.c"></a>实例kill_raise.c</h5><p>首先使用fork()创建了一个子进程，接着为了保证子进程不在父进程调用kill()之前退出，在<br>子进程中使用raise()函数向自身发送SIGSTOP 信号，使子进程暂停。接下来再在父进程中调用kill()向子<br>进程发送信号，在该示例中使用的是SIGKILL，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kill_raise.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">/* 创建一子进程 */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fork error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 在子进程中使用raise()函数发出SIGSTOP 信号,使子进程暂停 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child(pid : %d) is waiting for any signal\n"</span>, getpid());</span><br><span class="line">		raise(SIGSTOP);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">/* 在父进程中收集子进程发出的信号，并调用kill()函数进行相应的操作 */</span></span><br><span class="line">		<span class="keyword">if</span> ((waitpid(pid, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((ret = kill(pid, SIGKILL)) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Parent kill %d\n"</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-34-36.png" alt="Snipaste_2019-03-03_19-34-36"></p>
<h5 id="alarm-和pause"><a href="#alarm-和pause" class="headerlink" title="alarm()和pause()"></a>alarm()和pause()</h5><p><strong>函数说明</strong></p>
<p>alarm()也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它就向进程发送<br>SIGALARM 信号。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm()之前已设置过闹钟时<br>间，则任何以前的闹钟时间都被新值所代替。</p>
<p>pause()函数是用于将调用进程挂起直至捕捉到信号为止。这个函数很常用，通常可以用于判断信号是否已<br>到。</p>
<p><strong>alarm()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-40-34.png" alt="Snipaste_2019-03-03_19-40-34"></p>
<p><strong>pause()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-40-40.png" alt="Snipaste_2019-03-03_19-40-40"></p>
<h5 id="实例：alarm-pause-c"><a href="#实例：alarm-pause-c" class="headerlink" title="实例：alarm_ pause. c"></a>实例：alarm_ pause. c</h5><p>该实例实际上已完成了一个简单的sleep()函数的功能，由于SIGALARM 默认的系统动作为终止该进程，<br>因此程序在打印信息之前，就会被结束了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alarm_pause.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*调用alarm 定时器函数*/</span></span><br><span class="line">	<span class="keyword">int</span> ret = alarm(<span class="number">5</span>);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I have been waken up：%d.\n"</span>,ret); <span class="comment">/* 此语句不会被执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-50-30.png" alt="Snipaste_2019-03-03_19-50-30"></p>
<p>总结：pause()函数会将进程挂起直至捕捉到信号为止，而aiarm(5)函数会在进程中设置一个定时，5s后它就向进程发送<br>SIGALARM 信号终止进程。因此进程在pause()时会挂机不会打印信息，而5秒后记时到alarm(5)会发送SIGALARM终止进程。</p>
<h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>一个进程可以决定在该进程中需要对哪些信号进行什么样的操作(忽略，捕抓，以及缺省操作)。，另外，一个进程还可以选择如何处理信号(信号的处理)。</p>
<h5 id="函数说明-signal-amp-gaction"><a href="#函数说明-signal-amp-gaction" class="headerlink" title="函数说明(signal&amp;gaction)"></a>函数说明(signal&amp;gaction)</h5><p>使用signal()函数处理时，只需要指出要处理的信号和处理函数即可。它主要是用于前32 种非实时信号的<br>处理，不支持信号传递信息，但是由于使用简单、易于理解，因此也受到很多程序员的欢迎。</p>
<p>Linux 还支持一个更健壮、更新的信号处理函数sigaction()，推荐使用该函数。</p>
<h5 id="函数格式"><a href="#函数格式" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>signal()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-07-56.png" alt="Snipaste_2019-03-03_20-07-56"></p>
<p>这里需要对这个函数原型进行说明。这个函数原型有点复杂。可先用如下的typedef 进行替换说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里需要对这个函数原型进行说明。这个函数原型有点复杂。可先用如下的<span class="keyword">typedef</span> 进行替换说明：</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">sign *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, handler *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>gaction()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-16-54.png" alt="Snipaste_2019-03-03_20-16-54"></p>
<p>sigaction()函数中第2 个和第3 个参数中使用到sigaction 结构。这是一个看似非常复杂的结<br>构，要注意初始化。</p>
<p>sigaction 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span> signo);</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="keyword">int</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restore)(<span class="keyword">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sa_handler ：</strong>是一个函数指针，指定信号处理函数，这里除可以是用户自定义的处理函数外，还可以为<br>SIG_DFL（采用缺省的处理方式）或SIG_IGN（忽略信号）。它的处理函数只有一个参数，即信号值(signum)。</p>
<p><strong>sa_mask:</strong> 是一个信号集，它可以指定在信号处理程序执行过程中哪些信号应当被屏蔽，在调用信号捕获函<br>数之前，该信号集要加入到信号的信号屏蔽字中。</p>
<p><strong>sa_flags:</strong> 中包含了许多标志位，是对信号进行处理的各个选择项。它的常见可选值如表8.13 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-28-23.png" alt="Snipaste_2019-03-03_20-28-23"></p>
<h5 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h5><p>第一个实例表明了如何使用signal()函数捕捉相应信号，并做出给定的处理。这里，my_func 就是信号处理<br>的函数指针。读者还可以将其改为SIG_IGN 或SIG_DFL 查看运行结果。第二个实例是用sigaction()函数<br>实现同样的功能。</p>
<p><strong>signal()函数实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*自定义信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign_no == SIGINT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign_no == SIGQUIT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or 	SIGQUIT...\n"</span>);</span><br><span class="line">	<span class="comment">/* 发出相应的信号，并跳转到信号处理函数处 */</span></span><br><span class="line">	signal(SIGINT, my_func);</span><br><span class="line">	signal(SIGQUIT, my_func);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-34-15.png" alt="Snipaste_2019-03-03_20-34-15"></p>
<p>SIGINT （按ctrl-c 组合键触发）</p>
<p>SIGQUIT （按ctrl-\ 组合键触发）</p>
<p>详细参考上面：表8.6 Linux 常见信号的含义及其默认操作</p>
<p>sigaction()函数实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*自定义信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign_no == SIGINT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign_no == SIGQUIT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or 	SIGQUIT...\n"</span>);</span><br><span class="line">	<span class="comment">/* sigaction 结构初始化 */</span></span><br><span class="line">	action.sa_handler = my_func;</span><br><span class="line">	sigemptyset(&amp;action.sa_mask);</span><br><span class="line">	action.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 发出相应的信号，并跳转到信号处理函数处 */</span></span><br><span class="line">	sigaction(SIGINT, &amp;action, <span class="number">0</span>);</span><br><span class="line">	sigaction(SIGQUIT, &amp;action, <span class="number">0</span>);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果同上</p>
<h4 id="信号集函数组"><a href="#信号集函数组" class="headerlink" title="信号集函数组"></a>信号集函数组</h4><p>略</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量的使用主要是用来保护共享资源,使得资源在一个时刻只有一个进程(线程)所拥有，</p>
<h4 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h4><p>　在多线程或者多进程编程中，有一个非常需要关注的东西，那就是同步以及互斥问题。</p>
<p>　　同步是指多个进程之间的协作，而互斥是指多个进程之间，为了争夺有限的资源，而进行的竞争。</p>
<p>​    进程之间的互斥与同步关系存在的根源在于临界资源。临界资源是在同一个时刻只允许有限个（通常只有<br>一个）进程可以访问（读）或修改（写）的资源，通常包括硬件资源（处理器、内存、存储器以及其他外<br>围设备等）和软件资源（共享代码段，共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本<br>身也会成为临界资源。</p>
<p>​    信号量就是用来解决进程之间的同步与互斥问题的一种进程之间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（PV 操作）。其中信号量对应于某一<br>种资源，取一个非负的整型值。<strong>信号量值指的是当前可用的该资源的数量，若它等于0 则意味着目前没有可</strong><br><strong>用的资源。</strong></p>
<p><strong>PV 原子操作的具体定义如下：</strong></p>
<p>P 操作：如果有可用的资源（信号量值&gt;0），则占用一个资源（给信号量值减去一，进入临界区代码）;如<br>果没有可用的资源（信号量值等于0），则被阻塞到，直到系统将资源分配给该进程（进入等待队列，一直<br>等到资源轮到该进程）。</p>
<p>V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程。如果没有进程等待它，<br>则释放一个资源（给信号量值加一）。</p>
<h4 id="信号量的编程"><a href="#信号量的编程" class="headerlink" title="信号量的编程"></a>信号量的编程</h4><h5 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h5><p>在Linux 系统中，使用信号量通常分为以下几个步骤。</p>
<p>​    （1）创建信号量或获得在系统已存在的信号量，此时需要调用semget()函数。不同进程通过使用同一个信<br>号量键值来获得同一个信号量。</p>
<p>​    （2）初始化信号量，此时使用semctl()函数的SETVAL 操作。当使用二维信号量时，通常将信号量初始化<br>为1。</p>
<p>​    （3）进行信号量的PV 操作，此时调用semop()函数。这一步是实现进程之间的同步和互斥的核心工作部<br>分。</p>
<p>​    （4）如果不需要信号量，则从系统中删除它，此时使用semclt()函数的IPC_RMID 操作。此时需要注意，<br>在程序中不应该出现对已经被删除的信号量的操作</p>
<h5 id="函数格式-1"><a href="#函数格式-1" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>semget()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-20-27.png" alt="Snipaste_2019-03-03_21-20-27"></p>
<p><strong>semctl()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-22-47.png" alt="Snipaste_2019-03-03_21-22-47"></p>
<p><strong>semop()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-23-31.png" alt="Snipaste_2019-03-03_21-23-31"></p>
<h5 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><h4 id="共享内存概述"><a href="#共享内存概述" class="headerlink" title="共享内存概述"></a>共享内存概述</h4><p>​    共享内存是一种最为高效的进程间通信方式。因为进程可以直接读写内存，不需要任何数据<br>的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进<br>程将其映射到自己的私有地址空间。因此，进程就可以直接读写这一内存区而不需要进行数据的复制，<br>从而大大提高了效率。当然，由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁<br>和信号量等（请参考本章的共享内存实验）。其原理示意图如图8.8 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-36-13.png" alt="Snipaste_2019-03-03_21-36-13"></p>
<h4 id="共享内存编程"><a href="#共享内存编程" class="headerlink" title="共享内存编程"></a>共享内存编程</h4><h5 id="编程步骤-1"><a href="#编程步骤-1" class="headerlink" title="编程步骤"></a>编程步骤</h5><p>共享内存的实现分为两个步骤：</p>
<ul>
<li><p>第一步是创建共享内存，这里用到的函数是shmget()，也就是从内存中获<br>得一段共享内存区域，</p>
</li>
<li><p>第二步映射共享内存，也就是把这段创建的共享内存映射到具体的进程空间中，这<br>里使用的函数是shmat()。</p>
<p>到这里，就可以使用这段共享内存了，也就是可以使用不带缓冲的I/O 读写命令<br>对其进行操作。除此之外，当然还有撤销映射的操作，其函数为shmdt()。这里就主要介绍这3 个函数。</p>
</li>
</ul>
<h5 id="函数格式-2"><a href="#函数格式-2" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>shmget()函</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-12.png" alt="Snipaste_2019-03-03_21-40-12"></p>
<p><strong>shmat()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-23.png" alt="Snipaste_2019-03-03_21-40-23"></p>
<p><strong>shmdt()函</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-28.png" alt="Snipaste_2019-03-03_21-40-28"></p>
<h5 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h5><p>该实例说明如何使用基本的共享内存函数。</p>
<p>首先是创建一个共享内存区（采用的共享内存的键值为<br>IPC_PRIVATE，是因为本实例中创建的共享内存是父子进程之间的共用部分），之后创建子进程，在<br>父子两个进程中将共享内存分别映射到各自的进程地址空间之中。<br>父进程先等待用户输入，然后将用户输入的字符串写入到共享内存，之后往共享内存的头部写入<br>“WROTE” 字符串表示父进程已成功写入数据。子进程一直等到共享内存的头部字符串为<br>“WROTE”，然后将共享内存的有效数据（在父进程中用户输入的字符串）在屏幕上打印。父子两<br>个进程在完成以上工作之后，分别解除与共享内存的映射关系。<br>最后在子进程中删除共享内存。因为共享内存自身并不提供同步机制，所以应该额外实现不同进程之间的<br>同步（例如：信号量）。为了简单起见，在本实例中用标志字符串来实现非常简单的父子进程之间的同步。<br>这里要介绍的一个命令是ipcs，这是用于报告进程间通信机制状态的命令。它可以查看共享内存、消息队<br>列等各种进程间通信机制的情况，这里使用了system()函数用于调用shell 命令“ipcs”。</p>
<p>程序源代码如下所<br>示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* shmem.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> shmid;</span><br><span class="line">	<span class="keyword">char</span> *shm_addr;</span><br><span class="line">	<span class="keyword">char</span> flag[] = <span class="string">"WROTE"</span>;</span><br><span class="line">	<span class="keyword">char</span> *buff;</span><br><span class="line">	<span class="comment">/* 创建共享内存 */</span></span><br><span class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, BUFFER_SIZE, <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create shared-memory: %d\n"</span>,shmid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 显示共享内存情况 */</span></span><br><span class="line">	system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">/* 子进程处理 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*映射共享内存*/</span></span><br><span class="line">		<span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Child: shmat"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Child: Attach shared-memory: %p\n"</span>, shm_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">		<span class="comment">/* 通过检查在共享内存的头部是否标志字符串"WROTE"来确认</span></span><br><span class="line"><span class="comment">		父进程已经向共享内存写入有效数据 */</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">strncmp</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Child: Wait for enable data...\n"</span>);</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 获取共享内存的有效数据并显示 */</span></span><br><span class="line">		<span class="built_in">strcpy</span>(buff, shm_addr + <span class="built_in">strlen</span>(flag));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child: Shared-memory :%s\n"</span>, buff);</span><br><span class="line">		<span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">		<span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"shmdt"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Child: Deattach shared-memory\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">		<span class="comment">/* 删除共享内存 */</span></span><br><span class="line">		<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Child: shmctl(IPC_RMID)\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Delete shared-memory\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 父进程处理 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*映射共享内存*/</span></span><br><span class="line">		<span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Parent: shmat"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Parent: Attach shared-memory: %p\n"</span>, shm_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\nInput some string:\n"</span>);</span><br><span class="line">		fgets(buff, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">		<span class="built_in">strncpy</span>(shm_addr + <span class="built_in">strlen</span>(flag), buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">		<span class="built_in">strncpy</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag));</span><br><span class="line">		<span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">		<span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		perror(<span class="string">"Parent: shmdt"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Parent: Deattach shared-memory\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Finished\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这章也不是很懂</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>略吧。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>重点，开单独一章讲</p>
<h1 id="第三章：线程"><a href="#第三章：线程" class="headerlink" title="第三章：线程"></a>第三章：线程</h1><h2 id="Linux-线程概述"><a href="#Linux-线程概述" class="headerlink" title="Linux 线程概述"></a>Linux 线程概述</h2><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><p>​    进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆<br>栈段，这就造成了进程在进行切换等操作时都需要有比较复杂的上下文切换等动作。为了进一步减少处理机<br>的空转时间，支持多处理器以及减少上下文切换开销，进程在演化中出现了另一个概念——线程。</p>
<ul>
<li>线程<br>内独立的一条运行路线，处理器调度的最小单元，也可以称为轻量级进程。</li>
<li>线程可以对进程的内存空间和资<br>源进行访问，并与同一进程中的其他线程共享。因此，线程的上下文切换的开销比创建进程小很多。</li>
<li>同进程一样，线程也将相关的执行状态和存储变量放在线程控制表内。一个进程可以有多个线程，也就是有<br>多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。</li>
</ul>
<p>要注意的是，由于线程共享了进程的资源和地<br>址空间，因此，任何线程对系统资源的操作都会给其他线程带来影响。由此可知，多线程中的同步是非常重要的问题。在多线程系统中，进程与进程的关系如图9.1 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_22-56-29.png" alt="Snipaste_2019-03-03_22-56-29"></p>
<h3 id="线程机制的分类和特性"><a href="#线程机制的分类和特性" class="headerlink" title="线程机制的分类和特性"></a>线程机制的分类和特性</h3><p>线程按照其调度者可以分为用户级线程和核心级线程两种。</p>
<p>（1）用户级线程。<br>用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行<br>时不需要特定的内核支持。在这里，操作系统往往会提供一个用户空间的<strong>线程库</strong>，该线程库提供了线程的<br>创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞<br>的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是<br>在一个进程中的多个线程的调度中无法发挥多处理器的优势。</p>
<p>（2）轻量级进程。<br>轻量级进程是内核支持的用户线程，是内核线程的一种抽象对象。每个线程拥有一个或多个轻量级线程，<br>而每个轻量级线程分别被绑定在一个内核线程上。</p>
<p>（3）内核线程。<br>这种线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优<br>势。</p>
<h2 id="Linux-线程编程"><a href="#Linux-线程编程" class="headerlink" title="Linux 线程编程"></a>Linux 线程编程</h2><p>在Linux 中，使用的read 线程库是一套通用的线<br>程库，是由POSIX 提出的，因此具有很好的可移植性。(线程开发并非内核提供，而是由POSIX 提供的线程库支持的。）</p>
<h3 id="线程函数说明"><a href="#线程函数说明" class="headerlink" title="线程函数说明"></a>线程函数说明</h3><p><strong>1. pthread_create()：创建线程</strong></p>
<p>​    创建线程实际上就是确定调用该线程函数的入口点，这里通常使用的函数是 pthread_create()。在线程创建<br>以后，就开始运行相关的线程函数，在该函数运行完之后，该线程也就退出了，这也是线程退出一种方法。<br>另一种退出线程的方法是使用函数pthread_exit()，这是线程的主动行为。</p>
<p><strong>*注意：</strong>在使用线程函<em>
</em>数时，不能随意使用exit()退出函数进行出错处理，由于exit()的作用是使调用进程终止，往往一个进程包<em>
</em>含多个线程，因此，在使用exit()之后，该进程中的所有线程都终止了。因此，在线程中就可以使用<em>
</em>pthread_exit()来代替进程中的exit()。*</p>
<p><strong>2. pthread_join()可以用于将当前线程挂起来等待线程的结束</strong></p>
<p>​    由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放。正如进程之间可以用wait()系统调用来同步终止并释放资源一样，线<br>程之间也有类似机制，那就是pthread_join()函数。</p>
<p>​    pthread_join()可以用于将当前线程挂起来等待线程的结束。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函<br>数返回时，被等待线程的资源就被收回。</p>
<p><strong>3. 线程调用 pthread_exit()函数主动终止自身线程</strong></p>
<p><strong>4.调用pthread_cancel()函数终止另一个线程</strong></p>
<p>​    线程调用 pthread_exit()函数主动终止自身线程。但是在很多线程应用中，经常会遇到在别的线<br>程中要终止另一个线程的执行的问题。此时调用pthread_cancel()函数实现这种功能，但在被取消的线程的<br>内部需要调用pthread_setcancel()函数和pthread_setcanceltype()函数设置自己的取消状态，例如被取消的线<br>程接收到另一个线程的取消请求之后，是接受还是忽略这个请求；如果接受，是立刻进行终止操作还是等<br>待某个函数的调用等。</p>
<h3 id="函数格式-3"><a href="#函数格式-3" class="headerlink" title="函数格式"></a><strong>函数格式</strong></h3><p><strong>pthread_create()</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-13-26.png" alt="Snipaste_2019-03-03_23-13-26"></p>
<p><strong>pthread_exit()</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-13-53.png" alt="Snipaste_2019-03-03_23-13-53"></p>
<p><strong>pthread_join()</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-14-04.png" alt="Snipaste_2019-03-03_23-14-04"></p>
<p><strong>pthread_cancel</strong>()</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-14-12.png" alt="Snipaste_2019-03-03_23-14-12"></p>
<h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><p>以下实例中创建了 3 个线程，为了更好地描述线程之间的并行执行，让3 个线程重用同一个执行函数。每<br>个线程都有5 次循环（可以看成5 个小任务），每次循环之间会随机等待1～10s 的时间，意义在于模拟每<br>个任务的到达时间是随机的，并没有任何特定规律。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER 3 <span class="comment">/*线程数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER 5 <span class="comment">/*每个线程中的小任务数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS 10.0 <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 线程函数例程 */</span></span><br><span class="line">	<span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line">	<span class="keyword">int</span> delay_time = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">		sleep(delay_time);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>,</span><br><span class="line">		thrd_num, count, delay_time);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line">	<span class="keyword">void</span> * thrd_ret;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 创建多线程 */</span></span><br><span class="line">		res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line">			<span class="built_in">exit</span>(res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 等待线程结束 */</span></span><br><span class="line">		res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">		<span class="keyword">if</span> (!res)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;//随机1~10 的一个数给delay_time</span></span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-01-24.png" alt="Snipaste_2019-03-04_00-01-24"></p>
<h2 id="线程之间的同步与互斥"><a href="#线程之间的同步与互斥" class="headerlink" title="线程之间的同步与互斥"></a>线程之间的同步与互斥</h2><p>​    由于线程共享进程的资源和地址空间，因此在对这些资源进行操作时，必须考虑到线程间资源访问的同步<br>与互斥问题。这里主要介绍 POSIX 中两种线程同步机制，分别为互斥锁和信号量。这两个同步机制可以互<br>相通过调用对方来实现，<strong>但互斥锁更适合用于同时可用的资源是惟一的情况；信号量更适合用于同时可用</strong><br><strong>的资源为多个的情况。</strong></p>
<h3 id="互斥锁线程控制"><a href="#互斥锁线程控制" class="headerlink" title="互斥锁线程控制"></a>互斥锁线程控制</h3><p>函数说明</p>
<p>​    互斥锁是用一种简单的加锁方法来控制对共享资源的原子操作。这个互斥锁只有两种状态，也就是上锁和<br>解锁，可以把互斥锁看作某种意义上的全局变量。</p>
<p>​    在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作。若其他线程希望<strong>上锁一个已经被上锁的互斥锁</strong>，则该线程就会挂起，<br>直到上锁的线程释放掉互斥锁为止。可以说，这把互斥锁保证让每个线程对共享资源按顺序进行原子操作</p>
<p>互斥锁机制主要包括下面的基本函数。</p>
<ul>
<li>互斥锁初始化：pthread_mutex_init()</li>
<li>互斥锁上锁：pthread_mutex_lock()</li>
<li>互斥锁判断上锁：pthread_mutex_trylock()</li>
<li>互斥锁解锁：pthread_mutex_unlock()</li>
<li>消除互斥锁：pthread_mutex_destroy()</li>
</ul>
<p>互斥锁可以分为快速互斥锁、递归互斥锁和检错互斥锁。</p>
<p>这3 种锁的区别主要在于其他未占有互斥<br>锁的线程在希望得到互斥锁时是否需要阻塞等待。</p>
<ul>
<li>快速锁是指调用线程会阻塞直至拥有互斥锁的线程解锁<br>为止。</li>
<li>递归互斥锁能够成功地返回，并且增加调用线程在互斥上加锁的次数，</li>
<li>而检错互斥锁则为快速互斥<br>锁的非阻塞版本，它会立即返回并返回一个错误信息。默认属性为快速互斥锁。</li>
</ul>
<p><strong>函数格式</strong></p>
<p><strong>pthread_mutex_init()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-33-34.png" alt="Snipaste_2019-03-04_00-33-34"></p>
<p><strong>pthread_mutex_lock()等函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-33-41.png" alt="Snipaste_2019-03-04_00-33-41"></p>
<h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>下面的实例是在 上面示例代码的基础上增加互斥锁功能，实现原本独立与无序的多个线程能够按顺<br>序执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*thread_mutex.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER 3 <span class="comment">/* 线程数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER 3 <span class="comment">/* 每个线程的小任务数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS 10.0 <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line">	<span class="keyword">int</span> delay_time = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="comment">/* 互斥锁上锁 */</span></span><br><span class="line">	res = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Thread %d lock failed\n"</span>, thrd_num);</span><br><span class="line">		pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">		sleep(delay_time);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>,</span><br><span class="line">		thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">		pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line">	<span class="keyword">void</span> * thrd_ret;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">/* 互斥锁初始化 */</span>	</span><br><span class="line">	pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)	</span><br><span class="line">	&#123;	</span><br><span class="line">		res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line">			<span class="built_in">exit</span>(res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">		<span class="keyword">if</span> (!res)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 互斥锁解锁 */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	&#125;	</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>失败：后面线程没信息，原因不明，</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_01-09-37.png" alt="Snipaste_2019-03-04_01-09-37"></p>
<p>正确结果应该：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span>: job <span class="number">0</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">1</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">2</span> delay = <span class="number">6</span></span><br><span class="line">Thread <span class="number">0</span> finished</span><br><span class="line">Thread <span class="number">0</span> joined</span><br><span class="line">Thread <span class="number">1</span> is starting</span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">0</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">1</span> delay = <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">2</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">1</span> finished</span><br><span class="line">Thread <span class="number">1</span> joined</span><br><span class="line">Thread <span class="number">2</span> is starting</span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">0</span> delay = <span class="number">6</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">1</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">2</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">2</span> finished</span><br><span class="line">Thread <span class="number">2</span> joined</span><br></pre></td></tr></table></figure>
<h3 id="信号量线程控制"><a href="#信号量线程控制" class="headerlink" title="信号量线程控制"></a>信号量线程控制</h3><h4 id="信号量说"><a href="#信号量说" class="headerlink" title="信号量说"></a>信号量说</h4><p>​    信号量也就是操作系统中所用到的PV 原子操作，它广泛用于进程或线程间的同步与互斥。信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。这里先来简单复习一<br>下PV 原子操作的工作原理。<br>PV 原子操作是对整数计数器信号量sem 的操作。一次P 操作使sem 减一，而一次V 操作使sem 加一。<br>进程（或线程）根据信号量的值来判断是否对公共资源具有访问权限。当信号量sem 的值大于等于零<br>时，该进程（或线程）具有公共资源的访问权限；相反，当信号量sem 的值小于零时，该进程（或线<br>程）就将阻塞直到信号量sem 的值大于等于0 为止。<br>PV 原子操作主要用于进程或线程间的同步和互斥这两种典型情况。若用于互斥，几个进程（或线程）往<br>往只设置一个信号量sem，它们的操作流程如图9.2 所示。<br>当信号量用于同步操作时，往往会设置多个信号量，并安排不同的初始值来实现它们之间的顺序执行，它<br>们的操作流程如图9.3 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_01-14-08.png" alt="Snipaste_2019-03-04_01-14-08"></p>
<p>略</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/unix下输入与输出-I-0.html" itemprop="url">
                  unix下输入与输出(I/0)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 11:31:17" itemprop="dateCreated datePublished" datetime="2019-02-28T11:31:17+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-01 18:58:47" itemprop="dateModified" datetime="2019-03-01T18:58:47+08:00">2019-03-01</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本章节主要讲解Linux下如何对文件操作，包括两部分：</p>
<p>文件I/O和标准I/O</p>
<p>他们有什么区别，该部分将使用一个专门都一下节去讲解。</p>
<h1 id="第一节：文件I-O和标准I-O的比较"><a href="#第一节：文件I-O和标准I-O的比较" class="headerlink" title="第一节：文件I/O和标准I/O的比较"></a>第一节：文件I/O和标准I/O的比较</h1><p>来源说明</p>
<p>作者：zqixiao_09 </p>
<p>原文地址：<a href="https://blog.csdn.net/zqixiao_09/article/details/50444465" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50444465</a> </p>
<h2 id="什么是文件I-O和标准I-O"><a href="#什么是文件I-O和标准I-O" class="headerlink" title="什么是文件I/O和标准I/O"></a>什么是文件I/O和标准I/O</h2><p>文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。</p>
<p>标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。</p>
<ul>
<li>全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 </li>
<li>行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 </li>
<li>不带缓存：stderr就是了。</li>
</ul>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><ul>
<li><p>文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。</p>
</li>
<li><p>通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。</p>
</li>
<li><p>文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。</p>
<p><em>注：Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。</em></p>
</li>
</ul>
<h2 id="文件I-O和标准I-O使用的函数比较"><a href="#文件I-O和标准I-O使用的函数比较" class="headerlink" title="文件I/O和标准I/O使用的函数比较"></a>文件I/O和标准I/O使用的函数比较</h2><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_11-57-29.png" alt="Snipaste_2019-02-28_11-57-29"></p>
<h3 id="fopen与open比较"><a href="#fopen与open比较" class="headerlink" title="fopen与open比较"></a>fopen与open比较</h3><p><strong>标准I/O使用fopen函数打开一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span> *mod)</span><br></pre></td></tr></table></figure>
<ul>
<li>path：文件名。</li>
<li>mod：用于指定文件打开的模式的字符串，比如”r”,”w”,”w+”,”a”等等，可以加上字母b用以指定以二进制模式打开。</li>
<li>返回值：如果成功打开，返回一个FILE文件指针，如果失败返回NULL。（这里的文件指针并不是指向实际的文 件，而是一个关于文件信息的数据包，其中包括文件使用的缓冲区信息。）</li>
</ul>
<p><strong>文件IO使用open函数用于打开一个文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd=open(<span class="keyword">char</span> *name,<span class="keyword">int</span> how);</span><br></pre></td></tr></table></figure>
<ul>
<li>name：文件名字符串</li>
<li>how指定打开的模式：O_RDONLY(只读),O_WRONLY(只写）,O_RDWR （可读可写)。（其他模式请man 2 open）。</li>
<li>返回值：成功返回一个正整数称为文件描述符，这与标准I/O显著不同，失败的话返回-1，与标准I/O返回NULL也是不同的。</li>
</ul>
<h3 id="fclose与close比较"><a href="#fclose与close比较" class="headerlink" title="fclose与close比较"></a>fclose与close比较</h3><p>标准I/O使用fclose关闭文件，将文件指针传入即可，如果成功关闭，返回0，否则返回EOF</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fclose(fp)!=<span class="number">0</span>)  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error in closing file"</span>);</span><br></pre></td></tr></table></figure>
<p>文件IO使用close用于关闭open打开的文件，与fclose类似，只不过当错误发生时返回的是-1，而不是EOF，成功关闭同样是返回0。</p>
<h3 id="读文件比较：getc-fscanf-fgets和read"><a href="#读文件比较：getc-fscanf-fgets和read" class="headerlink" title="读文件比较：getc,fscanf,fgets和read"></a>读文件比较：getc,fscanf,fgets和read</h3><p><strong>标 准I/O中进行文件读取</strong></p>
<ul>
<li>可以使用 <strong>getc</strong>，一个字符一个字符的读取，也可以使用gets（读取标准io读入的）</li>
<li>fgets以字符串单位进行读取（读到遇 到的第一个换行字符的后面）</li>
</ul>
<p>gets（接受一个参数，文件指针）不判断目标数组是否能够容纳读入的字符，可能导致存储溢出(不建议使用），而fgets使用三个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数和gets一样，用于存储输入的地址，第二个参数为整数，表示输入字符串的最大长度，最后一个参数就是文件指针，指向要读取的文件。</p>
<ul>
<li>最 后是fscanf，与scanf类似，只不过增加了一个参数用于指定操作的文件，比如fscanf(fp,”%s”,words)</li>
</ul>
<p><strong>文件I/O中进行文件读取</strong></p>
<p>文件IO中使用read函数用于读取open函数打开的文件，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> numread=read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> qty);</span><br></pre></td></tr></table></figure>
<p>其中fd就是open返回的文件描述符，buf用于存储数据的目的缓冲区，而qty指定要读取的字节数。如果成功读取，就返回读取的字节数目（小于等于qty）</p>
<h3 id="判断文件结尾比较"><a href="#判断文件结尾比较" class="headerlink" title="判断文件结尾比较"></a>判断文件结尾比较</h3><p>如果尝试读取达到文件结尾，标准IO的getc会返回特殊值EOF，而fgets碰到EOF会返回NULL,而对于unix的read函数，情况有所不 同。read读取qty指定的字节数，最终读取的数据可能没有你所要求的那么多（qty），而当读到结尾再要读的话，read函数将返回0.</p>
<h3 id="写文件比较：putc-fputs-fprintf和write"><a href="#写文件比较：putc-fputs-fprintf和write" class="headerlink" title="写文件比较：putc,fputs,fprintf和write"></a>写文件比较：putc,fputs,fprintf和write</h3><p><strong>标准I/O中进行文件写入</strong></p>
<p>使用putc写入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putc(ch,fp);</span><br><span class="line"><span class="comment">//第一个参数是字符，第二个是文件指针。</span></span><br></pre></td></tr></table></figure>
<p>使用fputs写入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(buf,fp);</span><br><span class="line"><span class="comment">//仅仅是第一个参数换成了字符串地址。</span></span><br></pre></td></tr></table></figure>
<p>使用fprintf写入字符</p>
<p>fprintf与printf类似，增加了一个参数用于指定写入的文件，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello %s.\n"</span>,<span class="string">"dennis"</span>);</span><br></pre></td></tr></table></figure>
<p>切记fscanf和fprintf将FILE指针作为第一个参数，而putc,fputs则是作为第二个参数。</p>
<p><strong>文件I/O中进行文件写入</strong></p>
<p>在文件IO中提供write函数用于写入文件，原型与read类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result=write(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf ,<span class="keyword">size_t</span> amt);</span><br></pre></td></tr></table></figure>
<p>fd：文件描述符</p>
<p>buf：是将要写入的内存数据</p>
<p>amt：是要写的字节数。</p>
<p>返回值：如果写入成功返回写入的字节数，通过result与amt的比较可以判断是否写入正常，如果写入失败返回-1</p>
<h3 id="随机存取比较：fseek-、ftell-和lseek"><a href="#随机存取比较：fseek-、ftell-和lseek" class="headerlink" title="随机存取比较：fseek()、ftell()和lseek()"></a>随机存取比较：fseek()、ftell()和lseek()</h3><p><strong>标准I/O中进行随机存取</strong></p>
<p>标准I/O使用fseek和ftell用于文件的随机存取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fseek函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数：是文件指针</p>
<p>第二个参数：是一个long类型的偏移量（offset），表示从起始点开始移动的距离。</p>
<p>第三个参数：是用于指定起始点的模式，stdio.h指定了下列模式常量：SEEK_SET ：文件开始处， SEEK_CUR ：当前位置<br>，    SEEK_END： 文件结尾处</p>
<p>看几个调用例子： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_SET); <span class="comment">//找到文件的开始处 </span></span><br><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END); <span class="comment">//定位到文件结尾处 </span></span><br><span class="line">fseek(fp,<span class="number">2L</span>,SEEK_CUR); <span class="comment">//文件当前位置向前移动2个字节数</span></span><br></pre></td></tr></table></figure>
<p>而ftell函数用于返回文件的当前位置，返回类型是一个long类型，比如下面的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END);<span class="comment">//定位到结尾 </span></span><br><span class="line"><span class="keyword">long</span> last=ftell(fp); <span class="comment">//返回当前位置</span></span><br></pre></td></tr></table></figure>
<p>那么此时的last就是文件指针fp指向的文件的字节数。</p>
<p><strong>文件I/O中进行随机存取</strong></p>
<p>与标准I/O类似，unix系统提供了lseek来完成fseek的功能，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型如下：</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p>fildes:是文件描述符</p>
<p>offset:也是偏移量</p>
<p>whence:同样是指定起始点模式</p>
<p>唯一的不同是lseek有返回值，如果成功就 返回指针变化前的位置，否则返回-1。whence的取值与fseek相同：SEEK_SET,SEEK_CUR,SEEK_END，但也可以用整数 0,1,2相应代替。</p>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>上面我们一直在讨论文件I/O与标准I/O的区别，其实可以这样说，文件I/O是系统调用、标准I/O是库函数，看下面这张图：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_12-42-29.png" alt="Snipaste_2019-02-28_12-42-29"></p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>操作系统负责管理和分配所有的计算机资源。为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用。通过这组接口用户程序可以使用操作系统内核提供的各种功能。例如分配内存、创建进程、实现进程之间的通信等。</p>
<p>   为什么不允许程序直接访问计算机资源？答案是不安全。单片机开发中，由于不需要操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，程序访问资源的方式都发生了改变。操作系统基本上都支持多任务，即同时可以运行多个程序。如果允许程序直接访问系统资源，肯定会带来很多问题。因此，所有软硬件资源的管理和分配都有操作系统负责。程序要获取资源（如分配内存，读写串口）必须由操作系统来完成，即用户程序向操作系统发出服务请求，操作系统收到请求后执行相关的代码来处理。</p>
<p>   用户程序向操作系统提出请求的接口就是系统调用。所有的操作系统都会提供系统调用接口，只不过不同的操作系统提供的系统调用接口各不相同。Linux 系统调用接口非常精简，它继承了Unix 系统调用中最基本的和最有用的部分。这些系统调用按照功能大致可分为<strong>进程控制、进程间通信、文件系统控制、存储管理、网络管理、套接字控制、用户管理等几类。</strong></p>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>库函数可以说是对系统调用的一种封装，因为系统调用是面对的是操作系统，系统包括Linux、Windows等，如果直接系统调用，会影响程序的移植性，所以这里使用了库函数，比如说C库，这样只要系统中安装了C库，就都可以使用这些函数，比如printf()  scanf()等，C库相当于对系统函数进行了翻译，使我们的APP可以调用这些函数；</p>
<h4 id="用户编程接口API"><a href="#用户编程接口API" class="headerlink" title="用户编程接口API"></a>用户编程接口API</h4><p> 前面提到利用系统调用接口程序可以访问各种资源，但在实际开发中程序并不直接使用系统调用接口，而是使用用户编程接口（API）。为什么不直接使用系统调用接口呢？</p>
<p>原因如下：</p>
<p>1）系统调用接口功能非常简单，无法满足程序的需求。</p>
<p>2）不同操作系统的系统调用接口不兼容，程序移植时工作量大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户编程接口通俗的解释就是各种库（最重要的就是C库）中的函数。为了提高开发效率，C库中实现了很多函数。这些函数实现了常用的功能，供程序员调用。这样一来，程序员不需要自己编写这些代码，直接调用库函数就可以实现基本功能，提高了代码的复用率。使用用户编程接口还有一个好处：程序具有良好的可移植性。几乎所有的操作系统上都实现了C库，所以程序通常只需要重新编译一下就可以在其他操作系统下运行。</span><br><span class="line"></span><br><span class="line">用户编程接口（API）在实现时，通常都要依赖系统调用接口。例如，创建进程的API函数fork()对应于内核空间的sys_fork()系统调用。很多API函数西亚我哦通过多个系统调用来完成其功能。还有一些API函数不要调用任何系统调用。</span><br><span class="line"></span><br><span class="line"> 在Linux 中用户编程接口（API）遵循了在Unix中最流行的应用编程界面标准——POSIX标准。POSIX标准是由IEEE和ISO/IEC共同开发的标准系统。该标准基于当时想用的Unix 实践和经验，描述了操作系统的系统调用编程接口（实际上就是API），用于保证应用程序可以在源代码一级商多种操作系统上运行。这些系统调用编程接口主要是通过C库（libc )实现的。</span><br></pre></td></tr></table></figure>
<h2 id="一句话理解文件I-O和标准I-O"><a href="#一句话理解文件I-O和标准I-O" class="headerlink" title="一句话理解文件I/O和标准I/O"></a>一句话理解文件I/O和标准I/O</h2><ul>
<li>文件I/O更接近于底层硬件的I/O。其使用是通过是系统调用实现的。</li>
<li>标准I/O可以说是对文件I/O的一种封装，是基于库函数。</li>
<li>文件I/O多针对于操作系统而标准I/O多针对于应用程序</li>
</ul>
<h1 id="第二节：文件I-O"><a href="#第二节：文件I-O" class="headerlink" title="第二节：文件I/O"></a>第二节：文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX 系统文件 I/ O 函数的操作有—— 打开 文件、 读 文件、 写 文件 等。 UNIX 系统 中的 大多数 文件 I/ O 只需 用到 5 个 函数： open、 read、 write、 lseek 以及 close。</p>
<p>本章 描述 的 函数 经常 被称为 不带 缓冲 的 I/ O，术语 不带 缓冲 指的 是 每个 read 和 write 都 调用 内核 中的 一个 系统 调用。</p>
<p>只要 涉及 在 多个 进程 间 共享 资源， 原子 操作 的 概念 就 变得 非常 重要。 我们将 通过 文件 I/ O 和 open 函数 的 参数 来 讨论 此 概念。</p>
<p>本章 还将 进一步 讨论 在 多个 进程 间 如何 共享 文件， 以及 所 涉及 的 内核 有关 数据 结构。 在 描述 了 这些 特征 后， 将 说明 dup、 fcntl、 sync、 fsync 和 ioctl 函数。</p>
<h2 id="文件-描述-符"><a href="#文件-描述-符" class="headerlink" title="文件 描述 符"></a>文件 描述 符</h2><p>对于 内核 而言， 所有 打开 的 文件 都 通过 文件 描述 符 引用。 文件 描述 符 是 一个 非 负 整数。 当 打开 一个 现有 文件 或 创建 一个 新 文件 时， 内核 向 进程 返回 一个 文件 描述 符。当 读、 写 一个 文件 时， 使用 open 或 creat 返回 的 文件 描述 符 标识 该 文件， 将其 作为 参数 传送 给 read 或 write。</p>
<p>按照 惯例， UNIX 系统 shell 把 文件 描述 符 0 与 进程 的 标准 输入 关联， 文件 描述 符 1 与 标准 输出 关联， 文件 描述 符 2 与 标准 错误 关联。</p>
<p>文件 描述 符 的 变化 范围是 0 ～ OPEN_ MAX- 1（ 见图 2- 11）。 早期 的 UNIX 系统 实现 采用 的 上 限值 是 19（ 允许 每个 进程 最多 打开 20 个 文件）， 但 现在 很多 系统 将其 上限 值 增加 至 63。</p>
<h2 id="文件的打开和关闭及-创建"><a href="#文件的打开和关闭及-创建" class="headerlink" title="文件的打开和关闭及 创建"></a>文件的打开和关闭及 创建</h2><h3 id="函数-open"><a href="#函数-open" class="headerlink" title="函数 open"></a>函数 open</h3><p>调用 open 或 openat 函数 可以 打开 或 创建 一个 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>pathname ：</strong>是待打开/创建文件的路径名（如 C:/cpp/a.cpp）。</p>
<p><strong>oflag ：</strong>用于指定文件的打开/创建模式。</p>
<p>这个参数可由以下常量（定义于 fcntl.h）通过逻辑或构成。打开/创建文件时，至少得使用下述三个常量中的一个。</p>
<ul>
<li>O_RDONLY　　只读模式</li>
<li>O_WRONLY　　只写模式</li>
<li>O_RDWR　　读写模式</li>
</ul>
<p>以下常量是选用的：</p>
<ul>
<li>O_APPEND　　每次写操作都写入文件的末尾</li>
<li>O_CREAT　　如果指定文件不存在，则创建这个文件</li>
<li>O_EXCL　　如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li>
<li>O_TRUNC　　如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li>
<li>O_NOCTTY　　如果路径名指向终端设备，不要把这个设备用作控制终端。</li>
<li>O_NONBLOCK　　如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）</li>
</ul>
<p>以下三个常量同样是选用的，它们用于同步输入输出</p>
<ul>
<li>O_DSYNC　　等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。</li>
<li>O_RSYNC　　read 等待所有写入同一区域的写操作完成后再进行</li>
<li>O_SYNC　　等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li>
</ul>
<p><strong>第三个参数（…）</strong>仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。</p>
<p><strong>返回值：</strong>成功则返回文件描述符，否则返回 -1，open 返回的文件描述符一定是最小的未被使用的描述符。</p>
<p>函数 creat</p>
<p>也可 调用 creat 函数 创建 一个 新 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; fcntl. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *path, mode_ t mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 值： 若 成功， 返回 为 只 写 打开 的 文件 描述 符； 若 出错， 返回 − 1 注意，</p>
<p> 此 函数 等效 于： open( path, O_ WRONLY ｜ O_ CREAT ｜ O_ TRUNC, mode)。 因此现在很少有使用creat()函数来创建新文件;</p>
<h3 id="函数-close"><a href="#函数-close" class="headerlink" title="函数 close"></a>函数 close</h3><p>调用 close 函数可以关闭 一个已打开的文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line">int close (int fd)；</span><br></pre></td></tr></table></figure>
<p> 返回 值： 若 成功， 返回 0； 若 出错， 返回 − 1 </p>
<p>关闭 一个 文件 时 还会 释放 该 进程 加在 该 文件 上 的 所有 记录 锁。 </p>
<p> 当 一个 进程 终止 时， 内核 自动 关闭 它 所有 的 打开 文件。 很多 程序 都 利用 了 这一 功能 而 不显 式 地 用 close 关闭 打开 文件。 </p>
<h3 id="实例：文件的打开与关闭"><a href="#实例：文件的打开与关闭" class="headerlink" title="实例：文件的打开与关闭"></a>实例：文件的打开与关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd；</span><br><span class="line">   <span class="keyword">if</span>((fd=open(“test.txt”,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>)&lt;<span class="number">0</span>);</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fail tpo open"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      	close(fd);</span><br><span class="line"> 	 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h3 id="函数-read"><a href="#函数-read" class="headerlink" title="函数 read"></a>函数 read</h3><p>调用 read 函数 从 打开 文件 中 读 数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回读到的字节数，若已到文件末尾则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:读取数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要读取的字节数</span></span><br></pre></td></tr></table></figure>
<p> 　　有几种情况可使实际读到的字节数少于要求读的字节数：</p>
<p>　　1）读普通文件时，在读到要求字节数之前就已经达到了文件末端。例如，若在到达文件末端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0（文件末端）。</p>
<p>　　2）当从终端设备读时，通常一次最多读一行。</p>
<p>　　3）当从网络读时，网络中的缓存机构可能造成返回值小于所要求读的字结束。</p>
<p>　　4）当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</p>
<p>　　5）当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。</p>
<p>　　6）当某一个信号造成中断，而已经读取了部分数据。</p>
<h3 id="函数-write"><a href="#函数-write" class="headerlink" title="函数 write"></a>函数 write</h3><p>write函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nb　write函数定义如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure>
<h3 id="实例：使用-read-和-write-函数-复制-一个-文件。"><a href="#实例：使用-read-和-write-函数-复制-一个-文件。" class="headerlink" title="实例：使用 read 和 write 函数 复制 一个 文件。"></a>实例：使用 read 和 write 函数 复制 一个 文件。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: copy_file.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd,to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断入参</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s fromfile tofile !\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">if</span>( (from_fd = open(argv[<span class="number">1</span>],O_RDONLY | O_CREAT ))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s Error!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建目的文件</span></span><br><span class="line">    <span class="keyword">if</span>( (to_fd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT))==<span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s error! \n"</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//测得文件大小</span></span><br><span class="line">    file_len=lseek(from_fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(from_fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from file size is %d!\n"</span>,file_len);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//进行文件拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(from_fd, buffer, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(to_fd, buffer, ret );</span><br><span class="line">        file_len = ret;</span><br><span class="line">        bzero( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"there are %d buyes data left without copy!\n"</span>,file_len);</span><br><span class="line">    close(from_fd);</span><br><span class="line">    close(to_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lseek文件定位"><a href="#lseek文件定位" class="headerlink" title="lseek文件定位"></a>lseek文件定位</h2><p>lseek函数对文件当位置进行定位。它只能对可定位（可随机 访问）文件操作。管道，套接字和大部分字符设备文件不支持该类操作。</p>
<p> 函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>
<p> <strong>函数功能：</strong> lseek系统调用用来移动读写指针的位置</p>
<p><strong>参数说明：</strong></p>
<p>fd:要操作的文件</p>
<p>  offset：相对whence移动的位移数，允许负值</p>
<p>  whence：起始指针，它有三个取值</p>
<ul>
<li><p>SEEK_SET 从文件开始处计算偏移量</p>
</li>
<li><p>​         SEEK_CUR 从文件指针的当前位置开始计算偏移</p>
</li>
<li><p>SEEK_END 从文件结尾处开始计算偏移量</p>
<p>文件指针值等于当前指针值加上offset的值。     </p>
</li>
</ul>
<p><strong>返回值：</strong>调用成功时范围当前的读写位置，也就是距离文件开始处多少字节，若 有错误返回-1</p>
<p><strong>常见用法：</strong></p>
<ul>
<li>将文件读写指针移动到文件开头：lseek(int fildes, 0, SEEK_SET);</li>
<li>将文件读写指针移动到文件结尾：lseek(int fildes, 0, SEEK_END);</li>
<li>获取文件读写指针当前的位置：lseek(int fikdes, 0, SEEK_CUR);</li>
</ul>
<p><strong>实例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>  readfd, writefd;  </span><br><span class="line">    <span class="keyword">long</span> filelen=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span>  ret=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];  </span><br><span class="line">    <span class="keyword">char</span> *ptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*打开源文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((readfd=open(<span class="string">"test.txt"</span>, O_RDONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">      <span class="comment">/*创建目的文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((writefd=open(<span class="string">"dest.txt"</span>, O_WRONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*测得文件大小*/</span>  </span><br><span class="line">    filelen= lseek(readfd,<span class="number">0L</span>,SEEK_END);  </span><br><span class="line">    lseek(readfd,<span class="number">0L</span>,SEEK_SET);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read file size is %d\n"</span>,filelen);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进行文件拷贝*/</span>  </span><br><span class="line">    <span class="keyword">while</span>(ret)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret= read(readfd, buffer, BUFFER_SIZE);  </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read Error\n"</span>);   </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);          </span><br><span class="line">        &#125;  </span><br><span class="line">        write(writefd, buffer, ret);  </span><br><span class="line">        filelen-=ret;  </span><br><span class="line">        bzero(buffer,BUFFER_SIZE);  </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    close(readfd);   </span><br><span class="line">    close(writefd);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考实例：</strong></p>
<p><a href="https://www.cnblogs.com/mickole/p/3182033.html" target="_blank" rel="noopener">利用lseek()创建空洞文件</a></p>
<p><a href="https://www.cnblogs.com/zxysmalleyes/p/5321207.html" target="_blank" rel="noopener">用lseek拼接两个文件</a></p>
<h1 id="第三节：内核数据结构分析"><a href="#第三节：内核数据结构分析" class="headerlink" title="第三节：内核数据结构分析"></a>第三节：内核数据结构分析</h1><p>UNIX 系统 支持 在 不同 进程 间 共享 打开 文件。进程间的这种 共享是如何进行的，为此 先 介绍 内核 用于 所有 I/ O 的 数据 结构。 </p>
<p>内核 使用 3 种数 据 结构 表示 打开 文件， 它们 之间 的 关系 决定了 在 文件 共享 方面 一个 进程 对 另一个 进程 可能 产生 的 影响。 </p>
<p>（1）每个 进程 在 进程表 中 都有 一个 记录 项（文件表项）， 记录 项 中 包含 一张 打开 文件 描述 符 表， 可将 其 视为 一个 矢量， 每个 描述 符 占用 一项。 与 每个 文件 描述 符 相 关联 的 是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a． 文件 描述 符 标志（ close_ on_ exec， 参见 图 3- 7 和 3. 14 节）；</span><br><span class="line"></span><br><span class="line">b． 指向 一个 文件 表项 的 指针。</span><br></pre></td></tr></table></figure>
<p>（2） 内核 为所 有打 开 文件 维持 一张 文件 表。 每个 文件 表项 包含：</p>
<p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等， 关于 这些 标志 的 更多 信息 参见 3. 14 节）；</p>
<p> b． 当前 文件 偏移量； </p>
<p>c． 指向 该 文件 v 节点 表项 的 指针。</p>
<p> （3） 每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。 v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。 对于 大多数 文件， v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。 这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。 例如， i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等（ 4. 14 节 较 详细 地说 明了 典型 UNIX 系统 文件 系统， 并将 更多 地 介绍 i 节点）。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-34-56.png" alt="Snipaste_2019-02-28_16-34-56"></p>
<p>个人梳理：</p>
<ul>
<li><p>1.每个进程都会有一个进程表项，进程表项中包含一个文件描述符表，每个描述符占有一项，每个描述符对应一个指针。该指针指向文件表项。</p>
</li>
<li><p>2.内核会为所有的打开的文件创建 一张 文件表项。 每个文件表项包含：     </p>
<p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等）。</p>
<p>b． 当前 文件 偏移量；</p>
<p> c． 指向 该 文件 v 节点 表项 的 指针。</p>
</li>
<li><p>3.每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。</p>
<p>v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。</p>
<p>v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。</p>
<p> i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等。</p>
</li>
</ul>
<p>注：这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。</p>
<p>注意， 文件 描述 符 标志 和 文件 状态 标志 在作 用 范围 方面 的 区别， 前者 只用于 一个 进程 的 一个 描述 符， 而后 者 则应 用于 指向 该给 定 文件 表项 的 任何 进程 中的 所有 描述 符。</p>
<p><strong>两个 独立 进程 各自 打开 了 同一 文件</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-49-15.png" alt="Snipaste_2019-02-28_16-49-15"></p>
<p>第一个 进程 在 文件 描述 符 3 上 打开 该 文件， 而 另一个 进程 在 文件 描述 符 4 上 打开 该 文件。 打开 该 文件 的 两个 进程 都 获得 各自 的 一个 文件 表项， 但是对于一个 给定 的 文件只有 一个 v 节点表项。（为什么会创建有两个表项，而不指向欧安同意文件表项） 之所以 每个 进程 都 获得 自己的 文件 表项， 是因为 这可 以使 每个 进程 都有 它自己 的 对 该 文件 的 当前 偏移量。</p>
<h2 id="文件操作的进一步说明"><a href="#文件操作的进一步说明" class="headerlink" title="文件操作的进一步说明"></a>文件操作的进一步说明</h2><p>给出 了 这些 数据 结构 后， 现在 对 前面 所述 的 操作 进一步 说明。</p>
<ul>
<li>write：在 完成 每个 write 后， 在 文件 表项 中的 当前 文件 偏移量 即 增加 所 写入 的 字节数。 如果 这 导致 当前 文件 偏移量 超出 了 当前 文件 长度， 则 将 i 节点 表项 中的 当前 文件 长度 设置 为 当前 文件 偏移量（ 也就是 该文 件 加长 了）。</li>
<li>open：如果 用 O_ APPEND 标志 打开 一个 文件， 则 相应 标志 也 被 设置 到 文件 表项 的 文件 状态 标志 中。 每次 对这 种 具有 追加 写 标志 的 文件 执行 写 操作 时， 文件 表项 中的 当前 文件 偏移量 首先 会被 设置 为 i 节点 表项 中的 文件 长度。 这就 使得 每次 写入 的 数据 都 追加 到 文件 的 当前 尾端 处。</li>
<li>lseek：若 一个 文件 用 lseek 定位 到 文件 当前 的 尾端， 则 文件 表项 中的 当前 文件 偏移量 被 设置 为 i 节点 表项 中的 当前 文件 长度 </li>
</ul>
<p>注：lseek 函数 只 修改 文件 表项 中的 当前 文件 偏移量， 不进 行 任何 I/ O 操作。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>上面所秒述 的一切是对于多个进程读取同一文件的过程。 每个进程都有它自己的文件表项， 其中也有它自己 的当前文件偏移量。 但是，当多个进程写同一 文件时， 则可能产生预想不到的结果。 为了避免这种情况， 需要 理解原子操作的概念。</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="追加数据到-一个-文件"><a href="#追加数据到-一个-文件" class="headerlink" title="追加数据到 一个 文件"></a>追加数据到 一个 文件</h4><p>早期 的 UNIX 系统 版本 并不 支持 open 的 O_ APPEND 选项， 所以 程序 被 编写 成 下列 形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek( fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) 　 　 　 　 　 　<span class="comment">/* position to EOF*/</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (write( fd, buf, <span class="number">100</span>) != <span class="number">100</span>) 　 　<span class="comment">/* and write*/</span> </span><br><span class="line">	&#125;   </span><br><span class="line">        <span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" write error"</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" lseek error"</span>)</span></span>;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个参数表示偏移量，字母L表示long 型，就是让编译器知道0是long型的</span></span><br><span class="line"><span class="comment">其中 int whence 为下列其中一种:（SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2）.</span></span><br><span class="line"><span class="comment">	SEEK_SET 代表读写位置指向文件头</span></span><br><span class="line"><span class="comment">　　SEEK_CUR 代表目前的读写位置</span></span><br><span class="line"><span class="comment">　　SEEK_END 代表读写位置指向文件尾</span></span><br><span class="line"><span class="comment">这里的1和SEEK-CUR 是同一个意思。</span></span><br></pre></td></tr></table></figure>
<p>对 单个 进程 而言， 这段 程序 能 正常 工作， 但 若有 多个 进程 同时 使用 这种 方法 将 数据 追加 写到 同一 文件， 则 会 产生 问题.</p>
<h4 id="进程A和B对同一文件写操作"><a href="#进程A和B对同一文件写操作" class="headerlink" title="进程A和B对同一文件写操作"></a>进程A和B对同一文件写操作</h4><p>此时， 各 数据 结构 之间 的关系上节图 3- 8 中 所示。 每个 进程 都有 它自己 的 文件 表项， 但是 共享 一个 v 节点 表项。</p>
<ul>
<li>此时如果进程 A 调用了lseek， 它将进程 A 的 该文件当前偏移量设置为1500 字节</li>
<li>然后 内核 切换 进程， 进程 B 运行。 进程 B 执行 lseek， 也 将其 对 该 文件 的 当前 偏移量 设置 为 1 500 字节（ 当前 文件尾 端 处）。 然后 B 调用 write， 它将 B 的 该文 件 当前 文件 偏移量 增加 至 1 600。</li>
<li>然后， 内核 又 进行 进程 切换， 使 进程 A 恢复 运行。 当 A 调用 write 时， 就会从其当前文件偏移量（ 1 500） 处 开始 将 数据 写入 到 文件。</li>
</ul>
<p>这样 也就 覆盖 了 进程 B 刚才 写入 到 该文 件 中的 数据。</p>
<p><strong>问题 出在 逻辑 操作“ 先 定位 到 文件 尾端， 然后 写”， 它 使用 了 两个 分开 的 函数函调用。</strong> </p>
<p>解决问题 的 方法 是 使 这 两个 操作 对于 其他 进程 而言 成为 一个 原子 操作。 如果任何要求 多于 一个 函数 调用 的 操作 不 是 原子 操作， 则在 两个 函数 调用 之间， 内核 有可能 会 临时 挂起 进程（ 正如 我们 前面 所 假定 的）。 </p>
<p>UNIX 系统 为 这样 的 操作 提供 了 一种 原子 操作 方法， 即在 打开 文件 时 设置 O_ APPEND 标志（O_APPEND：每次写操作都写入文件的末尾）。  这样做 使得 内核 在 每次 写 操作 之前， 都将 进程 的 当前 偏移量 设置 到 该 文件 的 尾端 处， 于是 在 每次 写 之前 就不 再 需要 调用 lseek。</p>
<p><strong>原子操作：</strong>顾名思义，就是说像原子一样不可再细分不可被中途打断。一个操作是原子操作，意思就是说这个操作是以原子的方式被执行，要一口气执行完，执行过程不能够被OS的其他行为打断，是一个整体的过程，在其执行过程中，OS的其它行为是插不进来的。</p>
<h3 id="文件锁fctnl"><a href="#文件锁fctnl" class="headerlink" title="文件锁fctnl"></a>文件锁fctnl</h3><p>如何实现原子操作，这里就要用到文件锁fctnl().</p>
<p>该部分讨论文件在已经共享的情况下如何操作，也就是多个程序在操作同以稳健的情况下。，LInux中通常使用文件上锁的方法，来解决共享资源的竞争。</p>
<p>文件锁包括建议性锁（lockf（））和强制性锁（fcntl（））。fcntl不仅可以施加建议性锁还可以施加强制性锁，同时还能对为见额某一记录上锁，依旧是记录锁。</p>
<p>记录锁分为读取锁和写入锁。</p>
<p>略。。。</p>
<h2 id="重定向dup和dup2函数"><a href="#重定向dup和dup2函数" class="headerlink" title="重定向dup和dup2函数"></a>重定向dup和dup2函数</h2><p>函数dup和dup2提供了<strong>复制文件描述符的功能</strong>。</p>
<p>他们通常用于stdin,stdout或进程的stderr的重定向。一般来说，普通输出函数（如：printf），默认是将某信息写入到文件描述符为1的文件中，普通输入函数都默认从文件描述符为0的文件中读取数据。因此重定向操作实际上是关闭某个标准输入输出设备（文件描述符为0、1、2），而将另一个打开的普通文件的文件描述符设置为0、1、2.</p>
<ul>
<li>输入重定向：关闭标准输入设备，打开（或复制）某普通文件，使其文件描述符为0.</li>
<li>输出重定向：关闭标准输出设备，打开（或复制）某普通文件，使其文件描述符为1.    </li>
<li>错误输出重定向：关闭标准错误输入设备，打开（或复制）某普通文件，使其文件描述符为2.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">( <span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由 dup 返回 的 新 文件 描述 符 一定 是 当前 可用 文件 描述 符 中的 最小 数值。</p>
<p> 对于 dup2， 可 以用 fd2 参数 指定 新 描述 符 的 值。 如果 fd2 已经 打开， 则 先 将其 关闭。 如若 fd 等于 fd2， 则 dup2 返回 fd2， 而 不 关闭 它。 否则， fd2 的 FD_ CLOEXEC 文件 描述 符 标志 就被 清除， 这样 fd2 在 进程 调用 exec 时 是 打开 状态。</p>
<p>这些 函数 返回 的 新 文件 描述 符 与 参数 fd 共享 同一个 文件 表项</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_19-16-14.png" alt="Snipaste_2019-02-28_19-16-14"></p>
<h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于函数dup 允许你复制一个oldfd文件描述符。存入一个已存在的文件描述符，它就会返回一个与该描述符“相同”的新的文件描述符。即这两个描述符共享相同的内部结构，共享所有的锁定，读写位置和各项权限或flags等等。例如：对一个文件描述符进行了lseek操作，另一个文件描述符的读写位置也会随之改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd,newfd;</span><br><span class="line">        <span class="keyword">char</span> *bufFD=<span class="string">"Advanced Programming! write by fd\n"</span>;</span><br><span class="line">        <span class="keyword">char</span> *bufNewFD=<span class="string">"Advanced Programming! write by NewFD\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开始复制了</span></span><br><span class="line">        newfd = dup(fd);</span><br><span class="line">        <span class="comment">//使用fd写</span></span><br><span class="line">        write(fd,bufFD,<span class="built_in">strlen</span>(bufFD));</span><br><span class="line">        close(fd);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用newfd写</span></span><br><span class="line">        write(newfd,bufNewFD,<span class="built_in">strlen</span>(bufNewFD));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(close(newfd)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出：</span></span><br><span class="line"><span class="comment">	查看test.txt文件，里面有两段字符串：</span></span><br><span class="line"><span class="comment">	：Advanced Programming! write by fd</span></span><br><span class="line"><span class="comment">	：Advanced Programming! write by newfd</span></span><br></pre></td></tr></table></figure>
<pre><code>可以看出，对fd或newfd进行读写操作时对同一个文件操作，不会覆盖前面文件（共享读写位置）而且还可以看到fd关闭后，对newfd没有影响，使用newfd还可以操作打开的文件。
</code></pre><h3 id="dup2函数（该函数不是很懂）"><a href="#dup2函数（该函数不是很懂）" class="headerlink" title="dup2函数（该函数不是很懂）"></a>dup2函数（该函数不是很懂）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dup2 函数定义在 &lt;unistd.h&gt; 中，函数原形为：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2 )</span></span></span><br></pre></td></tr></table></figure>
<p> 返回值：如成功则返回新的文件描述符，否则出错返回-1. </p>
<p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。</p>
<p>若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等等.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> refd;</span><br><span class="line">        <span class="keyword">char</span> *buf=<span class="string">"Advanced Programming!\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        refd = dup2(fd,fileno(<span class="built_in">stdout</span>));</span><br><span class="line">        <span class="keyword">if</span>(refd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"redirect standard out error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写数据，本应该写入到stdout的信息重定向而写入到目标文件中（test.txt）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dup2的返回值：%d\n"</span>,refd);</span><br><span class="line">        write(fileno(<span class="built_in">stdout</span>),buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，可以看到以下内容</span></span><br><span class="line"><span class="comment">Advanced Programming!</span></span><br><span class="line"><span class="comment">dup2的返回值：1</span></span><br></pre></td></tr></table></figure>
<h1 id="第四节：标准I-O"><a href="#第四节：标准I-O" class="headerlink" title="第四节：标准I/O"></a>第四节：标准I/O</h1><p>标准 I/ O 的 由来</p>
<ul>
<li>标准 I/ O 指的 是 ANSI C 中 定义 的 用于 I/ O 操作 的 一系列 函数。 </li>
<li>只要 操作系统 中 安装 了 C 库， 标准 I/ O 函数 就可以 调用。即: 如果 程序 中 使 用的 是 标准 I/ O 函数， 那么 源 代码 不需要 修改 就可 以在 其他 操作系统 下 编译 运行， 具有 更好 的 可移植性。 </li>
<li>使用 标准 I/ O 可以 减少 系统 调用 的 次数， 提高 系统 效率。 标准 I/ O 函数 在 执行 时 也会 用到 系统 调用。 </li>
</ul>
<h2 id="流-和-FILE-对象"><a href="#流-和-FILE-对象" class="headerlink" title="流 和 FILE 对象"></a>流 和 FILE 对象</h2><p>标准 I/ O 的 核心 对象 就是 流。 当 用 标准 I/ O 打开 一个 文件 时， 就会 创建 一个 FILE 结构 体文件描述符，我们 把 这个 FILE 结构 体 形象 地 称为 流。然后 该文 件 描述 符 就用 于 后续 的 I/ O 操作。</p>
<p>标准 I/ O 文件 流 可用 于 单 字节 或 多 字节（“ 宽”） 字符 集。 流的 定向（ stream’ s orientation） 决定了 所 读、 写的 字符 是 单字 节 还是 多 字节 的。</p>
<p>标准 I/ O 函数 都 基于 流进 行 各种 操作。 标准 I/ O 中的 流的 缓冲 类型 有 以下 三种。 </p>
<p>（1） 全 缓冲： 在 这种 情况下， 当 填满 标准 I/ O 缓冲区 后才 进行 实际 I/ O 操作。 对于 存放 在 磁盘 上 的 普通 文件 用 标准 I/ O 打开 时 默认 是 全 缓冲 的。 当 缓冲区 已满 或 执行 flush 操作 时 才会 进行 磁盘 操作。</p>
<p> （2） 行 缓冲： 在 这种 情况下， 当 在 输入 和 输出 中 遇到 换行符 时 执行 I/ O 操作。 标准 输 入流 和 标准 输出 流 就是 使用 行 缓冲 的 典型 例子。 </p>
<p>（3） 无 缓冲： 不对 I/ O 操作 进行 缓冲， 即在 对流 的 读写 时会 立刻 操作 实际 的 文件。 标准 出错 流 是 不带 缓冲 的， 这就 使得 出错 信息 可以 立刻 显示 在 终端 上， 而 不管 输出 的 内容 是否 包含 换行符。</p>
<p>标准 I/ O 库 提供 缓冲 的 目的 是 尽可能 减少 使用 read 和 write 调用 的 次数。 它 也对 每个 I/ O 流 自动 地 进行 缓冲 管理， 从而 避免 了 应用 程序 需要 考虑 这一点 所带 来的 麻烦。 遗憾的是， 标准 I/ O 库 最 令人 迷惑 的 也是 它的 缓冲。</p>
<h2 id="标准输入-输出和标准错误"><a href="#标准输入-输出和标准错误" class="headerlink" title="标准输入,输出和标准错误"></a>标准输入,输出和标准错误</h2><p> 对 一个 进程 预 定义 了 3 个 流， 并且 这 3 个 流 可以 自动 地 被 进程 使用， 它们 是： 标准 输入、 标准输出和标准错误。 这些 流 文件 描述 符 STDIN_ FILENO、 STDOUT_ FILENO 和 STDERR_ FILENO 所。</p>
<p> 这 3 个 标准 I/ O 流通 过 预定 义 文件 指针 stdin、 stdout 和 stderr 加以 引用。 这 3 个 文件 指针 定义 在 头 文件&lt; stdio. h&gt; 中。</p>
<h2 id="标准-I-O-编程"><a href="#标准-I-O-编程" class="headerlink" title="标准 I/ O 编程"></a>标准 I/ O 编程</h2><h3 id="流的-打开"><a href="#流的-打开" class="headerlink" title="流的 打开"></a>流的 打开</h3><p>使用 标准 I/ O 打开 文件 的 函数 有 fopen()、 fdopen() 和 freopen()。</p>
<p> 它们 可以 以 不同 的 模式 打开 文件， 都 返回 一个 指向 FILE 的 指针， 该 指针 指向 对应 的 I/ O 流。 此后， 对 文件 的 读写 都是 通过 这个 FILE 指针 来 进行。</p>
<ul>
<li><p>fopen() 可以 指定 打开 文件 的 路径 和 模式，</p>
</li>
<li><p>fdopen() 可以 指定 打开 的 文件 描述 符 和 模式，</p>
</li>
<li><p>freopen() 除 可指 定 打开 的 文件、 模式 外， 还可 指定 特定 的 I/ O 流。</p>
<p>fopen() 函数 格式 如表 1. 1 所示。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-19-47.png" alt="Snipaste_2019-03-01_17-19-47"></p>
</li>
</ul>
<p>其中， mode 用于 指定 打开 文件 的 方式。 表 1. 2 说明了 fopen() 中 mode 的 各种 取值。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-20-03.png" alt="Snipaste_2019-03-01_17-20-03"></p>
<h3 id="流的-关闭"><a href="#流的-关闭" class="headerlink" title="流的 关闭"></a>流的 关闭</h3><p>关闭 流的 函数 为 fclose()， 该 函数 将 流的 缓冲区 内 的 数据 全部 写入 文件 中， 并 释放 相关 资源。 fclose() 函数 格式 如表 1. 3 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-22-18.png" alt="Snipaste_2019-03-01_17-22-18"></p>
<h3 id="错误-处理"><a href="#错误-处理" class="headerlink" title="错误 处理"></a>错误 处理</h3><p>标准 I/ O 函数 执行 时 如果 出现 错误， 会把 错误 码 保存 在 errno 中。 程序员 可以 通过 相应 的 函数 打印 错误 信息。</p>
<p>方发一</p>
<p>错误 处理 相关 函数 perror 如表 1. 4 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-24-15.png" alt="Snipaste_2019-03-01_17-24-15"></p>
<p>错误 处理 相关 函数 strerror 如表 1. 5 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-31-44.png" alt="Snipaste_2019-03-01_17-31-44"></p>
<h3 id="实例：打开关闭文件和错误处理"><a href="#实例：打开关闭文件和错误处理" class="headerlink" title="实例：打开关闭文件和错误处理"></a>实例：打开关闭文件和错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp; <span class="comment">// 定义流 指针 </span></span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>） <span class="comment">//NULL是系统定义的宏， 其值为0</span></span><br><span class="line">    &#123; </span><br><span class="line">        perror（＂ fail to fopen＂）; <span class="comment">// 输出 错误 信息 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose（ fp）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果文件1.txt不存在，程序执行时会打印如下信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *fp; </span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>（＂ fail to fopen: %s\ n＂, strerror（ errno））; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    fclose（ fp）;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果 文件 1. txt 不存在， 程序 执行 时会 打印 如下 信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure>
<h3 id="流的读写"><a href="#流的读写" class="headerlink" title="流的读写"></a>流的读写</h3><h4 id="1-字符-节）输入-输出"><a href="#1-字符-节）输入-输出" class="headerlink" title="1.字符(节）输入/输出"></a>1.字符(节）输入/输出</h4><p>一次 读 或 写 一个 字符， 如果 流 是 带 缓冲 的， 则 标准 I/ O 函数 处理 所有 缓冲。</p>
<p><strong>读取</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-29.png" alt="Snipaste_2019-03-01_17-39-29"></p>
<p>getc() 和 fgetc ()从 指 定的 流 中 读取 一个 字符（ 节）， getchar() 从 stdin 中 读取 一个 字符（ 节）。</p>
<p><strong>输出</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-57.png" alt="Snipaste_2019-03-01_17-39-57"></p>
<p>putc() 和 fputc() 向 指 定的 流 输出 一个 字符（ 节）， putchar() 向 stdout 输出 一个 字符（ 节）。 </p>
<p><strong>实例</strong></p>
<p>下面 这个 实例 结合 fputc() 和 fgetc()， 循环 从 标准 输入 读取 任意 个 字符 并将 其中 的 数字 输出 到 标准 输出。</p>
<p>华清远见嵌入式学院; 曾宏安; 冯利美. 嵌入式应用程序设计综合教程 (高等院校嵌入式人才培养规划教材) (Kindle 位置 217-218). 人民邮电出版社. Kindle 版本. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fput. c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">    <span class="keyword">int</span> c; </span><br><span class="line">    <span class="keyword">while</span>（ <span class="number">1</span> ） </span><br><span class="line">    &#123;	</span><br><span class="line">        c = fgetc（ <span class="built_in">stdin</span>）; <span class="comment">// 从 键盘 读取 一个 字符 </span></span><br><span class="line">        <span class="keyword">if</span> （（ c &gt;= <span class="string">'0'</span>） &amp;&amp; （c &lt;= <span class="string">'9'</span>）） fputc（ c, <span class="built_in">stdout</span>）; <span class="comment">// 若 输入 的 是 数字，输出 		if （c == '\n'） break; // 若 遇到 换行符， 跳出 循环</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行 结果 如下。 $ ./a. out abc98io# 4/ wm 984</span></span><br></pre></td></tr></table></figure>
<h4 id="2-行输入-输出"><a href="#2-行输入-输出" class="headerlink" title="2.行输入/输出"></a>2.行输入/输出</h4><p>行 输入/ 输出 函数 一次 操作 一行。如果 想要 一次 读 或 写 一行， 则 使用 fgets 和 fputs。 每 行都 以 一个 换行符 终止。 当 调用 fgets 时， 应 说明 能 处理 的 最大 行长。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-15.png" alt="Snipaste_2019-03-01_17-58-15"></p>
<p>gets 函数 容易 造成 缓冲区 溢出， 不 推荐 大家 使用。 fgets 从 指 定的 流 中 读取 一个 字符串， 当 遇到\ n 或 读取 了 size- 1 个 字符 后 返回。 注意， fgets 不能 保证 每次 都能 读出 一行。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-41.png" alt="Snipaste_2019-03-01_17-58-41"></p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 以 fgets() 为例 计算 一个 文本 文件 的 行数。 /*fgets. c*/ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; string. h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> main（ <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]） </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[ <span class="number">128</span>];</span><br><span class="line">    FILE *fp; <span class="keyword">if</span> （argc &lt; <span class="number">2</span>） </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>（＂ Usage : %s &lt; file&gt;\ n＂, argv[ <span class="number">0</span>]）;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> （（ fp = fopen（ argv[ <span class="number">1</span>], ＂r＂）） == <span class="literal">NULL</span>） </span><br><span class="line">	&#123; </span><br><span class="line">		perror（＂ fail to fopen＂）;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>（ fgets（ buf, <span class="number">128</span>, fp） != <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> （buf[ <span class="built_in">strlen</span>（ buf）- <span class="number">1</span>] == <span class="string">'\n'</span>） </span><br><span class="line">    	line++;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>（＂ The line of %s is %d\ n＂, argv[ <span class="number">1</span>], line）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行 该 程序， 结果 如下。 $ ./a. out test. txt The line of test. txt is 64</span></span><br></pre></td></tr></table></figure>
<h4 id="3-指定大小为单位读写文件"><a href="#3-指定大小为单位读写文件" class="headerlink" title="3.指定大小为单位读写文件"></a>3.指定大小为单位读写文件</h4><p>在 文件 流 被打 开 之后， 可 对 文件 流 按指 定 大小 为 单位 进行 读写 操作。fread 和 fwrite 函数 支持 这种 类型 的 I/ O。 每次 I/ O 操作 读 或 写 某种 数量 的 对象， 而每 个 对象 具有 指定 的 长度。 这 两个 函数 常 用于 从 二进制 文件 中 每次 读 或 写 一个 结构。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-27.png" alt="Snipaste_2019-03-01_18-13-27"></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-40.png" alt="Snipaste_2019-03-01_18-13-40"></p>
<h3 id="流的定位"><a href="#流的定位" class="headerlink" title="流的定位"></a>流的定位</h3><p>每个 打开 的 流 内部 都有 一个 当前 读写 位置。 流 在 打开 时， 当前 读写 位置 为 0， 表示 文件 的 开始 位置。 每 读写 一次 后， 当前 读写 位置 自动 增加 实际 读写 的 大小。 在 读写 流 之间 可 先 对流 进行 定位， 即 移动 到 指定 的 位置 再 操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-16-07.png" alt="Snipaste_2019-03-01_18-16-07"></p>
<h3 id="格式化-输入-输出"><a href="#格式化-输入-输出" class="headerlink" title="格式化 输入 输出"></a>格式化 输入 输出</h3><p>格式化 输入/ 输出 函数 可以 指定 输入/ 输出 的 具体 格式， 包括 读者 已经 非常 熟悉 的 printf()、 scanf() 等 函数。</p>
<p><strong>格式化输入</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-17-55.png" alt="Snipaste_2019-03-01_18-17-55"></p>
<p><strong>格式化输出</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-18-05.png" alt="Snipaste_2019-03-01_18-18-05"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/数据结构.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/数据结构.html" itemprop="url">
                  数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-27 12:41:05" itemprop="dateCreated datePublished" datetime="2019-02-27T12:41:05+08:00">2019-02-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-28 11:31:49" itemprop="dateModified" datetime="2019-02-28T11:31:49+08:00">2019-02-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章：数据结构基数"><a href="#第一章：数据结构基数" class="headerlink" title="第一章：数据结构基数"></a>第一章：数据结构基数</h1><h2 id="第一节：数据与c"><a href="#第一节：数据与c" class="headerlink" title="第一节：数据与c"></a>第一节：数据与c</h2><h2 id="第二节：数组和指针"><a href="#第二节：数组和指针" class="headerlink" title="第二节：数组和指针"></a>第二节：数组和指针</h2><h2 id="第三节：结构体"><a href="#第三节：结构体" class="headerlink" title="第三节：结构体"></a>第三节：结构体</h2><h2 id="第四节：其他结构"><a href="#第四节：其他结构" class="headerlink" title="第四节：其他结构"></a>第四节：其他结构</h2><h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><p>联合（union） 是一种数据类型， 它能在同一个内存空间中储存不同的数据类型（不是同时储存） 。 其典型的用法是， 设计一种表以储存既无规律、 事先也不知道顺序的混合类型。 使用联合类型的数组， 其中的联合都大小相等， 每个联合可以储存各种数据类型。 </p>
<h4 id="创建联合体"><a href="#创建联合体" class="headerlink" title="创建联合体"></a>创建联合体</h4><p>创建联合和创建结构的方式相同， 需要一个联合模板和联合变量。 可以用一个步骤定义联合， 也可以用联合标记分两步定义。 下面是一个带标记的联合模板： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold &#123;</span><br><span class="line"><span class="keyword">int</span> digit;</span><br><span class="line"><span class="keyword">double</span> bigfl;</span><br><span class="line"><span class="keyword">char</span> letter;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h4 id="定义（声明）联合体变量"><a href="#定义（声明）联合体变量" class="headerlink" title="定义（声明）联合体变量"></a>定义（声明）联合体变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit; <span class="comment">// hold类型的联合变量</span></span><br><span class="line"><span class="keyword">union</span> hold save[<span class="number">10</span>]; <span class="comment">// 内含10个联合变量的数组</span></span><br><span class="line"><span class="keyword">union</span> hold * pu; <span class="comment">// 指向hold类型联合变量的指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第1个声明创建了一个单独的联合变量fit。 编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。 在本例中， 占用空间最大的是 double类型的数据。 在我们的系统中， double类型占64位， 即8字节。 </li>
<li>第2个声明创建了一个数组save， 内含10个元素， 每个元素都是8字节。</li>
<li>第3个声明创建了一个指针， 该指针变量储存hold类型联合变量的地址。</li>
</ul>
<h4 id="初始化联合体"><a href="#初始化联合体" class="headerlink" title="初始化联合体"></a>初始化联合体</h4><p>需要注意的是， 联合只能储存一个值， 这与结构不同。</p>
<p> 有 3 种初始化的方法： 把一个联合初始化为另一个同类型的联合； 初始化联合的第1个元素； 或者根据C99标准， 使用指定初始化器：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold valA;</span><br><span class="line">valA.letter = <span class="string">'R'</span>;</span><br><span class="line"><span class="keyword">union</span> hold valB = valA; <span class="comment">// 用另一个联合来初始化</span></span><br><span class="line"><span class="keyword">union</span> hold valC = &#123;<span class="number">88</span>&#125;; <span class="comment">// 初始化联合的digit 成员</span></span><br><span class="line"><span class="keyword">union</span> hold valD = &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure>
<h4 id="使用联体"><a href="#使用联体" class="headerlink" title="使用联体"></a>使用联体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit.digit = <span class="number">23</span>; <span class="comment">//把 23 储存在 fit， 占2字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>; <span class="comment">// 清除23， 储存 2.0， 占8字节</span></span><br><span class="line">fit.letter = <span class="string">'h'</span>; <span class="comment">// 清除2.0， 储存h， 占1字节</span></span><br></pre></td></tr></table></figure>
<p>点运算符表示正在使用哪种数据类型。 在联合中， 一次只储存一个值。即使有足够的空间， 也不能同时储存一个char类型值和一个int类型值。 </p>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>略</p>
<h3 id="枚举（不懂）"><a href="#枚举（不懂）" class="headerlink" title="枚举（不懂）"></a>枚举（不懂）</h3><p>可以用枚举类型（enumerated type） 声明符号名称来表示整型常量。 使<br>用enum关键字， 可以创建一个新“类型”并指定它可具有的值（实际上， enum<br>常量是int类型， 因此， 只要能使用int类型的地方就可以使用枚举类型） 。 枚<br>举类型的目的是提高程序的可读性。 它的语法与结构的语法相同。</p>
<h4 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br></pre></td></tr></table></figure>
<p>第1个声明创建了spetrum作为标记名， 允许把enum spetrum作为一个类型名使用。 第2个声明使color作为该类型的变量。 第1个声明中花括号内的标<br>识符枚举了spectrum变量可能有的值。 因此， color 可能的值是 red、orange、 yellow 等。 这些符号常量被称为枚举符（enumerator） 。  </p>
<h4 id="枚举的使用（没懂）"><a href="#枚举的使用（没懂）" class="headerlink" title="枚举的使用（没懂）"></a>枚举的使用（没懂）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow)</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++)</span><br><span class="line">...;</span><br></pre></td></tr></table></figure>
<p>虽然枚举符（如red和blue） 是int类型， 但是枚举变量可以是任意整数类型， 前提是该整数类型可以储存枚举常量。 例如， spectrum的枚举符范围是<br>0～5， 所以编译器可以用unsigned char来表示color变量。 </p>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><h1 id="第二章：高级数据结构"><a href="#第二章：高级数据结构" class="headerlink" title="第二章：高级数据结构"></a>第二章：高级数据结构</h1><h2 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h2><p>计算机用户已经开发出的一些数据形式比我们提到过的数组和简单结构更有效地解决特定的问题。 这些形式包括队列、 二叉树、 堆、 哈希表和图表。 许多这样的形式都由链式结构（linked structure） 组成。 通<br>常， 每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。 这些指针把一个结构和另一个结构链接起来， 并提供一种路径能遍历整个彼此链接的结构。 </p>
<p>图14.3演示了一个二叉树结构， 每个单独的结构（或节点） 都和它下面的两个结构（或节点） 相连。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-27_12-56-40.png" alt="Snipaste_2019-02-27_12-56-40"></p>
<p>图14.3中显示的分级或树状的结构是否比数组高效？ 考虑一个有10级节点的树的情况。 它有210-1（或1023） 个节点， 可以储存1023个单词。 如果<br>这些单词以某种规则排列， 那么可以从最顶层开始， 逐级向下移动查找单词， 最多只需移动9次便可找到任意单词。 如果把这些单词都放在一个数组中， 最多要查找1023个元素才能找出所需的单词 。</p>
<h2 id="联合简介"><a href="#联合简介" class="headerlink" title="联合简介"></a>联合简介</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="typedef简介"><a href="#typedef简介" class="headerlink" title="typedef简介"></a>typedef简介</h2><h2 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h2><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/C指针：基本概念、核心技术及最佳实践.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/C指针：基本概念、核心技术及最佳实践.html" itemprop="url">
                  C指针：基本概念、核心技术及最佳实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-21 18:18:47" itemprop="dateCreated datePublished" datetime="2019-02-21T18:18:47+08:00">2019-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-23 16:24:51" itemprop="dateModified" datetime="2019-02-23T16:24:51+08:00">2019-02-23</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/C指针：基本概念、核心技术及最佳实践.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/第一节.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/第一节.html" itemprop="url">
                  C primer Plus
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-20 20:38:47" itemprop="dateCreated datePublished" datetime="2019-02-20T20:38:47+08:00">2019-02-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-28 11:31:49" itemprop="dateModified" datetime="2019-02-28T11:31:49+08:00">2019-02-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第一章：基数知识"><a href="#第一章：基数知识" class="headerlink" title="第一章：基数知识"></a>第一章：基数知识</h1><h2 id="第一节：数据和C"><a href="#第一节：数据和C" class="headerlink" title="第一节：数据和C"></a>第一节：数据和C</h2><h3 id="strlen和sizeof"><a href="#strlen和sizeof" class="headerlink" title="strlen和sizeof"></a>strlen和sizeof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>]=<span class="string">"wu"</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"strlen= %d,sizeof=%d;"</span> , <span class="built_in">strlen</span>(name) , <span class="keyword">sizeof</span>(name));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">返回值为：<span class="built_in">strlen</span>= <span class="number">2</span>,<span class="keyword">sizeof</span>=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">sizeof</span> 运算符， 它以字节为单位给出对象的大小。 <span class="built_in">strlen</span>()函数给出字符串中的字符长度。</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/第一节.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/linux环境配置.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux环境配置.html" itemprop="url">
                  linux环境配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-29 17:01:14" itemprop="dateCreated datePublished" datetime="2018-12-29T17:01:14+08:00">2018-12-29</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/1-移植U-Boot.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1-移植U-Boot.html" itemprop="url">
                  1.移植U-Boot
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 22:52:31" itemprop="dateCreated datePublished" datetime="2018-12-28T22:52:31+08:00">2018-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-03 11:41:44" itemprop="dateModified" datetime="2019-01-03T11:41:44+08:00">2019-01-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/第二阶段/" itemprop="url" rel="index"><span itemprop="name">第二阶段</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="移植-U-Boot"><a href="#移植-U-Boot" class="headerlink" title="移植 U-Boot"></a>移植 U-Boot</h2><h3 id="Bootloader-简介"><a href="#Bootloader-简介" class="headerlink" title="Bootloader 简介"></a>Bootloader 简介</h3><p>#### </p>
<h4 id="Bootload是什么"><a href="#Bootload是什么" class="headerlink" title="Bootload是什么"></a>Bootload是什么</h4><p>Bootloader是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备（关闭WATCHDOG、改变系统时钟、初始化存储控制器）、建立内存空间的映射表，将更多的代码复制到内存中等，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。 <em>它能将操作系统内核复制到内存中运行，我们将这段程序称为 Bootloader。</em></p>
<p>①Bootloader 就是这么一小段程序，它在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统</p>
<p>②我们还可以增强 Bootloader 的功能，比如增加网络功能、从 PC 上通过串口或网络下载文件、烧写文件、将 Flash 上压缩的文件解压后再运行等。</p>
<p>③Bootloader是基于特定硬件平台来实现的。因此，不可能有一个 Bootloader 支持所有的CPU、所有的电路板。即使是支持 CPU 架构比较多的 U-Boot，也不是一拿来就可以使用的，需要进行一些移植</p>
<h4 id="Bootloader是如何启动"><a href="#Bootloader是如何启动" class="headerlink" title="Bootloader是如何启动"></a>Bootloader是如何启动</h4><p>CPU 上电后，会从某个地址开始执行。比如 MIPS 结构的 CPU 会从 0xBFC00000 取第一条指令，而 ARM 结构的 CPU 则从地址 0x0000000 开始。嵌入式开发板中，需要把存储器件 ROM 或 Flash 等映射到这个地址，Bootloader 就存放在这个地址开始处，这样一上电就可以执行。<strong><em>(即将Bootloader 存放在0x0000000 这个地址开始处。这样一上电就可以执行Bootloader)</em></strong> </p>
<p>在开发时，通常可以使用各种命令操作 Bootloader，一般通过串口来连接 PC 和开发板，可以在串口上输入各种命令、观察运行结果等。</p>
<p>Bootloader 可以分为以下两种操作模式（Operation Mode）。<br>​    （1）启动加载（Boot loading）模式。<br>​    上电后，Bootloader 从板子上的某个固态存储设备上将操作系统加载到 RAM 中运行，整个过程并没有用户的介入。产品发布时，Bootloader 工作在这种模式下。<br>​    （2）下载（Downloading）模式。<br>​    在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（比如内核映象、文件系统映象），将它们直接放在内存运行或是烧入Flash 类固态存储设备中。<br>​    板子与主机间传输文件时，可以使用串口的 xmodem/ymodem/zmodem 协议，它们使用简单，只是速度比较慢；还可以使用网络通过 tftp、nfs 协议来传输，这时，主机上要开启 tftp、nfs 服务；还有其他方法，比如 USB 等。</p>
<h4 id="Bootloader-在linux中的分区"><a href="#Bootloader-在linux中的分区" class="headerlink" title="Bootloader 在linux中的分区"></a>Bootloader 在linux中的分区</h4><p>嵌入式 Linux 系统从软件的角度通常可以分为以下 4 个层次。</p>
<p>（1）引导加载程序。</p>
<p>包括固化在固件（firmware）中的 boot 代码（可选）和 Bootloader两大部分。有些 CPU 在运行 Bootloader 之前先运行一段固化的程序（固件，firmware），比如 x86结构的 CPU 就是先运行 BIOS 中的固件，然后才运行硬盘第一个分区（MBR）中的 Bootloader。在大多嵌入式系统中并没有固件，Bootloader 是上电后执行的第一程序。</p>
<p>（2）Linux 内核。</p>
<p>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由 Bootloader 传递给它的。</p>
<p>（3）文件系统。</p>
<p>包括根文件系统和建立于 Flash 内存设备之上的文件系统。里面包含了 Linux 系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux 的控制界面的 shell 程序、动态连接的程序运行时需要的 glibc 或 uClibc 库等。</p>
<p>（4）用户应用程序。<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间 可能还会包括一个嵌入式图形用户界面。常用的嵌入式 GUI 有：Qtopia 和 MiniGUI 等。 </p>
<p>嵌入系统的典型分区结构如下</p>
<p><img src="D:\MyBlog\图片\Snipaste_2018-12-28_23-39-14.png" alt="Snipaste_2018-12-28_23-39-14"></p>
<p><strong>“Boot parameters（参数）”</strong>分区中存放一些可设置的参数，比如 IP 地址、串口波特率、要传递给内核的命令行参数等。</p>
<p>正常启动过程中，Bootloader 首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会挂接（mount）根文件系统（“Root filesystem”），启动文件系统中的应用程序。</p>
<h4 id="Bootload启动步骤"><a href="#Bootload启动步骤" class="headerlink" title="Bootload启动步骤"></a>Bootload启动步骤</h4><p>汇编阶段 </p>
<ol>
<li><p>设置为SVC模式，关闭中断,MMU,看门狗</p>
</li>
<li><p>基本硬件设备初始化（初始化时钟，串口，flash,内存等）</p>
</li>
<li><p>自搬移到内存</p>
</li>
<li><p>设置好栈 跳转到C语言阶段 </p>
<p>C语言阶段</p>
</li>
<li><p>大部分硬件初始化</p>
</li>
<li><p>搬移内核到内存后，运行内核</p>
</li>
</ol>
<h4 id="常用-Bootloader-介绍"><a href="#常用-Bootloader-介绍" class="headerlink" title="常用 Bootloader 介绍"></a>常用 Bootloader 介绍</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-29_00-42-38.png" alt="Snipaste_2018-12-29_00-42-38"></p>
<p>本次使用的 S3C2410 开发板使用的Bootloader为U-Boot 。<br>​    U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p>
<h3 id="U-Boot-分析与移植"><a href="#U-Boot-分析与移植" class="headerlink" title="U-Boot 分析与移植"></a>U-Boot 分析与移植</h3><h4 id="U-Boot-简介"><a href="#U-Boot-简介" class="headerlink" title="U-Boot 简介"></a>U-Boot 简介</h4><p>U-Boot，全称为 Universal Boot Loader，即通用 Bootloader，是遵循 GPL 条款的开放源代码项目。</p>
<p><strong>U-Boot 有如下特性</strong></p>
<p>• 开放源码。</p>
<p>• 支持多种嵌入式操作系统内核，如 Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS。</p>
<p>• 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS、XScale。</p>
<p>• 较高的可靠性和稳定性。</p>
<p>• 高度灵活的功能设置，适合 U-Boot 调试、操作系统不同引导要求、产品发布等。</p>
<p>• 丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等。</p>
<p>• 较为丰富的开发调试文档与强大的网络技术支持。</p>
<p>• 支持 NFS 挂载、RAMDISK（压缩或非压缩）形式的根文件系统。</p>
<p>• 支持 NFS 挂载、从 Flash 中引导压缩或非压缩系统内核。</p>
<p>• 可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对 Linux 支持最为强劲。</p>
<p>• 支持目标板环境变量多种存储方式，如 Flash、NVRAM、EEPROM。</p>
<p>• CRC32 校验，可校验 Flash 中内核、RAMDISK 镜像文件是否完好。</p>
<p>• 上电自检功能：SDRAM、Flash 大小自动检测，SDRAM 故障检测，CPU 型号 。                            </p>
<p>• 上电自特殊功能：XIP 内核引导 。</p>
<h4 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h4><p>源码为U-Boot-1.1.6  版本。从 sourceforge 网站下载 U-Boot-1.1.6.tar.bz2后解压即得到全部源码。</p>
<p>U-Boot-1.1.6 根目录下共有 26 个子目录，可以分为 4 类。</p>
<p>（1）平台相关的或开发板相关的。<br>​    （2）通用的函数。<br>​    （3）通用的设备驱动程序。<br>​    （4）U-Boot 工具、示例程序、文档 。</p>
<p>这 26 个子目录的功能与作用如表  </p>
<p>详细参考：嵌入式Linux应用开发完全手册的15.2.2 U-Boot 源码结构部分</p>
<h4 id="U-Boot-的配置、编译、连接"><a href="#U-Boot-的配置、编译、连接" class="headerlink" title="U-Boot 的配置、编译、连接"></a>U-Boot 的配置、编译、连接</h4><p>要想了解对于某款开发板，使用哪些文件、哪个文件首先执行、可执行文件占用内存的情况，最好的方法就是阅读它的 Makefile。</p>
<p>如果要使用开发板 board/&lt;board_name&gt;，就先执行“make &lt;board_name&gt;_config”命令进行配置，然后执行“make all”，就可以生成如下 3个文件。</p>
<p>• U-Boot.bin：二进制可执行文件，它就是可以直接烧入 ROM、NOR Flash 的文件。<br>​    • U-Boot：ELF 格式的可执行文件。<br>​    • U-Boot.srec：Motorola S-Record 格式的可执行文件。</p>
<p>例如：S3C2410 的开发板，执行“make smdk2410_config”、“make all”后生成的 U-Boot.bin可以烧入 NOR Flash 中运行</p>
<h5 id="U-Boot-的配置"><a href="#U-Boot-的配置" class="headerlink" title="U-Boot 的配置"></a>U-Boot 的配置</h5><p>(1). S3C2410 的开发板，执行“make smdk2410_config”</p>
<p>在顶层 Makefile 中可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRCTREE := $(CURDIR) </span><br><span class="line">……</span><br><span class="line">MKCONFIG := $(SRCTREE)/mkconfig </span><br><span class="line">……</span><br><span class="line">smdk2410_config : unconfig </span><br><span class="line">	  @$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>则其中的 MKCONFIG 就是根目录下的 mkconfig文件。$(@:_config=)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。</p>
<p>所以“make smdk2410fi”实际上就是执行如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>补充：在 mkconfig 文件开头第 6 行给出了它的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span> # Parameters: Target Architecture CPU Board [VENDOR][SOC]</span><br></pre></td></tr></table></figure>
<p>对于 S3C2410、S3C2440，它们被称为 SoC(System on Chip)，上面除 CPU 外，还集成了包括 UART、USB 控制器、NAND Flash 控制器等设备（称为片内外设）。S3C2410/S3C2440 中的 CPU 为 ARM920T。</p>
<p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p>
<h5 id="U-Boot-的编译、连接"><a href="#U-Boot-的编译、连接" class="headerlink" title="U-Boot 的编译、连接"></a>U-Boot 的编译、连接</h5><p>配置完后，执行“make all”即可编译</p>
<p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p>
<h5 id="U-Boot-的使用"><a href="#U-Boot-的使用" class="headerlink" title="U-Boot 的使用"></a>U-Boot 的使用</h5><p>U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p>
<p>我们知道u-boot，可以运行可是命令，以及支持串口下载、网络下载等功能以方便开发中调式。但这篇文章中并不介绍u-boot 的用法。后续会补充详细 的u-boot常用命令以及开发中如何使用串口和网络下载功能。以及u-boot的实际使用操作。</p>
<h2 id="移植linux内核"><a href="#移植linux内核" class="headerlink" title="移植linux内核"></a>移植linux内核</h2><p>这部分我们主要了解熟悉linux内核。知道如何给内核打补丁，配置内核及编译内核等内容。</p>
<p>准备：</p>
<p>内核源码：2.6.22.6.tar.bz2</p>
<p>补丁文件：patch-2.6.22.bz2</p>
<h3 id="内核源码结构分析及Makefile分析"><a href="#内核源码结构分析及Makefile分析" class="headerlink" title="内核源码结构分析及Makefile分析"></a>内核源码结构分析及Makefile分析</h3><h4 id="内核源码结构分析"><a href="#内核源码结构分析" class="headerlink" title="内核源码结构分析"></a>内核源码结构分析</h4><p>略</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html" itemprop="url">
                  在Linux下写一个简单的驱动程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 23:12:10" itemprop="dateCreated datePublished" datetime="2018-12-26T23:12:10+08:00">2018-12-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-27 00:46:47" itemprop="dateModified" datetime="2018-12-27T00:46:47+08:00">2018-12-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
