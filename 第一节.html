<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第一章：基数知识第一节：数据和Cstrlen和sizeof1234567891011#include&quot;stdio.h&quot;#include&quot;string.h&quot;int main(void)&amp;#123;	char name[20]=&quot;wu&quot;; 	printf(&quot;strlen= %d,sizeof=%d;&quot; , strlen(name) , sizeof(name));&amp;#125;   返回值为：strle">
<meta name="keywords" content="C">
<meta property="og:type" content="article">
<meta property="og:title" content="C primer Plus">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/第一节.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:description" content="第一章：基数知识第一节：数据和Cstrlen和sizeof1234567891011#include&quot;stdio.h&quot;#include&quot;string.h&quot;int main(void)&amp;#123;	char name[20]=&quot;wu&quot;; 	printf(&quot;strlen= %d,sizeof=%d;&quot; , strlen(name) , sizeof(name));&amp;#125;   返回值为：strle">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-20_21-26-20.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-20_21-42-14.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-22_01-03-28.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-22_01-48-04.png">
<meta property="og:image" content="c:/Users/Dell/AppData/Roaming/Typora/typora-user-images/1550771326720.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-22_14-14-32.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_21-55-01.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_22-03-42.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-22_13-26-02.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-26_15-26-55.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-26_20-50-51.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_09-53-53.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_10-38-48.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_14-07-57.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_14-15-18.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-21_14-15-46.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-25_20-49-47.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-02-26_10-46-41.png">
<meta property="og:updated_time" content="2019-02-28T03:31:49.497Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C primer Plus">
<meta name="twitter:description" content="第一章：基数知识第一节：数据和Cstrlen和sizeof1234567891011#include&quot;stdio.h&quot;#include&quot;string.h&quot;int main(void)&amp;#123;	char name[20]=&quot;wu&quot;; 	printf(&quot;strlen= %d,sizeof=%d;&quot; , strlen(name) , sizeof(name));&amp;#125;   返回值为：strle">
<meta name="twitter:image" content="d:/MyBlog/图片/Snipaste_2019-02-20_21-26-20.png">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/第一节.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>C primer Plus | Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/第一节.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C primer Plus
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-20 20:38:47" itemprop="dateCreated datePublished" datetime="2019-02-20T20:38:47+08:00">2019-02-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-28 11:31:49" itemprop="dateModified" datetime="2019-02-28T11:31:49+08:00">2019-02-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章：基数知识"><a href="#第一章：基数知识" class="headerlink" title="第一章：基数知识"></a>第一章：基数知识</h1><h2 id="第一节：数据和C"><a href="#第一节：数据和C" class="headerlink" title="第一节：数据和C"></a>第一节：数据和C</h2><h3 id="strlen和sizeof"><a href="#strlen和sizeof" class="headerlink" title="strlen和sizeof"></a>strlen和sizeof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>]=<span class="string">"wu"</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"strlen= %d,sizeof=%d;"</span> , <span class="built_in">strlen</span>(name) , <span class="keyword">sizeof</span>(name));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">返回值为：<span class="built_in">strlen</span>= <span class="number">2</span>,<span class="keyword">sizeof</span>=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">sizeof</span> 运算符， 它以字节为单位给出对象的大小。 <span class="built_in">strlen</span>()函数给出字符串中的字符长度。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="常量和c预处理器"><a href="#常量和c预处理器" class="headerlink" title="常量和c预处理器"></a>常量和c预处理器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> taxrate;</span><br><span class="line">taxrate = <span class="number">0.015</span>;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span>常量名比数字表达的信息更多，便于阅读</span><br><span class="line"><span class="number">2.</span>多处使用一个常量， 有时需要改变它的值。 则只需更改符号常量的定义，便于修改。</span><br></pre></td></tr></table></figure>
<p>taxrate是一个变量， 程序可能会无意间改变它的值。 C语言还提供了一个更好的方案——C预处理器。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAXRATE 0.015</span></span><br><span class="line"></span><br><span class="line">注：编译程序时， 程序中所有的TAXRATE都会被直接替换成 <span class="number">0.015</span>。</span><br></pre></td></tr></table></figure>
<p>const限定符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MONTHS = <span class="number">12</span>; <span class="comment">// MONTHS在程序中不可更改， 值为12</span></span><br><span class="line"></span><br><span class="line">注：<span class="keyword">const</span>关键字，用于限定一个变量为只读 。它限定一个变量不允许被改变，产生静态作用。</span><br></pre></td></tr></table></figure>
<h3 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h3><p>C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相<br>关的详细信息。    </p>
<p>例如： limits.h头文件包含以下类似的代码： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN -32768</span></span><br><span class="line"><span class="comment">//这些明示常量代表int类型可表示的最大值和最小值。</span></span><br></pre></td></tr></table></figure>
<h3 id="printf-和scanf"><a href="#printf-和scanf" class="headerlink" title="printf()和scanf()"></a>printf()和scanf()</h3><p>请求printf()函数打印数据的指令要与待打印数据的类型相匹配。 例如，打印整数时使用%d， 打印字符时使用%c。 这些符号被称为转换说明 </p>
<p>​                        表4.3 转换说明及其打印的输出结果 <img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-26-20.png" alt="Snipaste_2019-02-20_21-26-20"></p>
<p>scanf()函数所用的转换说明与printf()函数几乎相同。 主要的区别是， 对于float类型和double类型， printf()都使用%f、 %e、 %E、 %g和%G转换说明。 而scanf()只把它们用于float类型， 对于double类型时要使用l修饰符。<br>​                    表4.6 ANSI C中scanf()的转换说明 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-42-14.png" alt="Snipaste_2019-02-20_21-42-14"></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式（expression） 由运算符和运算对象组成（前面介绍过， 运算对象是运算符操作的对象） 。 最简单的表达式是一个单独的运算对象， 以此为基础可以建立复杂的表达式。 </p>
<p>运算对象可以是常量、 变量或二者的组合。 一些表达式由子表达式（subexpression） 组成（子表达式即较小的表达式） 。  </p>
<p>C 表达式的一个最重要的特性是， 每个表达式都有一个值。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">-6</span> </span><br><span class="line"><span class="number">4</span>+<span class="number">21</span></span><br><span class="line">a*(b + c/d)/<span class="number">20</span></span><br><span class="line">q = <span class="number">5</span>*<span class="number">2</span></span><br><span class="line">x = ++q % <span class="number">3</span></span><br><span class="line">q &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>注意：int port /<em> 不是表达式， 没有值 </em>/ </p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句（statement） 是C程序的基本构建块。 一条语句相当于一条完整的计算机指令。 在C中， 大部分语句都以分号结尾。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">legs = <span class="number">4999999999999999999</span>KK</span><br><span class="line">只是一个表达式（它可能是一个较大表达式的一部分）  而下面的代码则是一条语句：</span><br><span class="line">legs = <span class="number">4</span>;</span><br><span class="line">最简单的语句是空语句：</span><br><span class="line">; <span class="comment">//空语句</span></span><br><span class="line">C把末尾加上一个分号的表达式都看作是一条语句（即， 表达式语</span><br><span class="line">句） 。 因此， 像下面这样写也没问题：</span><br><span class="line"><span class="number">3</span> + <span class="number">4</span>；</span><br><span class="line">x = <span class="number">25</span>;</span><br><span class="line">++x;</span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br></pre></td></tr></table></figure>
<h2 id="第二节：指针和数组"><a href="#第二节：指针和数组" class="headerlink" title="第二节：指针和数组"></a>第二节：指针和数组</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p>
<h4 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h4><p>int x;  //声明变量，申请整形4bit 的空间</p>
<p>x=40;  //将40存入整型变量 x 中              </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-03-28.png" alt="Snipaste_2019-02-22_01-03-28">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
<p>上图表示如何用整型变量 x 存储值 40。</p>
<p>变量 x 什么也不是，仅仅是某些内存地址的存储位置（x对应于地址）。在上述情况下，将值 40存储在 0x00394768 位置（40 存储于x对应地址的空间内），这个位置被变量 x 引用。这也意味着，程序中能使用某些变量引用某些地址。</p>
<p>内存地址也是数字或值。如果我们要在其他变量中存储这个数字（地址），那将是什么？</p>
<p>如果我们希望访问或以某个变量存储某个内存地址（如 0x00394768），就必须利用指针这种特殊变量及“取址”操作符。</p>
<h4 id="取址操作符"><a href="#取址操作符" class="headerlink" title="取址操作符"></a>取址操作符</h4><p>“取址”操作符（&amp;）返回操作数的内存地址。取址操作符是一元操作符，适应于变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr1.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var_int ;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Insert data\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;var_int);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例中，scanf 函数需要知道输入值应该存储的地址。函数 scanf 使用“取址”操作符（&amp;）得到存储用户输入值变量 var_int 的地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr2.c</span><br><span class="line">Source code. Ptr2.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Address of variable \"var_int\": %p\n"</span>, &amp;var_int);</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Address of variable <span class="string">"var_int"</span>: <span class="number">00394768</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">源代码 Ptr3.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of node = %p\n"</span>,&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable a = %p\n"</span>, &amp;(p.a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable b = %p\n"</span>, &amp;(p.b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Output:</span><br><span class="line">Address of node = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable a = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable b = <span class="number">003</span>AFB04</span><br></pre></td></tr></table></figure>
<h4 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h4><p>现在你知道如何通过“取址”操作符获取地址。接下来让我们使用一个变量来存储这个地址。这个特定变量能存储和操作变量地址，称为指针变量。</p>
<p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p>
<p>以下是声明指针变的一般形式 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 变量名 ;</span><br><span class="line"><span class="keyword">int</span>* intptr；</span><br><span class="line"><span class="keyword">char</span>* charptr；</span><br></pre></td></tr></table></figure>
<p>指针变量声明涉及一个名为解引用操作符 (*) ，用于帮助编译器识别他是一个指针变量。</p>
<h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>指针变量声明时没有指向。程序员必须在解引用它前让其指向有效的内存地址。</p>
<p>使用两种方式实现指针变量指向特定内存地址。</p>
<ol>
<li><p>利用指针地址（&amp;）分配变量的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 使用取址操作符获取变量 x 的地址</span></span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-48-04.png" alt="Snipaste_2019-02-22_01-48-04"></p>
<p>2.让指针变量指向来自堆的动态分配内存 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line">ptr = ( <span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count );</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1550771326720.png" alt="1550771326720"></p>
</li>
</ol>
<p>数组由数据类型相同的一系列元素组成。使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和②这些元素的类型。 编译器根据这些信息正确地创建数组。 普通变量可以使用的类型， 数组元素都可以用。 </p>
<h4 id="指针的八种操作"><a href="#指针的八种操作" class="headerlink" title="指针的八种操作"></a>指针的八种操作</h4><p>可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作</p>
<p>程序清单10.13演示了指针变量的 8种基本操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.13</span> ptr_ops.c程序</span><br><span class="line"><span class="comment">// ptr_ops.c -- 指针操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>　urn[<span class="number">5</span>]　=　&#123;　<span class="number">100</span>,　<span class="number">200</span>,　<span class="number">300</span>,　<span class="number">400</span>,　<span class="number">500</span>　&#125;;</span><br><span class="line">	<span class="keyword">int</span> * ptr1, *ptr2, *ptr3;</span><br><span class="line">	ptr1 = urn;　　　　　　　<span class="comment">// 把一个地址赋给指针 </span></span><br><span class="line">	ptr2 = &amp;urn[<span class="number">2</span>];　　　　 <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line">	<span class="comment">// 解引用指针，以及获得指针的地址 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pointer　value,　dereferenced　pointer,　pointer　address:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">	<span class="comment">// 指针加法</span></span><br><span class="line">    ptr3　=　ptr1　+　<span class="number">4</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nadding　an　int　to　a　pointer:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr1 + 4 = %p, *(ptr1 + 4) = %d\n"</span>, ptr1 + <span class="number">4</span>, *(ptr1 + <span class="number">4</span>));</span><br><span class="line">	ptr1++;　　　　　　　　　<span class="comment">// 递增指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nvalues　after　ptr1++:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">	ptr2--;　　　　　　　　　<span class="comment">// 递减指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nvalues　after　--ptr2:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n"</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class="line">	--ptr1;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line">	++ptr2;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nPointers　reset　to　original　values:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr1　=　%p,　ptr2　=　%p\n"</span>,　ptr1,　ptr2);</span><br><span class="line">	<span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nsubtracting　one　pointer　from　another:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\n"</span>,　</span><br><span class="line">	ptr2,　ptr1,　ptr2　-　ptr1);</span><br><span class="line">	<span class="comment">// 一个指针减去一个整数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nsubtracting　an　int　from　a　pointer:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr3　=　%p,　ptr3　-　2　=　%p\n"</span>,　ptr3,　ptr3　-　<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">pointer value, dereferenced pointer, pointer address:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, *ptr1 =<span class="number">100</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">adding an <span class="keyword">int</span> to a pointer:</span><br><span class="line">ptr1 + <span class="number">4</span> = <span class="number">0x7fff5fbff8e0</span>, *(ptr1 + <span class="number">4</span>) = <span class="number">500</span></span><br><span class="line">values after ptr1++:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d4</span>, *ptr1 =<span class="number">200</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">values after --ptr2:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d4</span>, *ptr2 = <span class="number">200</span>, &amp;ptr2 = <span class="number">0x7fff5fbff8c0</span></span><br><span class="line">Pointers reset to original values:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 = <span class="number">0x7fff5fbff8d8</span></span><br><span class="line">subtracting one pointer from another:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d8</span>, ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 - ptr1 = <span class="number">2</span></span><br><span class="line">subtracting an <span class="keyword">int</span> from a pointer:</span><br><span class="line">ptr3 = <span class="number">0x7fff5fbff8e0</span>, ptr3 - <span class="number">2</span> = <span class="number">0x7fff5fbff8d8</span></span><br></pre></td></tr></table></figure>
<ol>
<li>解引用：<em>运算符给出指针指向地址上储存的值。因此，</em>ptr1的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。</li>
<li>取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地址。因此&amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。</li>
<li>指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 +4与&amp;urn[4]等价。如果相加结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li>
<li>递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。</li>
</ol>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_14-14-32.png" alt="Snipaste_2019-02-22_14-14-32"></p>
<ol>
<li>指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2&amp;urn[2]等价，因为ptr3指向的是&amp;arn[4]。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li>
<li>递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。</li>
<li>指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出<br>一个值，或者导致运行时错误。</li>
<li>比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li>
</ol>
<h4 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h4><p><strong>函数原型中的形参的两种形式</strong></p>
<p>直接把变量相关的两类信息（类型及值）传递给函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function1(x);</span><br><span class="line"></span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure>
<p>把变量的地址传递给函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function2(&amp;x);</span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> * ptr)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>一个把x,y值交换的例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap3.c -- 使用指针解决交换函数的问题 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Originally x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">	interchange(&amp;x, &amp;y); <span class="comment">// 把地址发送给函数</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">	temp = *u; <span class="comment">// temp获得 u 所指向对象的值</span></span><br><span class="line">	*u = *v;</span><br><span class="line">	*v = temp;</span><br><span class="line">    </span><br><span class="line">    输出：Originally x = <span class="number">5</span> <span class="keyword">and</span> y = <span class="number">10.</span></span><br><span class="line">		 Now x = <span class="number">10</span> <span class="keyword">and</span> y = <span class="number">5.</span></span><br></pre></td></tr></table></figure>
<p>分析函数：interchange(&amp;x, &amp;y);</p>
<p>该函数的声明void interchange (int <em> u, int </em> v)，其u和v是指向整数的指针。因此该函数传递的不是x和y的值，而是它们的地址。</p>
<p>接下来，在函数体中声明了一个交换值时必需的临时变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br></pre></td></tr></table></figure>
<p>通过下面的语句把x的值储存在temp中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = *u;</span><br><span class="line"><span class="comment">//u的值是&amp;x，所以u指向x。即temp = *u=*(&amp;x)这意味着用*u即可表示x的值，</span></span><br><span class="line"><span class="comment">//&amp;运算符访问地址，u=&amp;x即获得下的地址</span></span><br><span class="line"><span class="comment">//*运算符获得地址上的值，*u=*（&amp;x）即获得（&amp;x）地址上的值，即x值。</span></span><br><span class="line"><span class="comment">//所以temp=x；</span></span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line">temp = u; <span class="comment">/* 不要这样做 */</span></span><br></pre></td></tr></table></figure>
<h4 id="变量：名称、地址和值关系"><a href="#变量：名称、地址和值关系" class="headerlink" title="变量：名称、地址和值关系"></a>变量：名称、地址和值关系</h4><p>变量的名称、地址和变量的值之间关系密切。</p>
<ul>
<li>编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。</li>
<li>在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。</li>
<li>简而言之，普通变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。</li>
</ul>
<p>​    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  x=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span>* p;</span><br><span class="line">        p=&amp;x;</span><br><span class="line">                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x的地址p=&amp;x=%p\n"</span>, p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p地址的值*p=*(&amp;x)=%d"</span>, *p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">x的地址p=&amp;x=<span class="number">0xbf89c298</span></span><br><span class="line">p地址的值*p=*(&amp;x)=<span class="number">100</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	总结：</span></span><br><span class="line"><span class="comment">	&amp;符号为取址符，可以获得变量的地址</span></span><br><span class="line"><span class="comment">    *指针操作符：能存储和操作变量地址，称为指针变量。同时能够用来读取地址内的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组由数据类型相同的一系列元素组成。 要使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和这些元素的②类型。 编译器根据这些信息正确地创建数组。  </p>
<p>声明数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一些数组声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; fl</span><br><span class="line">oat candy[<span class="number">365</span>]; <span class="comment">/* 内含365个float类型元素的数组 */</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">12</span>]; <span class="comment">/*内含12个char类型元素的数组*/</span></span><br><span class="line"><span class="keyword">int</span> states[<span class="number">50</span>]; <span class="comment">/*内含50个int类型元素的数组 */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>数组通常被用来储存程序需要的同一类数据。 例如， 一个内含12个整数元素的数组可以储存12个月的天数。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>,<span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>程序清单10.1演示了一个小程序， 打印每个月的天数。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.1</span> day_mon1.c程序</span><br><span class="line"><span class="comment">/* day_mon1.c -- 打印每个月的天数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; MONTHS; index++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Month %2d has %2d days.\n"</span>, index + <span class="number">1</span>, days[index]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Month <span class="number">1</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">2</span> has <span class="number">28</span> days.</span><br><span class="line">Month <span class="number">3</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">4</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">5</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">6</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">7</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">8</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">9</span> has <span class="number">30</span> days.</span><br></pre></td></tr></table></figure>
<h4 id="使用const声明数组"><a href="#使用const声明数组" class="headerlink" title="使用const声明数组"></a>使用const声明数组</h4><p>有时需要把数组设置为只读。 这样， 程序只能从数组中检索值， 不能把新值写入数组。 要创建只读数组， 应该用const声明和初始化数组。  </p>
<p>因此，程序清单10.1中初始化数组应改成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h4><p>指定初始化器（designated initializer） 。 利用该特性可以初始化指定的数组元素。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212</span><br></pre></td></tr></table></figure>
<h4 id="给数组元素赋值"><a href="#给数组元素赋值" class="headerlink" title="给数组元素赋值"></a>给数组元素赋值</h4><p>声明数组后， 可以借助数组下标（或索引） 给数组元素赋值。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给数组的元素赋值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> counter, evens[SIZE];</span><br><span class="line"><span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; SIZE; counter++)</span><br><span class="line">evens[counter] = <span class="number">2</span> * counter;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码中使用循环给数组的元素依次赋值。</span></span><br></pre></td></tr></table></figure>
<p><strong>一些错误的数组赋值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">oxen[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 初始化没问题 */</span></span><br><span class="line"><span class="keyword">int</span> yaks[SIZE];</span><br><span class="line">yaks = oxen; <span class="comment">/* 不允许 */</span></span><br><span class="line">yaks[SIZE] = oxen[SIZE]; <span class="comment">/* 数组下标越界 ,下表为0~(SIZE-1)*/</span></span><br><span class="line"> yaks[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 不起作用 */</span></span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>例如要分析5年内每个月的降水量数据，要如何表示数据。  </p>
<ul>
<li><p>一个方案是创建60个变量， 每个变量储存一个数据项（我们曾经提到过这一笨拙的方案， 和以前一样， 这个方案并不合适） 。</p>
</li>
<li><p>二个方案是把各年的数据分开储存会更好， 即创建5个数组， 每个数组12个元素。  </p>
<p><strong>第二方案该如何实现</strong>？</p>
<p>处理这种情况应该使用数组的数组。 主数组（master array） 有5个元素（每个元素表示一年） ， 每个元素是内含12个元素的数组（每个元素表示一个月） 。 下面是该数组的声明： </p>
</li>
</ul>
<h4 id="声明二维数组"><a href="#声明二维数组" class="headerlink" title="声明二维数组"></a>声明二维数组</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> rain[<span class="number">5</span>][<span class="number">12</span>]; <span class="comment">// 内含5个数组元素的数组， 每个数组元素内含12个float类型的元素</span></span><br></pre></td></tr></table></figure>
<p>  <img src="D:\MyBlog\图片\Snipaste_2019-02-21_21-55-01.png" alt="Snipaste_2019-02-21_21-55-01"></p>
<h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p><strong>初始化的两种方式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_22-03-42.png" alt="Snipaste_2019-02-21_22-03-42"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12 <span class="comment">// 一年的月份数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YEARS 5 <span class="comment">// 年数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//</span></span><br><span class="line">用<span class="number">2010</span>～<span class="number">2014</span>年的降水量数据初始化数组</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> rain[YEARS][MONTHS] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">2.4</span>, <span class="number">3.5</span>, <span class="number">6.6</span> &#125;,</span><br><span class="line">	&#123; <span class="number">8.5</span>, <span class="number">8.2</span>, <span class="number">1.2</span>, <span class="number">1.6</span>, <span class="number">2.4</span>, <span class="number">0.0</span>, <span class="number">5.2</span>, <span class="number">0.9</span>, <span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">1.4</span>, <span class="number">7.3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">9.1</span>, <span class="number">8.5</span>, <span class="number">6.7</span>, <span class="number">4.3</span>, <span class="number">2.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">6.1</span>, <span class="number">8.4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.2</span>, <span class="number">9.9</span>, <span class="number">8.4</span>, <span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">1.7</span>, <span class="number">4.3</span>, <span class="number">6.2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.6</span>, <span class="number">5.6</span>, <span class="number">3.8</span>, <span class="number">2.8</span>, <span class="number">3.8</span>, <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.3</span>, <span class="number">2.6</span>, <span class="number">5.2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。</p>
<p>例子：数组名是数组首元素的地址。如果flizny是一个数组，下面的语句成立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br><span class="line"><span class="comment">//flizny 和&amp;flizny[0]都表示数组首元素的内存地址（&amp;是地址运算符）。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　4</span></span><br><span class="line"><span class="keyword">short</span>　dates[SIZE];</span><br><span class="line"><span class="keyword">short</span> * pti;</span><br><span class="line"><span class="keyword">short</span>　index;</span><br><span class="line">pti = dates;　<span class="comment">// 把数组地址赋给指针</span></span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_13-26-02.png" alt="Snipaste_2019-02-22_13-26-02"></p>
<h3 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h3><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = sum(marbles); <span class="comment">// 可能的函数调用</span></span><br></pre></td></tr></table></figure>
<p>该函数的原型是什么？由于数组名marbless是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式<br>参数，即该形参是一个指向int的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span></span>; <span class="comment">// 对应的函数原型</span></span><br></pre></td></tr></table></figure>
<p>sum()从该参数获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。<br>我们有两种方法让函数获得元素个数这一信息。第一种方法是，在函数代码中写上固定的数组小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span> <span class="comment">// 相应的函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>　i;</span><br><span class="line">	<span class="keyword">int</span>　total　=　<span class="number">0</span>;	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)　　<span class="comment">// 假设数组有10个元素</span></span><br><span class="line">	total += ar[i];　　　　<span class="comment">// ar[i] 与 *(ar + i) 相同</span></span><br><span class="line">	<span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个比较灵活的方法是把数组大小作为第2个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar, <span class="keyword">int</span> n)</span>　　　 <span class="comment">// 更通用的方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>　i;</span><br><span class="line">	<span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)　　 <span class="comment">// 使用 n 个元素</span></span><br><span class="line">	total += ar[i];　　　　<span class="comment">// ar[i] 和 *(ar + i) 相同</span></span><br><span class="line">	<span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数要处理数组必须知道何时开始、何时结束。上面的sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）</p>
<p>还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　marbles[SIZE]　=　&#123;　<span class="number">20</span>,　<span class="number">10</span>,　<span class="number">5</span>,　<span class="number">39</span>,　<span class="number">4</span>,　<span class="number">16</span>,　<span class="number">19</span>,　<span class="number">26</span>,　</span><br><span class="line"><span class="number">31</span>,　<span class="number">20</span>　&#125;;</span><br><span class="line"><span class="keyword">long</span>　answer;</span><br><span class="line">answer　=　sump(marbles,　marbles　+　SIZE);<span class="comment">//marble为数组的首位，而marble+SIZE则为数组结束位置</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The　total　number　of　marbles　is　%ld.\n"</span>,　answer);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>　(start　&lt;　end)</span><br><span class="line">&#123;</span><br><span class="line">total += *start;　 <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">start++;　　　　　　<span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。</p>
<h3 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a>保护数组中的数据</h3><p>编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。(直接传递数值时使用的是原始数据的副本，不会意外修改原始数据。但是传递数值的指针的话使用原始数据，因此这样的函数可能修改原数组。)</p>
<p>如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p>
<p>处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的，但是要注意保护数组中的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>　<span class="title">add_to</span><span class="params">(<span class="keyword">double</span>　ar[],　<span class="keyword">int</span>　n,　<span class="keyword">double</span>　val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>　i;</span><br><span class="line">	<span class="keyword">for</span>　(i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">	ar[i]　+=　val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因此，调用该函数后，prices数组中的每个元素的值都增加了2.5：</span></span><br><span class="line">add_to(prices, <span class="number">100</span>, <span class="number">2.50</span>);</span><br><span class="line"><span class="comment">//该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。</span></span><br></pre></td></tr></table></figure>
<h4 id="对形式参数使用const"><a href="#对形式参数使用const" class="headerlink" title="对形式参数使用const"></a>对形式参数使用const</h4><p>为了避免修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span> <span class="comment">/* 函数定义 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>　i;</span><br><span class="line">	<span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(　i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">	total　+=　ar[i];</span><br><span class="line">	<span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const的其他内容"><a href="#const的其他内容" class="headerlink" title="const的其他内容"></a>const的其他内容</h4><p>使用const创建过变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure>
<p>虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加<br>灵活。可以创建const数组、const指针和指向const的指针。</p>
<p>如何使用const关键字保护数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.const数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MONTHS　12</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">days[<span class="number">9</span>] = <span class="number">44</span>;　　 <span class="comment">/* 编译错误 ,程序无法改变数组元素的值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//coon身体指针</span></span><br><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pd = rates;　　 <span class="comment">// pd指向数组的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：</span></span><br><span class="line">*pd = <span class="number">29.89</span>;　　　<span class="comment">// 不允许</span></span><br><span class="line">pd[<span class="number">2</span>] = <span class="number">222.22</span>;　　<span class="comment">//不允许</span></span><br><span class="line">rates[<span class="number">0</span>] = <span class="number">99.99</span>; <span class="comment">// 允许，因为rates未被const限定</span></span><br></pre></td></tr></table></figure>
<h2 id="第三节：结构体和其他数据形式"><a href="#第三节：结构体和其他数据形式" class="headerlink" title="第三节：结构体和其他数据形式"></a>第三节：结构体和其他数据形式</h2><p>本章介绍以下内容：</p>
<p>关键字：</p>
<p> struct、 union、 typedef</p>
<p>运算符： .、 -&gt;</p>
<p>什么是C结构， 如何创建结构模板和结构变量</p>
<p>如何访问结构的成员， 如何编写处理结构的函数</p>
<p>联合和指向函数的指针 </p>
<p>设计程序时， 最重要的步骤之一是选择表示数据的方法。 在许多情况下， 简单变量甚至是数组还不够。 为此， C提供了结构变量（structure variable） 提高你表示数据的能力， 它能让你创造新的形式。  </p>
<h3 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h3><h4 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h4><p>定义：结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p>
<p>结构声明（structure declaration） 描述了一个结构的组织布局。 声明类似下面这样：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> book &#123;</span><br><span class="line">				<span class="built_in">char</span> title[MAXTITL];</span><br><span class="line">				<span class="built_in">char</span> author[MAXAUTL];</span><br><span class="line">				<span class="built_in">float</span> value;</span><br><span class="line">			&#125;;</span><br></pre></td></tr></table></figure>
<p><em>该声明描述了一个由两个字符数组和一个float类型变量组成的结构。 该声明并未创建实际的数据对象， 只描述了该对象由什么组成。 〔 有时， 我们把结构声明称为模板， 因为它勾勒出结构是如何储存数据的。 〕</em>  </p>
<h4 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h4><p>结构体有两层含义。 一层含义是“结构布局”，  结构布局告诉编译器如何表示数据， 但是它并未让编译器为数据分配空间。 下一步是创建一个结构变量， 即是结构的另一层含义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span> <span class="comment">//声明结构体变脸。</span></span><br><span class="line"><span class="comment">//这把library声明为一个使用book结构布局的结构体变量。 </span></span><br><span class="line"><span class="comment">//注：关键字 struct， 它表明跟在其后的是一个结构， 后面是一个可选的标记（该例中是 book）</span></span><br></pre></td></tr></table></figure>
<p> <em>编译器执行这行代码便创建了一个结构变量library。 编译器使用book模板为该变量分配空间： 一个内含MAXTITL个元素的char数组、 一个内含MAXAUTL个元素的char数组和一个float类型的变量。</em> 这些存储空间都与一个名称library结合在一起（见图14.1） </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_15-26-55.png" alt="Snipaste_2019-02-26_15-26-55"></p>
<p>在结构变量的声明中， struct book所起的作用相当于一般声明中的int或float。 例如， 可以定义两个struct book类型的变量， 或者甚至是指向structbook类型结构的指针： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">doyle</span>, <span class="title">panshin</span>, * <span class="title">ptbook</span>;</span></span><br></pre></td></tr></table></figure>
<p>结构变量doyle和panshin中都包含title、 author和value部分。 指针ptbook 可以指向doyle、 panshin或任何其他book类型的结构变量。 从本质上看，book结构声明创建了一个名为struct book的新类型。 </p>
<h4 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h4><p>初始化一个结构变量与初始化数组的语法类似： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line"><span class="string">"The Pious Pirate and the Devious Damsel"</span>,</span><br><span class="line"><span class="string">"Renee Vivotte"</span>,</span><br><span class="line"><span class="number">1.95</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="结构体的初始化器"><a href="#结构体的初始化器" class="headerlink" title="结构体的初始化器"></a>结构体的初始化器</h4><p>C99和C11为结构提供了指定初始化器（designated initializer） [1]， 其语<br>法与数组的指定初始化器类似。 但是， 结构的指定初始化器使用点运算符和<br>成员名（而不是方括号和下标） 标识特定的元素 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只初始化book结构 的value成员， 可以这样做：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">surprise</span> = &#123;</span> .value = <span class="number">10.99</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可以按照任意顺序使用指定初始化器：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span> = &#123;</span> .value = <span class="number">25.99</span>,</span><br><span class="line">					 .author = <span class="string">"James Broadfool"</span>,</span><br><span class="line">					 .title = <span class="string">"Rue for the Toad"</span>,</span><br><span class="line">				   &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h4><p>使用结构成员运算符——点（.） 访问结构中的成员。  </p>
<p>例如， library.value即访问library的value部分。 可以像使用任何float类型变量那样使用library.value。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_gets(library.title, MAXTITL);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;library.value);</span><br></pre></td></tr></table></figure>
<h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>上面结构体只能处理一本书，程序如何扩展成可以处理多本书。 </p>
<p>显然，每本书的基本信息都可以用一个 book 类型的结构变量来表示。 为描述两本书， 需要使用两个变量， 以此类推。 可以使用这一类型的结构数组来处理多本书。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBKS 100 <span class="comment">/* 书籍的最大数量 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> <span class="comment">/* 简历 book 模板 */</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">/* book 类型结构的数组 */</span></span><br></pre></td></tr></table></figure>
<h4 id="声明结构数组"><a href="#声明结构数组" class="headerlink" title="声明结构数组"></a>声明结构数组</h4><p>声明结构数组和声明其他类型的数组类似。 下面是一个声明结构数组的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct book library[MAXBKS];</span><br></pre></td></tr></table></figure>
<p>以上代码把library声明为一个内含MAXBKS个元素的数组。 数组的每个元素都是一个book类型的数组。 因此， library[0]是第1个book类型的结构变量， library[1]是第2个book类型的结构变量， 以此类推。  参看图14.2 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_20-50-51.png" alt="Snipaste_2019-02-26_20-50-51"></p>
<p><em>注：其实存储形式有点像而为数组</em></p>
<h4 id="标识结构数组的成员"><a href="#标识结构数组的成员" class="headerlink" title="标识结构数组的成员"></a>标识结构数组的成员</h4><p>为了标识结构数组中的成员， 可以采用访问单独结构的规则： 在结构名后面加一个点运算符， 再在点运算符后面写上成员名。 如下所示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">0</span>].value <span class="comment">/* 第1个数组元素与value 相关联 */</span></span><br><span class="line">library[<span class="number">4</span>].title <span class="comment">/* 第5个数组元素与title 相关联 */</span></span><br></pre></td></tr></table></figure>
<p><em>注：其实和上面的结构体一样，只是多了下标来识别结构体数组中的第几个。</em></p>
<h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>即在一个结构中包含另一个结构（即嵌套结构） 。 </p>
<p>例如，Shalala Pirosky创建了一个有关她朋友信息的结构。 显然， 结构中需要一个成员表示朋友的姓名。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.3</span> <span class="keyword">friend</span>.c程序</span><br><span class="line"><span class="comment">// friend.c -- 嵌套结构示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * msgs[<span class="number">5</span>] =</span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">"Thank you for the wonderful evening, "</span>,</span><br><span class="line">	<span class="string">"You certainly prove that a "</span>,</span><br><span class="line">	<span class="string">"is a special kind of guy.We must get together"</span>,</span><br><span class="line">	<span class="string">"over a delicious "</span>,</span><br><span class="line">	<span class="string">" and have a few laughs"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span> <span class="comment">// 第1个结构</span></span><br><span class="line">				<span class="keyword">char</span> first[LEN];</span><br><span class="line">				<span class="keyword">char</span> last[LEN];</span><br><span class="line">    	    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span> <span class="comment">// 第2个结构</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span> <span class="comment">// 嵌套结构</span></span><br><span class="line">				<span class="keyword">char</span> favfood[LEN];</span><br><span class="line">				<span class="keyword">char</span> job[LEN];</span><br><span class="line">				<span class="keyword">float</span> income;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span> = &#123;</span> <span class="comment">// 初始化一个结构变量</span></span><br><span class="line">							&#123; <span class="string">"Ewen"</span>, <span class="string">"Villard"</span> &#125;,</span><br><span class="line">							<span class="string">"grilled salmon"</span>,</span><br><span class="line">							<span class="string">"personality coach"</span>,</span><br><span class="line">							<span class="number">68112.00</span></span><br><span class="line">						&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Dear %s, \n\n"</span>, fellow.handle.first);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s%s.\n"</span>, msgs[<span class="number">0</span>], fellow.handle.first);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s%s\n"</span>, msgs[<span class="number">1</span>], fellow.job);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msgs[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s%s%s"</span>, msgs[<span class="number">3</span>], fellow.favfood, msgs[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">if</span> (fellow.income &gt; <span class="number">150000.0</span>)</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"!!"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fellow.income &gt; <span class="number">75000.0</span>)</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"!"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"See you soon,"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"Shalala"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的输出：</span></span><br><span class="line"><span class="comment">Dear Ewen,</span></span><br><span class="line"><span class="comment">Thank you for the wonderful evening, Ewen.</span></span><br><span class="line"><span class="comment">You certainly prove that a personality coach</span></span><br><span class="line"><span class="comment">is a special kind of guy.We must get together</span></span><br><span class="line"><span class="comment">over a delicious grilled salmon and have a few laughs.</span></span><br><span class="line"><span class="comment">See you soon,</span></span><br><span class="line"><span class="comment">Shalala </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>为什么喜欢使用指向结构的指针。</p>
<ul>
<li><p>第一， 就像指向数组的指针比数组本身更容易操控（如， 排序问题） 一样， 指向结构的指针通常比结构本身更容易操控。</p>
</li>
<li><p>第二， 在一些早期的C实现中， 结构不能作为参数传递给函数， 但是可以传递指向结构的指针。 </p>
</li>
<li><p>第三， 即使能传递一个结构， 传递指针通常更有效率。 </p>
</li>
<li><p>第四， 一些用于表示数据的结构中包含指向其他结构的指针。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.4</span> friends.c程序</span><br><span class="line"><span class="comment">/* friends.c -- 使用指向结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> first[LEN];</span><br><span class="line">	<span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line">	<span class="keyword">char</span> favfood[LEN];</span><br><span class="line">	<span class="keyword">char</span> job[LEN];</span><br><span class="line">	<span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2] =</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">		&#123;</span><br><span class="line">        	&#123; <span class="string">"Ewen"</span>, <span class="string">"Villard"</span> &#125;,</span><br><span class="line">			<span class="string">"grilled salmon"</span>,</span><br><span class="line">			<span class="string">"personality coach"</span>,</span><br><span class="line">			<span class="number">68112.00</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">    	    &#123; <span class="string">"Rodney"</span>, <span class="string">"Swillbelly"</span> &#125;,</span><br><span class="line">			<span class="string">"tripe"</span>,</span><br><span class="line">			<span class="string">"tabloid editor"</span>,</span><br><span class="line">			<span class="number">432400.00</span></span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span> <span class="comment">/* 定义一个指向结构的指针 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"address #1: %p #2: %p\n"</span>, &amp;fellow[<span class="number">0</span>], &amp;fellow[<span class="number">1</span>]);</span><br><span class="line">	him = &amp;fellow[<span class="number">0</span>]; <span class="comment">/* 告诉编译器该指针指向何处 */</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"pointer #1: %p #2: %p\n"</span>, him, him + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"him-&gt;income is $%.2f: (*him).income is $%.2f\n"</span>,him-&gt;income,(*him).income);</span><br><span class="line">	him++; <span class="comment">/* 指向下一个结构 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"him-&gt;favfood is %s: him-&gt;handle.last is %s\n"</span>,him-&gt;favfood, him-&gt;handle.last);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出如下：</span></span><br><span class="line"><span class="comment">address #1: 0x7fff5fbff820 #2: 0x7fff5fbff874</span></span><br><span class="line"><span class="comment">pointer #1: 0x7fff5fbff820 #2: 0x7fff5fbff874</span></span><br><span class="line"><span class="comment">him-&gt;income is $68112.00: (*him).income is $68112.00</span></span><br><span class="line"><span class="comment">him-&gt;favfood is tripe: him-&gt;handle.last is Swillbelly</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="声明和初始化结构指针"><a href="#声明和初始化结构指针" class="headerlink" title="声明和初始化结构指针"></a>声明和初始化结构指针</h4><p>声明结构指针很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span>  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure>
<p>首先是关键字 struct， 其次是结构标记 guy， 然后是一个星号（*） ， 其后跟着指针名。 这个语法和其他指针声明一样 。</p>
<p>该声明并未创建一个新的结构， 但是指针him现在可以指向任意现有的guy类型的结构。</p>
<p> 例如，对于结构体：如果barney是一个guy类型的结构， 可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney; <span class="comment">//初始化jie，</span></span><br></pre></td></tr></table></figure>
<p>在本例中， 对于结构体数组：fellow 是一个结构数组， 这意味着 fellow[0]是一个结构。 所以， 要让 him 指向fellow[0]， 可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;fellow[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h4 id="用指针访问成员"><a href="#用指针访问成员" class="headerlink" title="用指针访问成员"></a>用指针访问成员</h4><p>指针him指向结构变量fellow[0]， 如何通过him获得fellow[0]的成员的值？ </p>
<p>第1种方法也是最常用的方法： 使用-&gt;运算符。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>*<em>这里要着重理解him是一个指针， 但是hime-&gt;income是该指针所指向结构的一个成员。 所以在该例中， him-&gt;income是一个float类型的变量。</em> </p>
<p>第2种方法是， 以这样的顺序指定结构成员的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 总结：如果him是指向guy类型结构barney的指针， 下面的关系恒成立： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：barney.income == (*him).income == him-&gt;income <span class="comment">// 假设 him == &amp;barney</span></span><br></pre></td></tr></table></figure>
<h3 id="向函数传递结构的信息"><a href="#向函数传递结构的信息" class="headerlink" title="向函数传递结构的信息"></a>向函数传递结构的信息</h3><p>函数的参数把值传递给函数。 每个值都是一个数字——可能是int类型、float类型， 可能是ASCII字符码， 或者是一个地址。 </p>
<p>那么C时如何把结构体作为参数使用？</p>
<p>程序员可以选择是①传递结构本身， 还是②传递指向结构的指针。 如果你只关心结构中的某一部分， 也可以把③结构的成员作为参数。</p>
<h4 id="传递结构成员"><a href="#传递结构成员" class="headerlink" title="传递结构成员"></a>传递结构成员</h4><p>只知要结构成员是一个具有单个值的数据类型（即， int及其相关类型、char、 float、 double或指针） ， 便可把它作为参数传递给接受该特定类型的函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.5</span> funds1.c程序</span><br><span class="line"><span class="comment">/* funds1.c -- 把结构成员作为参数传递 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> bankfund;</span><br><span class="line">	<span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">		<span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line">		<span class="number">4032.27</span>,</span><br><span class="line">		<span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line">		<span class="number">8543.94</span></span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n</span></span><br><span class="line"><span class="string">	sum(stan.bankfund, stan.savefund))</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 两个double类型的数相加 */</span></span><br><span class="line"><span class="string">double sum(double x, double y)</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">    return(x + y);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">运行该程序后输出如下：</span></span><br><span class="line"><span class="string">Stan has a total of $12576.21.</span></span><br></pre></td></tr></table></figure>
<h4 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h4><p>次把结构的地址作为参数。于函数要处理funds结构， 所以必须声明funds结构。  传递结构本身</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.6</span> funds2.c程序</span><br><span class="line"><span class="comment">/* funds2.c -- 传递指向结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> bankfund;</span><br><span class="line">	<span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> savefund;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>; <span class="comment">/* 参数是一个指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">		<span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line">		<span class="number">4032.27</span>,</span><br><span class="line">		<span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line">		<span class="number">8543.94</span></span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, 	sum(&amp;stan));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>(money-&gt;bankfund + money-&gt;savefund);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行该程序后输出如下：</span></span><br><span class="line"><span class="comment">Stan has a total of $12576.21</span></span><br></pre></td></tr></table></figure>
<h4 id="传递结构本身"><a href="#传递结构本身" class="headerlink" title="传递结构本身"></a>传递结构本身</h4><p>对于允许把结构作为参数的编译器， 可以把程序清单14.6重写为程序清单14.7。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.7</span> funds3.c程序</span><br><span class="line"><span class="comment">/* funds3.c -- 传递一个结构 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> bankfund;</span><br><span class="line">	<span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> savefund;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span>; <span class="comment">/* 参数是一个结构 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">		<span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line">		<span class="number">4032.27</span>,</span><br><span class="line">		<span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line">		<span class="number">8543.94</span></span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(stan));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span>(moolah.bankfund + moolah.savefund);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是运行该程序后的输出：</span></span><br><span class="line"><span class="comment">Stan has a total of $12576.21.</span></span><br></pre></td></tr></table></figure>
<h4 id="结构和结构指针的选择"><a href="#结构和结构指针的选择" class="headerlink" title="结构和结构指针的选择"></a>结构和结构指针的选择</h4><p>假设要编写一个与结构相关的函数， 是用结构指针作为参数， 还是用结构作为参数和返回值？ 两者各有优缺点。</p>
<ul>
<li><p>把指针作为参数有两个优点： 无论是以前还是现在的C实现都能使用这种方法， 而且执行起来很快， 只需要传递一个地址。 缺点是无法保护数据。不过， ANSI C新增的const限定符解决了这个问题。</p>
</li>
<li><p>把结构作为参数传递的优点是， 函数处理的是原始数据的副本， 这保护了原始数据。 另外， 代码风格也更清楚。</p>
</li>
<li><p>传递结构的两个缺点是： 较老版本的实现可能无法处理这样的代码， 而且传递结构浪费时间和存储空间。 尤其是把大型结构传递给函数， 而它只使用结构中的一两个成员时特别浪费。 这种情况下传递指针或只传递函数所需的成员更合 </p>
<p>假设定义了下面的结构类型：struct vector {double x; double y;}; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"><span class="function">struct <span class="built_in">vector</span> <span class="title">sum_vect</span><span class="params">(struct <span class="built_in">vector</span>, struct <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">ans = sum_vect(a,b);</span><br><span class="line">对程序员而言， 上面的版本比用指针传递的版本更自然。 指针版本如</span><br><span class="line">下：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_vect</span><span class="params">(<span class="keyword">const</span> struct <span class="built_in">vector</span> *, <span class="keyword">const</span> struct <span class="built_in">vector</span> *, struct <span class="built_in">vector</span> *)</span></span>;</span><br><span class="line">...</span><br><span class="line">sum_vect(&amp;a, &amp;b, &amp;ans);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="结构体的其他结构特性"><a href="#结构体的其他结构特性" class="headerlink" title="结构体的其他结构特性"></a>结构体的其他结构特性</h3><p>1.许把一个结构赋值给另一个结构， 但是数组不能这样做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果n_data和o_data都是相同类型的结构， 可以这样做： </span></span><br><span class="line">o_data = n_data; <span class="comment">// 把一个结构赋值给另一个结构</span></span><br><span class="line"><span class="comment">//这条语句把n_data的每个成员的值都赋给o_data的相应成员。 即使成员是数组， 也能完成赋值。</span></span><br></pre></td></tr></table></figure>
<p>2.还可以构初始化为相同类型的另一个结构 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> = &#123;</span><span class="string">"Ruthie"</span>, <span class="string">"George"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> = <span class="title">right_field</span>;</span> <span class="comment">// 把一个结构初始化为另一个结构</span></span><br></pre></td></tr></table></figure>
<p>3.函数不仅能把结构本身作为参数传递， 还能把结构作为返回值返回。 把结构作为函数参数可以把结构的信息传送给函数； 把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。 结构指针也允许这种双向通信。</p>
<h3 id="结构体中的字符数组和字符指针"><a href="#结构体中的字符数组和字符指针" class="headerlink" title="结构体中的字符数组和字符指针"></a>结构体中的字符数组和字符指针</h3><p>到目前为止， 我们在结构中都使用字符数组来储存字符串。 是否可以使用指向 char 的指针来代替字符数组？  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.结构体中的字符数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.其中的结构声明也可以这样写：结构体中的字符指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * first;</span><br><span class="line"><span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> = &#123;</span><span class="string">"Talia"</span>, <span class="string">"Summers"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> = &#123;</span><span class="string">"Brad"</span>, <span class="string">"Fallingjaw"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s and %s\n"</span>, veep.first, treas.first);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于struct names类型的结构变量veep， 以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。 </p>
</li>
<li><p>对于struct pnames类型的结构变量treas， 以上字符串储存在编译器储存常量的地方。</p>
</li>
<li><p>struct pnames结构不用为字符串分配任何存储空间（结构本身只储存了两个地址， 在我们的系统中共占16字节。 ）。 它使用的是储存在别处的字符串（如， 字符串常量或数组中的字符串） 。 简而言之， 在pnames结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。   </p>
</li>
</ul>
<p>（即字符指针 不会自动分配空间，需要在使用前初始化。如果使能赋值的话可能会占用到有效的代码段，如下面所示）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your accountant:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your attorney:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, attorney.last); <span class="comment">/* 这里有一个潜在的危险 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于会计师（accountant） ， 他的名储存在accountant结构变量的last成员中， 该结构中有一个储存字符串的数组。</p>
</li>
<li><p>对于律师（attorney） ， scanf()把字符串放到attorney.last表示的地址上。 由于这是未经初始化的变量， 地址可以是任何值， 因此程序可以把名放在任何地方。 如果走运的话， 程序不会出问题， 至少暂时不会出问题， 否则这一操作会导致程序崩溃。  </p>
</li>
</ul>
<h3 id="结构、-指针和malloc"><a href="#结构、-指针和malloc" class="headerlink" title="结构、 指针和malloc()"></a>结构、 指针和malloc()</h3><p>对于上面的问题，如果使用malloc()分配内存并使用指针储存该地址， 那么在结构中使用指针处理字符串就比较合理。 这种方法的优点是， 可以请求malloc()为字符串分配合适的存储空间。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * fname; <span class="comment">// 用指针代替数组</span></span><br><span class="line"><span class="keyword">char</span> * lname;</span><br><span class="line"><span class="keyword">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinfo</span> <span class="params">(struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har temp[SLEN];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter your first name.\n"</span>);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line"><span class="comment">// 分配内存储存名</span></span><br><span class="line">pst-&gt;fname = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 把名拷贝到已分配的内存</span></span><br><span class="line"><span class="built_in">strcpy</span>(pst-&gt;fname, temp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter your last name.\n"</span>);</span><br><span class="line">s_gets(temp, SLEN);</span><br></pre></td></tr></table></figure>
<p>要理解这两个字符串都未储存在结构中， 它们储存在 malloc()分配的内<br>存块中。 然而， 结构中储存着这两个字符串的地址， 处理字符串的函数通常<br>都要使用字符串的地址。  </p>
<p>下面就是一个使用字符指针的结构体对字符串处理的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">程序清单14.10 names3.c程序</span><br><span class="line">// names3.c -- 使用指针和 malloc()</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; // 提供 strcpy()、 strlen() 的原型</span><br><span class="line">#include &lt;stdlib.h&gt; // 提供 malloc()、 free() 的原型</span><br><span class="line">#define SLEN 81</span><br><span class="line"></span><br><span class="line">struct namect &#123;</span><br><span class="line">	char * fname; // 使用指针</span><br><span class="line">	char * lname;</span><br><span class="line">	int letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void getinfo(struct namect *); // 分配内存</span><br><span class="line">void makeinfo(struct namect *);</span><br><span class="line">void showinfo(const struct namect *);</span><br><span class="line">void cleanup(struct namect *); // 调用该函数时释放内存</span><br><span class="line">char * s_gets(char * st, int n);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123; </span><br><span class="line">    struct namect person;</span><br><span class="line">	getinfo(&amp;person);</span><br><span class="line">	makeinfo(&amp;person);</span><br><span class="line">	showinfo(&amp;person);</span><br><span class="line">	cleanup(&amp;person);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getinfo(struct namect * pst)</span><br><span class="line">&#123; </span><br><span class="line">    char temp[SLEN];</span><br><span class="line">	printf(&quot;Please enter your first name.\n&quot;);</span><br><span class="line">	s_gets(temp, SLEN);</span><br><span class="line"></span><br><span class="line">    // 分配内存以储存名</span><br><span class="line">	pst-&gt;fname = (char *) malloc(strlen(temp) + 1);</span><br><span class="line"></span><br><span class="line">    // 把名拷贝到动态分配的内存中</span><br><span class="line">	strcpy(pst-&gt;fname, temp);</span><br><span class="line">	printf(&quot;Please enter your last name.\n&quot;);</span><br><span class="line">	s_gets(temp, SLEN);</span><br><span class="line">	pst-&gt;lname = (char *) malloc(strlen(temp) + 1);</span><br><span class="line">	strcpy(pst-&gt;lname, temp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void makeinfo(struct namect * pst)</span><br><span class="line">&#123;</span><br><span class="line">    pst-&gt;letters = strlen(pst-&gt;fname) +	strlen(pst-&gt;lname);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void showinfo(const struct namect * pst)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s %s, your name contains %d letters.\n&quot;, pst-&gt;fname, pst-&gt;lname, pst-&gt;letters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cleanup(struct namect * pst)</span><br><span class="line">&#123; </span><br><span class="line">    free(pst-&gt;fname);</span><br><span class="line">	free(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * s_gets(char * st, int n)</span><br><span class="line">&#123; </span><br><span class="line">    char * ret_val;</span><br><span class="line">	char * find;</span><br><span class="line">	ret_val = fgets(st, n, stdin);</span><br><span class="line">	if (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">        find = strchr(st, &apos;\n&apos;); // 查找换行符</span><br><span class="line">		if (find) // 如果地址不是 NULL，</span><br><span class="line">			*find = &apos;\0&apos;; // 在此处放置一个空字符</span><br><span class="line">		else</span><br><span class="line">			while (getchar() != &apos;\n&apos;)</span><br><span class="line">		continue; // 处理输入行的剩余部分</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return ret_val;</span><br><span class="line">&#125; </span><br><span class="line">/*</span><br><span class="line">下面是该程序的输出：</span><br><span class="line">Please enter your first name.</span><br><span class="line">Floresiensis</span><br><span class="line">Please enter your last name.</span><br><span class="line">Mann</span><br><span class="line">Floresiensis Mann, your name contains 16 letters.</span><br></pre></td></tr></table></figure>
<h3 id="使用结构数组的函数"><a href="#使用结构数组的函数" class="headerlink" title="使用结构数组的函数"></a>使用结构数组的函数</h3><p>假设一个函数要处理一个结构数组。 由于数组名就是该数组的地址， 所以可以把它传递给函数。 </p>
<p>程序清单14.13把前面的金融程序扩展为两人， 所以需要一个内含两个funds结构的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.13</span> funds4.c程序</span><br><span class="line"><span class="comment">/* funds4.c -- 把结构数组传递给函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> bankfund;</span><br><span class="line">	<span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">	<span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money [], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">jones</span>[<span class="title">N</span>] = &#123;</span></span><br><span class="line">		&#123; <span class="string">"Garlic-Melon Bank"</span>, <span class="number">4032.27</span>, <span class="string">"Lucky's Savings and Loan"</span>, <span class="number">8543.94</span>&#125;,</span><br><span class="line">		&#123; <span class="string">"Honest Jack's Bank"</span>, <span class="number">3620.88</span>, <span class="string">"Party Time Savings"</span>, <span class="number">3802.91</span>&#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The Joneses have a total of $%.2f.\n"</span>,sum(jones, N));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money [], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">double</span> total;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		total += money[i].bankfund + money[i].savefund;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span>(total);</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">The Joneses have a total of $<span class="number">20000.00</span>.</span><br></pre></td></tr></table></figure>
<h3 id="把结构内容保存到文件中"><a href="#把结构内容保存到文件中" class="headerlink" title="把结构内容保存到文件中"></a>把结构内容保存到文件中</h3><p>由于结构可以储存不同类型的信息， 所以它是构建数据库的重要工具。例如， 可以用一个结构储存雇员或汽车零件的相关信息。 最终， 我们要把这些信息储存在文件中， 并且能再次检索。  </p>
<p>数据库文件可以包含任意数量的此类数据对象。 储存在一个结构中的整套信息被称为记录（record） ， 单独的项被称为字段（field） 。</p>
<p>例如， 回忆程序book结构： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> title[MAXTITL];</span><br><span class="line">	<span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line">	<span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果pbook标识一个文件流， 那么通过下面这条语句可以把信息储存在struct book类型的结构变量primer中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(pbooks, <span class="string">"%s %s %.2f\n"</span>, primer.title,primer.author, primer.value);</span><br></pre></td></tr></table></figure>
<p><strong>保存结构的程序示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.14</span> booksave.c程序</span><br><span class="line"><span class="comment">/* booksave.c -- 在文件中保存结构中的内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBKS 10 <span class="comment">/* 最大书籍数量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> <span class="comment">/* 建立 book 模板 */</span></span><br><span class="line">	<span class="keyword">char</span> title[MAXTITL];</span><br><span class="line">	<span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line">	<span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">/* 结构数组 */</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index, filecount;</span><br><span class="line">	FILE * pbooks;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct book);</span><br><span class="line">	<span class="keyword">if</span> ((pbooks = fopen(<span class="string">"book.dat"</span>, <span class="string">"a+b"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123; </span><br><span class="line">       	<span class="built_in">fputs</span>(<span class="string">"Can't open book.dat file\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">    rewind(pbooks); <span class="comment">/* 定位到文件开始 */</span></span><br><span class="line">	<span class="keyword">while</span> (count &lt; MAXBKS &amp;&amp; fread(&amp;library[count], size,<span class="number">1</span>, pbooks) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">        	<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"Current contents of book.dat:"</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%s by %s: $%.2f\n"</span>, library[count].title,</span><br><span class="line">				library[count].author, library[count].value);</span><br><span class="line">				count++;</span><br><span class="line">		&#125;</span><br><span class="line">    filecount = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == MAXBKS)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"The book.dat file is full."</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Please add new book titles."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Press [enter] at the start of a line to stop."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; MAXBKS &amp;&amp; s_gets(library[count].title, MAXTITL) !=<span class="literal">NULL</span>&amp;&amp; library[count].title[<span class="number">0</span>] != <span class="string">'\0'</span>)</span><br><span class="line">	&#123; </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Now enter the author."</span>);</span><br><span class="line">		s_gets(library[count].author, MAXAUTL);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Now enter the value."</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;library[count++].value);</span><br><span class="line">		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">continue</span>; <span class="comment">/* 清理输入行 */</span>	</span><br><span class="line">        <span class="keyword">if</span> (count &lt; MAXBKS)</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Enter the next title."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Here is the list of your books:"</span>);</span><br><span class="line">		<span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; count; index++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s by %s: $%.2f\n"</span>, library[index].title,</span><br><span class="line">		library[index].author, library[index].value);</span><br><span class="line">		fwrite(&amp;library[filecount], size, count - filecount,pbooks);</span><br><span class="line">	&#125; 	</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"No books? Too bad.\n"</span>);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Bye.\n"</span>);	</span><br><span class="line">		fclose(pbooks);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">	<span class="keyword">char</span> * find;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">        find = <span class="built_in">strchr</span>(st, <span class="string">'\n'</span>); <span class="comment">// 查找换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (find) <span class="comment">// 如果地址不是 NULL，</span></span><br><span class="line">			*find = <span class="string">'\0'</span>; <span class="comment">// 在此处放置一个空字符 </span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">continue</span>; <span class="comment">// 清理输入行</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们先看几个运行示例， 然后再讨论程序中的要点。</span></span><br><span class="line"><span class="comment">$ booksave</span></span><br><span class="line"><span class="comment">Please add new book titles.</span></span><br><span class="line"><span class="comment">Press [enter] at the start of a line to stop.</span></span><br><span class="line"><span class="comment">Metric Merriment</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Polly Poetica</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">18.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">Deadly Farce</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Dudley Forse</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">15.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">[enter]</span></span><br><span class="line"><span class="comment">Here is the list of your books:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">Bye.</span></span><br><span class="line"><span class="comment">$ booksave</span></span><br><span class="line"><span class="comment">Current contents of book.dat:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">Please add new book titles.</span></span><br><span class="line"><span class="comment">The Third Jar</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Nellie Nostrum</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">22.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">[enter]</span></span><br><span class="line"><span class="comment">Here is the list of your books:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">The Third Jar by Nellie Nostrum: $22.99</span></span><br><span class="line"><span class="comment">Bye.</span></span><br><span class="line"><span class="comment">$</span></span><br><span class="line"><span class="comment">再次运行booksave.c程序把这3本书作为当前的文件记录打印出来。</span></span><br></pre></td></tr></table></figure>
<h1 id="第二章：输入与输出"><a href="#第二章：输入与输出" class="headerlink" title="第二章：输入与输出"></a>第二章：输入与输出</h1><h2 id="第一节：单字符输入-输出"><a href="#第一节：单字符输入-输出" class="headerlink" title="第一节：单字符输入/输出"></a>第一节：单字符输入/输出</h2><ol>
<li>介绍输入、 输出以及缓冲输入和无缓冲输入的区别 </li>
<li>如何使用重定向把程序和文件相连接</li>
<li>介绍如何设计与用户交互的界面 </li>
<li>创建更友好的用户界面 </li>
<li>演示一些与输入验证相关的问题和解决方案。 </li>
</ol>
<p>I/O函数（如printf()、 scanf()、 getchar()、 putchar()等） 负责把信息传送到程序中。  </p>
<h3 id="单字符I-O：getchar-和putchar"><a href="#单字符I-O：getchar-和putchar" class="headerlink" title="单字符I/O：getchar()和putchar()"></a>单字符I/O：getchar()和putchar()</h3><p>getchar()和 putchar()每次只处理一个字符。 </p>
<p>程序清单8.1。该程序获取从键盘输入的字符， 并把这些字符发送到屏幕上。 程序使用while 循环， 当读到#字符时停止。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">8.1</span> echo.c程序</span><br><span class="line"><span class="comment">/* echo.c -- 重复输入 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'#'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户的交互如下：    </p>
<p><strong>Hello, there. I would[enter]</strong></p>
<p>Hello, there. I would</p>
<p><strong>like a #3 bag of potatoes.[enter]</strong></p>
<p>like a</p>
<p>例子中 “#” 作为结束输入， 就无法在文本中使用这个字符， 是否有更好的方法结束输入？， 是否有更好的方法结束输入？  要回答这些问题， 首先要了解 C程序如何处理键盘输入， 尤其是缓冲和标准输入文件的概念。 </p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>在老式系统运行程序清单8.1， 可能显示如下：</p>
<p>HHeelllloo,, tthheerree..II wwoouulldd[enter]</p>
<p>lliikkee aa #</p>
<p> 像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接） 输入， 即正在等待的程序可立即使用输入的字符。</p>
<p>大部分系统在用户按下Enter键之前不会重复打印刚输入的字符， 这种输入形式属于缓冲输入。 用户输入的字符被收集并储存在一个被称为缓冲区（buffer） 的临时存储区， 按下Enter键后， 程序才可使用用户输入的字符。 图8.1比较了这两种输入。 <img src="D:\MyBlog\图片\Snipaste_2019-02-21_09-53-53.png" alt="Snipaste_2019-02-21_09-53-53"></p>
<p><strong>为什么要有缓冲区？</strong></p>
<ul>
<li>把若干字符作为一个块进行传输比逐个发送这些字符节约时间</li>
<li>如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时， 传输的是正确的输入。</li>
</ul>
<p>虽然缓冲输入好处很多， 但是某些交互式程序也需要无缓冲输入。 例如， 在游戏中， 你希望按下一个键就执行相应的指令。 因此， 缓冲输入和无缓冲输入都有用武之地。 </p>
<p><strong>缓冲分为两类： 完全缓冲I/O和行缓冲I/O。</strong> </p>
<ul>
<li>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地） ， 通常出现在文件输入中。 缓冲区的大小取决于系统， 常见的大小是 512 字节和 4096字节。</li>
<li>行缓冲I/O指的是在出现换行符时刷新缓冲区。 键盘输入通常是行缓冲输入， 所以在按下Enter键后才刷新缓冲区 。</li>
</ul>
<h3 id="文件、流和键盘输入"><a href="#文件、流和键盘输入" class="headerlink" title="文件、流和键盘输入"></a>文件、流和键盘输入</h3><ul>
<li>文件（file） 是存储器中储存信息的区域。 通常， 文件都保存在某种永久存储器中（如， 硬盘、 U盘或DVD等） 。 </li>
<li>C可以使用主机操作系统的基本文件工具直接处理文件， 这些直接调用操作系统的函数被称为底层 I/O （low-level I/O） 。</li>
<li><strong>C程序处理的是流而不是直接处理文件。</strong> 流（stream） 是一个实际输入或输出映射的理想化数据流。 这意味着不同属性和不同种类的输入， 由属性更统一的流来表示。 于是， 打开文件的过程就是把流与文件相关联， 而且读写都通过流来完成。 从而达到屏蔽掉了不同系统的输入输出的差异， 以便用户使用统一的界面。 </li>
<li>C把输入和输出设备视为存储设备上的普通文件， 尤其是把键盘和显示设备视为每个C程序自动打开的文件。 stdin流表示键盘输入， stdout流表示屏幕输出。 getchar()、 putchar()、printf()和scanf()函数都是标准I/O包的成员， 处理这两个流。 </li>
</ul>
<p>总结：可以用处理文件的方式来处理键盘输入。 例如，程序读文件时要能检测文件的末尾才知应在何处停止。 因此， C 的输入函数内置了文件结尾检测器。 既然可以把键盘输入视为文件， 那么也应该能使用文件结尾检测器结束键盘输入。 </p>
<h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><p>计算机操作系统要以某种方式判断文件的开始和结束。</p>
<ul>
<li><p>在文件末尾放一个特殊的字符标记文件结尾。 图8.2演示了这种方法</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_10-38-48.png" alt="Snipaste_2019-02-21_10-38-48"></p>
</li>
<li><p>另一种方法是储存文件大小的信息。  如果文件有3000字节， 程序在读到3000字节时便达到文件的末尾。 </p>
</li>
</ul>
<p>无论操作系统实际使用何种方法检测文件结尾， 在C语言中， 用getchar()读取文件检测到文件结尾时将返回一个特殊的值， 即EOF（end offile的缩写） 。 scanf()函数检测到文件结尾时也返回EOF。 通常， EOF定义在stdio.h文件中： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure>
<p>如何在程序中使用EOF？ 把getchar()的返回值和EOF作比较。 如果两值不同， 就说明没有到达文件结尾。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br></pre></td></tr></table></figure>
<p>绝大部分系统（不是全部） 都有办法通过键盘模拟文件结尾条件（Enter）。完整程序如下</p>
<p>程序清单8.2 echo_eof.c程序 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* echo_eof.c -- 重复输入， 直到文件结尾 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h4><p>输入和输出涉及函数、 数据和设备。 例如， 上面 echo_eof.c程序， 该程序使用输入函数 getchar()，输出函putchar()。 输入/输出数据流由字符组成。 输入设备是键盘 ，输出设备是屏幕。</p>
<p> 假设你希望输入函数和数据类型不变， 仅改变程序查找数据的位置。 那么， 程序如何知道去哪里查找输入？ </p>
<p>默认情况下， C程序使用标准I/O包查找标准输入作为输入源。 即：stdin流， 它是把数据读入计算机的常用方式。 它可以是键盘或者时一个过时的设备， 如磁带、 穿孔卡或电传打印机， 甚至是一些先进技术， 如语音输入。 然而， 现代计算机非常灵活， 可以让它到别处查找输入。 尤其是， 可以让一个程序从文件中查找输入， 而不是从键盘。 </p>
<p><strong>程序可以通过两种方式使用文件</strong></p>
<ul>
<li>第 1 种方法是， 显式使用特定的函数打开文件、 关闭文件、 读取文件、 写入文件， 诸如此类。 </li>
<li>第2种方法是， 设计能与键盘和屏幕互动的程序， 通过不同的渠道重定向输入至文件和从文件输出。 换言之， 把stdin流重新赋给文件。 继续使用getchar()函数从输入流中获取数据， 但它并不关心从流的什么位置获取数据。 这种重定向的方法在某些方面有些限制， 但是用起来比较简单， 而且能让读者熟悉普通的文件处理技术。 </li>
</ul>
<p>重定向输入让程序使用文件而不是键盘来输入， 重定向输出让程序输出至文件而不是屏幕。 </p>
<p>重定向输入</p>
<p> 假设已经编译了echo_eof.c 程序 </p>
<p>现在要该程序处理名为words的文本文件输出到屏幕上 </p>
<p>./echo_eof &lt; words  ：&lt;符号是UNIX和DOS/Windows的重定向运算符， words为文本文件保存有“1314”。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-07-57.png" alt="Snipaste_2019-02-21_14-07-57"></p>
<h4 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h4><p>在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。  </p>
<p>echo_eof&gt;mywords  ：&gt;符号是重定向运算符。 它创建了一个名为mywords的新文件， 然<br>后把echo_eof的输出 重定向至该文件中。  </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-18.png" alt="Snipaste_2019-02-21_14-15-18"></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-46.png" alt="Snipaste_2019-02-21_14-15-46"></p>
<p>注：在下一行的开始处按下Ctrl+D（UNIX） 或Ctrl+Z（DOS） 即可结束该程序。 </p>
<h4 id="组合重定向"><a href="#组合重定向" class="headerlink" title="组合重定向"></a>组合重定向</h4><p>现在， 假设你希望制作一份mywords文件的副本， 并命名为savewords。只需输入以下命令即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_eof &lt; mywords &gt; savewords</span><br><span class="line"><span class="comment">//下面的命令也起作用， 因为命令与重定向运算符的顺序无关：</span></span><br><span class="line">echo_eof &gt; savewords &lt; mywords</span><br></pre></td></tr></table></figure>
<p>注意： 在一条命令中， 输入文件名和输出文件名不能相同。 </p>
<p><strong>在UNIX、 Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;） 时， 要遵循以下原则。</strong></p>
<ul>
<li><p>重定向运算符连接一个可执行程序（包括标准操作系统命令） 和一个数据文件， 不能用于连接一个数据文件和另一个数据文件， 也不能用于连接一个程序和另一个程序。</p>
</li>
<li><p>使用重定向运算符不能读取多个文件的输入， 也不能把输出定向至多个<br>文件 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fish &gt; beets ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; count ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; fish &lt; beets ←违反第<span class="number">2</span>条规则</span><br><span class="line">count &gt; beets fish ←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="创建更友好的用户界面"><a href="#创建更友好的用户界面" class="headerlink" title="创建更友好的用户界面"></a>创建更友好的用户界面</h3><p>学会避免编写一些中看不中用的程序，并创建更友好的用户界面， 让交互数据输入更方便， 减少错误输入的影响。 </p>
<p>略</p>
<h2 id="第二节：字符串符串输入-输出"><a href="#第二节：字符串符串输入-输出" class="headerlink" title="第二节：字符串符串输入/输出"></a>第二节：字符串符串输入/输出</h2><p>本章介绍以下内容：</p>
<ul>
<li><p>函数： gets_s()、 fgets()、 puts()、 fputs()、 strcat()、 strncat()、strcmp()、 strncmp()、 strcpy()、 strncpy()、 sprintf()、 strchr() </p>
</li>
<li><p>创建并使用字符串 </p>
</li>
<li>字符串是以空字符（\0）结尾的char类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过C也提供了许多专门用于处理字符串的函数</li>
<li>使用C库中的字符和字符串函数， 并创建自定义的字符串函数</li>
<li>使用命令行参数 </li>
</ul>
<p>字符串是以空字符（\0）结尾的char类型数组。 C提供了许多专门用于处理字符串的函数。本节将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。</p>
<p>程序清单11.1演示了在程序中表示字符串的几种方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">//　 strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MSG　<span class="meta-string">"I　am　a　symbolic　string　constant."</span> <span class="comment">//方法一：即字符串常量（字符串常量）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MAXLENGTH　81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>　words[MAXLENGTH]　=　<span class="string">"I　am　a　string　in　an　array."</span>; <span class="comment">//方法二：、char类型数组</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>; <span class="comment">//放法三：指向char的指针</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Here　are　some　strings:"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(MSG);</span><br><span class="line">	<span class="built_in">puts</span>(words);</span><br><span class="line">	<span class="built_in">puts</span>(pt1);</span><br><span class="line">    words[<span class="number">8</span>]　=　<span class="string">'p'</span>;</span><br><span class="line">	<span class="built_in">puts</span>(words);</span><br><span class="line">	<span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Here are some strings:</span><br><span class="line">I am an old-fashioned symbolic <span class="built_in">string</span> constant.</span><br><span class="line">I am a <span class="built_in">string</span> in an <span class="built_in">array</span>.</span><br><span class="line">Something is pointing at me.</span><br><span class="line">I am a spring in an <span class="built_in">array</span>.</span><br></pre></td></tr></table></figure>
<p>程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向<br>char的指针）定义字符串。</p>
<h3 id="如何定义字符串"><a href="#如何定义字符串" class="headerlink" title="如何定义字符串"></a>如何定义字符串</h3><h4 id="1-字符串字面量（字符串常量）"><a href="#1-字符串字面量（字符串常量）" class="headerlink" title="1.字符串字面量（字符串常量）"></a>1.字符串字面量（字符串常量）</h4><p>定义：用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中。</p>
<p>所以<em>“I am a symbolic stringconstant.”</em>  、<em>“I739am a string in an array.”</em>  、<em>“Something is pointed at me.”</em> 、<em>“Here are somestrings:”</em>都是字符串字面量。</p>
<p>从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：</p>
<p><em>char greeting[50] = “Hello, and”</em></p>
<p><em>“ how are” “ you”</em></p>
<p><em>“ today!”;</em></p>
<p>与下面的代码等价：char greeting[50] = “Hello, and how are you today!</p>
<p><strong>注意：如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\“）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。</p>
<h4 id="2-字符串数组初始化"><a href="#2-字符串数组初始化" class="headerlink" title="2.字符串数组初始化"></a>2.字符串数组初始化</h4><p>定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种形式的初始化比标准的数组初始化形式简单得多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常，让编译器确定数组的大小很方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。</p>
<p>##### </p>
<h4 id="3-指针和字符串"><a href="#3-指针和字符串" class="headerlink" title="3.指针和字符串"></a>3.指针和字符串</h4><p>实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5<br>中的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.5</span> p_and_s.c程序</span><br><span class="line"><span class="comment">/* p_and_s.c -- 指针和字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * mesg = <span class="string">"Don't be a fool!"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * copy;</span><br><span class="line">    copy = mesg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, copy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mesg = %s; &amp;mesg = %p; value = %p\n"</span>, mesg,&amp;mesg, mesg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"copy = %s; &amp;copy = %p; value = %p\n"</span>, copy,&amp;copy, copy);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line">Don't be a fool!</span><br><span class="line">mesg = Don't be a fool!; &amp;mesg = <span class="number">0x0012ff48</span>; value =<span class="number">0x0040a000</span></span><br><span class="line">copy = Don't be a fool!; &amp;copy = <span class="number">0x0012ff44</span>; value =<span class="number">0x0040a000</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li><p>首先第1项，mesg和copy都以字符串形式输出（%s转换说明）。这里没问题，两个字符串都是”Don’t be a fool!”。</p>
</li>
<li><p>第2项，打印两个指针的地址。如上输出所示，指针mesg和copy分别储存在地址为0x0012ff48和0x0012ff44的内存中。</p>
</li>
<li><p>意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。<em>语句copy = mesg;把mesg的值赋给copy，即让copy也指向mesg指向的字符。</em></p>
</li>
</ul>
<h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。</p>
<h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>字符串输入要做的第 1 件事是分配空间，以储存稍后读入的字符串。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">char</span> *name;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>最简单的方法是，在声明时显式指明数组的大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">81</span>];</span><br></pre></td></tr></table></figure>
<p>假设编写了如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">// strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"I am a symbolic string constant."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLENGTH 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har words[MAXLENGTH] = <span class="string">"I am a string in an array."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here are some strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line"> words[<span class="number">8</span>] = <span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的写法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="gets-函数"><a href="#gets-函数" class="headerlink" title="gets()函数"></a>gets()函数</h4><p>在读取字符串时， scanf()和转换说明%s只能读取一个单词。 可是在程序中经常要读取一整行输入， 而不仅仅是一个单词。 程序中读取一整行输入时需要使用gets()函数。</p>
<p> gets()函数简单易用， 它读取整行输入， 直至遇到换行符， 然后丢弃换行符， 储存其余字符， 并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。  </p>
<p><em>注：它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。（字符串输出介绍）</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.6</span> getsputs.c程序</span><br><span class="line"><span class="comment">/* getsputs.c -- 使用 gets() 和 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">	gets(words); <span class="comment">// 典型用法，用于输入字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Your string twice:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, words);</span><br><span class="line">	<span class="built_in">puts</span>(words);<span class="comment">//用于输出字符串，效果和print相同。</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">	Enter a <span class="built_in">string</span>, please.</span><br><span class="line">	I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">	Your <span class="built_in">string</span> twice:</span><br><span class="line">	I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">	I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">	Done.</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// gets整行输入（除了换行符） 都被储存在 words 中， puts(words) 和printf("%s\n, words")的效果相同。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>gets()唯一的参数是 words，它无法检查数组是否装得下输入行。数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。</p>
<p>如果输入的字符串过长， 会导致缓冲区溢出（buffer overflow） ， 即多余的字符超出了指定的目标空间。 如果这些多余的字符只是占用了尚未使用的内存， 就不会立即出现问题； 如果它们擦写掉程序中的其他数据， 会导致程序异常中止； 或者还有其他情况。（问题和上面分配空间相似。）</p>
<h5 id="gets-的替代品"><a href="#gets-的替代品" class="headerlink" title="gets()的替代品"></a>gets()的替代品</h5><p>由于容易出现“Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的。因此C 编程社区的许多人都建议在编程时摒弃 gets()。</p>
<h5 id="1-fgets-函数"><a href="#1-fgets-函数" class="headerlink" title="1.fgets()函数"></a>1.fgets()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> bufsize, FILE *stream)</span></span>;</span><br><span class="line">参数</span><br><span class="line">*buf: 字符型指针，指向用来存储所得数据的地址。</span><br><span class="line">bufsize: 整型数据，指明存储数据的大小。</span><br><span class="line">*stream: 文件结构体指针，将要读取的文件流。</span><br></pre></td></tr></table></figure>
<p>fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。 该函数专门设计用于处理文件输入， 所以一般情况下可能不太好用。 </p>
<p><strong>fgets()和gets()的区别如下</strong></p>
<ul>
<li>fgets()函数的第2个参数指明了读入字符的最大数量。 如果该参数的值是n， 那么fgets()将读入n-1个字符， 或者读到遇到的第一个换行符为止。 </li>
<li>如果fgets()读到一个换行符， 会把它储存在字符串中。 （fgets()会保留换行符， gets()会丢弃换行符。 ）</li>
<li>fgets()函数的第3 个参数指明要读入的文件。 如果读入从键盘输入的数据， 则以stdin（标准输入） 作为参数。</li>
</ul>
<p>因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出） ， 通常要与 fputs()函数（和puts()类似） 配对使用， 除非该函数不在字符串末尾 添加换行符。 </p>
<p>fputs()函数的第2个参数指明它要写入的文件。 如果要显示在计算机显示器上， 应使用stdout（标准输出） 作为该参数。 （fputs后面介绍）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.7</span> fgets1.c程序</span><br><span class="line"><span class="comment">/* fgets1.c -- 使用 fgets() 和 fputs() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">	fgets(words, STLEN, <span class="built_in">stdin</span>);<span class="comment">//words为写入内容，STLEN存储数据大小,stdin指向读取文件指针为标准输入。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(words);</span><br><span class="line">	<span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Enter another string, please."</span>);</span><br><span class="line">	fgets(words, STLEN, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(words);</span><br><span class="line">	<span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">下面是该程序的输出示例：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">apple pie</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">apple pie</span><br><span class="line">apple pie</span><br><span class="line">Enter another <span class="built_in">string</span>, please.</span><br><span class="line">strawberry shortcake</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">strawberry sh</span><br><span class="line">strawberry shDone.</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>第1行输入， apple pie， 比fgets()读入的整行输入短， 因此， apple pie\n\0被储存在数组中。 所以当puts()显示该字符串时又在末尾添加了换行符， 因此apple pie后面有一行空行。 因为fputs()不在字符串末尾添加换行符， 所以并未打印出空行。</li>
<li>第2行输入， strawberry shortcake， 超过了大小的限制， 所以fgets()只读入了13个字符， 并把strawberry sh\0 储存在数组中。 再次提醒读者注意，puts()函数会在待输出字符串末尾添加一个换行符， 而fputs()不会这样做。 </li>
</ul>
<h5 id="2-gets-s-函数"><a href="#2-gets-s-函数" class="headerlink" title="2.gets_s()函数"></a>2.gets_s()函数</h5><p>过去通常用fgets()来代替gets()， fgets()函数稍微复杂些， 在处理输入方面与gets()略有不同。 C11标准新增的gets_s()函数也可代替gets()。 该函数与gets()函数更接近， 而且可以替换现有代码中的gets()。 但是， 它是stdio.h输入/输出函数系列中的可选扩展， 所以支持C11的编译器也不一定支持它。 </p>
<p>C11新增的gets_s()函数（可选） 和fgets()类似， 用一个参数限制读入的字符数。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets_s</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">size_t</span> sizeInCharacters)</span></span>;</span><br></pre></td></tr></table></figure>
<p>gets_s()与fgets()的区别如下。</p>
<p>gets_s()只从标准输入中读取数据， 所以不需要第3个参数。</p>
<p>如果gets_s()读到换行符， 会丢弃它而不是储存它。</p>
<h5 id="3-s-gets-函数"><a href="#3-s-gets-函数" class="headerlink" title="3.s_gets()函数"></a>3.s_gets()函数</h5><p>程序清单11.9演示了fgets()函数的一种用法： 读取整行输入并用空字符<br>代替换行符， 或者读取一部分输入， 并丢弃其余部分。 既然没有处理这种情<br>况的标准函数， 我们就创建一个， 在后面的程序中会用得上。 程序清单<br>11.10提供了一个这样的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.10</span> s_gets()函数</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>); </span><br><span class="line"> 	<span class="keyword">if</span> (ret_val) <span class="comment">// 即， ret_val != NULL</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">			st[i] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：如果 fgets()返回 NULL， 说明读到文件结尾或出现读取错误， s_gets()函数跳过了这个过程。 它模仿程序清单11.9的处理方法， 如果字符串中出现换行符， 就用空字符替换它； 如果字符串中出现空字符， 就丢弃该输入行的其余字符， 然后返回与fgets()相同的值。 </p>
<h4 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h4><p>scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾：scanf()更像是“获取单词”函数， 而不是“获取字符串”函数； 如果预留的存储区装得下输入行， gets()和fgets()会读取第1个换行符之前所有的字符。 </p>
<p>scanf()函数有两种方法确定输入结束。 无论哪种方法， 都从第1个非空白字符作为字符串的开始。 </p>
<ul>
<li>如果使用%s转换说明， 以下一个空白字符（空行、空格、 制表符或换行符） 作为字符串的结束（字符串不包括空白字符） 。</li>
<li>如果指定了字段宽度， 如%10s， 那么scanf()将读取10 个字符或读到第1个空白<br>字符停止（先满足的条件即是结束输入的条件） ， 见图11.3。 </li>
</ul>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-25_20-49-47.png" alt="Snipaste_2019-02-25_20-49-47"></p>
<p>scanf()函数返回一个整数值， 该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF） 。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.11</span> scan_str.c程序</span><br><span class="line"><span class="comment">/* scan_str.c -- 使用 scanf() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> name1[<span class="number">11</span>], name2[<span class="number">11</span>];</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please enter 2 names.\n"</span>);</span><br><span class="line">	count = <span class="built_in">scanf</span>(<span class="string">"%5s %10s"</span>, name1, name2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I read the %d names %s and %s.\n"</span>, count, name1,me2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的3个输出示例：</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Jesse Jukes</span></span><br><span class="line"><span class="comment">I read the 2 names Jesse and Jukes.</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Portensia Callowit</span></span><br><span class="line"><span class="comment">I read the 2 names Porte and nsia.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>分析：第1个输出示例， 两个名字的字符个数都未超过字段宽度。 第2个输出示例， 只读入了Applebottham的前10个字符Applebotth（因为使用了%10s转换说明） 。 第3个输出示例， Portensia的后4个字符nsia被写入name2中， 因为第2次调用scanf()时， 从上一次调用结束的地方继续读取数据。 在该例中， 读取的仍是Portensia中的字母。 </p>
<p>scanf()和gets()类似， 也存在一些潜在的缺点。 如果输入行的内容过长，scanf()也会导致数据溢出。 不过， 在%s转换说明中使用字段宽度可防止溢出。 </p>
<h3 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h3><p>C有3个标准库函数用于打印字符串： put()、 fputs()和printf() 。</p>
<h4 id="puts-函数"><a href="#puts-函数" class="headerlink" title="puts()函数"></a>puts()函数</h4><p>puts()函数很容易使用， 只需把字符串的地址作为参数传递给它即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.12</span> put_out.c程序</span><br><span class="line"><span class="comment">/* put_out.c -- 使用 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF <span class="meta-string">"I am a #defined string."</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">80</span>] = <span class="string">"An array was initialized to me."</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * str2 = <span class="string">"A pointer was initialized to me."</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"I'm an argument to puts()."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(DEF);</span><br><span class="line">	<span class="built_in">puts</span>(str1);</span><br><span class="line">	<span class="built_in">puts</span>(str2);</span><br><span class="line">	<span class="built_in">puts</span>(&amp;str1[<span class="number">5</span>]);</span><br><span class="line"> 	<span class="built_in">puts</span>(str2 + <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">I'm an argument to puts().</span><br><span class="line">I am a <span class="meta">#defined string.</span></span><br><span class="line">An <span class="built_in">array</span> was initialized to me.</span><br><span class="line">A pointer was initialized to me.</span><br><span class="line">ray was initialized to me.</span><br><span class="line">inter was initialized to me.</span><br></pre></td></tr></table></figure>
<p>注：每个字符串独占一行， 因为puts()在显示字符串时会自动在其末尾添加一个换行符。 （这点太舒服了，printf()还要自己加换行。）</p>
<p>puts()如何知道在何处停止？ 该函数在遇到换行符时就停止输出， 所以必须确保有换行符。 不要模仿程序清单11.13中的程序！ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.13</span> nono.c程序</span><br><span class="line"><span class="comment">/* nono.c -- 千万不要模仿！ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> side_a[] = <span class="string">"Side A"</span>;</span><br><span class="line">	<span class="keyword">char</span> dont[] = &#123; <span class="string">'W'</span>, <span class="string">'O'</span>, <span class="string">'W'</span>, <span class="string">'!'</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> side_b[] = <span class="string">"Side B"</span>;</span><br><span class="line">	<span class="built_in">puts</span>(dont); <span class="comment">/* dont 不是一个字符串，是个wow！字节 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：由于dont缺少一个表示结束的空字符， 所以它不是一个字符串， 因此puts()不知道在何处停止。 它会一直打印dont后面内存中的内容， 直到发现一个空字符为止。 为了让puts()能尽快读到空字符， 我们把dont放在side_a和side_b之间。 下面是该程序的一个运行示例：<br>WOW!Side A </p>
<h4 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs()函数"></a>fputs()函数</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line">（<span class="number">1</span>）str：这是一个数组，包含了要写入的以空字符终止的字符序列。</span><br><span class="line">（<span class="number">2</span>）stream：指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</span><br><span class="line">返回值：该函数返回一个非负值，如果发生错误则返回 EOF(<span class="number">-1</span>)。</span><br></pre></td></tr></table></figure>
<p>fputs()函数是puts()针对文件定制的版本。 </p>
<p>它们的区别如下：</p>
<ul>
<li>fputs()函数的第 2 个参数指明要写入数据的文件。 如果要打印在显示器上， 可以用定义在stdio.h中的stdout（标准输出） 作为该参数。  </li>
<li>与puts()不同， fputs()不会在输出的末尾添加换行符。 </li>
</ul>
<p>注意： gets()丢弃输入中的换行符， 但是puts()在输出中添加换行符。 另一方面， fgets()保留输入中的换行符， fputs()不在输出中添加换行符。 （好绕）</p>
<h3 id="常见字符串处理函数"><a href="#常见字符串处理函数" class="headerlink" title="常见字符串处理函数"></a>常见字符串处理函数</h3><p>C库提供了多个处理字符串的函数， ANSI C把这些函数的原型放在string.h头文件中。 其中最常用的函数strlen()、 strcat()、 strcmp()、strncmp()、 strcpy()和 strncpy()。 另外， 还有sprintf()函数， 其原型在stdio.h头文件中。 </p>
<p><strong>1.strlen()函数 ：用于统计字符串的长度。</strong> </p>
<p>略</p>
<p><strong>2.strcat()函数 ：用于拼接字符串</strong></p>
<p> 函数接受两个字符串作为参数。 该函数把第2个字符串的备份附加在第1个字符串末尾， 并把拼接后形成的新字符串作为第1个字符串， 第2个字符串不变。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.18</span> str_cat.c程序</span><br><span class="line"><span class="comment">/* str_cat.c -- 拼接两个字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* strcat()函数的原型在该头文件中 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">	<span class="keyword">char</span> addon [] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line"><span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">	<span class="built_in">puts</span>(flower);</span><br><span class="line">	<span class="built_in">puts</span>(addon);</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">			st[i] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出示例如下：</span></span><br><span class="line"><span class="comment">What is your favorite flower?</span></span><br><span class="line"><span class="comment">wonderflower</span></span><br><span class="line"><span class="comment">wonderflowers smell like old shoes.</span></span><br><span class="line"><span class="comment">s smell like old shoes.</span></span><br><span class="line"><span class="comment">bye</span></span><br><span class="line"><span class="comment">从以上输出可以看出， flower改变了， 而addon保持不变。</span></span><br></pre></td></tr></table></figure>
<p><strong>3.strcmp()函数</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">设这两个字符串为str1，str2，</span><br><span class="line">若str1=str2，则返回零；</span><br><span class="line">若str1&lt;str2，则返回负数；</span><br><span class="line">若str1&gt;str2，则返回正数。</span><br></pre></td></tr></table></figure>
<p><strong>4.sprintf()函数</strong></p>
<p> 是字符串格式化命令,主要功能是把格式化的数据写入某个字符串中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原型</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [ argument] … )</span></span>;</span><br><span class="line">参数列表</span><br><span class="line">buffer：<span class="keyword">char</span>型指针，指向将要写入的字符串的缓冲区。</span><br><span class="line">format：格式化字符串。</span><br><span class="line">[argument]...：可选参数，可以是任何类型的数据。nst <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crt_sprintf.c</span></span><br><span class="line"><span class="comment">// compile with: /W3</span></span><br><span class="line"><span class="comment">// This program uses sprintf to format various</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//data and place them in the string named buffer.</span></span><br><span class="line"><span class="comment">// 程序使用sprintf 将各种数据格式化后置于字符数组buffer中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">   <span class="keyword">int</span>   i = <span class="number">35</span>, j;</span><br><span class="line">   <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">   <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">   j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"   String:    %s\n"</span>, s ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Character: %c\n"</span>, c ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Integer:   %d\n"</span>, i ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Real:      %f\n"</span>, fp );<span class="comment">// C4996</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>, buffer, j );</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果 [<span class="number">1</span>]  ：</span><br><span class="line">Output:</span><br><span class="line">String: computer </span><br><span class="line">　　</span><br><span class="line">Character: l</span><br><span class="line">Integer: <span class="number">35</span></span><br><span class="line">Real: <span class="number">1.732053</span></span><br><span class="line">character count = <span class="number">79</span></span><br></pre></td></tr></table></figure>
<p><strong>其他字符串函数</strong> </p>
<ol>
<li><p>char <em>strcpy(char </em> restrict s1, const char * restrict s2);</p>
<p>该函数把s2指向的字符串（包括空字符） 拷贝至s1指向的位置， 返回值是s1。</p>
</li>
<li><p>char <em>strncpy(char </em> restrict s1, const char * restrict s2, size_t n);</p>
<p>该函数把s2指向的字符串拷贝至s1指向的位置， 拷贝的字符数不超过n， 其返回值是s1该函数不会拷贝空字符后面的字符， 如果源字符串的字符少于n个， 目标字符串就以拷贝的空字符尾； 如果源字符串有n个或超过n个字符， 就不拷贝空字符。</p>
</li>
<li><p>char <em>strcat(char </em> restrict s1, const char * restrict s2);</p>
<p>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 该函数返回s1。</p>
</li>
<li><p>char <em>strncat(char </em> restrict s1, const char * restrict s2, size_t n);</p>
<p>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 不会拷贝s2字符串中空字符和其后的字符， 并在拷贝字符的末尾添加一个空字符。 该函数返回s1。</p>
</li>
<li><p>int strcmp(const char <em> s1, const char </em> s2);</p>
<p>如果s1字符串在机器排序序列中位于s2字符串的后面， 该函数返回一个正数； 如果两个字符串相等， 则返回0； 如果s1字符串在机器排序序列中位于s2字符串的前面， 则返回一个负数。</p>
</li>
<li><p>int strncmp(const char <em> s1, const char </em> s2, size_t n);</p>
<p>该函数的作用和strcmp()类似， 不同的是， 该函数在比较n个字符后或遇到第1个空字符时停止比较。</p>
</li>
<li><p>char <em>strchr(const char </em> s, int c);</p>
<p>如果s字符串中包含c字符， 该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分， 所以在查找范围内） ； 如果在字符串s中  </p>
</li>
</ol>
<h3 id="输入-输出的应用技巧"><a href="#输入-输出的应用技巧" class="headerlink" title="输入/输出的应用技巧"></a>输入/输出的应用技巧</h3><h4 id="自定义输入-输出函数"><a href="#自定义输入-输出函数" class="headerlink" title="自定义输入/输出函数"></a>自定义输入/输出函数</h4><p>实际使用中，不一定非要使用C库中的标准函数， 如果无法使用这些函数或者想扩张输入/输出的某一功能， 完全可以在getchar()和putchar()的基础上自定义所需的函数。 </p>
<p>下面两个经典的自定义输入/输出函数 </p>
<p>1.字符串， 不添加\n </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.14</span> put1()函数</span><br><span class="line"><span class="comment">/* put1.c -- 打印字符串， 不添加\n */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span><span class="comment">/* 不会改变字符串 */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">while</span> (*<span class="built_in">string</span> != <span class="string">'\0'</span>)</span><br><span class="line">	<span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指向char的指针string最初指向传入参数的首元素。 因为该函数不会改变<br>传入的字符串， 所以形参使用了const限定符。 打印了首元素的内容后， 指<br>针递增1， 指向下一个元素。 while循环重复这一过程， 直到指针指向包含空<br>字符的元素。  </p>
<p>++的优先级高于<em>， 因此putchar(</em>string++)打印string指向的值， 递增的是string本身， 而不是递增它所指向的字符。 （即先比较厚打印，当比较到\0时退出）</p>
<p>2.设计一个类似puts()的函数， 而且该函数还给出待打印字符的个数。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* put2.c -- 打印一个字符串， 并统计打印的字符数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">put2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*<span class="built_in">string</span>) <span class="comment">/* 常规用法 */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">	count++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>); <span class="comment">/* 不统计换行符 */</span></span><br><span class="line">	<span class="keyword">return</span>(count);</span><br><span class="line">&#125;</span><br><span class="line">num = put2(<span class="string">"pizza"</span>);<span class="comment">//调用将返回统计的字符数， 并将其赋给num</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><p>我们来处理一个按字母表顺序排序字符串的实际问题。 准备名单表、 创建索引和许多其他情况下都会用到字符串排序。 该程序主要是用 strcmp()函数来确定两个字符串的顺序。 一般的做法是读取字符串函数、 排序字符串并打印出来。  </p>
<p>略</p>
<h4 id="把字符串转换为数字"><a href="#把字符串转换为数字" class="headerlink" title="把字符串转换为数字"></a>把字符串转换为数字</h4><p>数字既能以字符串形式储存， 也能以数值形式储存。 把数字储存为字符串就是储存数字字符。 例如， 数字213以’2’、 ‘1’、 ‘3’、 ‘\0’的形式被储存在字符串数组中。 以数值形式储存213， 储存的是int类型的值。 </p>
<p>略</p>
<h2 id="第三节：文件输入-输出"><a href="#第三节：文件输入-输出" class="headerlink" title="第三节：文件输入/输出"></a>第三节：文件输入/输出</h2><p>本章介绍以下内容函数：</p>
<ul>
<li>fopen()、 getc()、 putc()、 exit()、 fclose()</li>
<li>fprintf()、 fscanf()、 fgets()、 fputs()</li>
<li>rewind()、 fseek()、 ftell()、 fflush()</li>
<li>fgetpos()、 fsetpos()、 feof()、 ferror()</li>
<li>ungetc()、 setvbuf()、 fread()、 fwrite()</li>
</ul>
<p>如何使用C标准I/O系列的函数处理文件文件模式和二进制模式、 文本和二进制格式、 缓冲和无缓冲I/O<br>使用既可以顺序访问文件也可以随机访问文件的函数文件是当今计算机系统不可或缺的部分。 文件用于储存程序、 文档、 数据、 书信、 表格、 图形、 照片、 视频和许多其他种类的信息。 作为程序员，必须会编写创建文件和从文件读写数据的程序。 本章将介绍相关的内容。</p>
<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><ol>
<li><p><strong>文件（file）</strong></p>
<p>文件（file）： 通常是在磁盘或固态硬盘上的一段已命名的存储区。 对我们而言， stdio.h就是一个文件的名称， 该文件中包含一些有用的信息 。</p>
<p>C把文件看作是一系列连续的字节， 每个字节都能被单独读取。 C提供两种文件模式： 文本模式和二进制模式。 </p>
</li>
<li><p><strong>文本模式和二进制模式</strong> </p>
<p>所有文件的内容都以二进制形式（0或1） 储存。 但是， 如果文件最初使用二进制编码的字符（例如， ASCII或Unicode） 表示文本（就像C字符串那样） ， 该文件就是文本文件， 其中包含文本内容。 如果文件中的二进制值代<br>表机器语言代码或数值数据（使用相同的内部表示， 假设， 用于long或double类型的值） 或图片或音乐编码， 该文件就是二进制文件， 其中包含二进制内容。 </p>
</li>
<li><p><strong>I/O的级别</strong> </p>
<p>除了选择文件的模式， 大多数情况下， 还可以选择I/O的两个级别（即处理文件访问的两个级别） 。 底I/O（low-level I/O） 使用操作系统提供的基本I/O服务。 标准高级I/O（standard high-level I/O） 使用C库的标准包和stdio.h头文件定义。 </p>
</li>
<li><p><strong>标准文件</strong>  </p>
<p>C程序会自动打开3个文件， 它们被称为标准输入（standard input） 、 标准输出（standard output） 和标准错误输出（standard error output） 。 在默认情况下， 标准输入是系统的普通输入设备， 通常为键盘； 标准输出和标准错误输出是系统的普通输出设备， 通常为显示屏 </p>
<p>标准输入为程序提供输入， 它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出， 它是putchar()、 puts()和printf()使用的文件。  </p>
</li>
</ol>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>与底层I/O相比， 标准I/O包除了可移植以外还有两个好处。 </p>
<p>第一， 标准I/O有许多专门的函数简化了处理不同I/O的问题。 例如， printf()把不同形式的数据转换成与终端相适应的字符串输出。 </p>
<p>第二， 输入和输出都是缓冲的。也就是说， 一次转移一大块信息而不是一字节信息（通常至少512字节） 。 例如， 当程序读取文件时， 一块数据被拷贝到缓冲区（一块中介存储区域） 。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.1</span> count.c程序</span><br><span class="line"><span class="comment">/* count.c -- 使用标准 I/O */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // 提供 exit()的原型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ch; <span class="comment">// 读取文件时， 储存每个字符的地方</span></span><br><span class="line">	FILE *fp; <span class="comment">// “文件指针”</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s filename\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = getc(fp)) != EOF)</span><br><span class="line">	&#123; </span><br><span class="line">        putc(ch, <span class="built_in">stdout</span>); <span class="comment">// 与putchar(ch); 相同</span></span><br><span class="line">		count++;</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File %s has %lu characters\n"</span>, argv[<span class="number">1</span>], count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检查命令行参数"><a href="#检查命令行参数" class="headerlink" title="检查命令行参数"></a>检查命令行参数</h4><p>程序清单中的程序检查argc的值， 查看是否有命令行参数。如果没有， 程序将打印一条消息并退出程序。 字符串 argv[0]是该程序的名称。 显式使用 argv[0]而不是程序名， 错误消息的描述会随可执行文件名的改变而自动改变。</p>
<p><em>补充：int main(int argc,char</em> argv[ ])</p>
<ul>
<li><em>argc：是命令行总的参数个数</em><br>​    argv[]是argc个参数，其中第0个参数是程序的全名，以后的参数命令行后面跟的用户输入的参数，</li>
<li><em>char </em>argv[]：是一个字符数组,其大小是int argc,<em><br>​       </em>主要用于命令行参数argv[]参数，数组里每个元素代表一个参数;*</li>
</ul>
<h4 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h4><p>程序使用fopen()函数打开文件。 该函数声明在stdio.h中。  </p>
<p>它的第1个参数是待打开文件的名称， 更确切地说是一个包含<br>改文件名的字符串地址。 第 2 个参数是一个字符串， 指定待打开文件的模<br>式。  下表列出了C库提供的一些模式。 </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_10-46-41.png" alt="Snipaste_2019-02-26_10-46-41"></p>
<p>**</p>
<p><em>注意：如果使用任何一种”w”模式（不带x字母） 打开一个现有文件， 该文件的内容会被删除， 以便程序在一个空白文件中开始操作。 然而， 如果使用带x字母的任何一种模式， 将无法打开一个现有文件。</em></p>
<p>序成功打开文件后， fopen()将返回文件指针（file pointer） ， 其他I/O 函数可以使用这个指针指定该文件。  </p>
<p>文件指针（该例中是fp） 的类型是指向FILE的指针， FILE是一个定义在stdio.h中的派生类型。 文件指针fp并不指向实际的文件， 它指向一个包含文件信息的数据对象， 其中包含操作文件的<br>I/O函数所用的缓冲区信息。</p>
<p><em>理解：好像是fopen的话 会创建一个FILE的数据结构，用于保存 打开的文件信息 ，然后使用指针指向该数据结构</em></p>
<h4 id="getc-和putc-函数"><a href="#getc-和putc-函数" class="headerlink" title="getc()和putc()函数"></a>getc()和putc()函数</h4><p>getc()和putc()函数与getchar()和putchar()函数类似。 所不同的是， 要告诉<br>getc()和putc()函数使用哪一个文件。 </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch = getchar();<span class="comment">//从标准输入中获取一个字符，一般指键盘”： </span></span><br><span class="line">ch = getc(fp); <span class="comment">//从fp指定的文件中获取一个字符</span></span><br><span class="line">putc(ch, fpout);<span class="comment">//把字符ch放入FILE指针fpout指定的文件中</span></span><br><span class="line"><span class="comment">//第1个参数是待写入的字符， 第2个参数是文件指针。</span></span><br></pre></td></tr></table></figure>
<h4 id="文件结尾-1"><a href="#文件结尾-1" class="headerlink" title="文件结尾"></a>文件结尾</h4><p>读取数据时程序时如何知道文件结尾的，getc()函数在读取一个字符时发现是文件结尾， 它将返回一个特殊值EOF。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(<span class="string">"wacky.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">while</span> (( ch = getc(fp)) != EOF)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(ch); <span class="comment">//处理输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.fclose()函数   </p>
<p>fclose(fp)函数关闭fp指定的文件， 必要时刷新缓冲区。 对于较正式的程<br>序， 应该检查是否成功关闭文件。 如果成功关闭， fclose()函数返回0， 否则<br>返回EOF： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error in closing file %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//如果磁盘已满、 移动硬盘被移除或出现I/O错误， 都会导致调用fclose()函数失败。</span></span><br></pre></td></tr></table></figure>
<h4 id="应用：一个简单的文件压缩程序"><a href="#应用：一个简单的文件压缩程序" class="headerlink" title="应用：一个简单的文件压缩程序"></a>应用：一个简单的文件压缩程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.2</span> reducto.c程序</span><br><span class="line"><span class="comment">// reducto.c –把文件压缩成原来的1/3！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // 提供 exit()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // 提供 strcpy()、 strcat()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 40</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *in, *out; <span class="comment">// 声明两个指向 FILE 的指针</span></span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="keyword">char</span> name[LEN]; <span class="comment">// 储存输出文件名</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s filename\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//设置输入</span></span><br><span class="line"><span class="keyword">if</span> ((in = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"I couldn't open the file \"%s\"\n"</span>,</span><br><span class="line">	argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//设置输出</span></span><br><span class="line"><span class="built_in">strncpy</span>(name, argv[<span class="number">2</span>], LEN - <span class="number">5</span>); <span class="comment">// 拷贝文件名</span></span><br><span class="line">name[LEN - <span class="number">5</span>] = <span class="string">'\0'</span>;<span class="comment">//参数LEN-5确保了预留有5个空字符添加.red后缀而不溢出</span></span><br><span class="line"><span class="built_in">strcat</span>(name, <span class="string">".red"</span>); <span class="comment">// 在文件名后添加.red</span></span><br><span class="line"> <span class="keyword">if</span> ((out = fopen(name, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 以写模式打开文件</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create output file.\n"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//拷贝数据</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(in)) != EOF)</span><br><span class="line"><span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">	putc(ch, out);<span class="comment">// 打印3个字符中的第1个字符</span></span><br><span class="line"><span class="comment">// 收尾工作</span></span><br><span class="line">	<span class="keyword">if</span> (fclose(in) != <span class="number">0</span> || fclose(out) != <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in closing files\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设可执行文件名是reducto， 待读取的文件名为eddy， 该文件中包含下面一行内容：</span></span><br><span class="line"><span class="comment">So even Eddy came oven ready.</span></span><br><span class="line"><span class="comment">命令如下：</span></span><br><span class="line"><span class="comment">reducto eddy</span></span><br><span class="line"><span class="comment">待写入的文件名为eddy.red。 该程序把输出显示在eddy.red中， 而不是屏幕上。打开eddy.red， 内容如下：</span></span><br><span class="line"><span class="comment">Send money</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="文件I-O：-fprintf-、-fscanf-、-fgets-和fputs"><a href="#文件I-O：-fprintf-、-fscanf-、-fgets-和fputs" class="headerlink" title="文件I/O： fprintf()、 fscanf()、 fgets()和fputs()"></a>文件I/O： fprintf()、 fscanf()、 fgets()和fputs()</h3><p>文件I/O函数要用FILE指针指定待处理的文件。这些函数都要求用指向 FILE 的指针（如， stdout） 指定一个文件， 或者使用fopen()的返回值   fprintf()和fscanf()函数 </p>
<h4 id="fprintf-和fscanf-函数"><a href="#fprintf-和fscanf-函数" class="headerlink" title="fprintf()和fscanf()函数"></a>fprintf()和fscanf()函数</h4><p>文件I/O函数fprintf()和fscanf()函数的工作方式与printf()和scanf()类似，区别在于前者需要用第1个参数指定待处理的文件。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.3</span> addaword.c程序</span><br><span class="line"><span class="comment">/* addaword.c -- 使用 fprintf()、 fscanf() 和 rewind() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 41</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">char</span> words[MAX];</span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">"wordy"</span>, <span class="string">"a+"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; </span><br><span class="line">        	<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Can't open \"wordy\" file.\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Enter words to add to the file; press the #"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"key at the beginning of a line to terminate."</span>);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">"%40s"</span>, words) == <span class="number">1</span>) &amp;&amp; (words[<span class="number">0</span>] != <span class="string">'#'</span>))</span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">"%s\n"</span>, words);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"File contents:"</span>);</span><br><span class="line">	rewind(fp); <span class="comment">/* 返回到文件开始处 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, words) == <span class="number">1</span>)	</span><br><span class="line">	<span class="built_in">puts</span>(words);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error closing file\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fgets-和fputs-函数"><a href="#fgets-和fputs-函数" class="headerlink" title="fgets()和fputs()函数"></a>fgets()和fputs()函数</h4><h4 id="随机访问：-fseek-和ftell"><a href="#随机访问：-fseek-和ftell" class="headerlink" title="随机访问： fseek()和ftell()"></a>随机访问： fseek()和ftell()</h4><p>…待续</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/linux环境配置.html" rel="next" title="linux环境配置">
                <i class="fa fa-chevron-left"></i> linux环境配置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/C指针：基本概念、核心技术及最佳实践.html" rel="prev" title="C指针：基本概念、核心技术及最佳实践">
                C指针：基本概念、核心技术及最佳实践 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章：基数知识"><span class="nav-number">1.</span> <span class="nav-text">第一章：基数知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节：数据和C"><span class="nav-number">1.1.</span> <span class="nav-text">第一节：数据和C</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#strlen和sizeof"><span class="nav-number">1.1.1.</span> <span class="nav-text">strlen和sizeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量和c预处理器"><span class="nav-number">1.1.2.</span> <span class="nav-text">常量和c预处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#明示常量"><span class="nav-number">1.1.3.</span> <span class="nav-text">明示常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-和scanf"><span class="nav-number">1.1.4.</span> <span class="nav-text">printf()和scanf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式"><span class="nav-number">1.1.5.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句"><span class="nav-number">1.1.6.</span> <span class="nav-text">语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节：指针和数组"><span class="nav-number">1.2.</span> <span class="nav-text">第二节：指针和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">1.2.1.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量的地址"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">变量的地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取址操作符"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">取址操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针声明"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">指针声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针赋值"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">指针赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针的八种操作"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">指针的八种操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用指针在函数间通信"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">使用指针在函数间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量：名称、地址和值关系"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">变量：名称、地址和值关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">1.2.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化数组"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">初始化数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用const声明数组"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">使用const声明数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定初始化器"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">指定初始化器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给数组元素赋值"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">给数组元素赋值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多维数组"><span class="nav-number">1.2.3.</span> <span class="nav-text">多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明二维数组"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">声明二维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化二维数组"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">初始化二维数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针和数组"><span class="nav-number">1.2.4.</span> <span class="nav-text">指针和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数、数组和指针"><span class="nav-number">1.2.5.</span> <span class="nav-text">函数、数组和指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护数组中的数据"><span class="nav-number">1.2.6.</span> <span class="nav-text">保护数组中的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对形式参数使用const"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">对形式参数使用const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const的其他内容"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">const的其他内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节：结构体和其他数据形式"><span class="nav-number">1.3.</span> <span class="nav-text">第三节：结构体和其他数据形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">结构体变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明结构体"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">声明结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义结构体变量"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">定义结构体变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化结构"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">初始化结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体的初始化器"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">结构体的初始化器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问结构成员"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">访问结构成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构数组"><span class="nav-number">1.3.2.</span> <span class="nav-text">结构数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明结构数组"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">声明结构数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标识结构数组的成员"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">标识结构数组的成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套结构体"><span class="nav-number">1.3.3.</span> <span class="nav-text">嵌套结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向结构的指针"><span class="nav-number">1.3.4.</span> <span class="nav-text">指向结构的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明和初始化结构指针"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">声明和初始化结构指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用指针访问成员"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">用指针访问成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向函数传递结构的信息"><span class="nav-number">1.3.5.</span> <span class="nav-text">向函数传递结构的信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传递结构成员"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">传递结构成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递结构的地址"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">传递结构的地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递结构本身"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">传递结构本身</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构和结构指针的选择"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">结构和结构指针的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体的其他结构特性"><span class="nav-number">1.3.6.</span> <span class="nav-text">结构体的其他结构特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体中的字符数组和字符指针"><span class="nav-number">1.3.7.</span> <span class="nav-text">结构体中的字符数组和字符指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构、-指针和malloc"><span class="nav-number">1.3.8.</span> <span class="nav-text">结构、 指针和malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用结构数组的函数"><span class="nav-number">1.3.9.</span> <span class="nav-text">使用结构数组的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把结构内容保存到文件中"><span class="nav-number">1.3.10.</span> <span class="nav-text">把结构内容保存到文件中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章：输入与输出"><span class="nav-number">2.</span> <span class="nav-text">第二章：输入与输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节：单字符输入-输出"><span class="nav-number">2.1.</span> <span class="nav-text">第一节：单字符输入/输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单字符I-O：getchar-和putchar"><span class="nav-number">2.1.1.</span> <span class="nav-text">单字符I/O：getchar()和putchar()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区"><span class="nav-number">2.1.2.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件、流和键盘输入"><span class="nav-number">2.1.3.</span> <span class="nav-text">文件、流和键盘输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件结尾"><span class="nav-number">2.1.4.</span> <span class="nav-text">文件结尾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重定向和文件"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">重定向和文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重定向输出"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">重定向输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合重定向"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">组合重定向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建更友好的用户界面"><span class="nav-number">2.1.5.</span> <span class="nav-text">创建更友好的用户界面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节：字符串符串输入-输出"><span class="nav-number">2.2.</span> <span class="nav-text">第二节：字符串符串输入/输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何定义字符串"><span class="nav-number">2.2.1.</span> <span class="nav-text">如何定义字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-字符串字面量（字符串常量）"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1.字符串字面量（字符串常量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字符串数组初始化"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2.字符串数组初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-指针和字符串"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">3.指针和字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串输入"><span class="nav-number">2.2.2.</span> <span class="nav-text">字符串输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分配空间"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">分配空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gets-函数"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">gets()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#gets-的替代品"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">gets()的替代品</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-fgets-函数"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">1.fgets()函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-gets-s-函数"><span class="nav-number">2.2.2.2.3.</span> <span class="nav-text">2.gets_s()函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-s-gets-函数"><span class="nav-number">2.2.2.2.4.</span> <span class="nav-text">3.s_gets()函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scanf-函数"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">scanf()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串输出"><span class="nav-number">2.2.3.</span> <span class="nav-text">字符串输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#puts-函数"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">puts()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fputs-函数"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">fputs()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见字符串处理函数"><span class="nav-number">2.2.4.</span> <span class="nav-text">常见字符串处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入-输出的应用技巧"><span class="nav-number">2.2.5.</span> <span class="nav-text">输入/输出的应用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义输入-输出函数"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">自定义输入/输出函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串排序"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">字符串排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#把字符串转换为数字"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">把字符串转换为数字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节：文件输入-输出"><span class="nav-number">2.3.</span> <span class="nav-text">第三节：文件输入/输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一些基本概念"><span class="nav-number">2.3.1.</span> <span class="nav-text">一些基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准I-O"><span class="nav-number">2.3.2.</span> <span class="nav-text">标准I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检查命令行参数"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">检查命令行参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fopen-函数"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">fopen()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getc-和putc-函数"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">getc()和putc()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件结尾-1"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">文件结尾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用：一个简单的文件压缩程序"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">应用：一个简单的文件压缩程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件I-O：-fprintf-、-fscanf-、-fgets-和fputs"><span class="nav-number">2.3.3.</span> <span class="nav-text">文件I/O： fprintf()、 fscanf()、 fgets()和fputs()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fprintf-和fscanf-函数"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">fprintf()和fscanf()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fgets-和fputs-函数"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">fgets()和fputs()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机访问：-fseek-和ftell"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">随机访问： fseek()和ftell()</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
