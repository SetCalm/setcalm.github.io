<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/SetCalm/setcalm.github.io/"/>
  <updated>2018-12-18T18:59:46.584Z</updated>
  <id>https://github.com/SetCalm/setcalm.github.io/</id>
  
  <author>
    <name>Jeff Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cs</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-19-cs.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-19-cs.html</id>
    <published>2022-12-18T18:58:59.000Z</published>
    <updated>2018-12-18T18:59:46.584Z</updated>
    
    <content type="html"><![CDATA[<p>由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。</p><p>另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。</p><p>谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。&lt;/p&gt;
&lt;p&gt;另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。&lt;/p&gt;
&lt;p&gt;谢谢！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重要说明</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/重要说明.html</id>
    <published>2019-12-28T13:37:19.000Z</published>
    <updated>2019-02-23T08:32:34.454Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。</p><p>博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。&lt;/p&gt;
&lt;p&gt;博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C指针：基本概念、核心技术及最佳实践</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/C%E6%8C%87%E9%92%88%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/C指针：基本概念、核心技术及最佳实践.html</id>
    <published>2019-02-21T10:18:47.000Z</published>
    <updated>2019-02-23T08:24:51.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识</p><a id="more"></a><h2 id="1-内存与类型"><a href="#1-内存与类型" class="headerlink" title="1.内存与类型"></a>1.内存与类型</h2><ul><li>内存是一组以二进制方式存储信息的单元，存储容量取决于底层硬件或体系结构以及位长（1、2、4、8、16、32、64或128位）。</li><li>内存用于存储指令和数据序列。内存分为永久和临时存储两种类型，临时/非永久存储（如RAM、cache、寄存器等）。</li></ul><h3 id="1-2类型"><a href="#1-2类型" class="headerlink" title="1.2类型"></a>1.2类型</h3><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-31-53.png" alt="Snipaste_2019-02-21_18-31-53"></p><p>​                        图1.1 内存层次</p><h3 id="1-3内存排列"><a href="#1-3内存排列" class="headerlink" title="1.3内存排列"></a>1.3内存排列</h3><p>内存在空间呈线性序列排列，其中每个位置对应一个存储数据位置的地址。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-37-40.png" alt="Snipaste_2019-02-21_18-37-40"></p><p>内存地址是用于访问基本信息单元的数字。信息就是数据。图中显示了内存转储，在内存中数据存储在连续单元中。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-41-45.png" alt="Snipaste_2019-02-21_18-41-45"></p><h3 id="1-2数据与指令"><a href="#1-2数据与指令" class="headerlink" title="1.2数据与指令"></a>1.2数据与指令</h3><p>数据和指令是所有程序的固有部分。指令或程序逻辑操作与程序相关的数据（见图）。运行程序时，加载器首先加载程序到内存中，被加载程序称为进程（运行程序的实例）并由操作系统加载。<img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-46-23.png" alt="Snipaste_2019-02-21_18-46-23"></p><p>；3</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C primer Plus</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E7%AC%AC%E4%B8%80%E8%8A%82.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/第一节.html</id>
    <published>2019-02-20T12:38:47.000Z</published>
    <updated>2019-02-25T14:59:09.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：基数知识"><a href="#第一章：基数知识" class="headerlink" title="第一章：基数知识"></a>第一章：基数知识</h1><h2 id="第一节：数据和C"><a href="#第一节：数据和C" class="headerlink" title="第一节：数据和C"></a>第一节：数据和C</h2><h3 id="strlen和sizeof"><a href="#strlen和sizeof" class="headerlink" title="strlen和sizeof"></a>strlen和sizeof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>]=<span class="string">"wu"</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strlen= %d,sizeof=%d;"</span> , <span class="built_in">strlen</span>(name) , <span class="keyword">sizeof</span>(name));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">返回值为：<span class="built_in">strlen</span>= <span class="number">2</span>,<span class="keyword">sizeof</span>=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">sizeof</span> 运算符， 它以字节为单位给出对象的大小。 <span class="built_in">strlen</span>()函数给出字符串中的字符长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="常量和c预处理器"><a href="#常量和c预处理器" class="headerlink" title="常量和c预处理器"></a>常量和c预处理器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> taxrate;</span><br><span class="line">taxrate = <span class="number">0.015</span>;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span>常量名比数字表达的信息更多，便于阅读</span><br><span class="line"><span class="number">2.</span>多处使用一个常量， 有时需要改变它的值。 则只需更改符号常量的定义，便于修改。</span><br></pre></td></tr></table></figure><p>taxrate是一个变量， 程序可能会无意间改变它的值。 C语言还提供了一个更好的方案——C预处理器。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAXRATE 0.015</span></span><br><span class="line"></span><br><span class="line">注：编译程序时， 程序中所有的TAXRATE都会被直接替换成 <span class="number">0.015</span>。</span><br></pre></td></tr></table></figure><p>const限定符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MONTHS = <span class="number">12</span>; <span class="comment">// MONTHS在程序中不可更改， 值为12</span></span><br><span class="line"></span><br><span class="line">注：<span class="keyword">const</span>关键字，用于限定一个变量为只读 。它限定一个变量不允许被改变，产生静态作用。</span><br></pre></td></tr></table></figure><h3 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h3><p>C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相<br>关的详细信息。    </p><p>例如： limits.h头文件包含以下类似的代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN -32768</span></span><br><span class="line"><span class="comment">//这些明示常量代表int类型可表示的最大值和最小值。</span></span><br></pre></td></tr></table></figure><h3 id="printf-和scanf"><a href="#printf-和scanf" class="headerlink" title="printf()和scanf()"></a>printf()和scanf()</h3><p>请求printf()函数打印数据的指令要与待打印数据的类型相匹配。 例如，打印整数时使用%d， 打印字符时使用%c。 这些符号被称为转换说明 </p><p>​                        表4.3 转换说明及其打印的输出结果 <img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-26-20.png" alt="Snipaste_2019-02-20_21-26-20"></p><p>scanf()函数所用的转换说明与printf()函数几乎相同。 主要的区别是， 对于float类型和double类型， printf()都使用%f、 %e、 %E、 %g和%G转换说明。 而scanf()只把它们用于float类型， 对于double类型时要使用l修饰符。<br>​                    表4.6 ANSI C中scanf()的转换说明 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-42-14.png" alt="Snipaste_2019-02-20_21-42-14"></p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式（expression） 由运算符和运算对象组成（前面介绍过， 运算对象是运算符操作的对象） 。 最简单的表达式是一个单独的运算对象， 以此为基础可以建立复杂的表达式。 </p><p>运算对象可以是常量、 变量或二者的组合。 一些表达式由子表达式（subexpression） 组成（子表达式即较小的表达式） 。  </p><p>C 表达式的一个最重要的特性是， 每个表达式都有一个值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">-6</span> </span><br><span class="line"><span class="number">4</span>+<span class="number">21</span></span><br><span class="line">a*(b + c/d)/<span class="number">20</span></span><br><span class="line">q = <span class="number">5</span>*<span class="number">2</span></span><br><span class="line">x = ++q % <span class="number">3</span></span><br><span class="line">q &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>注意：int port /<em> 不是表达式， 没有值 </em>/ </p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句（statement） 是C程序的基本构建块。 一条语句相当于一条完整的计算机指令。 在C中， 大部分语句都以分号结尾。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">legs = <span class="number">4999999999999999999</span>KK</span><br><span class="line">只是一个表达式（它可能是一个较大表达式的一部分）  而下面的代码则是一条语句：</span><br><span class="line">legs = <span class="number">4</span>;</span><br><span class="line">最简单的语句是空语句：</span><br><span class="line">; <span class="comment">//空语句</span></span><br><span class="line">C把末尾加上一个分号的表达式都看作是一条语句（即， 表达式语</span><br><span class="line">句） 。 因此， 像下面这样写也没问题：</span><br><span class="line"><span class="number">3</span> + <span class="number">4</span>；</span><br><span class="line">x = <span class="number">25</span>;</span><br><span class="line">++x;</span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br></pre></td></tr></table></figure><h2 id="第二节：指针和数组"><a href="#第二节：指针和数组" class="headerlink" title="第二节：指针和数组"></a>第二节：指针和数组</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p><h4 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h4><p>int x;  //声明变量，申请整形4bit 的空间</p><p>x=40;  //将40存入整型变量 x 中              </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-03-28.png" alt="Snipaste_2019-02-22_01-03-28">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p><p>上图表示如何用整型变量 x 存储值 40。</p><p>变量 x 什么也不是，仅仅是某些内存地址的存储位置（x对应于地址）。在上述情况下，将值 40存储在 0x00394768 位置（40 存储于x对应地址的空间内），这个位置被变量 x 引用。这也意味着，程序中能使用某些变量引用某些地址。</p><p>内存地址也是数字或值。如果我们要在其他变量中存储这个数字（地址），那将是什么？</p><p>如果我们希望访问或以某个变量存储某个内存地址（如 0x00394768），就必须利用指针这种特殊变量及“取址”操作符。</p><h4 id="取址操作符"><a href="#取址操作符" class="headerlink" title="取址操作符"></a>取址操作符</h4><p>“取址”操作符（&amp;）返回操作数的内存地址。取址操作符是一元操作符，适应于变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr1.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Insert data\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;var_int);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例中，scanf 函数需要知道输入值应该存储的地址。函数 scanf 使用“取址”操作符（&amp;）得到存储用户输入值变量 var_int 的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr2.c</span><br><span class="line">Source code. Ptr2.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Address of variable \"var_int\": %p\n"</span>, &amp;var_int);</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Address of variable <span class="string">"var_int"</span>: <span class="number">00394768</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">源代码 Ptr3.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of node = %p\n"</span>,&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable a = %p\n"</span>, &amp;(p.a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable b = %p\n"</span>, &amp;(p.b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Output:</span><br><span class="line">Address of node = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable a = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable b = <span class="number">003</span>AFB04</span><br></pre></td></tr></table></figure><h4 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h4><p>现在你知道如何通过“取址”操作符获取地址。接下来让我们使用一个变量来存储这个地址。这个特定变量能存储和操作变量地址，称为指针变量。</p><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p><p>以下是声明指针变的一般形式 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 变量名 ;</span><br><span class="line"><span class="keyword">int</span>* intptr；</span><br><span class="line"><span class="keyword">char</span>* charptr；</span><br></pre></td></tr></table></figure><p>指针变量声明涉及一个名为解引用操作符 (*) ，用于帮助编译器识别他是一个指针变量。</p><h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>指针变量声明时没有指向。程序员必须在解引用它前让其指向有效的内存地址。</p><p>使用两种方式实现指针变量指向特定内存地址。</p><ol><li><p>利用指针地址（&amp;）分配变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 使用取址操作符获取变量 x 的地址</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-48-04.png" alt="Snipaste_2019-02-22_01-48-04"></p><p>2.让指针变量指向来自堆的动态分配内存 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line">ptr = ( <span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count );</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1550771326720.png" alt="1550771326720"></p></li></ol><p>数组由数据类型相同的一系列元素组成。使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和②这些元素的类型。 编译器根据这些信息正确地创建数组。 普通变量可以使用的类型， 数组元素都可以用。 </p><h4 id="指针的八种操作"><a href="#指针的八种操作" class="headerlink" title="指针的八种操作"></a>指针的八种操作</h4><p>可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作</p><p>程序清单10.13演示了指针变量的 8种基本操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.13</span> ptr_ops.c程序</span><br><span class="line"><span class="comment">// ptr_ops.c -- 指针操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　urn[<span class="number">5</span>]　=　&#123;　<span class="number">100</span>,　<span class="number">200</span>,　<span class="number">300</span>,　<span class="number">400</span>,　<span class="number">500</span>　&#125;;</span><br><span class="line"><span class="keyword">int</span> * ptr1, *ptr2, *ptr3;</span><br><span class="line">ptr1 = urn;　　　　　　　<span class="comment">// 把一个地址赋给指针 </span></span><br><span class="line">ptr2 = &amp;urn[<span class="number">2</span>];　　　　 <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line"><span class="comment">// 解引用指针，以及获得指针的地址 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pointer　value,　dereferenced　pointer,　pointer　address:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line"><span class="comment">// 指针加法</span></span><br><span class="line">    ptr3　=　ptr1　+　<span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nadding　an　int　to　a　pointer:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 + 4 = %p, *(ptr1 + 4) = %d\n"</span>, ptr1 + <span class="number">4</span>, *(ptr1 + <span class="number">4</span>));</span><br><span class="line">ptr1++;　　　　　　　　　<span class="comment">// 递增指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nvalues　after　ptr1++:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">ptr2--;　　　　　　　　　<span class="comment">// 递减指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nvalues　after　--ptr2:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n"</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class="line">--ptr1;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line">++ptr2;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nPointers　reset　to　original　values:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1　=　%p,　ptr2　=　%p\n"</span>,　ptr1,　ptr2);</span><br><span class="line"><span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nsubtracting　one　pointer　from　another:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\n"</span>,　</span><br><span class="line">ptr2,　ptr1,　ptr2　-　ptr1);</span><br><span class="line"><span class="comment">// 一个指针减去一个整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nsubtracting　an　int　from　a　pointer:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr3　=　%p,　ptr3　-　2　=　%p\n"</span>,　ptr3,　ptr3　-　<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">pointer value, dereferenced pointer, pointer address:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, *ptr1 =<span class="number">100</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">adding an <span class="keyword">int</span> to a pointer:</span><br><span class="line">ptr1 + <span class="number">4</span> = <span class="number">0x7fff5fbff8e0</span>, *(ptr1 + <span class="number">4</span>) = <span class="number">500</span></span><br><span class="line">values after ptr1++:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d4</span>, *ptr1 =<span class="number">200</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">values after --ptr2:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d4</span>, *ptr2 = <span class="number">200</span>, &amp;ptr2 = <span class="number">0x7fff5fbff8c0</span></span><br><span class="line">Pointers reset to original values:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 = <span class="number">0x7fff5fbff8d8</span></span><br><span class="line">subtracting one pointer from another:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d8</span>, ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 - ptr1 = <span class="number">2</span></span><br><span class="line">subtracting an <span class="keyword">int</span> from a pointer:</span><br><span class="line">ptr3 = <span class="number">0x7fff5fbff8e0</span>, ptr3 - <span class="number">2</span> = <span class="number">0x7fff5fbff8d8</span></span><br></pre></td></tr></table></figure><ol><li>解引用：<em>运算符给出指针指向地址上储存的值。因此，</em>ptr1的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。</li><li>取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地址。因此&amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。</li><li>指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 +4与&amp;urn[4]等价。如果相加结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li><li>递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_14-14-32.png" alt="Snipaste_2019-02-22_14-14-32"></p><ol><li>指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2&amp;urn[2]等价，因为ptr3指向的是&amp;arn[4]。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li><li>递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。</li><li>指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出<br>一个值，或者导致运行时错误。</li><li>比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li></ol><h4 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h4><p><strong>函数原型中的形参的两种形式</strong></p><p>直接把变量相关的两类信息（类型及值）传递给函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function1(x);</span><br><span class="line"></span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure><p>把变量的地址传递给函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function2(&amp;x);</span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> * ptr)</span></span></span><br></pre></td></tr></table></figure><p><strong>一个把x,y值交换的例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap3.c -- 使用指针解决交换函数的问题 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Originally x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">interchange(&amp;x, &amp;y); <span class="comment">// 把地址发送给函数</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">temp = *u; <span class="comment">// temp获得 u 所指向对象的值</span></span><br><span class="line">*u = *v;</span><br><span class="line">*v = temp;</span><br><span class="line">    </span><br><span class="line">    输出：Originally x = <span class="number">5</span> <span class="keyword">and</span> y = <span class="number">10.</span></span><br><span class="line"> Now x = <span class="number">10</span> <span class="keyword">and</span> y = <span class="number">5.</span></span><br></pre></td></tr></table></figure><p>分析函数：interchange(&amp;x, &amp;y);</p><p>该函数的声明void interchange (int <em> u, int </em> v)，其u和v是指向整数的指针。因此该函数传递的不是x和y的值，而是它们的地址。</p><p>接下来，在函数体中声明了一个交换值时必需的临时变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br></pre></td></tr></table></figure><p>通过下面的语句把x的值储存在temp中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = *u;</span><br><span class="line"><span class="comment">//u的值是&amp;x，所以u指向x。即temp = *u=*(&amp;x)这意味着用*u即可表示x的值，</span></span><br><span class="line"><span class="comment">//&amp;运算符访问地址，u=&amp;x即获得下的地址</span></span><br><span class="line"><span class="comment">//*运算符获得地址上的值，*u=*（&amp;x）即获得（&amp;x）地址上的值，即x值。</span></span><br><span class="line"><span class="comment">//所以temp=x；</span></span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line">temp = u; <span class="comment">/* 不要这样做 */</span></span><br></pre></td></tr></table></figure><h4 id="变量：名称、地址和值关系"><a href="#变量：名称、地址和值关系" class="headerlink" title="变量：名称、地址和值关系"></a>变量：名称、地址和值关系</h4><p>变量的名称、地址和变量的值之间关系密切。</p><ul><li>编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。</li><li>在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。</li><li>简而言之，普通变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。</li></ul><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  x=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span>* p;</span><br><span class="line">        p=&amp;x;</span><br><span class="line">                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x的地址p=&amp;x=%p\n"</span>, p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p地址的值*p=*(&amp;x)=%d"</span>, *p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">x的地址p=&amp;x=<span class="number">0xbf89c298</span></span><br><span class="line">p地址的值*p=*(&amp;x)=<span class="number">100</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">&amp;符号为取址符，可以获得变量的地址</span></span><br><span class="line"><span class="comment">    *指针操作符：能存储和操作变量地址，称为指针变量。同时能够用来读取地址内的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组由数据类型相同的一系列元素组成。 要使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和这些元素的②类型。 编译器根据这些信息正确地创建数组。  </p><p>声明数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一些数组声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; fl</span><br><span class="line">oat candy[<span class="number">365</span>]; <span class="comment">/* 内含365个float类型元素的数组 */</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">12</span>]; <span class="comment">/*内含12个char类型元素的数组*/</span></span><br><span class="line"><span class="keyword">int</span> states[<span class="number">50</span>]; <span class="comment">/*内含50个int类型元素的数组 */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>数组通常被用来储存程序需要的同一类数据。 例如， 一个内含12个整数元素的数组可以储存12个月的天数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>,<span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br></pre></td></tr></table></figure><p>程序清单10.1演示了一个小程序， 打印每个月的天数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.1</span> day_mon1.c程序</span><br><span class="line"><span class="comment">/* day_mon1.c -- 打印每个月的天数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; MONTHS; index++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Month %2d has %2d days.\n"</span>, index + <span class="number">1</span>, days[index]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Month <span class="number">1</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">2</span> has <span class="number">28</span> days.</span><br><span class="line">Month <span class="number">3</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">4</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">5</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">6</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">7</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">8</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">9</span> has <span class="number">30</span> days.</span><br></pre></td></tr></table></figure><h4 id="使用const声明数组"><a href="#使用const声明数组" class="headerlink" title="使用const声明数组"></a>使用const声明数组</h4><p>有时需要把数组设置为只读。 这样， 程序只能从数组中检索值， 不能把新值写入数组。 要创建只读数组， 应该用const声明和初始化数组。  </p><p>因此，程序清单10.1中初始化数组应改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h4><p>指定初始化器（designated initializer） 。 利用该特性可以初始化指定的数组元素。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212</span><br></pre></td></tr></table></figure><h4 id="给数组元素赋值"><a href="#给数组元素赋值" class="headerlink" title="给数组元素赋值"></a>给数组元素赋值</h4><p>声明数组后， 可以借助数组下标（或索引） 给数组元素赋值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给数组的元素赋值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> counter, evens[SIZE];</span><br><span class="line"><span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; SIZE; counter++)</span><br><span class="line">evens[counter] = <span class="number">2</span> * counter;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码中使用循环给数组的元素依次赋值。</span></span><br></pre></td></tr></table></figure><p><strong>一些错误的数组赋值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">oxen[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 初始化没问题 */</span></span><br><span class="line"><span class="keyword">int</span> yaks[SIZE];</span><br><span class="line">yaks = oxen; <span class="comment">/* 不允许 */</span></span><br><span class="line">yaks[SIZE] = oxen[SIZE]; <span class="comment">/* 数组下标越界 ,下表为0~(SIZE-1)*/</span></span><br><span class="line"> yaks[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 不起作用 */</span></span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>例如要分析5年内每个月的降水量数据，要如何表示数据。  </p><ul><li><p>一个方案是创建60个变量， 每个变量储存一个数据项（我们曾经提到过这一笨拙的方案， 和以前一样， 这个方案并不合适） 。</p></li><li><p>二个方案是把各年的数据分开储存会更好， 即创建5个数组， 每个数组12个元素。  </p><p><strong>第二方案该如何实现</strong>？</p><p>处理这种情况应该使用数组的数组。 主数组（master array） 有5个元素（每个元素表示一年） ， 每个元素是内含12个元素的数组（每个元素表示一个月） 。 下面是该数组的声明： </p></li></ul><h4 id="声明二维数组"><a href="#声明二维数组" class="headerlink" title="声明二维数组"></a>声明二维数组</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> rain[<span class="number">5</span>][<span class="number">12</span>]; <span class="comment">// 内含5个数组元素的数组， 每个数组元素内含12个float类型的元素</span></span><br></pre></td></tr></table></figure><p>  <img src="D:\MyBlog\图片\Snipaste_2019-02-21_21-55-01.png" alt="Snipaste_2019-02-21_21-55-01"></p><h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p><strong>初始化的两种方式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_22-03-42.png" alt="Snipaste_2019-02-21_22-03-42"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12 <span class="comment">// 一年的月份数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YEARS 5 <span class="comment">// 年数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//</span></span><br><span class="line">用<span class="number">2010</span>～<span class="number">2014</span>年的降水量数据初始化数组</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> rain[YEARS][MONTHS] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">2.4</span>, <span class="number">3.5</span>, <span class="number">6.6</span> &#125;,</span><br><span class="line">&#123; <span class="number">8.5</span>, <span class="number">8.2</span>, <span class="number">1.2</span>, <span class="number">1.6</span>, <span class="number">2.4</span>, <span class="number">0.0</span>, <span class="number">5.2</span>, <span class="number">0.9</span>, <span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">1.4</span>, <span class="number">7.3</span> &#125;,</span><br><span class="line">&#123; <span class="number">9.1</span>, <span class="number">8.5</span>, <span class="number">6.7</span>, <span class="number">4.3</span>, <span class="number">2.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">6.1</span>, <span class="number">8.4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.2</span>, <span class="number">9.9</span>, <span class="number">8.4</span>, <span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">1.7</span>, <span class="number">4.3</span>, <span class="number">6.2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.6</span>, <span class="number">5.6</span>, <span class="number">3.8</span>, <span class="number">2.8</span>, <span class="number">3.8</span>, <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.3</span>, <span class="number">2.6</span>, <span class="number">5.2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。</p><p>例子：数组名是数组首元素的地址。如果flizny是一个数组，下面的语句成立：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br><span class="line"><span class="comment">//flizny 和&amp;flizny[0]都表示数组首元素的内存地址（&amp;是地址运算符）。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　4</span></span><br><span class="line"><span class="keyword">short</span>　dates[SIZE];</span><br><span class="line"><span class="keyword">short</span> * pti;</span><br><span class="line"><span class="keyword">short</span>　index;</span><br><span class="line">pti = dates;　<span class="comment">// 把数组地址赋给指针</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_13-26-02.png" alt="Snipaste_2019-02-22_13-26-02"></p><h3 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h3><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = sum(marbles); <span class="comment">// 可能的函数调用</span></span><br></pre></td></tr></table></figure><p>该函数的原型是什么？由于数组名marbless是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式<br>参数，即该形参是一个指向int的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span></span>; <span class="comment">// 对应的函数原型</span></span><br></pre></td></tr></table></figure><p>sum()从该参数获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。<br>我们有两种方法让函数获得元素个数这一信息。第一种方法是，在函数代码中写上固定的数组小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span> <span class="comment">// 相应的函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)　　<span class="comment">// 假设数组有10个元素</span></span><br><span class="line">total += ar[i];　　　　<span class="comment">// ar[i] 与 *(ar + i) 相同</span></span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个比较灵活的方法是把数组大小作为第2个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar, <span class="keyword">int</span> n)</span>　　　 <span class="comment">// 更通用的方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)　　 <span class="comment">// 使用 n 个元素</span></span><br><span class="line">total += ar[i];　　　　<span class="comment">// ar[i] 和 *(ar + i) 相同</span></span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数要处理数组必须知道何时开始、何时结束。上面的sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）</p><p>还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　marbles[SIZE]　=　&#123;　<span class="number">20</span>,　<span class="number">10</span>,　<span class="number">5</span>,　<span class="number">39</span>,　<span class="number">4</span>,　<span class="number">16</span>,　<span class="number">19</span>,　<span class="number">26</span>,　</span><br><span class="line"><span class="number">31</span>,　<span class="number">20</span>　&#125;;</span><br><span class="line"><span class="keyword">long</span>　answer;</span><br><span class="line">answer　=　sump(marbles,　marbles　+　SIZE);<span class="comment">//marble为数组的首位，而marble+SIZE则为数组结束位置</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The　total　number　of　marbles　is　%ld.\n"</span>,　answer);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>　(start　&lt;　end)</span><br><span class="line">&#123;</span><br><span class="line">total += *start;　 <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">start++;　　　　　　<span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。</p><h3 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a>保护数组中的数据</h3><p>编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。(直接传递数值时使用的是原始数据的副本，不会意外修改原始数据。但是传递数值的指针的话使用原始数据，因此这样的函数可能修改原数组。)</p><p>如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p><p>处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的，但是要注意保护数组中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>　<span class="title">add_to</span><span class="params">(<span class="keyword">double</span>　ar[],　<span class="keyword">int</span>　n,　<span class="keyword">double</span>　val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">for</span>　(i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">ar[i]　+=　val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因此，调用该函数后，prices数组中的每个元素的值都增加了2.5：</span></span><br><span class="line">add_to(prices, <span class="number">100</span>, <span class="number">2.50</span>);</span><br><span class="line"><span class="comment">//该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。</span></span><br></pre></td></tr></table></figure><h4 id="对形式参数使用const"><a href="#对形式参数使用const" class="headerlink" title="对形式参数使用const"></a>对形式参数使用const</h4><p>为了避免修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span> <span class="comment">/* 函数定义 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(　i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">total　+=　ar[i];</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const的其他内容"><a href="#const的其他内容" class="headerlink" title="const的其他内容"></a>const的其他内容</h4><p>使用const创建过变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加<br>灵活。可以创建const数组、const指针和指向const的指针。</p><p>如何使用const关键字保护数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.const数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MONTHS　12</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">days[<span class="number">9</span>] = <span class="number">44</span>;　　 <span class="comment">/* 编译错误 ,程序无法改变数组元素的值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//coon身体指针</span></span><br><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pd = rates;　　 <span class="comment">// pd指向数组的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：</span></span><br><span class="line">*pd = <span class="number">29.89</span>;　　　<span class="comment">// 不允许</span></span><br><span class="line">pd[<span class="number">2</span>] = <span class="number">222.22</span>;　　<span class="comment">//不允许</span></span><br><span class="line">rates[<span class="number">0</span>] = <span class="number">99.99</span>; <span class="comment">// 允许，因为rates未被const限定</span></span><br></pre></td></tr></table></figure><h1 id="第二章：输入与输出"><a href="#第二章：输入与输出" class="headerlink" title="第二章：输入与输出"></a>第二章：输入与输出</h1><h2 id="第一节-单字符输入-输出"><a href="#第一节-单字符输入-输出" class="headerlink" title="第一节 单字符输入/输出"></a>第一节 单字符输入/输出</h2><ol><li>介绍输入、 输出以及缓冲输入和无缓冲输入的区别 </li><li>如何使用重定向把程序和文件相连接</li><li>介绍如何设计与用户交互的界面 </li><li>创建更友好的用户界面 </li><li>演示一些与输入验证相关的问题和解决方案。 </li></ol><p>I/O函数（如printf()、 scanf()、 getchar()、 putchar()等） 负责把信息传送到程序中。  </p><h3 id="单字符I-O：getchar-和putchar"><a href="#单字符I-O：getchar-和putchar" class="headerlink" title="单字符I/O：getchar()和putchar()"></a>单字符I/O：getchar()和putchar()</h3><p>getchar()和 putchar()每次只处理一个字符。 </p><p>程序清单8.1。该程序获取从键盘输入的字符， 并把这些字符发送到屏幕上。 程序使用while 循环， 当读到#字符时停止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">8.1</span> echo.c程序</span><br><span class="line"><span class="comment">/* echo.c -- 重复输入 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'#'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户的交互如下：    </p><p><strong>Hello, there. I would[enter]</strong></p><p>Hello, there. I would</p><p><strong>like a #3 bag of potatoes.[enter]</strong></p><p>like a</p><p>例子中 “#” 作为结束输入， 就无法在文本中使用这个字符， 是否有更好的方法结束输入？， 是否有更好的方法结束输入？  要回答这些问题， 首先要了解 C程序如何处理键盘输入， 尤其是缓冲和标准输入文件的概念。 </p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>在老式系统运行程序清单8.1， 可能显示如下：</p><p>HHeelllloo,, tthheerree..II wwoouulldd[enter]</p><p>lliikkee aa #</p><p> 像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接） 输入， 即正在等待的程序可立即使用输入的字符。</p><p>大部分系统在用户按下Enter键之前不会重复打印刚输入的字符， 这种输入形式属于缓冲输入。 用户输入的字符被收集并储存在一个被称为缓冲区（buffer） 的临时存储区， 按下Enter键后， 程序才可使用用户输入的字符。 图8.1比较了这两种输入。 <img src="D:\MyBlog\图片\Snipaste_2019-02-21_09-53-53.png" alt="Snipaste_2019-02-21_09-53-53"></p><p><strong>为什么要有缓冲区？</strong></p><ul><li>把若干字符作为一个块进行传输比逐个发送这些字符节约时间</li><li>如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时， 传输的是正确的输入。</li></ul><p>虽然缓冲输入好处很多， 但是某些交互式程序也需要无缓冲输入。 例如， 在游戏中， 你希望按下一个键就执行相应的指令。 因此， 缓冲输入和无缓冲输入都有用武之地。 </p><p><strong>缓冲分为两类： 完全缓冲I/O和行缓冲I/O。</strong> </p><ul><li>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地） ， 通常出现在文件输入中。 缓冲区的大小取决于系统， 常见的大小是 512 字节和 4096字节。</li><li>行缓冲I/O指的是在出现换行符时刷新缓冲区。 键盘输入通常是行缓冲输入， 所以在按下Enter键后才刷新缓冲区 。</li></ul><h3 id="文件、流和键盘输入"><a href="#文件、流和键盘输入" class="headerlink" title="文件、流和键盘输入"></a>文件、流和键盘输入</h3><ul><li>文件（file） 是存储器中储存信息的区域。 通常， 文件都保存在某种永久存储器中（如， 硬盘、 U盘或DVD等） 。 </li><li>C可以使用主机操作系统的基本文件工具直接处理文件， 这些直接调用操作系统的函数被称为底层 I/O （low-level I/O） 。</li><li><strong>C程序处理的是流而不是直接处理文件。</strong> 流（stream） 是一个实际输入或输出映射的理想化数据流。 这意味着不同属性和不同种类的输入， 由属性更统一的流来表示。 于是， 打开文件的过程就是把流与文件相关联， 而且读写都通过流来完成。 从而达到屏蔽掉了不同系统的输入输出的差异， 以便用户使用统一的界面。 </li><li>C把输入和输出设备视为存储设备上的普通文件， 尤其是把键盘和显示设备视为每个C程序自动打开的文件。 stdin流表示键盘输入， stdout流表示屏幕输出。 getchar()、 putchar()、printf()和scanf()函数都是标准I/O包的成员， 处理这两个流。 </li></ul><p>总结：可以用处理文件的方式来处理键盘输入。 例如，程序读文件时要能检测文件的末尾才知应在何处停止。 因此， C 的输入函数内置了文件结尾检测器。 既然可以把键盘输入视为文件， 那么也应该能使用文件结尾检测器结束键盘输入。 </p><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><p>计算机操作系统要以某种方式判断文件的开始和结束。</p><ul><li><p>在文件末尾放一个特殊的字符标记文件结尾。 图8.2演示了这种方法</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_10-38-48.png" alt="Snipaste_2019-02-21_10-38-48"></p></li><li><p>另一种方法是储存文件大小的信息。  如果文件有3000字节， 程序在读到3000字节时便达到文件的末尾。 </p></li></ul><p>无论操作系统实际使用何种方法检测文件结尾， 在C语言中， 用getchar()读取文件检测到文件结尾时将返回一个特殊的值， 即EOF（end offile的缩写） 。 scanf()函数检测到文件结尾时也返回EOF。 通常， EOF定义在stdio.h文件中： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure><p>如何在程序中使用EOF？ 把getchar()的返回值和EOF作比较。 如果两值不同， 就说明没有到达文件结尾。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br></pre></td></tr></table></figure><p>绝大部分系统（不是全部） 都有办法通过键盘模拟文件结尾条件（Enter）。完整程序如下</p><p>程序清单8.2 echo_eof.c程序 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* echo_eof.c -- 重复输入， 直到文件结尾 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h4><p>输入和输出涉及函数、 数据和设备。 例如， 上面 echo_eof.c程序， 该程序使用输入函数 getchar()，输出函putchar()。 输入/输出数据流由字符组成。 输入设备是键盘 ，输出设备是屏幕。</p><p> 假设你希望输入函数和数据类型不变， 仅改变程序查找数据的位置。 那么， 程序如何知道去哪里查找输入？ </p><p>默认情况下， C程序使用标准I/O包查找标准输入作为输入源。 即：stdin流， 它是把数据读入计算机的常用方式。 它可以是键盘或者时一个过时的设备， 如磁带、 穿孔卡或电传打印机， 甚至是一些先进技术， 如语音输入。 然而， 现代计算机非常灵活， 可以让它到别处查找输入。 尤其是， 可以让一个程序从文件中查找输入， 而不是从键盘。 </p><p><strong>程序可以通过两种方式使用文件</strong></p><ul><li>第 1 种方法是， 显式使用特定的函数打开文件、 关闭文件、 读取文件、 写入文件， 诸如此类。 </li><li>第2种方法是， 设计能与键盘和屏幕互动的程序， 通过不同的渠道重定向输入至文件和从文件输出。 换言之， 把stdin流重新赋给文件。 继续使用getchar()函数从输入流中获取数据， 但它并不关心从流的什么位置获取数据。 这种重定向的方法在某些方面有些限制， 但是用起来比较简单， 而且能让读者熟悉普通的文件处理技术。 </li></ul><p>重定向输入让程序使用文件而不是键盘来输入， 重定向输出让程序输出至文件而不是屏幕。 </p><p>重定向输入</p><p> 假设已经编译了echo_eof.c 程序 </p><p>现在要该程序处理名为words的文本文件输出到屏幕上 </p><p>./echo_eof &lt; words  ：&lt;符号是UNIX和DOS/Windows的重定向运算符， words为文本文件保存有“1314”。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-07-57.png" alt="Snipaste_2019-02-21_14-07-57"></p><h4 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h4><p>在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。  </p><p>echo_eof&gt;mywords  ：&gt;符号是重定向运算符。 它创建了一个名为mywords的新文件， 然<br>后把echo_eof的输出 重定向至该文件中。  </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-18.png" alt="Snipaste_2019-02-21_14-15-18"></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-46.png" alt="Snipaste_2019-02-21_14-15-46"></p><p>注：在下一行的开始处按下Ctrl+D（UNIX） 或Ctrl+Z（DOS） 即可结束该程序。 </p><h4 id="组合重定向"><a href="#组合重定向" class="headerlink" title="组合重定向"></a>组合重定向</h4><p>现在， 假设你希望制作一份mywords文件的副本， 并命名为savewords。只需输入以下命令即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_eof &lt; mywords &gt; savewords</span><br><span class="line"><span class="comment">//下面的命令也起作用， 因为命令与重定向运算符的顺序无关：</span></span><br><span class="line">echo_eof &gt; savewords &lt; mywords</span><br></pre></td></tr></table></figure><p>注意： 在一条命令中， 输入文件名和输出文件名不能相同。 </p><p><strong>在UNIX、 Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;） 时， 要遵循以下原则。</strong></p><ul><li><p>重定向运算符连接一个可执行程序（包括标准操作系统命令） 和一个数据文件， 不能用于连接一个数据文件和另一个数据文件， 也不能用于连接一个程序和另一个程序。</p></li><li><p>使用重定向运算符不能读取多个文件的输入， 也不能把输出定向至多个<br>文件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fish &gt; beets ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; count ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; fish &lt; beets ←违反第<span class="number">2</span>条规则</span><br><span class="line">count &gt; beets fish ←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建更友好的用户界面"><a href="#创建更友好的用户界面" class="headerlink" title="创建更友好的用户界面"></a>创建更友好的用户界面</h3><p>学会避免编写一些中看不中用的程序，并创建更友好的用户界面， 让交互数据输入更方便， 减少错误输入的影响。 </p><p>略</p><h2 id="第二节：字符串符串输入-输出"><a href="#第二节：字符串符串输入-输出" class="headerlink" title="第二节：字符串符串输入/输出"></a>第二节：字符串符串输入/输出</h2><p>本章介绍以下内容：</p><ul><li><p>函数： gets_s()、 fgets()、 puts()、 fputs()、 strcat()、 strncat()、strcmp()、 strncmp()、 strcpy()、 strncpy()、 sprintf()、 strchr() </p></li><li><p>创建并使用字符串 </p></li><li>字符串是以空字符（\0）结尾的char类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过C也提供了许多专门用于处理字符串的函数</li><li>使用C库中的字符和字符串函数， 并创建自定义的字符串函数</li><li>使用命令行参数 </li></ul><p>字符串是以空字符（\0）结尾的char类型数组。 C提供了许多专门用于处理字符串的函数。本节将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。</p><p>程序清单11.1演示了在程序中表示字符串的几种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">//　 strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MSG　<span class="meta-string">"I　am　a　symbolic　string　constant."</span> <span class="comment">//方法一：即字符串常量（字符串常量）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MAXLENGTH　81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>　words[MAXLENGTH]　=　<span class="string">"I　am　a　string　in　an　array."</span>; <span class="comment">//方法二：、char类型数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>; <span class="comment">//放法三：指向char的指针</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here　are　some　strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line">    words[<span class="number">8</span>]　=　<span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Here are some strings:</span><br><span class="line">I am an old-fashioned symbolic <span class="built_in">string</span> constant.</span><br><span class="line">I am a <span class="built_in">string</span> in an <span class="built_in">array</span>.</span><br><span class="line">Something is pointing at me.</span><br><span class="line">I am a spring in an <span class="built_in">array</span>.</span><br></pre></td></tr></table></figure><p>程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向<br>char的指针）定义字符串。</p><h3 id="如何定义字符串"><a href="#如何定义字符串" class="headerlink" title="如何定义字符串"></a>如何定义字符串</h3><h4 id="1-字符串字面量（字符串常量）"><a href="#1-字符串字面量（字符串常量）" class="headerlink" title="1.字符串字面量（字符串常量）"></a>1.字符串字面量（字符串常量）</h4><p>定义：用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中。</p><p>所以<em>“I am a symbolic stringconstant.”</em>  、<em>“I739am a string in an array.”</em>  、<em>“Something is pointed at me.”</em> 、<em>“Here are somestrings:”</em>都是字符串字面量。</p><p>从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：</p><p><em>char greeting[50] = “Hello, and”</em></p><p><em>“ how are” “ you”</em></p><p><em>“ today!”;</em></p><p>与下面的代码等价：char greeting[50] = “Hello, and how are you today!</p><p><strong>注意：如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\“）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。</p><h4 id="2-字符串数组初始化"><a href="#2-字符串数组初始化" class="headerlink" title="2.字符串数组初始化"></a>2.字符串数组初始化</h4><p>定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种形式的初始化比标准的数组初始化形式简单得多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，让编译器确定数组的大小很方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。</p><p>##### </p><h4 id="3-指针和字符串"><a href="#3-指针和字符串" class="headerlink" title="3.指针和字符串"></a>3.指针和字符串</h4><p>实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5<br>中的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.5</span> p_and_s.c程序</span><br><span class="line"><span class="comment">/* p_and_s.c -- 指针和字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * mesg = <span class="string">"Don't be a fool!"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * copy;</span><br><span class="line">    copy = mesg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, copy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mesg = %s; &amp;mesg = %p; value = %p\n"</span>, mesg,&amp;mesg, mesg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"copy = %s; &amp;copy = %p; value = %p\n"</span>, copy,&amp;copy, copy);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line">Don't be a fool!</span><br><span class="line">mesg = Don't be a fool!; &amp;mesg = <span class="number">0x0012ff48</span>; value =<span class="number">0x0040a000</span></span><br><span class="line">copy = Don't be a fool!; &amp;copy = <span class="number">0x0012ff44</span>; value =<span class="number">0x0040a000</span></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li><p>首先第1项，mesg和copy都以字符串形式输出（%s转换说明）。这里没问题，两个字符串都是”Don’t be a fool!”。</p></li><li><p>第2项，打印两个指针的地址。如上输出所示，指针mesg和copy分别储存在地址为0x0012ff48和0x0012ff44的内存中。</p></li><li><p>意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。<em>语句copy = mesg;把mesg的值赋给copy，即让copy也指向mesg指向的字符。</em></p></li></ul><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。</p><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>字符串输入要做的第 1 件事是分配空间，以储存稍后读入的字符串。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">char</span> *name;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最简单的方法是，在声明时显式指明数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">81</span>];</span><br></pre></td></tr></table></figure><p>假设编写了如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">// strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"I am a symbolic string constant."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLENGTH 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har words[MAXLENGTH] = <span class="string">"I am a string in an array."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here are some strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line"> words[<span class="number">8</span>] = <span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的写法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="gets-函数"><a href="#gets-函数" class="headerlink" title="gets()函数"></a>gets()函数</h4><p>在读取字符串时， scanf()和转换说明%s只能读取一个单词。 可是在程序中经常要读取一整行输入， 而不仅仅是一个单词。 程序中读取一整行输入时需要使用gets()函数。</p><p> gets()函数简单易用， 它读取整行输入， 直至遇到换行符， 然后丢弃换行符， 储存其余字符， 并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。  </p><p><em>注：它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。（字符串输出介绍）</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.6</span> getsputs.c程序</span><br><span class="line"><span class="comment">/* getsputs.c -- 使用 gets() 和 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">gets(words); <span class="comment">// 典型用法，用于输入字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, words);</span><br><span class="line"><span class="built_in">puts</span>(words);<span class="comment">//用于输出字符串，效果和print相同。</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">Your <span class="built_in">string</span> twice:</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">Done.</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// gets整行输入（除了换行符） 都被储存在 words 中， puts(words) 和printf("%s\n, words")的效果相同。</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>gets()唯一的参数是 words，它无法检查数组是否装得下输入行。数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。</p><p>如果输入的字符串过长， 会导致缓冲区溢出（buffer overflow） ， 即多余的字符超出了指定的目标空间。 如果这些多余的字符只是占用了尚未使用的内存， 就不会立即出现问题； 如果它们擦写掉程序中的其他数据， 会导致程序异常中止； 或者还有其他情况。（问题和上面分配空间相似。）</p><h5 id="gets-的替代品"><a href="#gets-的替代品" class="headerlink" title="gets()的替代品"></a>gets()的替代品</h5><p>由于容易出现“Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的。因此C 编程社区的许多人都建议在编程时摒弃 gets()。</p><h5 id="1-fgets-函数"><a href="#1-fgets-函数" class="headerlink" title="1.fgets()函数"></a>1.fgets()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> bufsize, FILE *stream)</span></span>;</span><br><span class="line">参数</span><br><span class="line">*buf: 字符型指针，指向用来存储所得数据的地址。</span><br><span class="line">bufsize: 整型数据，指明存储数据的大小。</span><br><span class="line">*stream: 文件结构体指针，将要读取的文件流。</span><br></pre></td></tr></table></figure><p>fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。 该函数专门设计用于处理文件输入， 所以一般情况下可能不太好用。 </p><p><strong>fgets()和gets()的区别如下</strong></p><ul><li>fgets()函数的第2个参数指明了读入字符的最大数量。 如果该参数的值是n， 那么fgets()将读入n-1个字符， 或者读到遇到的第一个换行符为止。 </li><li>如果fgets()读到一个换行符， 会把它储存在字符串中。 （fgets()会保留换行符， gets()会丢弃换行符。 ）</li><li>fgets()函数的第3 个参数指明要读入的文件。 如果读入从键盘输入的数据， 则以stdin（标准输入） 作为参数。</li></ul><p>因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出） ， 通常要与 fputs()函数（和puts()类似） 配对使用， 除非该函数不在字符串末尾 添加换行符。 </p><p>fputs()函数的第2个参数指明它要写入的文件。 如果要显示在计算机显示器上， 应使用stdout（标准输出） 作为该参数。 （fputs后面介绍）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.7</span> fgets1.c程序</span><br><span class="line"><span class="comment">/* fgets1.c -- 使用 fgets() 和 fputs() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">fgets(words, STLEN, <span class="built_in">stdin</span>);<span class="comment">//words为写入内容，STLEN存储数据大小,stdin指向读取文件指针为标准输入。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter another string, please."</span>);</span><br><span class="line">fgets(words, STLEN, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">下面是该程序的输出示例：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">apple pie</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">apple pie</span><br><span class="line">apple pie</span><br><span class="line">Enter another <span class="built_in">string</span>, please.</span><br><span class="line">strawberry shortcake</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">strawberry sh</span><br><span class="line">strawberry shDone.</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>第1行输入， apple pie， 比fgets()读入的整行输入短， 因此， apple pie\n\0被储存在数组中。 所以当puts()显示该字符串时又在末尾添加了换行符， 因此apple pie后面有一行空行。 因为fputs()不在字符串末尾添加换行符， 所以并未打印出空行。</li><li>第2行输入， strawberry shortcake， 超过了大小的限制， 所以fgets()只读入了13个字符， 并把strawberry sh\0 储存在数组中。 再次提醒读者注意，puts()函数会在待输出字符串末尾添加一个换行符， 而fputs()不会这样做。 </li></ul><h5 id="2-gets-s-函数"><a href="#2-gets-s-函数" class="headerlink" title="2.gets_s()函数"></a>2.gets_s()函数</h5><p>过去通常用fgets()来代替gets()， fgets()函数稍微复杂些， 在处理输入方面与gets()略有不同。 C11标准新增的gets_s()函数也可代替gets()。 该函数与gets()函数更接近， 而且可以替换现有代码中的gets()。 但是， 它是stdio.h输入/输出函数系列中的可选扩展， 所以支持C11的编译器也不一定支持它。 </p><p>C11新增的gets_s()函数（可选） 和fgets()类似， 用一个参数限制读入的字符数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets_s</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">size_t</span> sizeInCharacters)</span></span>;</span><br></pre></td></tr></table></figure><p>gets_s()与fgets()的区别如下。</p><p>gets_s()只从标准输入中读取数据， 所以不需要第3个参数。</p><p>如果gets_s()读到换行符， 会丢弃它而不是储存它。</p><h5 id="3-s-gets-函数"><a href="#3-s-gets-函数" class="headerlink" title="3.s_gets()函数"></a>3.s_gets()函数</h5><p>程序清单11.9演示了fgets()函数的一种用法： 读取整行输入并用空字符<br>代替换行符， 或者读取一部分输入， 并丢弃其余部分。 既然没有处理这种情<br>况的标准函数， 我们就创建一个， 在后面的程序中会用得上。 程序清单<br>11.10提供了一个这样的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.10</span> s_gets()函数</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>); </span><br><span class="line"> <span class="keyword">if</span> (ret_val) <span class="comment">// 即， ret_val != NULL</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">st[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：如果 fgets()返回 NULL， 说明读到文件结尾或出现读取错误， s_gets()函数跳过了这个过程。 它模仿程序清单11.9的处理方法， 如果字符串中出现换行符， 就用空字符替换它； 如果字符串中出现空字符， 就丢弃该输入行的其余字符， 然后返回与fgets()相同的值。 </p><h4 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h4><p>scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾：scanf()更像是“获取单词”函数， 而不是“获取字符串”函数； 如果预留的存储区装得下输入行， gets()和fgets()会读取第1个换行符之前所有的字符。 </p><p>scanf()函数有两种方法确定输入结束。 无论哪种方法， 都从第1个非空白字符作为字符串的开始。 </p><ul><li>如果使用%s转换说明， 以下一个空白字符（空行、空格、 制表符或换行符） 作为字符串的结束（字符串不包括空白字符） 。</li><li>如果指定了字段宽度， 如%10s， 那么scanf()将读取10 个字符或读到第1个空白<br>字符停止（先满足的条件即是结束输入的条件） ， 见图11.3。 </li></ul><p><img src="D:\MyBlog\图片\Snipaste_2019-02-25_20-49-47.png" alt="Snipaste_2019-02-25_20-49-47"></p><p>scanf()函数返回一个整数值， 该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF） 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.11</span> scan_str.c程序</span><br><span class="line"><span class="comment">/* scan_str.c -- 使用 scanf() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> name1[<span class="number">11</span>], name2[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter 2 names.\n"</span>);</span><br><span class="line">count = <span class="built_in">scanf</span>(<span class="string">"%5s %10s"</span>, name1, name2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I read the %d names %s and %s.\n"</span>, count, name1,me2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的3个输出示例：</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Jesse Jukes</span></span><br><span class="line"><span class="comment">I read the 2 names Jesse and Jukes.</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Portensia Callowit</span></span><br><span class="line"><span class="comment">I read the 2 names Porte and nsia.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>分析：第1个输出示例， 两个名字的字符个数都未超过字段宽度。 第2个输出示例， 只读入了Applebottham的前10个字符Applebotth（因为使用了%10s转换说明） 。 第3个输出示例， Portensia的后4个字符nsia被写入name2中， 因为第2次调用scanf()时， 从上一次调用结束的地方继续读取数据。 在该例中， 读取的仍是Portensia中的字母。 </p><p>scanf()和gets()类似， 也存在一些潜在的缺点。 如果输入行的内容过长，scanf()也会导致数据溢出。 不过， 在%s转换说明中使用字段宽度可防止溢出。 </p><h3 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h3><p>C有3个标准库函数用于打印字符串： put()、 fputs()和printf() 。</p><h4 id="puts-函数"><a href="#puts-函数" class="headerlink" title="puts()函数"></a>puts()函数</h4><p>puts()函数很容易使用， 只需把字符串的地址作为参数传递给它即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.12</span> put_out.c程序</span><br><span class="line"><span class="comment">/* put_out.c -- 使用 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF <span class="meta-string">"I am a #defined string."</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">80</span>] = <span class="string">"An array was initialized to me."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * str2 = <span class="string">"A pointer was initialized to me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"I'm an argument to puts()."</span>);</span><br><span class="line"><span class="built_in">puts</span>(DEF);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="built_in">puts</span>(str2);</span><br><span class="line"><span class="built_in">puts</span>(&amp;str1[<span class="number">5</span>]);</span><br><span class="line"> <span class="built_in">puts</span>(str2 + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">I'm an argument to puts().</span><br><span class="line">I am a <span class="meta">#defined string.</span></span><br><span class="line">An <span class="built_in">array</span> was initialized to me.</span><br><span class="line">A pointer was initialized to me.</span><br><span class="line">ray was initialized to me.</span><br><span class="line">inter was initialized to me.</span><br></pre></td></tr></table></figure><p>注：每个字符串独占一行， 因为puts()在显示字符串时会自动在其末尾添加一个换行符。 （这点太舒服了，printf()还要自己加换行。）</p><p>puts()如何知道在何处停止？ 该函数在遇到换行符时就停止输出， 所以必须确保有换行符。 不要模仿程序清单11.13中的程序！ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.13</span> nono.c程序</span><br><span class="line"><span class="comment">/* nono.c -- 千万不要模仿！ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> side_a[] = <span class="string">"Side A"</span>;</span><br><span class="line"><span class="keyword">char</span> dont[] = &#123; <span class="string">'W'</span>, <span class="string">'O'</span>, <span class="string">'W'</span>, <span class="string">'!'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> side_b[] = <span class="string">"Side B"</span>;</span><br><span class="line"><span class="built_in">puts</span>(dont); <span class="comment">/* dont 不是一个字符串，是个wow！字节 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于dont缺少一个表示结束的空字符， 所以它不是一个字符串， 因此puts()不知道在何处停止。 它会一直打印dont后面内存中的内容， 直到发现一个空字符为止。 为了让puts()能尽快读到空字符， 我们把dont放在side_a和side_b之间。 下面是该程序的一个运行示例：<br>WOW!Side A </p><h4 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs()函数"></a>fputs()函数</h4><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line">（<span class="number">1</span>）str：这是一个数组，包含了要写入的以空字符终止的字符序列。</span><br><span class="line">（<span class="number">2</span>）stream：指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</span><br><span class="line">返回值：该函数返回一个非负值，如果发生错误则返回 EOF(<span class="number">-1</span>)。</span><br></pre></td></tr></table></figure><p>fputs()函数是puts()针对文件定制的版本。 </p><p>它们的区别如下：</p><ul><li>fputs()函数的第 2 个参数指明要写入数据的文件。 如果要打印在显示器上， 可以用定义在stdio.h中的stdout（标准输出） 作为该参数。  </li><li>与puts()不同， fputs()不会在输出的末尾添加换行符。 </li></ul><p>注意： gets()丢弃输入中的换行符， 但是puts()在输出中添加换行符。 另一方面， fgets()保留输入中的换行符， fputs()不在输出中添加换行符。 （好绕）</p><h3 id="常见字符串处理函数"><a href="#常见字符串处理函数" class="headerlink" title="常见字符串处理函数"></a>常见字符串处理函数</h3><p>C库提供了多个处理字符串的函数， ANSI C把这些函数的原型放在string.h头文件中。 其中最常用的函数strlen()、 strcat()、 strcmp()、strncmp()、 strcpy()和 strncpy()。 另外， 还有sprintf()函数， 其原型在stdio.h头文件中。 </p><p><strong>1.strlen()函数 ：用于统计字符串的长度。</strong> </p><p>略</p><p><strong>2.strcat()函数 ：用于拼接字符串</strong></p><p> 函数接受两个字符串作为参数。 该函数把第2个字符串的备份附加在第1个字符串末尾， 并把拼接后形成的新字符串作为第1个字符串， 第2个字符串不变。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.18</span> str_cat.c程序</span><br><span class="line"><span class="comment">/* str_cat.c -- 拼接两个字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* strcat()函数的原型在该头文件中 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line"><span class="keyword">char</span> addon [] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line"><span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line"><span class="built_in">puts</span>(flower);</span><br><span class="line"><span class="built_in">puts</span>(addon);</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">st[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出示例如下：</span></span><br><span class="line"><span class="comment">What is your favorite flower?</span></span><br><span class="line"><span class="comment">wonderflower</span></span><br><span class="line"><span class="comment">wonderflowers smell like old shoes.</span></span><br><span class="line"><span class="comment">s smell like old shoes.</span></span><br><span class="line"><span class="comment">bye</span></span><br><span class="line"><span class="comment">从以上输出可以看出， flower改变了， 而addon保持不变。</span></span><br></pre></td></tr></table></figure><p><strong>3.strcmp()函数</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">设这两个字符串为str1，str2，</span><br><span class="line">若str1=str2，则返回零；</span><br><span class="line">若str1&lt;str2，则返回负数；</span><br><span class="line">若str1&gt;str2，则返回正数。</span><br></pre></td></tr></table></figure><p><strong>4.sprintf()函数</strong></p><p> 是字符串格式化命令,主要功能是把格式化的数据写入某个字符串中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原型</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [ argument] … )</span></span>;</span><br><span class="line">参数列表</span><br><span class="line">buffer：<span class="keyword">char</span>型指针，指向将要写入的字符串的缓冲区。</span><br><span class="line">format：格式化字符串。</span><br><span class="line">[argument]...：可选参数，可以是任何类型的数据。nst <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crt_sprintf.c</span></span><br><span class="line"><span class="comment">// compile with: /W3</span></span><br><span class="line"><span class="comment">// This program uses sprintf to format various</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//data and place them in the string named buffer.</span></span><br><span class="line"><span class="comment">// 程序使用sprintf 将各种数据格式化后置于字符数组buffer中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">   <span class="keyword">int</span>   i = <span class="number">35</span>, j;</span><br><span class="line">   <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">   <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">   j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"   String:    %s\n"</span>, s ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Character: %c\n"</span>, c ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Integer:   %d\n"</span>, i ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Real:      %f\n"</span>, fp );<span class="comment">// C4996</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>, buffer, j );</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果 [<span class="number">1</span>]  ：</span><br><span class="line">Output:</span><br><span class="line">String: computer </span><br><span class="line">　　</span><br><span class="line">Character: l</span><br><span class="line">Integer: <span class="number">35</span></span><br><span class="line">Real: <span class="number">1.732053</span></span><br><span class="line">character count = <span class="number">79</span></span><br></pre></td></tr></table></figure><p><strong>其他字符串函数</strong> </p><ol><li><p>char <em>strcpy(char </em> restrict s1, const char * restrict s2);</p><p>该函数把s2指向的字符串（包括空字符） 拷贝至s1指向的位置， 返回值是s1。</p></li><li><p>char <em>strncpy(char </em> restrict s1, const char * restrict s2, size_t n);</p><p>该函数把s2指向的字符串拷贝至s1指向的位置， 拷贝的字符数不超过n， 其返回值是s1该函数不会拷贝空字符后面的字符， 如果源字符串的字符少于n个， 目标字符串就以拷贝的空字符尾； 如果源字符串有n个或超过n个字符， 就不拷贝空字符。</p></li><li><p>char <em>strcat(char </em> restrict s1, const char * restrict s2);</p><p>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 该函数返回s1。</p></li><li><p>char <em>strncat(char </em> restrict s1, const char * restrict s2, size_t n);</p><p>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 不会拷贝s2字符串中空字符和其后的字符， 并在拷贝字符的末尾添加一个空字符。 该函数返回s1。</p></li><li><p>int strcmp(const char <em> s1, const char </em> s2);</p><p>如果s1字符串在机器排序序列中位于s2字符串的后面， 该函数返回一个正数； 如果两个字符串相等， 则返回0； 如果s1字符串在机器排序序列中位于s2字符串的前面， 则返回一个负数。</p></li><li><p>int strncmp(const char <em> s1, const char </em> s2, size_t n);</p><p>该函数的作用和strcmp()类似， 不同的是， 该函数在比较n个字符后或遇到第1个空字符时停止比较。</p></li><li><p>char <em>strchr(const char </em> s, int c);</p><p>如果s字符串中包含c字符， 该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分， 所以在查找范围内） ； 如果在字符串s中  </p></li></ol><h3 id="输入-输出的应用技巧"><a href="#输入-输出的应用技巧" class="headerlink" title="输入/输出的应用技巧"></a>输入/输出的应用技巧</h3><h4 id="自定义输入-输出函数"><a href="#自定义输入-输出函数" class="headerlink" title="自定义输入/输出函数"></a>自定义输入/输出函数</h4><p>实际使用中，不一定非要使用C库中的标准函数， 如果无法使用这些函数或者想扩张输入/输出的某一功能， 完全可以在getchar()和putchar()的基础上自定义所需的函数。 </p><p>下面两个经典的自定义输入/输出函数 </p><p>1.字符串， 不添加\n </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.14</span> put1()函数</span><br><span class="line"><span class="comment">/* put1.c -- 打印字符串， 不添加\n */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span><span class="comment">/* 不会改变字符串 */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">string</span> != <span class="string">'\0'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向char的指针string最初指向传入参数的首元素。 因为该函数不会改变<br>传入的字符串， 所以形参使用了const限定符。 打印了首元素的内容后， 指<br>针递增1， 指向下一个元素。 while循环重复这一过程， 直到指针指向包含空<br>字符的元素。  </p><p>++的优先级高于<em>， 因此putchar(</em>string++)打印string指向的值， 递增的是string本身， 而不是递增它所指向的字符。 （即先比较厚打印，当比较到\0时退出）</p><p>2.设计一个类似puts()的函数， 而且该函数还给出待打印字符的个数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* put2.c -- 打印一个字符串， 并统计打印的字符数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">put2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">string</span>) <span class="comment">/* 常规用法 */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">count++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>); <span class="comment">/* 不统计换行符 */</span></span><br><span class="line"><span class="keyword">return</span>(count);</span><br><span class="line">&#125;</span><br><span class="line">num = put2(<span class="string">"pizza"</span>);<span class="comment">//调用将返回统计的字符数， 并将其赋给num</span></span><br></pre></td></tr></table></figure><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><p>我们来处理一个按字母表顺序排序字符串的实际问题。 准备名单表、 创建索引和许多其他情况下都会用到字符串排序。 该程序主要是用 strcmp()函数来确定两个字符串的顺序。 一般的做法是读取字符串函数、 排序字符串并打印出来。  </p><p>略</p><h4 id="把字符串转换为数字"><a href="#把字符串转换为数字" class="headerlink" title="把字符串转换为数字"></a>把字符串转换为数字</h4><p>数字既能以字符串形式储存， 也能以数值形式储存。 把数字储存为字符串就是储存数字字符。 例如， 数字213以’2’、 ‘1’、 ‘3’、 ‘\0’的形式被储存在字符串数组中。 以数值形式储存213， 储存的是int类型的值。 </p><p>略</p><h2 id="第三节：文件输入-输出"><a href="#第三节：文件输入-输出" class="headerlink" title="第三节：文件输入/输出"></a>第三节：文件输入/输出</h2><p>本章介绍以下内容函数：</p><ul><li>fopen()、 getc()、 putc()、 exit()、 fclose()</li><li>fprintf()、 fscanf()、 fgets()、 fputs()</li><li>rewind()、 fseek()、 ftell()、 fflush()</li><li>fgetpos()、 fsetpos()、 feof()、 ferror()</li><li>ungetc()、 setvbuf()、 fread()、 fwrite()</li></ul><p>如何使用C标准I/O系列的函数处理文件<br>文件模式和二进制模式、 文本和二进制格式、 缓冲和无缓冲I/O<br>使用既可以顺序访问文件也可以随机访问文件的函数<br>文件是当今计算机系统不可或缺的部分。 文件用于储存程序、 文档、 数<br>据、 书信、 表格、 图形、 照片、 视频和许多其他种类的信息。 作为程序员，<br>必须会编写创建文件和从文件读写数据的程序。 本章将介绍相关的内容。 </p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章：基数知识&quot;&gt;&lt;a href=&quot;#第一章：基数知识&quot; class=&quot;headerlink&quot; title=&quot;第一章：基数知识&quot;&gt;&lt;/a&gt;第一章：基数知识&lt;/h1&gt;&lt;h2 id=&quot;第一节：数据和C&quot;&gt;&lt;a href=&quot;#第一节：数据和C&quot; class=&quot;headerlink&quot; title=&quot;第一节：数据和C&quot;&gt;&lt;/a&gt;第一节：数据和C&lt;/h2&gt;&lt;h3 id=&quot;strlen和sizeof&quot;&gt;&lt;a href=&quot;#strlen和sizeof&quot; class=&quot;headerlink&quot; title=&quot;strlen和sizeof&quot;&gt;&lt;/a&gt;strlen和sizeof&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&quot;stdio.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&quot;string.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; name[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]=&lt;span class=&quot;string&quot;&gt;&quot;wu&quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;strlen= %d,sizeof=%d;&quot;&lt;/span&gt; , &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(name) , &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(name));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回值为：&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注：&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; 运算符， 它以字节为单位给出对象的大小。 &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;()函数给出字符串中的字符长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://github.com/SetCalm/setcalm.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>linux环境配置</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/linux环境配置.html</id>
    <published>2018-12-29T09:01:14.000Z</published>
    <updated>2018-12-29T09:01:14.458Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1.移植U-Boot</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/1-%E7%A7%BB%E6%A4%8DU-Boot.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/1-移植U-Boot.html</id>
    <published>2018-12-28T14:52:31.000Z</published>
    <updated>2019-01-03T03:41:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移植-U-Boot"><a href="#移植-U-Boot" class="headerlink" title="移植 U-Boot"></a>移植 U-Boot</h2><h3 id="Bootloader-简介"><a href="#Bootloader-简介" class="headerlink" title="Bootloader 简介"></a>Bootloader 简介</h3><p>#### </p><h4 id="Bootload是什么"><a href="#Bootload是什么" class="headerlink" title="Bootload是什么"></a>Bootload是什么</h4><p>Bootloader是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备（关闭WATCHDOG、改变系统时钟、初始化存储控制器）、建立内存空间的映射表，将更多的代码复制到内存中等，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。 <em>它能将操作系统内核复制到内存中运行，我们将这段程序称为 Bootloader。</em></p><p>①Bootloader 就是这么一小段程序，它在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统</p><p>②我们还可以增强 Bootloader 的功能，比如增加网络功能、从 PC 上通过串口或网络下载文件、烧写文件、将 Flash 上压缩的文件解压后再运行等。</p><p>③Bootloader是基于特定硬件平台来实现的。因此，不可能有一个 Bootloader 支持所有的CPU、所有的电路板。即使是支持 CPU 架构比较多的 U-Boot，也不是一拿来就可以使用的，需要进行一些移植</p><h4 id="Bootloader是如何启动"><a href="#Bootloader是如何启动" class="headerlink" title="Bootloader是如何启动"></a>Bootloader是如何启动</h4><p>CPU 上电后，会从某个地址开始执行。比如 MIPS 结构的 CPU 会从 0xBFC00000 取第一条指令，而 ARM 结构的 CPU 则从地址 0x0000000 开始。嵌入式开发板中，需要把存储器件 ROM 或 Flash 等映射到这个地址，Bootloader 就存放在这个地址开始处，这样一上电就可以执行。<strong><em>(即将Bootloader 存放在0x0000000 这个地址开始处。这样一上电就可以执行Bootloader)</em></strong> </p><p>在开发时，通常可以使用各种命令操作 Bootloader，一般通过串口来连接 PC 和开发板，可以在串口上输入各种命令、观察运行结果等。</p><p>Bootloader 可以分为以下两种操作模式（Operation Mode）。<br>​    （1）启动加载（Boot loading）模式。<br>​    上电后，Bootloader 从板子上的某个固态存储设备上将操作系统加载到 RAM 中运行，整个过程并没有用户的介入。产品发布时，Bootloader 工作在这种模式下。<br>​    （2）下载（Downloading）模式。<br>​    在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（比如内核映象、文件系统映象），将它们直接放在内存运行或是烧入Flash 类固态存储设备中。<br>​    板子与主机间传输文件时，可以使用串口的 xmodem/ymodem/zmodem 协议，它们使用简单，只是速度比较慢；还可以使用网络通过 tftp、nfs 协议来传输，这时，主机上要开启 tftp、nfs 服务；还有其他方法，比如 USB 等。</p><h4 id="Bootloader-在linux中的分区"><a href="#Bootloader-在linux中的分区" class="headerlink" title="Bootloader 在linux中的分区"></a>Bootloader 在linux中的分区</h4><p>嵌入式 Linux 系统从软件的角度通常可以分为以下 4 个层次。</p><p>（1）引导加载程序。</p><p>包括固化在固件（firmware）中的 boot 代码（可选）和 Bootloader两大部分。有些 CPU 在运行 Bootloader 之前先运行一段固化的程序（固件，firmware），比如 x86结构的 CPU 就是先运行 BIOS 中的固件，然后才运行硬盘第一个分区（MBR）中的 Bootloader。在大多嵌入式系统中并没有固件，Bootloader 是上电后执行的第一程序。</p><p>（2）Linux 内核。</p><p>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由 Bootloader 传递给它的。</p><p>（3）文件系统。</p><p>包括根文件系统和建立于 Flash 内存设备之上的文件系统。里面包含了 Linux 系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux 的控制界面的 shell 程序、动态连接的程序运行时需要的 glibc 或 uClibc 库等。</p><p>（4）用户应用程序。<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间 可能还会包括一个嵌入式图形用户界面。常用的嵌入式 GUI 有：Qtopia 和 MiniGUI 等。 </p><p>嵌入系统的典型分区结构如下</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-28_23-39-14.png" alt="Snipaste_2018-12-28_23-39-14"></p><p><strong>“Boot parameters（参数）”</strong>分区中存放一些可设置的参数，比如 IP 地址、串口波特率、要传递给内核的命令行参数等。</p><p>正常启动过程中，Bootloader 首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会挂接（mount）根文件系统（“Root filesystem”），启动文件系统中的应用程序。</p><h4 id="Bootload启动步骤"><a href="#Bootload启动步骤" class="headerlink" title="Bootload启动步骤"></a>Bootload启动步骤</h4><p>汇编阶段 </p><ol><li><p>设置为SVC模式，关闭中断,MMU,看门狗</p></li><li><p>基本硬件设备初始化（初始化时钟，串口，flash,内存等）</p></li><li><p>自搬移到内存</p></li><li><p>设置好栈 跳转到C语言阶段 </p><p>C语言阶段</p></li><li><p>大部分硬件初始化</p></li><li><p>搬移内核到内存后，运行内核</p></li></ol><h4 id="常用-Bootloader-介绍"><a href="#常用-Bootloader-介绍" class="headerlink" title="常用 Bootloader 介绍"></a>常用 Bootloader 介绍</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-29_00-42-38.png" alt="Snipaste_2018-12-29_00-42-38"></p><p>本次使用的 S3C2410 开发板使用的Bootloader为U-Boot 。<br>​    U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p><h3 id="U-Boot-分析与移植"><a href="#U-Boot-分析与移植" class="headerlink" title="U-Boot 分析与移植"></a>U-Boot 分析与移植</h3><h4 id="U-Boot-简介"><a href="#U-Boot-简介" class="headerlink" title="U-Boot 简介"></a>U-Boot 简介</h4><p>U-Boot，全称为 Universal Boot Loader，即通用 Bootloader，是遵循 GPL 条款的开放源代码项目。</p><p><strong>U-Boot 有如下特性</strong></p><p>• 开放源码。</p><p>• 支持多种嵌入式操作系统内核，如 Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS。</p><p>• 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS、XScale。</p><p>• 较高的可靠性和稳定性。</p><p>• 高度灵活的功能设置，适合 U-Boot 调试、操作系统不同引导要求、产品发布等。</p><p>• 丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等。</p><p>• 较为丰富的开发调试文档与强大的网络技术支持。</p><p>• 支持 NFS 挂载、RAMDISK（压缩或非压缩）形式的根文件系统。</p><p>• 支持 NFS 挂载、从 Flash 中引导压缩或非压缩系统内核。</p><p>• 可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对 Linux 支持最为强劲。</p><p>• 支持目标板环境变量多种存储方式，如 Flash、NVRAM、EEPROM。</p><p>• CRC32 校验，可校验 Flash 中内核、RAMDISK 镜像文件是否完好。</p><p>• 上电自检功能：SDRAM、Flash 大小自动检测，SDRAM 故障检测，CPU 型号 。                            </p><p>• 上电自特殊功能：XIP 内核引导 。</p><h4 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h4><p>源码为U-Boot-1.1.6  版本。从 sourceforge 网站下载 U-Boot-1.1.6.tar.bz2后解压即得到全部源码。</p><p>U-Boot-1.1.6 根目录下共有 26 个子目录，可以分为 4 类。</p><p>（1）平台相关的或开发板相关的。<br>​    （2）通用的函数。<br>​    （3）通用的设备驱动程序。<br>​    （4）U-Boot 工具、示例程序、文档 。</p><p>这 26 个子目录的功能与作用如表  </p><p>详细参考：嵌入式Linux应用开发完全手册的15.2.2 U-Boot 源码结构部分</p><h4 id="U-Boot-的配置、编译、连接"><a href="#U-Boot-的配置、编译、连接" class="headerlink" title="U-Boot 的配置、编译、连接"></a>U-Boot 的配置、编译、连接</h4><p>要想了解对于某款开发板，使用哪些文件、哪个文件首先执行、可执行文件占用内存的情况，最好的方法就是阅读它的 Makefile。</p><p>如果要使用开发板 board/&lt;board_name&gt;，就先执行“make &lt;board_name&gt;_config”命令进行配置，然后执行“make all”，就可以生成如下 3个文件。</p><p>• U-Boot.bin：二进制可执行文件，它就是可以直接烧入 ROM、NOR Flash 的文件。<br>​    • U-Boot：ELF 格式的可执行文件。<br>​    • U-Boot.srec：Motorola S-Record 格式的可执行文件。</p><p>例如：S3C2410 的开发板，执行“make smdk2410_config”、“make all”后生成的 U-Boot.bin可以烧入 NOR Flash 中运行</p><h5 id="U-Boot-的配置"><a href="#U-Boot-的配置" class="headerlink" title="U-Boot 的配置"></a>U-Boot 的配置</h5><p>(1). S3C2410 的开发板，执行“make smdk2410_config”</p><p>在顶层 Makefile 中可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRCTREE := $(CURDIR) </span><br><span class="line">……</span><br><span class="line">MKCONFIG := $(SRCTREE)/mkconfig </span><br><span class="line">……</span><br><span class="line">smdk2410_config : unconfig </span><br><span class="line">  @$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>则其中的 MKCONFIG 就是根目录下的 mkconfig文件。$(@:_config=)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。</p><p>所以“make smdk2410fi”实际上就是执行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>补充：在 mkconfig 文件开头第 6 行给出了它的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span> # Parameters: Target Architecture CPU Board [VENDOR][SOC]</span><br></pre></td></tr></table></figure><p>对于 S3C2410、S3C2440，它们被称为 SoC(System on Chip)，上面除 CPU 外，还集成了包括 UART、USB 控制器、NAND Flash 控制器等设备（称为片内外设）。S3C2410/S3C2440 中的 CPU 为 ARM920T。</p><p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p><h5 id="U-Boot-的编译、连接"><a href="#U-Boot-的编译、连接" class="headerlink" title="U-Boot 的编译、连接"></a>U-Boot 的编译、连接</h5><p>配置完后，执行“make all”即可编译</p><p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p><h5 id="U-Boot-的使用"><a href="#U-Boot-的使用" class="headerlink" title="U-Boot 的使用"></a>U-Boot 的使用</h5><p>U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p><p>我们知道u-boot，可以运行可是命令，以及支持串口下载、网络下载等功能以方便开发中调式。但这篇文章中并不介绍u-boot 的用法。后续会补充详细 的u-boot常用命令以及开发中如何使用串口和网络下载功能。以及u-boot的实际使用操作。</p><h2 id="移植linux内核"><a href="#移植linux内核" class="headerlink" title="移植linux内核"></a>移植linux内核</h2><p>这部分我们主要了解熟悉linux内核。知道如何给内核打补丁，配置内核及编译内核等内容。</p><p>准备：</p><p>内核源码：2.6.22.6.tar.bz2</p><p>补丁文件：patch-2.6.22.bz2</p><h3 id="内核源码结构分析及Makefile分析"><a href="#内核源码结构分析及Makefile分析" class="headerlink" title="内核源码结构分析及Makefile分析"></a>内核源码结构分析及Makefile分析</h3><h4 id="内核源码结构分析"><a href="#内核源码结构分析" class="headerlink" title="内核源码结构分析"></a>内核源码结构分析</h4><p>略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移植-U-Boot&quot;&gt;&lt;a href=&quot;#移植-U-Boot&quot; class=&quot;headerlink&quot; title=&quot;移植 U-Boot&quot;&gt;&lt;/a&gt;移植 U-Boot&lt;/h2&gt;&lt;h3 id=&quot;Bootloader-简介&quot;&gt;&lt;a href=&quot;#Bootloader-简
      
    
    </summary>
    
      <category term="第二阶段" scheme="https://github.com/SetCalm/setcalm.github.io/categories/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下写一个简单的驱动程序</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-26-%E5%9C%A8Linux%E4%B8%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html</id>
    <published>2018-12-26T15:12:10.000Z</published>
    <updated>2018-12-26T16:46:47.600Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符设备驱动程序之概述</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-25-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%A6%82%E8%BF%B0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-25-字符设备驱动程序之概述.html</id>
    <published>2018-12-25T13:57:27.000Z</published>
    <updated>2018-12-26T15:11:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux程序启动过程"><a href="#Linux程序启动过程" class="headerlink" title="Linux程序启动过程"></a>Linux程序启动过程</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_22-01-25.png" alt="Snipaste_2018-12-25_22-01-25"></p><p>我们知道：通过U-boot启动内核，内核驱动应用程序。</p><p>应用程序通过open，read，write等API来实现读写文件，点灯，获取按键灯操作。它们是如何实现的呢。</p><p>API与驱动是如何实现对应如下关系的呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open--&gt;led_open</span><br><span class="line">read--&gt;led_read</span><br><span class="line">write--》led_write</span><br></pre></td></tr></table></figure><p>下面简单讨论如何实现的映射关系</p><p>一个简单的应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   fd=open(<span class="string">"/dev/led"</span>,O_RDWD);</span><br><span class="line">    write(fd1,&amp;val,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    fd2=open(<span class="string">"hello.txt"</span>,O_DWD);</span><br><span class="line">    write(fd2,&amp;va1,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开led的过程</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_22-48-27.png" alt="Snipaste_2018-12-25_22-48-27"></p><p>C库的open是如何进入内核的led.open</p><ol><li><p>open调用实际上是执行一个swi val汇编指令引发异常。当发生异常后，会进入内核的异常处理函数</p></li><li><p>system call Interface（系统调用接口）①根据异常处理函数发生原因val值，调用不同驱动函数（system_open）。</p></li><li><p>VFS(虚拟文件系统)最终根据打开的文件/dev/led）找到相应的驱动程序led_open。</p></li><li><p>执行led_open程序，打开led。</p></li></ol><h2 id="设备调用框架"><a href="#设备调用框架" class="headerlink" title="设备调用框架"></a>设备调用框架</h2><p>   <img src="D:\MyBlog\图片\Snipaste_2018-12-26_00-10-13.png" alt="Snipaste_2018-12-26_00-10-13"></p><ol><li>应用程序调用C库的函数（open，read，write）或直接使用Linux系统调用接口①</li><li>C库函数调(例：open)用实际上是执行一个swi val汇编指令引发异常。当发生异常后，会进入内核的异常处理函数②</li><li>Linux系统调用接口根据异常处理函数发生原因val值，调用VFS中不同驱动函数（system_open）。③</li><li>VFS(虚拟文件系统)最终根据打开文件的属性找到更底层的程序。</li><li>执行驱动程序</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_21-29-57.png" alt="Snipaste_2018-12-26_21-29-57"></p><p>应用层如何调用驱动</p><ol><li><p>应用层：Open(“/dev/xxx”,   )：打开”/dev/xxx”文件，参看属性：字符设备，及主设备号（major）：111。然后根据在VFS找到对应major的结构体;</p></li><li><p>内核层：VFS对应major的结构体保存有入口函数 register_chrdev();信息</p><p>​         register_chrdev()根据major调用相应的file_operations()，</p></li><li><p>驱动层：file调用相应的驱动程序函数led_open();</p></li></ol><p>用户空间</p><p>vfs major</p><p>内核空间</p><p>驱动</p><p>驱动程序：file_open</p><h2 id="驱动程序框架"><a href="#驱动程序框架" class="headerlink" title="驱动程序框架"></a>驱动程序框架</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_23-08-17.png" alt="Snipaste_2018-12-25_23-08-17"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_00-25-20.png" alt="Snipaste_2018-12-26_00-25-20"></p><h3 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h3><p>写出驱动程序led_open，led_write，led_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_leds_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buff, </span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp)</span></span>&#123;&#125;</span><br><span class="line">                                         <span class="function"><span class="keyword">static</span> ssize_t <span class="title">s3c24xx_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> * ppos)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>VFS:将驱动程序告诉内核的VFS。</p><p>​    定义一个结构体static struct file_operations()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">s3c24xx_leds_fops</span> = &#123;</span></span><br><span class="line">    .owner  =   THIS_MODULE,    <span class="comment">/* 这是一个宏，推向编译模块时自动创建的__this_module变量 */</span></span><br><span class="line">    .open   =   s3c24xx_leds_open,     </span><br><span class="line">.read=s3c24xx_leds_read,   </span><br><span class="line">.write=s3c24xx_leds_write,   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="system-call-Interface"><a href="#system-call-Interface" class="headerlink" title="system call Interface"></a>system call Interface</h3><p>注册到内核VFS：register_chrdev()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);</span><br></pre></td></tr></table></figure><p>谁调用驱动——&gt;驱动人口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">s3c24xx_leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);<span class="comment">//注册到内核VFS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(s3c24xx_leds_init);<span class="comment">//初始化函数</span></span><br></pre></td></tr></table></figure><p>int register_chrdev（unsigned int major，const char <em> name，struct file_operations </em> fops);</p><p>注册字符设备分配设备名。设备名注册到chrdev结构图内</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_01-24-07.png" alt="Snipaste_2018-12-26_01-24-07"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>open(“/dev/led”,O_RDWD);根据设备名major找到驱动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux程序启动过程&quot;&gt;&lt;a href=&quot;#Linux程序启动过程&quot; class=&quot;headerlink&quot; title=&quot;Linux程序启动过程&quot;&gt;&lt;/a&gt;Linux程序启动过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_20
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LS80-UBOOT</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-25-LS80-UBOOT.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-25-LS80-UBOOT.html</id>
    <published>2018-12-24T17:50:08.000Z</published>
    <updated>2018-12-25T13:57:42.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux如何启动"><a href="#linux如何启动" class="headerlink" title="linux如何启动"></a>linux如何启动</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_01-53-36.png" alt="Snipaste_2018-12-25_01-53-36"></p><p>bootload的目的：启动内核</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_04-00-13.png" alt="Snipaste_2018-12-25_04-00-13"></p><ol><li>u-boot功能：</li><li>关看门狗</li><li>初始化时钟</li><li>初始化SDRAM</li><li>从Flash读出内核</li><li>附加功能（开发功能：方便开发）<ul><li>烧写Flash</li><li>网卡</li><li>USB 串口</li></ul></li><li>启动内内核</li></ol><h2 id="u-boot体验"><a href="#u-boot体验" class="headerlink" title="u-boot体验"></a>u-boot体验</h2><p>uboot的四重奏</p><ol><li>解压缩</li><li>打补丁</li><li>配置</li><li>编译</li></ol><h3 id="0-文件"><a href="#0-文件" class="headerlink" title="0.文件"></a>0.文件</h3><p>源文件：u-boot-1.1.6.tar.bz2</p><p>补丁文件：u-boot-1.1.6_jz2440.patch</p><h3 id="1-解压缩"><a href="#1-解压缩" class="headerlink" title="1.解压缩"></a>1.解压缩</h3><p>解压u-boot-1.1.6.tar.bz2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>tar -xjf u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2</span><br><span class="line"><span class="number">2.</span>cd u-boot<span class="number">-1.1</span><span class="number">.6</span></span><br></pre></td></tr></table></figure><h3 id="2-打补丁"><a href="#2-打补丁" class="headerlink" title="2.打补丁"></a>2.打补丁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../u-boot-1.1.6_jz2440.patc</span><br></pre></td></tr></table></figure><ol><li><p>patch：打补丁命令</p></li><li><p>-p1:补丁打在哪里的位置：</p><p>打开u-boot-1.1.6_jz2440.patc</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_02-27-00.png" alt="Snipaste_2018-12-25_02-27-00"></p><p>红色为打补丁位置，因为在u-boot-1.1.6位置所以要忽略u-boot-1.1.6。此时使用-p1表示忽略一级忽略。</p><p>例：-p2：忽略u-boot-1.1.6/board/</p></li><li><p>../u-boot-1.1.6_jz2440.patc为指示补丁文件所在目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ ls<span class="comment">//0.查看源文件，补丁文件</span></span><br><span class="line">u-boot<span class="number">-1.1</span><span class="number">.6</span>_jz2440.patch  u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2</span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ tar -xjf u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2<span class="comment">//1.解压源文件</span></span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ cd u-boot<span class="number">-1.1</span><span class="number">.6</span>/  <span class="comment">//cd 到解压后源文件</span></span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot/u-boot<span class="number">-1.1</span><span class="number">.6</span>$ patch -p1 &lt; ../u-boot<span class="number">-1.1</span><span class="number">.6</span>_jz2440.patch  <span class="comment">//打补丁源文件</span></span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/<span class="number">100</span>ask24x0.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/boot_init.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/config.mk</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/flash.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/lowlevel_init.S</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/Makefile</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/u-boot.lds</span><br><span class="line">patching file board/MAI/bios_emulator/scitech/src/v86bios/lex.l</span><br><span class="line">patching file common/cmd_bootm.c</span><br><span class="line">patching file common/cmd_load.c</span><br><span class="line">patching file common/cmd_menu_bak.c</span><br><span class="line">patching file common/cmd_menu.c</span><br><span class="line">patching file common/cmd_nand.c</span><br><span class="line">patching file common/cmd_nand_legacy.c</span><br><span class="line">patching file common/cmd_suspend.c</span><br><span class="line">patching file common/cmd_usbslave.c</span><br><span class="line">patching file common/env_nand.c</span><br><span class="line">patching file common/main.c</span><br><span class="line">patching file common/Makefile</span><br><span class="line">patching file cpu/arm920t/cpu.c</span><br><span class="line">patching file cpu/arm920t/Makefile</span><br><span class="line">patching file cpu/arm920t/s3c24x0/interrupts.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/Makefile</span><br><span class="line">patching file cpu/arm920t/s3c24x0/nand_flash.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/nand_flash_legacy.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/speed.c</span><br><span class="line">patching file cpu/arm920t/start.S</span><br><span class="line">patching file cpu/arm920t/suspend.S</span><br><span class="line">patching file doc/README.SBC8560</span><br><span class="line">patching file drivers/cfi_flash.c</span><br><span class="line">patching file drivers/dm9000x.c</span><br><span class="line">patching file drivers/jedec_flash.c</span><br><span class="line">patching file drivers/Makefile</span><br><span class="line">patching file drivers/nand/nand_base.c</span><br><span class="line">patching file drivers/nand/nand_ids.c</span><br><span class="line">patching file drivers/nand/nand_util.c</span><br><span class="line">patching file drivers/nand_legacy/nand_legacy.c</span><br><span class="line">patching file drivers/usb/<span class="number">2440u</span>sb.h</span><br><span class="line">patching file drivers/usb/Makefile</span><br><span class="line">patching file drivers/usb/mrgtmp0</span><br><span class="line">patching file drivers/usb/usb.h</span><br><span class="line">patching file drivers/usb/usbin.c</span><br><span class="line">patching file drivers/usb/usbin.h</span><br><span class="line">patching file drivers/usb/usbinit.c</span><br><span class="line">patching file drivers/usb/usbinit.h</span><br><span class="line">patching file drivers/usb/usblib.c</span><br><span class="line">patching file drivers/usb/usblib.h</span><br><span class="line">patching file drivers/usb/usbmain.c</span><br><span class="line">patching file drivers/usb/usbmain.h</span><br><span class="line">patching file drivers/usb/usbout.c</span><br><span class="line">patching file drivers/usb/usbout.h</span><br><span class="line">patching file drivers/usb/usbsetup.c</span><br><span class="line">patching file drivers/usb/usbsetup.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/mach-types.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/types.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/u-boot-arm.h</span><br><span class="line">patching file include/configs/<span class="number">100</span>ask24x0.h</span><br><span class="line">patching file include/configs/SBC8560.h</span><br><span class="line">patching file include/def.h</span><br><span class="line">patching file include/flash.h</span><br><span class="line">patching file include/nand.h</span><br><span class="line">patching file include/s3c2410.h</span><br><span class="line">patching file include/s3c24x0.h</span><br><span class="line">patching file include/usb.h</span><br><span class="line">patching file lib_arm/armlinux.c</span><br><span class="line">patching file lib_arm/board.c</span><br><span class="line">patching file Makefile</span><br><span class="line">patching file net/net.c</span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot/u-boot<span class="number">-1.1</span><span class="number">.6</span>$</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="number">100</span>ask24x0_config</span><br></pre></td></tr></table></figure><h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>按上面执行即可获得u-boot.bin文件</p><h3 id="设置u-boot环境变量"><a href="#设置u-boot环境变量" class="headerlink" title="设置u-boot环境变量"></a>设置u-boot环境变量</h3><p>如下图4步走：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">100</span>ask Bootloader <span class="keyword">for</span> OpenJTAG #####</span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">[o] Download u-boot to Nor Flash</span><br><span class="line">[c] Re-scan Nor Flash</span><br><span class="line">[u] Copy bootloader from nand to nor</span><br><span class="line">[v] Copy bootloader from nor to nand</span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">[d] Download to SDRAM &amp; Run</span><br><span class="line">[z] Download zImage into RAM</span><br><span class="line">[g] Boot linux from RAM</span><br><span class="line">[f] Format the Nand Flash</span><br><span class="line">[s] Set the boot parameters</span><br><span class="line">[b] Boot the system</span><br><span class="line">[r] Reboot u-boot</span><br><span class="line">[q] Quit from menu</span><br><span class="line">Enter your selection: q <span class="comment">//1.退出</span></span><br><span class="line">OpenJTAG&gt; print  <span class="comment">//2.打印Uboot环境</span></span><br><span class="line">bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,<span class="number">115200</span></span><br><span class="line">bootcmd=nand read.jffs2 <span class="number">0x30007FC0</span> kernel; bootm <span class="number">0x30007FC0</span></span><br><span class="line">baudrate=<span class="number">115200</span></span><br><span class="line">ethaddr=<span class="number">08</span>:<span class="number">00</span>:<span class="number">3</span>e:<span class="number">26</span>:<span class="number">0</span>a:<span class="number">5b</span></span><br><span class="line">ipaddr=<span class="number">192.168</span><span class="number">.1</span><span class="number">.17</span></span><br><span class="line">serverip=<span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">netmask=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">mtdids=nand0=nandflash0</span><br><span class="line">mtdparts=mtdparts=nandflash0:<span class="number">256</span>k@<span class="number">0</span>(bootloader),<span class="number">128</span>k(params),<span class="number">2</span>m(kernel),-(root)</span><br><span class="line">bootdelay=<span class="number">5</span></span><br><span class="line"><span class="built_in">stdin</span>=serial</span><br><span class="line"><span class="built_in">stdout</span>=serial</span><br><span class="line"><span class="built_in">stderr</span>=serial</span><br><span class="line">partition=nand0,<span class="number">0</span></span><br><span class="line">mtddevnum=<span class="number">0</span></span><br><span class="line">mtddevname=bootloader</span><br><span class="line"></span><br><span class="line">Environment size: <span class="number">450</span>/<span class="number">131068</span> bytes</span><br><span class="line">OpenJTAG&gt; <span class="built_in">set</span> bootdelay <span class="number">10</span> <span class="comment">//3.重新配置启动计数时间</span></span><br><span class="line">OpenJTAG&gt; save <span class="comment">//4，保存</span></span><br><span class="line">Saving Environment to NAND...</span><br><span class="line">Erasing Nand...Writing to Nand... done</span><br><span class="line">OpenJTAG&gt;</span><br><span class="line">penJTAG&gt; reset<span class="comment">//5.复位重启</span></span><br></pre></td></tr></table></figure><h3 id="分析make-100ask24x0-config"><a href="#分析make-100ask24x0-config" class="headerlink" title="分析make 100ask24x0_config"></a>分析make 100ask24x0_config</h3><p>打开Makefile找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>ask24x0_config:unconfig</span><br><span class="line">@$(MKCONFIG) $(@:_config=) arm arm920t <span class="number">100</span>ask24x0 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>执行：make 100ask24x0_config</p><p>等于执行：@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0脚本语句。</p><p>分析：@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0</p><ol><li><p>MKCONFIG    := $(SRCTREE)/mkconfig //源文件所在的目录下的mkconfig</p></li><li><p>$(@:_config=)  100ask24x0_config</p><p>$(@   $:当前目标即100ask24x0_config</p><p>:_config= 表示替换空</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_05-15-26.png" alt="Snipaste_2018-12-25_05-15-26"></p></li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_05-31-01.png" alt="Snipaste_2018-12-25_05-31-01"></p><p>向mkconfig传递$1~$6参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux如何启动&quot;&gt;&lt;a href=&quot;#linux如何启动&quot; class=&quot;headerlink&quot; title=&quot;linux如何启动&quot;&gt;&lt;/a&gt;linux如何启动&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_2018-12-25
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-12-21-LS7-4-UART</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-LS7-4-UART.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-LS7-4-UART.html</id>
    <published>2018-12-21T13:11:40.000Z</published>
    <updated>2018-12-24T14:30:56.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="usart功能："><a href="#usart功能：" class="headerlink" title="usart功能："></a>usart功能：</h3><p>打印调式信息</p><p>外接各种模块：gps，蓝牙，WiFi….</p><p>结构简单，可靠。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_21-17-33.png" alt="Snipaste_2018-12-21_21-17-33"></p><h3 id="简单协议"><a href="#简单协议" class="headerlink" title="简单协议"></a>简单协议</h3><p>波特率</p><p>数据格式：数据位，停止位，校验位，流量控制。</p><p>如何发送字节</p><p>假如要发送一个字节’A’;</p><p>‘A’ :0x41:0b01000001</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-22-10.png" alt="Snipaste_2018-12-21_22-22-10"></p><p>①双方约定好每一位占据的时间（波特率）</p><p>​    假设每一单位时间ts，（t=1/baud（s））</p><p>②开始时txd为高电平，当开始发送数据时把数据线拉低，计时1t（s）为开始位。</p><p>③写：ARM根据数据’A’驱动TXD的电平</p><p>   读：通过在数据的中间时间段读取电平</p><p>当8位数据发送完毕，再发送一个检验位（奇/偶检验），但随着技术提高现在几乎都为0，不校验。</p><p>④一个字节（8bit）完成后发送一个停止位（高电平，一般设置占据1/1.5/2t（s）时间）。传送完成，此时txd高电平空闲状态，等待开始下个字节发送。</p><h3 id="关于逻辑电平表示"><a href="#关于逻辑电平表示" class="headerlink" title="关于逻辑电平表示"></a>关于逻辑电平表示</h3><p>1.TTL/CMOS表示</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-26-58.png" alt="Snipaste_2018-12-21_22-26-58"></p><p>0~0.7 (y) v表示逻辑“0”，x（2）~5v表示逻辑“1”</p><p>2.RS232表示</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-28-24.png" alt="Snipaste_2018-12-21_22-28-24"></p><p>+3~012v表示逻辑“0”，-3~-12v表示逻辑“1”</p><p>总结：cmos/ttl电平范围（0~5v）小，传输距离近，RS-232电平范围（-12~+12v）大，可以距离远。一般远距离使用RS232。</p><p>cmos/ttl和rs232电平波形相反。</p><h3 id="常见串口接口"><a href="#常见串口接口" class="headerlink" title="常见串口接口"></a>常见串口接口</h3><h4 id="直接引出"><a href="#直接引出" class="headerlink" title="直接引出"></a>直接引出</h4><h4 id="RS232接口、RS485"><a href="#RS232接口、RS485" class="headerlink" title="RS232接口、RS485"></a>RS232接口、RS485</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-44-39.png" alt="Snipaste_2018-12-21_22-44-39"></p><h4 id="usb接口"><a href="#usb接口" class="headerlink" title="usb接口"></a>usb接口</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-44-49.png" alt="Snipaste_2018-12-21_22-44-49"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>参考：<a href="https://www.cnblogs.com/Ph-one/p/3994797.html" target="_blank" rel="noopener">USB/232/485/TTL/CMOS（串口通信）</a></p><p>1.USB:电脑的USB口信号时USB信号，为差分信号，电压范围：+400mV~-400mV间变化；直流电压5V 驱动电流500MA</p><p>2.232电平：　　逻辑1(MARK)=-3V～-15V　　逻辑0(SPACE)=+3～+15V</p><p>3.485电平：　　它是<a href="http://www.baidu.com/s?wd=%E5%B7%AE%E5%88%86%E4%BF%A1%E5%8F%B7&amp;hl_tag=textlink&amp;tn=SE_hldp01350_v6v6zkg6" target="_blank" rel="noopener">差分信号</a>，两信号线 ＋2V～＋6V表示“0”，　　- 6V～- 2V表示“1”。</p><p>4.TTL电平：　　一般输出高电平是3.5V，输出低电平是0.2V。</p><p>5.CMOS  ：　　门闩值为0.3VCC和0.7VCC，比如对于5V供电器件，分别为1.5V和3.5V（大概）</p><p>对于TTL器件和CMOS器件相连，如果是CMOS器件输出到TTL器件，这个也是可以直接连的，因为CMOS电平的范围是TTL输入电平范围的子集。但如果反过来就不行，因为TTL电平的输出范围要比CMOS电平的范围大，有可能出现不确定的电平状态,引起电路出现不可预知的混乱。</p><h3 id="UART-结构框图"><a href="#UART-结构框图" class="headerlink" title="UART 结构框图"></a>UART 结构框图</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_23-01-04.png" alt="Snipaste_2018-12-21_23-01-04"></p><p>程序是如何把内存的数据发送到串口？</p><p>程序把内存的数据写入FITO(先进先出)存储器内，uart单元会把FIFI的数据写入移位器（Transmit Shifiter），然后移位器（Transmit Shifiter）按照设置好协议逐位发送给串口。</p><p>当内存接收完毕，uart单元产生中断给CPU</p><p>程序是如何接收串口的数据写到串口？</p><p>uart单元会逐位接收串口的数据，然后把接收到的数据写入移位器（Receiver Shifiter）内，然后程序会把FITO(先进先出)存储器内的数据写入内存。</p><p>当内存接收完毕，uart单元产生中断给CPU</p><h2 id="软件编程"><a href="#软件编程" class="headerlink" title="软件编程"></a>软件编程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>设置引脚用于串口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置引脚用于串口 */</span></span><br><span class="line"><span class="comment">/* GPH2,3用于TxD0, RxD0 */</span></span><br><span class="line">GPHCON&amp;=~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON&amp;=~((<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line"><span class="comment">//上拉</span></span><br><span class="line">GPHUP!=((<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置波特率</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-11-56.png" alt="Snipaste_2018-12-24_21-11-56"></p></li></ol><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置波特率 */</span></span><br><span class="line"><span class="comment">/* UBRDIVn = (int)( UART clock / ( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment"> *  UART clock = 50M</span></span><br><span class="line"><span class="comment"> *  UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 设置使用PCLK时钟50MHZ,中断/查询模式 */</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure><p>​    3.设置数据格式 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置数据格式 */</span></span><br><span class="line"></span><br><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure><p>uart0_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 115200,8n1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置引脚用于串口 */</span></span><br><span class="line"><span class="comment">/* GPH2,3用于TxD0, RxD0 */</span></span><br><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置波特率 */</span></span><br><span class="line"><span class="comment">/* UBRDIVn = (int)( UART clock / ( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment"> *  UART clock = 50M</span></span><br><span class="line"><span class="comment"> *  UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* PCLK,中断/查询模式 */</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置数据格式 */</span></span><br><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位, 无较验位, 1个停止位 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-46-03.png" alt="Snipaste_2018-12-24_21-46-03"></p><p><strong>输入字节</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-46-15.png" alt="Snipaste_2018-12-24_21-46-15"></p><p>由上可知：判断是否有数据：当上面该位为0，UTXH0寄存器里面有数据，等待发送，为1时：数据发送出去，为空，此时写入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UTRSTAT0 */</span></span><br><span class="line"><span class="comment">/* UTXH0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</span><br></pre></td></tr></table></figure><p>注意在上c2440_soc.h中添加</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_22-11-30.png" alt="Snipaste_2018-12-24_22-11-30"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_22-11-12.png" alt="Snipaste_2018-12-24_22-11-12"></p><p>UTXH0地址为0向0000020（L）</p><p>数据格式为byte</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     __REG_BYTE(x)(*(volatile unsigned char *)(x)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     UTXH0                    __REG_BYTE(0x50000020)  <span class="comment">//UART 0 transmission hold</span></span></span><br></pre></td></tr></table></figure><p><strong>输出字节：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出字符串：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">putchar</span>(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* UTRSTAT0 */</span></span><br><span class="line"><span class="comment">/* UTXH0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;h3 id=&quot;usart功能：&quot;&gt;&lt;a href=&quot;#usart功能：&quot; class=&quot;headerlink&quot; title=&quot;u
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-21-LS7-4-ARM芯片时钟体系</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-2018-12-21-LS7-4-ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-2018-12-21-LS7-4-ARM芯片时钟体系.html</id>
    <published>2018-12-21T13:10:58.000Z</published>
    <updated>2018-12-24T17:48:13.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LS6-3.ARM芯片时钟体系</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-LS6-3-ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-LS6-3-ARM芯片时钟体系.html</id>
    <published>2018-12-20T16:03:42.000Z</published>
    <updated>2018-12-21T13:13:06.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时钟体系架构"><a href="#时钟体系架构" class="headerlink" title="时钟体系架构"></a>时钟体系架构</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-10-02.png" alt="Snipaste_2018-12-21_00-10-02"></p><p>cpu：fclk</p><p>AHB:高速总线（HCLK）</p><p>APB:低速总线（PCLK）</p><h3 id="时钟最大范围"><a href="#时钟最大范围" class="headerlink" title="时钟最大范围"></a>时钟最大范围</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-14-33.png" alt="Snipaste_2018-12-21_00-14-33"></p><h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>可以通过①外部引脚提供和②晶振提供</p><h2 id="JZ2240开发板时钟选择"><a href="#JZ2240开发板时钟选择" class="headerlink" title="JZ2240开发板时钟选择"></a>JZ2240开发板时钟选择</h2><h3 id="jz2240时钟源"><a href="#jz2240时钟源" class="headerlink" title="jz2240时钟源"></a>jz2240时钟源</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-22-05.png" alt="Snipaste_2018-12-21_00-22-05"></p><p>时钟源可以由外部引脚提供或者12M晶振提供，通过OM[3:2]选择使用哪个作为时钟源，选择方式如下：</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-26-49.png" alt="Snipaste_2018-12-21_00-26-49"></p><h3 id="JZ2240开发板时钟选择-1"><a href="#JZ2240开发板时钟选择-1" class="headerlink" title="JZ2240开发板时钟选择"></a>JZ2240开发板时钟选择</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-28-56.png" alt="Snipaste_2018-12-21_00-28-56"></p><p>图中看出OM[3:2]都为00:注时钟源和USB时钟源都为12M晶振。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-18-58.png" alt="Snipaste_2018-12-21_00-18-58"></p><p>三者时钟源由12M晶振提供，通过PLL(锁相环)来倍频得到FCLK：400Mhz</p><h3 id="JZ2240时钟分析"><a href="#JZ2240时钟分析" class="headerlink" title="JZ2240时钟分析"></a>JZ2240时钟分析</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-41-25.png" alt="Snipaste_2018-12-21_00-41-25"></p><ul><li><p>由①OM[3,2]选择②MPLL（主时钟源）,③UPLL（USB时钟源）的时钟源，这里OM[3,2]=00，选择MPLL，UPLL时钟为OSC（外部12M晶振）（硬件）。</p></li><li><p>时钟源通过②MPLL锁相环倍频得到⑦FCLK：400Mmz,</p></li><li><p>通过CLKCNTL获的⑤HCLK,⑥PCLK时钟</p><p>FCLK：提供给CPU</p><p>HCLK:AHB(高速总线)</p><p>PCLK:APB(低速总线)</p></li></ul><h2 id="时钟系统总结"><a href="#时钟系统总结" class="headerlink" title="时钟系统总结"></a>时钟系统总结</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-53-58.png" alt="Snipaste_2018-12-21_00-53-58"></p><h2 id="软件编程"><a href="#软件编程" class="headerlink" title="软件编程"></a>软件编程</h2><h3 id="时钟设置原理"><a href="#时钟设置原理" class="headerlink" title="时钟设置原理"></a>时钟设置原理</h3><p>通过控制MPLL，HDIV和PDIV</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_01-10-41.png" alt="Snipaste_2018-12-21_01-10-41"></p><ol><li>电源启动，复位引脚维持一段时间等待电源稳定，才输出高电平。（专用复位芯片会使复位脚等待一段时间才会高电平）</li><li>根据OM[3:2]=00,选择FCLK=12Mhz晶振提供时钟，此时CPU未运行。</li><li>等复位脚松开高电平时，cpu开始运行。此时PLL锁存OM[3:2]的值</li><li>设置PLL，此时CPU停止工作，</li><li>PLL开始工作，等待PLL输出稳定频率，CPU 开始运行</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_19-53-38.png" alt="Snipaste_2018-12-21_19-53-38"></p><p>我们要设置S3C2440的FCLK=400Mhz，HCLK=100Mhz，PCLK=50Mhz</p><p>1.使  FCLK=400M:通过MPLLCON设置。</p><p>2.使HCLK=100Mhz，PCLK=50Mhz：设置CLKDIV</p><p>HCLK=FCLK/4</p><p>PCLK=FCLK/8=HCLK/2</p><h3 id="如何设置系统设置"><a href="#如何设置系统设置" class="headerlink" title="如何设置系统设置"></a>如何设置系统设置</h3><p>如何通过程序控制MPLL，HDIV和PDIV</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>1.使  FCLK=400M:通过MPLLCON设置</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-22-49.png" alt="Snipaste_2018-12-21_20-22-49"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-27-42.png" alt="Snipaste_2018-12-21_20-27-42"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-24-14.png" alt="Snipaste_2018-12-21_20-24-14"></p><p>从图看出要使FCLK=400M:<strong>MPLLCON=(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</strong></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>2.使HCLK=100Mhz，PCLK=50Mhz：设置CLKDIV</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-10-08.png" alt="Snipaste_2018-12-21_20-10-08"></p><p>HCLK=FCLK/4:CLKDIVN[2:1]=0b10</p><p>PCLK=FCLK/8=HCLK/2:CLKDIVN[0]=1</p><p>即：CLKDIVN=0b101=0x05  FCLK:HCLK:PCLK=1:4：8</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-46-14.png" alt="Snipaste_2018-12-21_20-46-14"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该命令是使处理器工作在异步模式下，</p><p>HDIV不等于0 ，需要设置在异步模式，否则CPU工作在HCLK=100时钟。</p><h3 id="开编程"><a href="#开编程" class="headerlink" title="开编程"></a>开编程</h3><p>由于时钟使用到汇编的协处理器指令，所以时钟程序使用汇编来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span></span><br><span class="line"><span class="comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000000</span></span><br><span class="line">ldr r1, =<span class="number">0xFFFFFFFF</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000014</span></span><br><span class="line">ldr r1, =<span class="number">0x5</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置CPU工作于异步模式 */</span></span><br><span class="line">mrc p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line">orr r0,r0,#<span class="number">0xc0000000</span>   <span class="comment">//R1_nF:OR:R1_iA</span></span><br><span class="line">mcr p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span></span><br><span class="line"><span class="comment"> *  m = MDIV+8 = 92+8=100</span></span><br><span class="line"><span class="comment"> *  p = PDIV+2 = 1+2 = 3</span></span><br><span class="line"><span class="comment"> *  s = SDIV = 1</span></span><br><span class="line"><span class="comment"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000004</span></span><br><span class="line">ldr r1, =(<span class="number">92</span>&lt;&lt;<span class="number">12</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span></span><br><span class="line"><span class="comment"> * 然后CPU工作于新的频率FCLK</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时钟体系架构&quot;&gt;&lt;a href=&quot;#时钟体系架构&quot; class=&quot;headerlink&quot; title=&quot;时钟体系架构&quot;&gt;&lt;/a&gt;时钟体系架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_2018-12-21_00-10-02.pn
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-20-LS5-2.key之led控制.md</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-20-LS5-2-key%E4%B9%8Bled%E6%8E%A7%E5%88%B6.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-20-LS5-2-key之led控制.html</id>
    <published>2018-12-20T09:39:31.000Z</published>
    <updated>2018-12-20T16:01:30.495Z</updated>
    
    <content type="html"><![CDATA[<p>简介：</p><p>通过开发板上的S2,S3,S4控制D10,D11,D12的亮灭</p><ul><li>按下S2，D10亮；松开S2，D10灭。</li><li>按下S3，D11亮；松开S3，D11灭。</li><li>按下S4，D12亮；松开S4，D12灭。</li></ul><p>原理图：</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-12-16.png" alt="Snipaste_2018-12-20_18-12-16"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-11-19.png" alt="Snipaste_2018-12-20_18-11-19"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-09-17.png" alt="Snipaste_2018-12-20_18-09-17"></p><p>通过原理图看出S2(GPF0)，S3(GPF2)，S4(GPG3)。D10(GPF4)，D11(GPF5)，D12(GPF6).</p><p>当按键松开时为高电平，按下为低电平。</p><p>当D10~D12输出低电平时亮，高电平时，灭</p><p>软件编程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * key控制LED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s3c2440_soc.h"</span><span class="comment">//引入头文件，寄存器定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val1;</span><br><span class="line"><span class="keyword">int</span> val2;</span><br><span class="line"><span class="comment">/*配置GPF4/5/6为输出引脚*/</span></span><br><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">12</span>));</span><br><span class="line">GPFCON |=  ((<span class="number">1</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置GPF0/2，GPG3为输入引脚*/</span></span><br><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">val1=GPFDAT;<span class="comment">//保存GPFDAT的值</span></span><br><span class="line">val2=GPGDAT;<span class="comment">//保存GPGDAT的值</span></span><br><span class="line"><span class="keyword">if</span>(val1&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val1&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val2&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介：&lt;/p&gt;
&lt;p&gt;通过开发板上的S2,S3,S4控制D10,D11,D12的亮灭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按下S2，D10亮；松开S2，D10灭。&lt;/li&gt;
&lt;li&gt;按下S3，D11亮；松开S3，D11灭。&lt;/li&gt;
&lt;li&gt;按下S4，D12亮；松开S4，D12灭。&lt;
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-%E9%98%BF%E9%87%8C%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-阿里图床测试.html</id>
    <published>2018-12-19T20:06:41.821Z</published>
    <updated>2018-12-20T06:21:11.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里图床测试"><a href="#阿里图床测试" class="headerlink" title="阿里图床测试"></a>阿里图床测试</h1><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-31-14.png" alt="Snipaste_2018-12-20_03-19-45"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阿里图床测试&quot;&gt;&lt;a href=&quot;#阿里图床测试&quot; class=&quot;headerlink&quot; title=&quot;阿里图床测试&quot;&gt;&lt;/a&gt;阿里图床测试&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://setcalm.oss-cn-zhangjiakou.aliyuncs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-12-14-LS1-开发之系统安装</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-18-LS2-%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-18-LS2-开发之系统安装.html</id>
    <published>2018-12-18T09:51:48.000Z</published>
    <updated>2018-12-20T06:20:58.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="烧录软件安装"><a href="#烧录软件安装" class="headerlink" title="烧录软件安装"></a>烧录软件安装</h2><h3 id="EasyOpenJTAG介绍及安装程序"><a href="#EasyOpenJTAG介绍及安装程序" class="headerlink" title="EasyOpenJTAG介绍及安装程序"></a>EasyOpenJTAG介绍及安装程序</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><a id="more"></a><p>该部分为win 8,10 系统需要设置，非win 8,10 系统略过。 </p><p>由于 Windows10 的安全机制，安装 EasyOpenJTAG 更麻烦一点： 需要更改 Windows 的<br>启动模式， 禁用“驱动程序签名强制”功能。</p><p>详细教程：<a href="https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html</a></p><p>点击桌面右下角的通知图标，选择“所有设置”，如图 4.11 所示。然后选择“更新和安全”，如图 4.12 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-50-55.png" alt="Snipaste_2018-12-17_17-50-55"></p><p>(1) 选择左边选项栏中的“恢复”，选择高级启动的“立即重启”，然后选择“更新和安全”，如图 4.13 所示。然后选择“疑难解答”，如图 4.14 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-52-03.png" alt="Snipaste_2018-12-17_17-52-03"></p><p>(2) 接着在“高级选项”里选择“启动设置”，如图 4.15 所示。在“启动设置”里面选择重启，如图 4.16 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-47-16.png" alt="Snipaste_2018-12-17_17-47-16">(3) 此时电脑会重启，重启之后不会直接进入系统界面，而是进入图 4.17 所示的“启<br>动设置“界面，按下键盘的” F7“，禁用驱动程序强制签名。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-52-59.png" alt="Snipaste_2018-12-17_17-52-59"></p><p>如下步骤是正常的驱动安装流程，非 win 8,10 系统(比如 winxp,win7 系统)直接从这里开始。 </p><h4 id="2-开始安装-EasyOpenJTAG驱动"><a href="#2-开始安装-EasyOpenJTAG驱动" class="headerlink" title="2.开始安装 EasyOpenJTAG驱动"></a>2.开始安装 EasyOpenJTAG驱动</h4><p>(1) 将 EasyOpenJTAG 插入电脑 USB 口。打开“设备管理器”。在设备管理器可以看到两个感叹号图标的设备，这表示 EasyOpenJTAG 未安装驱动。 选中第一个带感叹号的设备，右键鼠标，在弹出的菜单中选择“更新驱动程序”，如图 所示</p><p> <img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_18-07-57.png" alt="Snipaste_2018-12-17_18-07-57"></p><p>(2) 选择“浏览我的计算机以查找驱动程序软件”再选择驱动程序的路径，点击“下一步”，如图 4.21 所示。在弹出的 Windows 安全警告窗口里，选择“始终安装此驱动程序软件”，如图 4.22 所示 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_15-50-26.png" alt="Snipaste_2018-12-18_15-50-26"></p><p>（4）之后看到如图 4.23 所示的安装成功提示信息。同样的方法，点击第二个带感叹号的<br>设备。 这样一共重复三次即可更新完所有驱动，驱动安装好后设备管理器显示:一个“ US B<br>Serial Port” ,一个“100ASK JTAG”，一个“100ASK Serial Port”，如图 4.24 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_15-52-39.png" alt="Snipaste_2018-12-18_15-52-39"></p><p>（安装完成）</p><h4 id="3-安装-EasyOpenJTAG应用程序-（oflash）"><a href="#3-安装-EasyOpenJTAG应用程序-（oflash）" class="headerlink" title="3.安装 EasyOpenJTAG应用程序 （oflash）"></a>3.安装 EasyOpenJTAG应用程序 （oflash）</h4><p> （1） 双击“01.OpenOCD with GUI setup.exe “一路OK，就完成。【略】</p><p>（2）测试是否安装成功。 </p><p>打开 Windows 命令窗口，如图 4.9 所示。 在窗口输入“oflash”命令即可启动 oflash，如图 4.10 所示即表示安装成功 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_16-05-24.png" alt="Snipaste_2018-12-18_16-05-24"></p><h4 id="4-失败解决方法"><a href="#4-失败解决方法" class="headerlink" title="4.失败解决方法"></a>4.失败解决方法</h4><p>无法找到某环境，配置环境变量。</p><p>找到OpenJTAG的bin 目录，将其按照下面加入环境变量。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_16-21-55.png" alt="Snipaste_2018-12-18_16-21-55"></p><h3 id="EasyOpenJTAG烧录程序"><a href="#EasyOpenJTAG烧录程序" class="headerlink" title="EasyOpenJTAG烧录程序"></a>EasyOpenJTAG烧录程序</h3><ul><li>用于烧录.bin文件（uboot.bin，裸板程序），只能烧小文件，速度极慢。 </li><li>uboot文件可以烧录到–&gt;Nor,Nand。裸板文件只能烧录到–&gt;Nand。</li></ul><h4 id="烧录leds-bin文件（cmd下oflash）"><a href="#烧录leds-bin文件（cmd下oflash）" class="headerlink" title="烧录leds.bin文件（cmd下oflash）"></a>烧录leds.bin文件（cmd下oflash）</h4><ul><li><p>选择启动方式：Nand启动</p></li><li><p>选择要烧录的.bin 文件路径。</p><p>（D:\韦东山\1_ARM裸机1期加强版(新1期)\源码文档图片\源码\源码<em>20180321</em>添加传感器\001_led_on_008_003）</p></li><li><p>开始oflash烧录</p></li></ul><ol><li>打开cmdwindows+R：选择烧录文件盘符：D</li><li>cd 到烧录目录：cd:D:\韦东山\1_ARM裸机1期加强版(新1期)\源码文档图片\源码\源码<em>20180321</em>添加传感器\001_led_on_008_003</li><li>启动oflash并选择烧录.bin文件：oflash led_on.bin</li><li>选择烧录工具：enter the number：0</li><li>选择烧录芯片：enter the number：1</li><li>选择烧录地址：select the function to test：0（裸机文件只能从Nand启动）</li><li>再次确认烧录地址：select the function to test：0</li><li>烧录到第0块：input target block number：0</li></ol><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_17-15-08.png" alt="Snipaste_2018-12-18_17-15-08"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_17-21-51.png" alt="Snipaste_2018-12-18_17-21-51"></p><p>烧录成功ok.</p><p>拔掉OpenJTGA,重启开发板，观察led。</p><p>使用usbshaolu</p><h2 id="如何烧录系统"><a href="#如何烧录系统" class="headerlink" title="如何烧录系统"></a>如何烧录系统</h2><p>我们知道使用OpenJTGA烧录一个Uboot文件用了几分钟，烧写速度非常的慢。在实际开发中经常要修改编译，那有没有更快的烧写方法呢。因此引入使用Uboot通过usb烧写bin 文件。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Windows和linux系统启动比较"><a href="#Windows和linux系统启动比较" class="headerlink" title="Windows和linux系统启动比较"></a>Windows和linux系统启动比较</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-55-36.png" alt="Snipaste_2018-12-18_18-55-36"></p><p>图1-1</p><h4 id="jz2440v3的flash介绍"><a href="#jz2440v3的flash介绍" class="headerlink" title="jz2440v3的flash介绍"></a>jz2440v3的flash介绍</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-58-23.png" alt="Snipaste_2018-12-18_18-58-23"></p><p>图1-2</p><p>　Bootloader 即引导加载程序，是系统加电后运行的第一段<a href="https://www.baidu.com/s?wd=%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">软件代码</a>。简单的说u-boot是bootloader，它们所完成的任务也大同小异。</p><p>uboot可以烧录在Nor，Nand 上，一般u-boot烧录在Nor，用于系统启动引导。</p><p>Nand比较大，内核及文件系统存在于Nand Flash</p><h4 id="jz2440烧录框架"><a href="#jz2440烧录框架" class="headerlink" title="jz2440烧录框架"></a>jz2440烧录框架</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-45-45.png" alt="Snipaste_2018-12-18_18-45-45"></p><ol><li>将启动设置在Nor启动</li><li>将u-boot烧录在到Nor Flsh上</li><li>开机，Nor启动，uboot启动</li><li>使用uboot的usb下载功能，使用pc传文件给开发板（kernel及rootfs）</li><li>uboot收到文件后再烧录到flash</li></ol><h4 id="如何烧录系统-1"><a href="#如何烧录系统-1" class="headerlink" title="如何烧录系统"></a>如何烧录系统</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-59-59.png" alt="Snipaste_2018-12-18_18-59-59"></p><p>图1-3</p><ol><li>通过op、eop烧录U-boot到Nor</li><li>通过usb烧录Kernel和文件系统。</li></ol><h2 id="开始烧录系统"><a href="#开始烧录系统" class="headerlink" title="开始烧录系统"></a>开始烧录系统</h2><h3 id="设置启动方式"><a href="#设置启动方式" class="headerlink" title="设置启动方式"></a>设置启动方式</h3><p>将启动设置在Nor启动</p><h3 id="将u-boot烧录在到Nor-Flsh上"><a href="#将u-boot烧录在到Nor-Flsh上" class="headerlink" title="将u-boot烧录在到Nor Flsh上"></a>将u-boot烧录在到Nor Flsh上</h3><p>参考：上面<strong>EasyOpenJTAG烧录程序</strong></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-12-07.png" alt="Snipaste_2018-12-18_18-12-07"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-13-24.png" alt="Snipaste_2018-12-18_18-13-24"></p><p>## </p><h3 id="开机，Nor启动，uboot启动"><a href="#开机，Nor启动，uboot启动" class="headerlink" title="开机，Nor启动，uboot启动"></a>开机，Nor启动，uboot启动</h3><p>拔掉OpenJTAG,设置Nor启动，连接usb及com到pc，使用MobaXterm打开串口，重新启动。</p><p>让开发板运行于 UBOOT，不要让它启动进入内核（在 UBOOT 启动时在串口<br>工具里按下空格【计数三秒内】，阻止它启动 Linux ）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_20-43-46.png" alt="Snipaste_2018-12-18_20-43-46"></p><h3 id="usb传文件给开发板（kernel及rootfs）"><a href="#usb传文件给开发板（kernel及rootfs）" class="headerlink" title="usb传文件给开发板（kernel及rootfs）"></a>usb传文件给开发板（kernel及rootfs）</h3><h4 id="烧录内核"><a href="#烧录内核" class="headerlink" title="烧录内核"></a>烧录内核</h4><p>MobaXterm命令内输入：k</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_20-49-09.png" alt="Snipaste_2018-12-18_20-49-09"></p><p>打开DNW,选择烧录内核</p><p>（usb驱动和DNW安装在下面）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-08-49.png" alt="Snipaste_2018-12-18_21-08-49"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-12-14.png" alt="Snipaste_2018-12-18_21-12-14"></p><h4 id="烧录文件系统"><a href="#烧录文件系统" class="headerlink" title="烧录文件系统"></a>烧录文件系统</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-10-13.png" alt="Snipaste_2018-12-18_21-10-13"></p><h4 id="擦除分区"><a href="#擦除分区" class="headerlink" title="擦除分区"></a>擦除分区</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-17-25.png" alt="Snipaste_2018-12-18_21-17-25"></p><h4 id="完成重启并校准"><a href="#完成重启并校准" class="headerlink" title="完成重启并校准"></a>完成重启并校准</h4><p>启动，重启要求校准，校准失败执行下面命令。会再次校准。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-19-50.png" alt="Snipaste_2018-12-18_21-19-50"></p><h3 id="补充：usb驱动和DNW安装"><a href="#补充：usb驱动和DNW安装" class="headerlink" title="补充：usb驱动和DNW安装"></a>补充：usb驱动和DNW安装</h3><p>注意：一定要完成下面连点：</p><ol><li>连接usb线及com线到pc</li><li>使用MobaXterm打开串口，重新启动，让开发板运行于 UBOOT（在开发板启动时在串口<br>工具里按下空格【计数三秒内】，阻止它启动 Linux ）</li></ol><p>3.运行 zadig-2.3.exe，可以看到如下图 4.25 界面： </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-34-47.png" alt="Snipaste_2018-12-18_21-34-47"></p><p>注意，如果上图位置 1 处的下拉框中没有“SEC S3C2410X Text B/D”，可以点击菜单<br>“Options”，选中“List All Device”；再重接 USB线 。</p><p>4.安装好驱动程序， 设备管理器如图 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-37-32.png" alt="Snipaste_2018-12-18_21-37-32"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;烧录软件安装&quot;&gt;&lt;a href=&quot;#烧录软件安装&quot; class=&quot;headerlink&quot; title=&quot;烧录软件安装&quot;&gt;&lt;/a&gt;烧录软件安装&lt;/h2&gt;&lt;h3 id=&quot;EasyOpenJTAG介绍及安装程序&quot;&gt;&lt;a href=&quot;#EasyOpenJTAG介绍及安装程序&quot; class=&quot;headerlink&quot; title=&quot;EasyOpenJTAG介绍及安装程序&quot;&gt;&lt;/a&gt;EasyOpenJTAG介绍及安装程序&lt;/h3&gt;&lt;h4 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h4&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS4-1.1LED实现</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-15-LS4-1-1LED%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-15-LS4-1-1LED实现.html</id>
    <published>2018-12-15T14:32:25.000Z</published>
    <updated>2018-12-20T08:15:07.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="S3C2440框架"><a href="#S3C2440框架" class="headerlink" title="S3C2440框架"></a>S3C2440框架</h2><a id="more"></a><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_23-40-16.png" alt="Snipaste_2018-12-15_23-40-16"></p><p>Cpu：</p><p>SRAM：SOC内部集成有4K的SRAM片内内存</p><p>GPIO控制器：gpio（General Purpose：通用输入输出接口）</p><p>Nand控制器：外接256M的NandFlash</p><p>NorFlash：NorFlash直接接在Mcu上面（2M）</p><h2 id="S3C2440是如何启动"><a href="#S3C2440是如何启动" class="headerlink" title="S3C2440是如何启动"></a>S3C2440是如何启动</h2><h3 id="NOR启动"><a href="#NOR启动" class="headerlink" title="NOR启动"></a>NOR启动</h3><p>（NorFlash基本地址为0，此时片内SRAM 地址为0X4000 0000）</p><ol><li>程序（bin）烧录在NorFlash</li><li>Cpu从Nor上第一个地址开始（0）读出第一个指令（四字节）执行</li><li>Cpu连接读出其他指令执行</li></ol><p>(即：Nor启动：开机后Cpu从Nor上第一个地址 （0）字节开始连续读出指令并执行)</p><h3 id="Nand启动"><a href="#Nand启动" class="headerlink" title="Nand启动"></a>Nand启动</h3><p>（使用片内4KRAM，基地址为0，此时NorFlash不可可用）</p><ul><li>程序（bin）烧录在NandFlash</li><li>2440硬件首先把Nand前4K的内容复制到片内SRAM内</li><li>然后Cpu从 SRAM的0地址取出第一条指令并执行。</li></ul><p>(即：Nor启动：开机后硬件将Nand前4K的内容复制到片内SRAM，然后Cpu开始SRAM连续读出指令并执行)</p><h2 id="如何通过S3C2440控制led"><a href="#如何通过S3C2440控制led" class="headerlink" title="如何通过S3C2440控制led"></a>如何通过S3C2440控制led</h2><h3 id="GPIO管脚直接控制led"><a href="#GPIO管脚直接控制led" class="headerlink" title="GPIO管脚直接控制led"></a>GPIO管脚直接控制led</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_23-04-50.png" alt="Snipaste_2018-12-15_23-04-50"></p><p>R作用：根据I=U/R,而led电阻很小，如果不接R通过led的电流I会很大，从而烧掉led。这里R具有限流作用，保护led。</p><p>该电路缺点：有些主芯片可能只能输出1.5V或更低电压 或者该芯片只能输出很弱的电流。此时引脚的驱动能力就会不足。</p><p>此时需要改变电路是用三极管驱动，外部供电来实现更大的驱动能力，如下</p><h3 id="三极管驱动led"><a href="#三极管驱动led" class="headerlink" title="三极管驱动led"></a>三极管驱动led</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_23-06-06.png" alt="Snipaste_2018-12-15_23-06-06"></p><p>总结：主芯片引脚通过输出高电平、低电平改变led状态。</p><p>我们不关心GPIO输出的电压值，统一使用高电平和低电平称呼。简称：1/0</p><p>逻辑”1“  ：高电平</p><p>逻辑”0“  ：低电平</p><h2 id="JZ2440实现led控制"><a href="#JZ2440实现led控制" class="headerlink" title="JZ2440实现led控制"></a>JZ2440实现led控制</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_00-13-38.png" alt="Snipaste_2018-12-16_00-13-38"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_00-14-21.png" alt="Snipaste_2018-12-16_00-14-21"></p><h3 id="硬件分析"><a href="#硬件分析" class="headerlink" title="硬件分析"></a>硬件分析</h3><p>从原理图可以看出：当GPF4输出低电平时D10亮， 当GPF4输出高电平时D10灭。</p><p>那么如何控制GPF4输出高低电平呢。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-09-11.png" alt="Snipaste_2018-12-16_01-09-11"></p><h3 id="软件控制led原理"><a href="#软件控制led原理" class="headerlink" title="软件控制led原理"></a>软件控制led原理</h3><h4 id="GPIO配置寄存器"><a href="#GPIO配置寄存器" class="headerlink" title="GPIO配置寄存器"></a>GPIO配置寄存器</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-16-12.png" alt="Snipaste_2018-12-16_01-16-12"></p><h5 id="1-输入-输出状态配置"><a href="#1-输入-输出状态配置" class="headerlink" title="1.输入/输出状态配置"></a>1.输入/输出状态配置</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-22-12.png" alt="Snipaste_2018-12-16_01-22-12"></p><p><strong>配置GPF4为输出状态</strong></p><p>即把0x100写入GPFCON[地址：0x6000050内]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPFCONF[<span class="number">9</span>:<span class="number">8</span>]=<span class="number">0b01</span> ;<span class="comment">//设置GPF4引脚为输出状态，0b表示二进制</span></span><br></pre></td></tr></table></figure><h5 id="2-输入-输出电平设置"><a href="#2-输入-输出电平设置" class="headerlink" title="2.输入/输出电平设置"></a>2.输入/输出电平设置</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-29-52.png" alt="Snipaste_2018-12-16_01-29-52"></p><p><strong>配置GPF4输出高/低电平</strong></p><p>输出高电平，led熄灭：即把0x10写入GPFDAT[地址：0x6000054内]</p><p>输出高低平，led熄灭：即把0写入GPFDAT[地址：0x6000054内]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPFDAT[<span class="number">4</span>]=<span class="number">1</span> ;<span class="comment">//设置GPF4输出高电平，灯灭</span></span><br><span class="line">GPFDAT[<span class="number">4</span>]=<span class="number">0</span> ;<span class="comment">//设置GPF4输出低电平，灯亮</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>配置GPF4为输出状态</strong></p><p>即把0x100写入GPFCON[地址：0x6000050内]</p><p><strong>配置GPF4输出高/低电平</strong></p><p>输出高电平，led熄灭：即把0x10写入GPFDAT[地址：0x6000054内]</p><p>输出高低平，led熄灭：即把0写入GPFDAT[地址：0x6000054内]</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="汇编实现"><a href="#汇编实现" class="headerlink" title="汇编实现"></a>汇编实现</h3><h4 id="几条实用汇编代码"><a href="#几条实用汇编代码" class="headerlink" title="几条实用汇编代码"></a>几条实用汇编代码</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-22-51.png" alt="Snipaste_2018-12-18_23-22-51"></p><p>为甚麽引入伪指令：</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-31-14.png" alt="Snipaste_2018-12-18_23-31-14"></p><p>MOV R0, #0X12345678 //该指令为64位指令，而ARM指令为32位，剩下的无法保存。所以引入伪指令。</p><h4 id="开始汇编点亮led"><a href="#开始汇编点亮led" class="headerlink" title="开始汇编点亮led"></a>开始汇编点亮led</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 点亮LED1: gpf4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//汇编默认的开始处</span></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置GPF4为输出引脚</span></span><br><span class="line"><span class="comment"> * 把0x100写到地址0x56000050</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r1, =<span class="number">0x56000050</span></span><br><span class="line">ldr r0, =<span class="number">0x100</span><span class="comment">/* mov r0, #0x100 */</span></span><br><span class="line">str r0, [r1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置GPF4输出高电平 </span></span><br><span class="line"><span class="comment"> * 把0写到地址0x56000054</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r1, =<span class="number">0x56000054</span></span><br><span class="line">ldr r0, =<span class="number">0</span><span class="comment">/* mov r0, #0 */</span></span><br><span class="line">str r0, [r1]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 死循环 相当while（1）*/</span></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>编译led_on.S文件：  arm-linux-gcc -c -o led_on led_on.S </p><p>补充：安装交叉编译工具</p><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><h4 id="led-c"><a href="#led-c" class="headerlink" title="led.c"></a>led.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 点亮LED1: gpf4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义寄存器地址，从手册</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFCON(*(volatile unsigned long *)0xe0200060)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFDAT(*(volatile unsigned long *)0xe0200064)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 配置GPF4CON为输出引脚</span></span><br><span class="line"><span class="comment"> * 把0x100写到地址0x56000050</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> GPFCON=<span class="number">0X100</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置GPF4DAT输出高电平 </span></span><br><span class="line"><span class="comment"> * 把0写到地址0x56000054</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  GPFDAT=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a. 我们写出了main函数, 谁来调用它?<br>​    b. main函数中变量保存在内存中, 这个内存地址是多少?<br>​    答: 我们还需要写一个汇编代码, 给main函数设置内存, 调用main函数,下面代码。</p><p>汇编代码周一功能：设置内存，调用main函数。</p><h4 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置内存: sp 栈 */</span></span><br><span class="line">ldr sp, =<span class="number">4096</span>  <span class="comment">/* nand启动 */</span></span><br><span class="line"><span class="comment">//ldr sp, =0x40000000+4096  /* nor启动 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用main */</span></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>作者：mymainn<br>​    原文：<a href="https://blog.csdn.net/xiaodingqq/article/details/79182402" target="_blank" rel="noopener">https://blog.csdn.net/xiaodingqq/article/details/79182402</a> </p><p>为什么要nand启动设置成4096，nor启动设置为0x40000000+4096？</p><p>1.SDRAM的地址是 0x30000000 - 0x40000000。</p><p>2.Nand启动时，片内4K RAM基地址为0（在0地址处），Nor Flash不可访问。我们把栈设在这4k内存的顶部</p><p>3.Nor启动时，片内RAM地址为0x4000 0000，片内RAM在0x4000 0000往后的4k 此时的栈顶可以设置到内存的顶部：0x40000000 + 4k（4096）。</p><ol start="4"><li>调用C函数时，返回地址、局部变量一般都保存在栈里，所以调用C程序时要设置栈指针</li><li>之所以设成4096，是由于S4C2410、S3C2440从NAND Flash启动时，它的内部4K RAM的地址为0～4095，可以把栈指针指向最后──其实你也可以指向0～4095中间某个位置，只要不破坏要运行的代码就可以</li></ol><h4 id="start-s优化"><a href="#start-s优化" class="headerlink" title="start.s优化"></a>start.s优化</h4><p>添加：关闭看门狗，以及自动识别是nor/nand启动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">ldr r0, =<span class="number">0x53000000</span></span><br><span class="line">ldr r1, =<span class="number">0</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置内存: sp 栈 */</span></span><br><span class="line"><span class="comment">/* 分辨是nor/nand启动</span></span><br><span class="line"><span class="comment"> * 写0到0地址, 再读出来</span></span><br><span class="line"><span class="comment"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span></span><br><span class="line"><span class="comment"> * 否则就是nor启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mov r1, #<span class="number">0</span></span><br><span class="line">ldr r0, [r1] <span class="comment">/* 读出原来的值备份 */</span></span><br><span class="line">str r1, [r1] <span class="comment">/* 0-&gt;[0] */</span> </span><br><span class="line">ldr r2, [r1] <span class="comment">/* r2=[0] */</span></span><br><span class="line">cmp r1, r2   <span class="comment">/* r1==r2? 如果相等表示是NAND启动 */</span></span><br><span class="line">ldr sp, =<span class="number">0x40000000</span>+<span class="number">4096</span> <span class="comment">/* 先假设是nor启动 */</span></span><br><span class="line">moveq sp, #<span class="number">4096</span>  <span class="comment">/* nand启动 */</span></span><br><span class="line">streq r0, [r1]   <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b hal</span><br></pre></td></tr></table></figure><h4 id="led-c优化"><a href="#led-c优化" class="headerlink" title="led.c优化"></a>led.c优化</h4><p>上面的led.c在配置寄存器时会在配置某位时会会破坏该寄存器的其它位数据。因此需要使用位操作寄存器以避免影响其他位。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_15-28-08.png" alt="Snipaste_2018-12-20_15-28-08"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_15-27-16.png" alt="Snipaste_2018-12-20_15-27-16"></p><p><strong>/<em> 配置GPF4位输出：配置GPF4CON的9，8位为01</em>/</strong></p><p>第一步：将8，9清0</p><p>GPFCON &amp;= ~(3&lt;&lt;8);//8,9位清0</p><p>第一步：将8位置1</p><p>GPFCON |=  (1&lt;&lt;8);</p><p><strong>原理解析</strong></p><p><strong>GPFCON &amp;= ~(3&lt;&lt;8)//8,9位清0</strong></p><p>//1.(3&lt;&lt;8)，3二进制位11，（3&lt;&lt;8）数据左移8位：0000 0000 0000 0000 0000 0011 0000 0000,</p><p>//2.~(3&lt;&lt;8）取反：此时：1111 1111 1111 1111 1111 1100 1111 1111</p><p>//3.GPFCON &amp;= ~(3&lt;&lt;8); 与0</p><table><thead><tr><th>a&amp;b</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>从表看出 ，b=0：a会被清0，但是b=1；a不变，因此达到清0指定位：</p><p>假如：GPFCON=1010 1111 0000 1111 0010 10<strong>11</strong> 1101 0011</p><p>GPFCON &amp;= ~(3&lt;&lt;8)= 1010 1111 0000 1111 0010 10<strong>00</strong> 1101 0011，从而达到清0指定位，而不改变其它位。</p><p><strong>GPFCON |=  (1&lt;&lt;8)</strong></p><p>//1.(3&lt;&lt;8)，（1&lt;&lt;8）数据左移8位：0000 0000 0000 0000 0000 001 0000 0000,</p><p>//2.GPFCON |=  (1&lt;&lt;8) 或1</p><table><thead><tr><th>a\</th><th>b</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>从表看出 ，b=1：a会被☞1，但是b=0；a不变，因此达到置1指定位：</p><p>假如：GPFCON=1010 1111 0000 1111 0010 10<strong>00</strong> 1101 0011</p><p>GPFCON &amp;= ~(3&lt;&lt;8)= 1010 1111 0000 1111 0010 10<strong>001</strong> 1101 0011，从而达到置1指定位，而不改变其它位</p><p>总结：通过上面两步：&amp;0，|1达到将9，8 位变为01。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 点亮LED1: gpf4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义寄存器地址，从手册</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFCON(*(volatile unsigned long *)0xe0200060)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFDAT(*(volatile unsigned long *)0xe0200064)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 配置GPF4CON为输出引脚</span></span><br><span class="line"><span class="comment"> * 把0x100写到地址0x56000050</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">8</span>);<span class="comment">//8,9位清0</span></span><br><span class="line">GPFCON |=  (<span class="number">1</span>&lt;&lt;<span class="number">8</span>);<span class="comment">//9置1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置GPF4DAT输出高电平 </span></span><br><span class="line"><span class="comment"> * 把0写到地址0x56000054</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//4位清0;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：安装交叉编译工具"><a href="#补充：安装交叉编译工具" class="headerlink" title="补充：安装交叉编译工具"></a>补充：安装交叉编译工具</h2><p>教程：<a href="https://blog.csdn.net/dearwind153/article/details/39017131" target="_blank" rel="noopener">https://blog.csdn.net/dearwind153/article/details/39017131</a></p><p>网上下载 arm-linux-gcc-4.4.3.tar.gz</p><p><a href="http://pan.baidu.com/s/1bpEq2Mr" target="_blank" rel="noopener">arm-linux-gcc-4.4.3.tar.gz</a> （百度云盘，密码：1gtt）</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>1、解压交叉编译开发工具包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sudo tar xvzf arm-linux-gcc<span class="number">-4.4</span><span class="number">.3</span>.tar.gz -C /</span><br><span class="line"><span class="comment">//解压工具链到根目录，这里的解压目录可以任意指定。系统中会增加目录/opt/FriendlyARM/toolschain/4.4.3/</span></span><br></pre></td></tr></table></figure><p>2、修改环境变量，把交叉编译器的路径加入到PATH</p><p>  采用修改/etc/bash.bashrc文件的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①用vim打开文件：</span></span><br><span class="line">  <span class="meta">#sudo vim /etc/bash.bashrc</span></span><br><span class="line"><span class="comment">//②在最后面新建一行加上:</span></span><br><span class="line">  <span class="keyword">export</span>  PATH=$PATH:/opt/FriendlyARM/toolschain/<span class="number">4.4</span><span class="number">.3</span>/bin</span><br></pre></td></tr></table></figure><hr><p>3、立即使新的环境变量生效，不用重启电脑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#source /etc/bash.bashrc</span></span><br></pre></td></tr></table></figure><p>4、检查是否将路径加入到PATH</p><pre><code>#echo $PATH若显示的内容中有刚刚添加的交叉编译器所在目录，则证明编译环境安装成功。</code></pre><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-19_02-24-41.png" alt="Snipaste_2018-12-19_02-24-41"></p><p>5、测试是否安装成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#arm-linux-gcc -v</span></span><br></pre></td></tr></table></figure><p>上面的指令会显示arm-linux-gcc信息和版本，显示的内容信息：</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-19_02-25-28.png" alt="Snipaste_2018-12-19_02-25-28"></p><p>此时，证明安装成功。</p><p>6，编译实验</p><p>写个HelloWorld程序，测试交叉工具连</p><p>新建一个hello.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行下面的指令：</p><p>   #arm-linux-gcc -o hello hello.c</p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>尝试烧录到Nor，和Nand都行前面说法只能烧录Nand是说我说法，但烧录N偶然会导致Nor启动无法进入系统，因此建议烧录在Nand下，再次说明。</p><p><strong>要是不报错说明安装成功。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;S3C2440框架&quot;&gt;&lt;a href=&quot;#S3C2440框架&quot; class=&quot;headerlink&quot; title=&quot;S3C2440框架&quot;&gt;&lt;/a&gt;S3C2440框架&lt;/h2&gt;
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS2_JZ2440V3开发之开发板硬件连接及驱动安装</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-14-LS3-JZ2440V3%E5%BC%80%E5%8F%91%E4%B9%8B%E8%AE%A4%E8%AF%86%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8F%8A%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-14-LS3-JZ2440V3开发之认识开发板及驱动安装.html</id>
    <published>2018-12-14T11:09:34.000Z</published>
    <updated>2018-12-20T06:20:21.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="熟悉开发板步骤"><a href="#熟悉开发板步骤" class="headerlink" title="熟悉开发板步骤"></a>熟悉开发板步骤</h2><h3 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h3><p>板载 USB 串口、 JTAG、 usb下载口(dnw) </p><a id="more"></a><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_19-24-58.png" alt="Snipaste_2018-12-14_19-24-58"></p><p>​            图 4.1 接口介绍<br>①为板载 USB串口；②为 USB下载口，又名 dnw；③是 JTAG 口。 </p><p>三接口与PC模型</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_19-50-53.png" alt="Snipaste_2018-12-14_19-50-53"></p><ul><li><p><strong>烧写：</strong></p><p>PC 使用eop通过JTAG烧写口实现烧写。(可靠但速度很慢，大文件使用USB 烧录)</p></li><li><p><strong>调式信息</strong></p><p>一般开发板使用串口打印实现调式。PC通过串口把命令发给开发板，而开发板通过串口把结果发给PC。</p></li><li><p><strong>USB Device</strong></p><p>烧写大文件（kernel，rootfs）使用USB设备，前提是板子运行有支持USB 下载程序的u-boot。</p></li></ul><h2 id="裸机开发步骤"><a href="#裸机开发步骤" class="headerlink" title="裸机开发步骤"></a>裸机开发步骤</h2><h3 id="不同系统下应用程序开发比较"><a href="#不同系统下应用程序开发比较" class="headerlink" title="不同系统下应用程序开发比较"></a>不同系统下应用程序开发比较</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_20-43-03.png" alt="Snipaste_2018-12-14_20-43-03"></p><p><strong>Ubuntu</strong></p><p>名词解释：gcc</p><ul><li>gcc是linux系统下主要的编译软件，</li><li>gcc的全称是GNU编译器套件（GNU Compiler Collection），</li><li>除了可以编译c语言开发的程序外，还可以开发C++、Java等多个语言的程序。</li><li>GCC的初衷是为GNU操作系统专门编写的一款编译器。</li></ul><p><strong>使用gcc的原因：</strong>功能强大、稳定、开源免费。</p><p><strong>gcc版本查看：</strong>gcc  -v  </p><p><strong>ARM裸机开发</strong></p><p>交叉编译模式：<br>​    通常编译嵌入式程序的平台称为宿主机（如：PC的ubuntu系统，CPU架构为X86架构），运行嵌入式程序的平台成为目标机（如：某款ARM开发板，CPU架构为ARM架构）。在X86平台编辑和通过编译器arm-linux-gcc编译的ARM架构的程序，两者属于不同的架构平台，从而属于交叉编译模式。然后将程序烧写到ARM开发板中（下载方式有：JTAG、USB、SD卡、网络等多种方式），然后在开发板上运行该程序。</p><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p>推荐使用windows平台的source insight和notepad。<br>source insight在查看代码、编辑代码等功能时非常好用。</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>推荐使用arm-linux-gcc<br>arm-linux-gcc是基于linux平台的arm编译器。它是开源免费的编译器。<br>arm-linux-gcc功能强大、稳定、支持的arm芯片众多、更新速度快。</p><h4 id="入门误区：使用ads、MDK"><a href="#入门误区：使用ads、MDK" class="headerlink" title="入门误区：使用ads、MDK"></a>入门误区：使用ads、MDK</h4><p>ads（停止更新）、MDK，是windows平台的编译器，功能较弱。<br>1）只适合个人或者小团队的开发，不适合于中型、大型团队的协作开发。<br>2）是收费软件。</p><h3 id="安装source-insight"><a href="#安装source-insight" class="headerlink" title="安装source insight"></a>安装source insight</h3><p>略</p><h3 id="安装notepad"><a href="#安装notepad" class="headerlink" title="安装notepad"></a>安装notepad</h3><p>略</p><h3 id="安装free-hex-edtor"><a href="#安装free-hex-edtor" class="headerlink" title="安装free-hex-edtor"></a>安装free-hex-edtor</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;熟悉开发板步骤&quot;&gt;&lt;a href=&quot;#熟悉开发板步骤&quot; class=&quot;headerlink&quot; title=&quot;熟悉开发板步骤&quot;&gt;&lt;/a&gt;熟悉开发板步骤&lt;/h2&gt;&lt;h3 id=&quot;接口介绍&quot;&gt;&lt;a href=&quot;#接口介绍&quot; class=&quot;headerlink&quot; title=&quot;接口介绍&quot;&gt;&lt;/a&gt;接口介绍&lt;/h3&gt;&lt;p&gt;板载 USB 串口、 JTAG、 usb下载口(dnw) &lt;/p&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS1_JZ2440V3开发之环境搭建</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-14-LS1-JZ2440V3%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-14-LS1-JZ2440V3开发之环境搭建.html</id>
    <published>2018-12-14T11:07:11.000Z</published>
    <updated>2018-12-20T06:20:00.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>嵌入式开发者中一般需要用的软件、工具如下：<br>✓ 虚拟机 Workstation Player                                                                            ✓ Linux系统     Ubuntu 16.04 LTS<br>✓ 远程登录/远程传输/串口三合一软件 MobaXterm<br>✓ FTP 传输工具 FileZilla<br>✓ TFTP 服务器软件 tftpd.exe</p><a id="more"></a><p>(1) 为什么要使用虚拟机?                                                                 </p><p>后续开发都是在 Windows 下编辑代码,在 Linux 下编译代码。要么安装双系统，要么使用虚拟机。我们推荐后者。</p><p>（其实更希望搭建NAS装个Ubuntu，然后在哪里都能开发，以免换电脑啥的得重新搭建环境（环境搭建很麻烦人）。年后会尝试搭建个NAS服务器，用于资料存储。）</p><p>(2) 在 Windows 操作 Linux 有两种方式：</p><p>一是切换到虚拟机 ubuntu，在虚拟机中操作ubuntu；另一种是远程登录 ubuntu，开发中更多使用后者。 在 Windows 上远程登录 ubuntu并执行各种命令时，使用 ssh 工具； 在 Windows 和 ubuntu 之间传输文件时，通常使用 FTP工具。</p><p>(3) 要观察开发板打印的调试信息时，最方便的方法是使用串口。<br>以上远程登录、 FTP 传输、串口传输都可以使用一个软件实现——MobaXterm(目录在资料光盘-》 工具和驱动\串口和远程登录工具)</p><p>(4) 虽然 MobaXterm 也有 FTP 功能， 但使用另一个 FTP 工具 FileZilla 在Windows 与 ubuntu 之间的传输文件更方便。 </p><h3 id="安装虚拟机-Workstation-Player"><a href="#安装虚拟机-Workstation-Player" class="headerlink" title="安装虚拟机 Workstation Player"></a>安装虚拟机 Workstation Player</h3><p>略（已安装过，以后更新）</p><h3 id="使用虚拟机安装-Ubuntu"><a href="#使用虚拟机安装-Ubuntu" class="headerlink" title="使用虚拟机安装 Ubuntu"></a>使用虚拟机安装 Ubuntu</h3><p>略（已安装过，以后更新）</p><h3 id="Ubuntu配置"><a href="#Ubuntu配置" class="headerlink" title="Ubuntu配置"></a>Ubuntu配置</h3><h4 id="安装完整版本的-VIM"><a href="#安装完整版本的-VIM" class="headerlink" title="安装完整版本的 VIM"></a>安装完整版本的 VIM</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><h4 id="VI的个性设置"><a href="#VI的个性设置" class="headerlink" title="VI的个性设置"></a>VI的个性设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：vi`~/.vimrc</span><br></pre></td></tr></table></figure><h4 id="安装-SSH"><a href="#安装-SSH" class="headerlink" title="安装 SSH"></a>安装 SSH</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure><ul><li>SSH的英文全称是Secure SHell。通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS和IP欺骗。</li><li>SSH传输的数据是经过压缩的，所以可以加快传输的速度。</li><li>SSH有很多功能，它既可以代替telnet，又可以为ftp、 pop、甚至ppp提供一个安全的”通道”。</li><li>SSH客户端与服务器端通讯时，用户名及口令均进行了加密，有效防止了对口令的窃听。</li></ul><h4 id="启用-root密码"><a href="#启用-root密码" class="headerlink" title="启用 root密码"></a>启用 root密码</h4><p>启用 root 帐号 (也就是 设置一个口令) 使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>如何在终端机模式下切换到 root 身份?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s -H</span><br><span class="line">Password: &lt;在这注明您的密码&gt;</span><br></pre></td></tr></table></figure><h4 id="更新ubuntu的源"><a href="#更新ubuntu的源" class="headerlink" title="更新ubuntu的源"></a>更新ubuntu的源</h4><p>参考网站：</p><p>1.如何在/etc/apt/sources.list添加新内容：<a href="https://blog.csdn.net/qq_31811537/article/details/79310567" target="_blank" rel="noopener">https://blog.csdn.net/qq_31811537/article/details/79310567</a></p><p>2.如何在/etc/apt/sources.list添加新内容：<a href="https://blog.csdn.net/xiayaobo/article/details/46970663" target="_blank" rel="noopener">https://blog.csdn.net/xiayaobo/article/details/46970663</a></p><p>如果apt-get安装软件包的时候，速度很慢可以根据ubuntu的版本，百度里面查找更换为国内163的源</p><p><strong>编辑(更新)源命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><strong>通知ubuntu启用新的更新源:</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><strong>更新软件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h4 id="ubuntu版本查询"><a href="#ubuntu版本查询" class="headerlink" title="ubuntu版本查询"></a>ubuntu版本查询</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsb_release -a</span><br></pre></td></tr></table></figure><h4 id="查询ubuntu是32位还是64位版本"><a href="#查询ubuntu是32位还是64位版本" class="headerlink" title="查询ubuntu是32位还是64位版本"></a>查询ubuntu是32位还是64位版本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname -m</span><br><span class="line"><span class="comment">// 如果显示i686,你安装了32位操作系统</span></span><br><span class="line"><span class="comment">//如果显示 x86_64，你安装了64位操作系统</span></span><br></pre></td></tr></table></figure><h3 id="ubuntu设置静态ip"><a href="#ubuntu设置静态ip" class="headerlink" title="ubuntu设置静态ip"></a>ubuntu设置静态ip</h3><h4 id="windows设置静态ip"><a href="#windows设置静态ip" class="headerlink" title="windows设置静态ip"></a>windows设置静态ip</h4><p>win10怎么把电脑的IP地址设置成固定IP地址：<a href="https://jingyan.baidu.com/album/ac6a9a5e295f842b653eacfa.html?picindex=2" target="_blank" rel="noopener">https://jingyan.baidu.com/album/ac6a9a5e295f842b653eacfa.html?picindex=2</a></p><h4 id="Ubuntu网络设置"><a href="#Ubuntu网络设置" class="headerlink" title="Ubuntu网络设置"></a>Ubuntu网络设置</h4><h5 id="VMware中网络的设置（设置为：桥接模式）"><a href="#VMware中网络的设置（设置为：桥接模式）" class="headerlink" title="VMware中网络的设置（设置为：桥接模式）"></a>VMware中网络的设置（设置为：桥接模式）</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_13-43-55.png" alt="Snipaste_2018-12-17_13-43-55"></p><h5 id="查看ip网络信息"><a href="#查看ip网络信息" class="headerlink" title="查看ip网络信息"></a>查看ip网络信息</h5><p>用ifconfig命令</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_13-49-29.png" alt="Snipaste_2018-12-17_13-49-29"></p><h5 id="修改网络配置文件"><a href="#修改网络配置文件" class="headerlink" title="修改网络配置文件"></a>修改网络配置文件</h5><ul><li>打开网络配置文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>配置如下信息，然后保存退出</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-00-30.png" alt="Snipaste_2018-12-17_14-00-30"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="keyword">auto</span> eth0</span><br><span class="line">iface eth0 inet <span class="keyword">static</span></span><br><span class="line">address <span class="number">192.168</span><span class="number">.31</span><span class="number">.99</span>  <span class="comment">// //设置本机IP地址</span></span><br><span class="line">gateway <span class="number">192.168</span><span class="number">.31</span><span class="number">.1</span>  <span class="comment">//网关</span></span><br><span class="line">netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>    <span class="comment">//掩码</span></span><br></pre></td></tr></table></figure><h5 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h5 id="检查ip是否配置成功"><a href="#检查ip是否配置成功" class="headerlink" title="检查ip是否配置成功"></a>检查ip是否配置成功</h5><p>先用ifconfig检查一下ip</p><p> 用ping命令检查本机与windows系统是否连通：ping 192.168.31.101（windows IP）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-45-15.png" alt="Snipaste_2018-12-17_14-45-15"></p><h5 id="ping不通解决方法"><a href="#ping不通解决方法" class="headerlink" title="ping不通解决方法"></a>ping不通解决方法</h5><p>如果出现如下这种情况</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-32-40.png" alt="Snipaste_2018-12-17_14-32-40"></p><p>参考：Ubuntu虚拟机无法ping通windows，反之可以ping通解决方法：<a href="https://blog.csdn.net/qq_26822029/article/details/80428138" target="_blank" rel="noopener">https://blog.csdn.net/qq_26822029/article/details/80428138</a></p><ul><li>打开“网络和共享中心”</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-51-03.png" alt="Snipaste_2018-12-17_14-51-03"></p><ul><li>选择<strong>windiws防火墙</strong>选项</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-55-01.png" alt="Snipaste_2018-12-17_14-55-01"></p><ul><li>选择<strong>“高级设置”</strong></li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-53-43.png" alt="Snipaste_2018-12-17_14-53-43"></p><ul><li>选择“入站规则”，找到名称为“文件和打印机共享（回显请求-ICMPv4-In）”（配置文件为“专用，公用的那个”）勾上。</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-57-44.png" alt="Snipaste_2018-12-17_14-57-44"></p><h5 id="配置DNS-域名解析-服务器"><a href="#配置DNS-域名解析-服务器" class="headerlink" title="配置DNS(域名解析)服务器"></a>配置DNS(域名解析)服务器</h5><p>打开DNS服务器配置文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/resolvconf/resolv.conf.d/tail</span><br></pre></td></tr></table></figure><p>写入以下信息   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">192.168</span><span class="number">.31</span> <span class="comment">//和windowsDNS相同</span></span><br></pre></td></tr></table></figure><p>重启本地服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/resolvconf restart</span><br></pre></td></tr></table></figure><h5 id="ping网址"><a href="#ping网址" class="headerlink" title="ping网址"></a>ping网址</h5><p>ping  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_15-20-11.png" alt="Snipaste_2018-12-17_15-20-11"></p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="安装-MobaXterm-（SSH，FTP，Serial）"><a href="#安装-MobaXterm-（SSH，FTP，Serial）" class="headerlink" title="安装 MobaXterm （SSH，FTP，Serial）"></a>安装 MobaXterm （SSH，FTP，Serial）</h4><p>MobaXterm 在资料光盘\工具和驱动\串口和远程登录工具目录，解压文件MobaXterm_Portable_v10.4 即可 。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_22-48-43.png" alt="Snipaste_2018-12-16_22-48-43"></p><h5 id="新建-SSH连接"><a href="#新建-SSH连接" class="headerlink" title="新建 SSH连接"></a>新建 SSH连接</h5><p>打开 MobaXterm， 点击左上角的 Session（会话控制），在弹出的窗口中选择 SSH，<br>如图 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_15-38-50.png" alt="Snipaste_2018-12-17_15-38-50"></p><p>在新窗口中输入账号 和密码 ，回车登陆 ubuntu 。此时界面分为两块，左边的是主机的文件，右边是终端。 勾选左下角的“Follow terminal folder”可以让它们的工作路径保持一致 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_15-40-46.png" alt="Snipaste_2018-12-17_15-40-46"></p><h5 id="新建FTP连接"><a href="#新建FTP连接" class="headerlink" title="新建FTP连接"></a>新建FTP连接</h5><p>失败(略)</p><h5 id="新建串口连接"><a href="#新建串口连接" class="headerlink" title="新建串口连接"></a>新建串口连接</h5><p>点击session选择serial</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_22-12-48.png" alt="Snipaste_2018-12-15_22-12-48"></p><p>选择COM口（我的为COM12）及波特率和3框中的控制流为None（参考下图设置）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_22-16-34.png" alt="Snipaste_2018-12-15_22-16-34"></p><p>点击OK,输入<strong>ls</strong>使用串口观察打印信息（打印信息为系统目录结构）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_20-17-22.png" alt="Snipaste_2018-12-14_20-17-22"></p><h4 id="FTP传输工具-FileZill"><a href="#FTP传输工具-FileZill" class="headerlink" title="FTP传输工具 FileZill"></a>FTP传输工具 FileZill</h4><p>略</p><h4 id="TFTP服务器-tftp"><a href="#TFTP服务器-tftp" class="headerlink" title="TFTP服务器 tftp"></a>TFTP服务器 tftp</h4><p>用的软件是 tftpd.exe<br>     开发板与电脑之间用网线直接连接并使用 TFTP 下载 </p><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;p&gt;嵌入式开发者中一般需要用的软件、工具如下：&lt;br&gt;✓ 虚拟机 Workstation Player                                                                            ✓ Linux系统     Ubuntu 16.04 LTS&lt;br&gt;✓ 远程登录/远程传输/串口三合一软件 MobaXterm&lt;br&gt;✓ FTP 传输工具 FileZilla&lt;br&gt;✓ TFTP 服务器软件 tftpd.exe&lt;/p&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS0_嵌入式学习路线</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-14-LS0-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-14-LS0-嵌入式学习路线.html</id>
    <published>2018-12-14T05:16:10.000Z</published>
    <updated>2018-12-20T06:19:43.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序员的三大方向"><a href="#程序员的三大方向" class="headerlink" title="程序员的三大方向"></a>程序员的三大方向</h2><ol><li>专业领域</li><li>业务领域</li><li>操作系统领域 </li></ol><h3 id="专业领域"><a href="#专业领域" class="headerlink" title="专业领域"></a>专业领域</h3><a id="more"></a><p>它又可以分为两类：学术研究和工程实现</p><h4 id="学术研究"><a href="#学术研究" class="headerlink" title="学术研究"></a>学术研究</h4><p>比如语音、图像处理、人工智能，这类工作需要你有比较强的理论知识。</p><h4 id="工程实现"><a href="#工程实现" class="headerlink" title="工程实现"></a>工程实现</h4><p>他们懂得这些专业领域的概念，但是没有深入钻研。可以使用各类开源资料实现某个目标，做出产品。比如图像处理，他懂得用 opencv 里几百个复杂函数来实现头像识别。有时候还可以根据具体芯片来优化这些函数。 </p><h3 id="业务领域"><a href="#业务领域" class="headerlink" title="业务领域"></a>业务领域</h3><p>业务领域也就是应用程序，这又可以分为下面 两类。</p><h4 id="界面显示"><a href="#界面显示" class="headerlink" title="界面显示"></a>界面显示</h4><p>即：Android APP 和 IOS APP  GUI 界面 开发。</p><ul><li>一个程序需要有 GUI 界面，但是程序的内在逻辑才是核心。 Android、 IOS 的开发工具给我们简化了 GUI 的开发，并提供了这些控件的交互机制，封装并提供了一些服务(比如网络传输)。</li><li>但是程序内部的业务逻辑、对视频图像声音的处理等等，这才是核心。另外别忘了服务器那边的后台程序：怎样更安全地保存数据、保护客户的隐私，怎样处理成千上万上百万的并发访问，等等，这也是核心 </li></ul><h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p>​    数据结构、算法是必备，然后凭兴趣选择数据库、网络编程等等进行深入钻研， 做应用开发的人选择了某个行业，后面是很难换行业的，选行很重要 。</p><p>例如：</p><p>​    视频会议系统里，各个模块怎么对接，各类协议怎么兼容，你不深入这个行业，你根本搞不清楚。<br>应用开发的职位永远是最多的，入门门槛也低。基本上只要你会 C 语言，面试时表现比较得体，一般公司都会给你机会。因为：<br>① 你进公司后，还需要重新培训你：熟悉它们的业务逻辑。<br>② 你要做的，基本也就是一个个模块，框架都有人给你定好了，你去填代码就可以了。 </p><h3 id="操作系统领域"><a href="#操作系统领域" class="headerlink" title="操作系统领域"></a>操作系统领域</h3><ul><li>UCOS 太简单， VxWorks 太贵太专业， Windows 不玩嵌入式了， IOS 不开源，所以对于操作系统领域我们也只能玩 Linux 了。</li><li>Android 跟 QT 一样，都是一套 GUI 系统。很多时候 Linux+Android 成了标配。在学习中我们应该关心的是Android 的整个系统、里面的机制，而不是学习几个 API 然后开发界面程序。</li></ul><h4 id="操作系统领域包含的内容"><a href="#操作系统领域包含的内容" class="headerlink" title="操作系统领域包含的内容"></a>操作系统领域包含的内容</h4><p>操作系统领域所包含的内容，简单地说，就是制作出一台装好系统的专用“电脑”， 可以分为：<br>① 为产品规划硬件：按需求、性能、成本选择主芯片，搭配周边外设，交由硬件开发人员设计。<br>② 给单板制作、安装操作系统、编写驱动<br>③ 定制维护、升级等系统方案<br>④ 还可能要配置、安装 Android 等 GUI 系统：<br>⑤ 为应用开发人员配置开发环境<br>⑥ 从系统角度解决疑难问题：这个领域，通常被称为“底层系统”或是“驱动开发”。</p><h4 id="操作系统领域知识要求"><a href="#操作系统领域知识要求" class="headerlink" title="操作系统领域知识要求"></a>操作系统领域知识要求</h4><p>① 懂硬件知识才能看懂电路图<br>② 英文好会看芯片手册<br>③ 有编写、移植驱动程序的能力                                                                     ④ 对操作系统本身有一定的理解，才能解决各类疑难问题<br>⑤ 理解 Android 内部机制<br>⑥ 懂汇编、 C 语言、 C++、 JAVA </p><h4 id="操作系统领域是一个大坑"><a href="#操作系统领域是一个大坑" class="headerlink" title="操作系统领域是一个大坑"></a>操作系统领域是一个大坑</h4><p>① 这行的入门，绝对需要半年以上，即使全天学习也要半年。<br>② 它的职位，绝对比 APP 的职位少<br>③ 并且你没有 1、 2 年经验，招你到公司后一开始你做的还是 APP。 </p><h4 id="操作系统领域优点"><a href="#操作系统领域优点" class="headerlink" title="操作系统领域优点"></a>操作系统领域优点</h4><p>① 学好后，行业通杀，想换行就换行；想自己做产品就自己做产品。<br>② 相比做应用程序的人，不会被经常变动的需求搞得天天加班。<br>③ 门槛高，当然薪水相对就高。 </p><h4 id="操作系统领域适合人员人"><a href="#操作系统领域适合人员人" class="headerlink" title="操作系统领域适合人员人"></a>操作系统领域适合人员人</h4><p>① 硬件工程师想转软件工程师，从底层软件入门会比较好<br>② 单片机工程师，想升级一下。会 Linux 底层的人肯定会单片机，会单片机的人不一定<br>会 Linux。<br>③ 时间充足的学生：如果你正读大二大三，那么花上半年学习嵌入式 Linux 底层多有益<br>处。<br>④ 想掌握整个系统的人，比如你正在公司里写 APP，但是想升为系统工程师，那么底层<br>不得不学。<br>⑤ 想自己创业做实体产品的工程师，你有钱的话什么技术都不用学，但是如果没钱又想<br>做产品，那么 Linux 底层不得不学。<br>⑥ 做 Linux APP 的人，没错，他们也要学习。 </p><h3 id="应用程序与操作系统关系"><a href="#应用程序与操作系统关系" class="headerlink" title="应用程序与操作系统关系"></a>应用程序与操作系统关系</h3><p>① 开发实体产品时，应用程序写得好的人，有时候需要操作系统的知识。比如调度优先级的设置、知道某些函数可能会令进程休眠。</p><p>② 写应用程序的人进阶为系统工程师时，需要从上到下都了解，这时候就需要有操作系统领域的知识了，否则，你怎么设计整个系统的方案呢？</p><p>③ 操作系统领域负责底层系统，在上面开发什么业务跟他没关系。这行很多是技术宅，行业专家。<br>④操作系统和业务之间并没有一个界线。有操作系统经验，再去做应用，你会对系统知根知底，碰到问题时都有解决思路。</p><p>因此一个号的程序员必须学会操作系统，这有利于你更好的在产品开发中，写出更优秀的应用程序。并且在开发实体产品时，更好的从上到下了解产品开发的整个过程，有利于进阶为系统工程师对整个系统的方案设计。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从前面可以看出：在嵌入式开发区中操作系统是很重要的一部分，而GUI方面由于Google 的实力太强了，现在Android 无处不在，所以很多时候 Linux+Android 成了嵌入式开发的标配 。在以后学习中，就把操作系统默认为 Linux，讲讲怎么学习嵌入式 Linux+Android 系统。</p><p>注：Google好像在开发新手机系统：<strong>Fuchsia</strong></p><h2 id="怎么学习嵌入式-Linux-操作系统"><a href="#怎么学习嵌入式-Linux-操作系统" class="headerlink" title="怎么学习嵌入式 Linux 操作系统"></a>怎么学习嵌入式 Linux 操作系统</h2><p>① 操作系统具有进程管理、存储管理、文件管理和设备管理等功能，这些核心功能非常稳定可靠，基本上不需要我们修改代码。我们只需要针对自己的硬件完善驱动程序</p><p>② 学习驱动时必定会涉及其他知识，比如存储管理、进程调度。当你深入理解了驱动程序后，也会加深对操作系统其他部分的理解</p><p>③ Linux 内核中大部分代码都是设备驱动程序，可以认为 Linux 内核由各类驱动构成但是， 要成为该领域的高手，一定要深入理解 Linux 操作系统本身，要去研读它的源代码。</p><h3 id="学习路线图"><a href="#学习路线图" class="headerlink" title="学习路线图"></a>学习路线图</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_14-38-08.png" alt="Snipaste_2018-12-14_14-38-08"></p><p>在这里将嵌入式学习分为入门，中级，高级。后期会还会加入深入：关于专业，领域类知识以及实际项目类内容。</p><h4 id="学习路线-入门"><a href="#学习路线-入门" class="headerlink" title="学习路线-入门"></a>学习路线-入门</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_14-45-25.png" alt="Snipaste_2018-12-14_14-45-25"></p><p><strong>C语言</strong></p><ul><li>会C语言基本语法：会编写“ Hello, world!” ， </li><li>会指针操作，结构体及会写冒泡排序</li><li>需要掌握链表操作。 </li><li>不需要去学习任何的函数使用，比如文件操作、 多线程编程、网络编程等等； 这些知识，会在编写 Linux 应用程序时学习，在操作系统特别是驱动学习时用不着。</li></ul><p><strong>PC Linux 基本操作：</strong>   </p><ul><li>PC Linux，使用 Ubuntu 。</li><li>通常工作模式是这样：在 Windows 下阅读、编写代码， 然后把代码上传到 PC Linux去编译。 </li><li>通常使用命令行来操作 Ubuntu。因此需要掌握一些常用命令。</li></ul><p>①cd 目录名 // 进入某个目录 </p><p>② pwd : Print Work Directory（打印当前目录 显示出当前工作目录的绝对路径）</p><p>③ mkdir : Make Directory（创建目录） </p><p>④ rm : Remove（删除目录或文件） </p><p>⑤ ls : List（列出目录内容）</p><p>⑥ mount : 挂载 </p><p>⑦ chown : Change owner（改变文件的属主，即拥有者） </p><p>⑧ chmod : Change mode（改变权限）  </p><p>⑨ vi : </p><p><strong>硬件知识</strong> </p><p>① 学习《微机原理》 ,《模拟电路》 ：理解一个计算机的组成及各个部件的交互原理 ，理解各种门电路的原理及使用， 还可以掌握一些逻辑运算（ 与、 或等） 。 </p><p>②学会看原理图芯片手册，及各种协议（usart，spi，i2c）。</p><p>总结：该阶段并未开始实际的嵌入式学习，属于 准备阶段。只有当上面这些内容了解后才能够算入门，才能进入真正的嵌入式开发。后面的所有开发均是在前面熟悉下才能进行。</p><h4 id="学习路线-中级"><a href="#学习路线-中级" class="headerlink" title="学习路线-中级"></a>学习路线-中级</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_14-45-46.png" alt="Snipaste_2018-12-14_14-45-46"></p><p>驱动程序=Linux 驱动程序软件框架+ARM 开发板硬件操作，我们可以从简单的裸机开发入手， 先掌握硬件操作，并且还可以：<br>① 掌握如何在 PC Linux 下编译程序、把程序烧录到板子上并运行它<br>② 为学习 bootloader 打基础： 掌握了各种硬件操作后，后面一组合就是一个 bootloader </p><p><strong>裸板程序开发</strong></p><p>学习裸板程序开发的目的有两个：<br>① 掌握裸机程序的结构， 为后续的 u-boot 作准备<br>② 练习硬件知识，即：怎么看原理图、芯片手册，怎么写代码来操作硬件 </p><p>注：后面的 u-boot 可以认为是裸机程序的集合，我们在裸机开发中逐个掌握各个部件，再集合<br>起来就可以得到一个 u-boot 了。 后续的驱动开发， 也涉及硬件操作，你可以在裸机开发中<br>学习硬件知识 </p><p><strong>bootloader 的学习</strong></p><ul><li>bootloader 有很多种， vivi、 u-boot 等等，最常用的是 u-boot </li><li>u-boot 功能强大、 源码比较多 。</li><li>u-boot 的主要功能就是：启动内核。 它涉及：读取内核到内存、设置启动参数、启动内核。 按照这个主线，我们尝试自己从零编写一个 bootloader ，让我们快速理解 u-boot 主要功能的实现 </li></ul><h4 id="学习路线-高级"><a href="#学习路线-高级" class="headerlink" title="学习路线-高级"></a>学习路线-高级</h4><p><strong>Linux 内核的学习</strong></p><p>​    内核本身不是我们学习的重点，但是了解一下内核的启动过程， 还是很有必要的：工作中有可能要修改内核以适配硬件， 掌握了启动过程才知道去配置，编译，修改及移植哪些内核文件。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_14-47-09.png" alt="Snipaste_2018-12-14_14-47-09"></p><p><strong>根文件系统</strong></p><ul><li>在驱动程序开发阶段，我们喜欢搭建一个最小根文件系统来调试驱动；</li><li>在开发应用程序时， 也需要搭建文件系统，把各种库、配置文件放进去；</li><li>在发布产品时，你还需要修改配置文件，使得产品可以自动运行程序；</li><li>甚至你想实现插上 U 盘后自动启动某个程序，这也要要修改配置文件；</li></ul><p>这一切，都需要你理解根文件系统的构成，理解内核启动后是根据什么配置文件来启动哪些<br>应用程序。 </p><p><strong>驱动程序的学习</strong> </p><p>掌握开发过程中碰到的机制： 查询、休眠-唤醒、中断、异步通知、 poll、 同步、互斥等等。后更复杂的驱动程序，就是在这些机制的基础上， 根据硬件特性设计出精巧的软件框架。 </p><p><strong>Linux 应用程序的学习</strong><br>① 编译方法不同：<br>嵌入式 Linux 应用程序，我们需要“ 交叉编译” ： 程序要在 PC Linux 上编译，但是运行时要放到单板上。 并且， 它的编译环境需要你自己搭建：解压出工具链后设计 PATH， 还要自己构造一套 Makefile 系统。<br>② 调试方法不同 </p><p>对于嵌入式 Linux 应用程序，你可以更喜欢用打印；或是在PC Linux 上通过 GDB 观察应用程序在单板上的运行状况。 </p><p>③ 可用的资源不同： </p><p>对于嵌入式 Linux 应用程序， 很多时候需要去寻找、下载、 编译、使用开源库。 </p><p>④ 功能不同 </p><p>嵌入式 Linux 应用程序一般都要操作若干种硬件，比如监控设备中要操作摄像头、存储音视频，无人机中要操作 GPS、 螺旋桨， POS 机中要操作银行卡等等。它跟单板上的硬件联系很大， 很多时候需要你懂点硬件知识，至少是知道怎么通过驱动程序来操作这些硬件。 </p><p>因此在Linux下应用程序和window应用程序差别很大，且针对性不同，Linux一般为硬件操作。对于Linux开发应用程序，那么一定要有算法、数据结构、网络编程等基础，然后再掌握一些设计模式， </p><p>后续我们还需要学习Android系统开发。只用当Linux+Android一起才能开发出完美的实际产嵌入式品</p><h4 id="学习路线-深入"><a href="#学习路线-深入" class="headerlink" title="学习路线-深入"></a>学习路线-深入</h4><p>略</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>本次中不会去专门写<strong>学习路线-入门内容</strong>，后续会补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序员的三大方向&quot;&gt;&lt;a href=&quot;#程序员的三大方向&quot; class=&quot;headerlink&quot; title=&quot;程序员的三大方向&quot;&gt;&lt;/a&gt;程序员的三大方向&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;专业领域&lt;/li&gt;
&lt;li&gt;业务领域&lt;/li&gt;
&lt;li&gt;操作系统领域 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;专业领域&quot;&gt;&lt;a href=&quot;#专业领域&quot; class=&quot;headerlink&quot; title=&quot;专业领域&quot;&gt;&lt;/a&gt;专业领域&lt;/h3&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>M1_MT7688程序设计环境配置</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-08-M1-MT7688Duo%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E5%89%AF%E6%9C%AC.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-08-M1-MT7688Duo程序设计环境配置-副本.html</id>
    <published>2018-12-12T09:28:27.945Z</published>
    <updated>2018-12-20T06:18:27.551Z</updated>
    
    <content type="html"><![CDATA[<p>注：由于使用的开发板为LinkIt Smart 7688 Duo，因此后续不会有LinkIt Smart 7688。或一笔带过。</p><h3 id="程序设计环境向导"><a href="#程序设计环境向导" class="headerlink" title="程序设计环境向导"></a>程序设计环境向导</h3><p>这一章介绍：</p><ul><li>本平台使用的操作系统</li><li>LinkIt Smart 7688开发平台提供的程序设计环境</li><li>各种程序设计模型以及如何在开发板上使用</li><li>用于与开发板进行Wi-Fi通信的网络环境</li><li>使用C/C++、Python和Node.js创建应用程序的方法</li></ul><a id="more"></a><h4 id="本平台使用的操作系统"><a href="#本平台使用的操作系统" class="headerlink" title="本平台使用的操作系统"></a>本平台使用的操作系统</h4><p>LinkIt Smart 7688开发平台使用OpenWrt开源嵌入式Linux操作系统，这个操作系统最初是针对嵌入式设备 (如无线路由器) 而开发的。OpenWrt的主要特性如下：</p><p>1)      大量的网络控制功能</p><p>2)      完全可写的文件系统，同时具备包管理</p><p>3)      丰富和可扩展的功能集，超过3400种软件包且数量还在不断增长。</p><h4 id="程序设计环境概述"><a href="#程序设计环境概述" class="headerlink" title="程序设计环境概述"></a>程序设计环境概述</h4><ul><li>LinkIt Smart 7688开发平台运行在OpenWrt Linux环境，它支持本地C/C++、高级语言Python和JavaScript（使用Node.js）开发。</li><li>通过本地应用程序，您可以为需要更高性能的设备创建驱动程序、框架和系统应用程序。而通过高级语言开发则使您能够快速构建设备原型。</li><li>因为LinkIt Smart 7688没有显示器，所以您需要在一台独立的计算机上远程开发高级程序，通常把这台计算机称为主机平台。大部分的编辑和开发工作都在主机平台上完成，最终生成的程序再传送到LinkIt Smart 7688这个目标平台上执行</li></ul><table><thead><tr><th>编程语言</th><th>工具和库</th><th>应用</th><th>主机平台</th></tr></thead><tbody><tr><td>C/C++</td><td>交叉编译工具链</td><td>系统编程</td><td>l  OS X   l  Linux</td></tr><tr><td>Python</td><td>LinkIt Smart 7688的 Python运行时库</td><td>l  设备原型化   l  网络   l  物联网应用</td><td>l  OS X   l  Linux   l  Windows</td></tr><tr><td>Node.js</td><td>LinkIt Smart 7688的 Node.js运行时库</td><td>l  设备原型化   l  网络   l  物联网应用</td><td>l  OS X   l  Linux   l  Windows</td></tr></tbody></table><h4 id="各种程序设计模型以及如何在开发板上使用"><a href="#各种程序设计模型以及如何在开发板上使用" class="headerlink" title="各种程序设计模型以及如何在开发板上使用"></a>各种程序设计模型以及如何在开发板上使用</h4><p> 图11显示了LinkIt Smart 7688和LinkIt Smart 7688 Duo的程序设计模型以及有关的用于访问传感器的软件栈。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/Snipaste_2018-12-12_17-41-39.png" alt="Snipaste_2018-12-12_17-41-39"></p><p>​    在LinkIt Smart 7688 Duo开发板中，各类外部设备和外设连接到Atmega32U4，并受MCU的控制。但是，由于MPU和MCU可以通过UART接口进行通讯，所以您既可以选择使用C/C++、Python和Node.js为MPU开发应用程序，也可以使用Arduino为MCU开发Arduino程序。</p><p>而在LinkIt Smart7688开发板中，各类外部设备和外设都直接连接到MT7688AN MPU上并由Linux系统控制。设备应用程序也是在MT7688ANMPU的Linux系统中执行。</p><h5 id="LinkIt-Smart-7688开发平台的Wi-Fi通讯共有三种模式"><a href="#LinkIt-Smart-7688开发平台的Wi-Fi通讯共有三种模式" class="headerlink" title="LinkIt Smart 7688开发平台的Wi-Fi通讯共有三种模式"></a>LinkIt Smart 7688开发平台的Wi-Fi通讯共有三种模式</h5><ul><li>AP model</li><li>Station model</li><li>Repeater model</li></ul><h5 id="AP-model"><a href="#AP-model" class="headerlink" title="AP model"></a>AP model</h5><p>在AP模式下，LinkIt Smart 7688开发板作为一个热点组建一个局域网，如图12所示。AP模式主要用于配置开发板设置。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/Snipaste_2018-12-12_19-01-37.png" alt="Snipaste_2018-12-12_19-01-37"></p><p>图12 LinkIt Smart 7688运行在AP模式</p><h5 id="Station-model"><a href="#Station-model" class="headerlink" title="Station model"></a>Station model</h5><p>在STA模式下，LinkIt Smart 7688开发板可以加入一个已知的Wi-Fi网络并访问Internet，如图13所示。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/Snipaste_2018-12-12_19-02-56.png" alt="Snipaste_2018-12-12_19-02-56"></p><p>图13 LinkIt Smart 7688运行在STA模式</p><p>Station model除了可以让应用程序在Internet上访问远程系统或云服务之外，还可以让用户使用opkg软件包管理器将软件从OpenWrt安装到开发板上。这时，您的计算机需加入到与开发板相同的Wi-Fi网中，并通过 SSH协议连接到开发板。</p><h5 id="Repeater-model"><a href="#Repeater-model" class="headerlink" title="Repeater model"></a>Repeater model</h5><p>在Repeater model模式下，LinkIt Smart 7688开发板可以加入一个已知的Wi-Fi网络并访问Internet，并且自身作为也可以作为热点被其他设备连接组建一个局域网。</p><p>其模式为前连者的结合体。</p><h4 id="设置MT7688编程环境"><a href="#设置MT7688编程环境" class="headerlink" title="设置MT7688编程环境"></a>设置MT7688编程环境</h4><h5 id="建立C-C-编程环境"><a href="#建立C-C-编程环境" class="headerlink" title="建立C/C++编程环境"></a>建立C/C++编程环境</h5><p>略（失败）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/Snipaste_2018-12-13_19-22-03.png" alt="Snipaste_2018-12-13_19-22-03"></p><p>交叉编译工具链包含在LinkIt Smart 7688 SDK的软件包中，它支持Mac OS X和Linux系统，在编写这个文档时还不支持Windows系统。要使用这个工具链，请把它下载并解压到您选择的目录，并把工具链目录命名为CC_TOOLS。</p><h6 id="C语言的Hello-World例程"><a href="#C语言的Hello-World例程" class="headerlink" title="C语言的Hello World例程"></a>C语言的Hello World例程</h6><p>1)      打开文本编辑器并创建一个名为helloworld.c的文件</p><p>2)      复制并粘贴下方的示例代码，保存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>  argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"Hello, World!\n "</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3)      在主机PC，输入以下命令对代码进行交叉编译</p><p>CC_TOOLS/bin/mipsel-openwrt-linux-g++ helloworld.c -o helloworld</p><p>4)      假设主机环境已连接到LinkIt Smart 7688的Wi-Fi网络，使用SCP工具将生成的名为helloworld的二进制文件传送到 LinkIt Smart 7688。 例如：</p><p>scp ./helloworld <a href="mailto:root@mylinkit.local" target="_blank" rel="noopener">root@mylinkit.local</a>:helloworld</p><p>5)      最后，在LinkIt Smart 7688的SSH终端执行这个程序：</p><p># ./helloworld </p><p>现在，您应该能看到屏幕输出了字符串“Hello,World！”。</p><p>参考：<a href="http://www.cnblogs.com/gtsup/p/9448220.html" target="_blank" rel="noopener">http://www.cnblogs.com/gtsup/p/9448220.html</a></p><h5 id="建立Python编程环境"><a href="#建立Python编程环境" class="headerlink" title="建立Python编程环境"></a>建立Python编程环境</h5><ul><li>高级编程语言由LinkIt<br>Smart 7688中的相应语言解释器执行。您可以远程编程，然后将代码发送到LinkIt Smart 7688中执行。</li><li>高级编程语言环境很简单，您只需要安装一个文本编辑器和一个用来在计算机和LinkIt Smart 7688之间传输程序文件的工具软件即可</li></ul><h6 id="安装SCP工具"><a href="#安装SCP工具" class="headerlink" title="安装SCP工具"></a>安装SCP工具</h6><h6 id="Python语言的Hello-World例程"><a href="#Python语言的Hello-World例程" class="headerlink" title="Python语言的Hello World例程"></a>Python语言的Hello World例程</h6><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>开发板：LinkIt Smart 7688 Duo</p><p>Putty：<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p><!--more--><h4 id="登录7688-Duo-Board的Web-UI"><a href="#登录7688-Duo-Board的Web-UI" class="headerlink" title="登录7688 Duo Board的Web UI"></a>登录7688 Duo Board的Web UI</h4><ul><li>打开电路板（供电）。</li><li>在您的计算机上，搜索<em>LinkIt_Smart_7688_XXXXXX</em> Wi-Fi接入点（XXXXXX是MAC地址）并连接到主板。</li><li>打开  <code>http://mylinkit.local</code>，设置密码并登录LinkIt Smart 7688 Web UI。</li></ul><h5 id="使用micro-USB线为电路板加电"><a href="#使用micro-USB线为电路板加电" class="headerlink" title="使用micro-USB线为电路板加电"></a>使用micro-USB线为电路板加电</h5><ul><li>如下图1-1所示，连接LinkIt Smart 7688开发板。（将电缆连接到电源（<strong>PWR</strong>）接口，而不是MPU复位按钮附近的USB主机（<strong>HOST</strong>）接口。）</li><li>LED（绿色）将首先亮起，然后是Wi-Fi LED（橙色），它将闪烁一次。然后，大约4到5秒后，Wi-Fi LED将亮起以指示引导加载程序已初始化。</li><li>然后开始启动过程，大约需要30秒。接下来，Wi-Fi LED熄灭; 这意味着系统已准备好接受Wi-Fi连接。下图1-2显示了Wi-Fi LED状态如何与系统状态匹配。</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_16-41-00.png" alt="Snipaste_2018-12-08_16-41-00"></p><p>图1-1</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_16-49-55.png" alt="Snipaste_2018-12-08_16-49-55"></p><p>图1-2</p><h5 id="将您的PC连接到LinkIt-Smart-7688开发板的wifi"><a href="#将您的PC连接到LinkIt-Smart-7688开发板的wifi" class="headerlink" title="将您的PC连接到LinkIt_Smart_7688开发板的wifi"></a>将您的PC连接到LinkIt_Smart_7688开发板的wifi</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_16-53-25.png" alt="Snipaste_2018-12-08_16-53-25"></p><p>连接到<strong>LinkIt_Smart_7688_Duo</strong> 后，橙色LED将每秒闪烁三次。这表示该板处于<strong>AP</strong>模式。</p><p>此时你的电脑无法上网。因为它现在加入了LinkIt Smart 7688开发板形成的局域网（LAN），如下所示。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_16-56-13.png" alt="Snipaste_2018-12-08_16-56-13"></p><h5 id="访问LinkIt-Smart-7688-Web-UI配置工具，设置密码"><a href="#访问LinkIt-Smart-7688-Web-UI配置工具，设置密码" class="headerlink" title="访问LinkIt Smart 7688 Web UI配置工具，设置密码"></a>访问LinkIt Smart 7688 Web UI配置工具，设置密码</h5><p>LinkIt Smart 7688 Web UI，这是一种配置电路板设置的工具。</p><ul><li>在您的Web浏览器中打开  <code>http://mylinkit.local</code>，如下所示。</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-01-15.png" alt="Snipaste_2018-12-08_17-01-15"></p><p>设置密码，确定后，如下图</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-04-20.png" alt="Snipaste_2018-12-08_17-04-20"></p><h4 id="更新固件"><a href="#更新固件" class="headerlink" title="更新固件"></a>更新固件</h4><h5 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h5><p>固件：<a href="https://docs.labs.mediatek.com/resource/linkit-smart-7688/zh_cn/downloads" target="_blank" rel="noopener">https://docs.labs.mediatek.com/resource/linkit-smart-7688/zh_cn/downloads</a></p><p>在Web UI主页单击<strong>UPGRADE FIRMWARE</strong></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-09-59.png" alt="Snipaste_2018-12-08_17-09-59"></p><h5 id="运行LinkIt-Smart-7688固件更新程序应用程序"><a href="#运行LinkIt-Smart-7688固件更新程序应用程序" class="headerlink" title="运行LinkIt Smart 7688固件更新程序应用程序"></a>运行LinkIt Smart 7688固件更新程序应用程序</h5><ul><li>单击  <strong>选择文件</strong>  并选择  <em>lks7688.img</em>  文件，然后单击  <strong>升级和重新启动</strong></li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-10-59.png" alt="Snipaste_2018-12-08_17-10-59"></p><p>如下图所示，等待结束</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-11-50.png" alt="Snipaste_2018-12-08_17-11-50"></p><ul><li><p>确保电源稳定。Wi-Fi LED闪烁约3分钟（固件正在更新），然后电路板将重新启动，LED指示灯将保持亮起约30秒（重新启动）。最后，电路板进入<strong>AP</strong>模式并准备连接。</p></li><li><p>找到<em>LinkIt_Smart_7688_XXXXXX</em> AP并通过Wi-Fi连接电路板。请注意，在将电路板连接到客户端设备后，Wi-Fi LED每秒闪烁3次。现在，重新加载  <em>mylinkit.local</em>  网页，设置新密码并登录。新的固件版本详细信息将显示在  <strong>软件信息下</strong>，如下所示。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-16-32.png" alt="Snipaste_2018-12-08_17-16-32"></p></li></ul><h4 id="安装终端模拟器putty并登录"><a href="#安装终端模拟器putty并登录" class="headerlink" title="安装终端模拟器putty并登录"></a>安装终端模拟器putty并登录</h4><p>打开putty和在配置窗口中键入  <code>mylinkit.local</code> 在  主机名中，单击SSH单选按钮，然后打开</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-28-22.png" alt="Snipaste_2018-12-08_17-28-22"></p><p>初次登录会弹出安全警报窗口，单击Yes</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-30-00.png" alt="Snipaste_2018-12-08_17-30-00"></p><p>显示PuTTY终端窗口。使用 您之前在Web UI中设置的用户名  <em>root</em>和密码登录。登录后如下图</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-31-19.png" alt="Snipaste_2018-12-08_17-31-19"></p><p>终端模拟器安装并登录成功。</p><h4 id="将7688-Duo-Board连接到Internet"><a href="#将7688-Duo-Board连接到Internet" class="headerlink" title="将7688 Duo Board连接到Internet"></a>将7688 Duo Board连接到Internet</h4><h5 id="将LinkIt-Smart-7688连接到具有Internet访问权限的Wi-Fi接入点"><a href="#将LinkIt-Smart-7688连接到具有Internet访问权限的Wi-Fi接入点" class="headerlink" title="将LinkIt Smart 7688连接到具有Internet访问权限的Wi-Fi接入点"></a>将LinkIt Smart 7688连接到具有Internet访问权限的Wi-Fi接入点</h5><ul><li>在浏览器中打开  <code>mylinkit.local</code>，并使用您的密码登录Web UI。在Web UI中单击“  NetWork”</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-37-43.png" alt="Snipaste_2018-12-08_17-37-43"></p><ul><li>在  <strong>网络设置</strong> 屏幕中，选择 <strong>Repeater  mode</strong>。从“  <strong>检测到的Wi-Fi网络”</strong>  列表中选择要连接的AP，选择AP后输入密码。并设置中继器SSID名称和密码。单击  <strong>配置和重新启动</strong> 以完成，如下所示</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-41-49.png" alt="Snipaste_2018-12-08_17-41-49"></p><h5 id="将主机连接到同一网络中的AP"><a href="#将主机连接到同一网络中的AP" class="headerlink" title="将主机连接到同一网络中的AP"></a>将主机连接到同一网络中的AP</h5><p>打开计算机上的Wi-Fi连接到步骤1中使用的同一访问点。您的计算机现在位于由您连接的Wi-Fi接入点形成的同一局域网下</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-50-13.png" alt="Snipaste_2018-12-08_17-50-13"></p><h5 id="检查Internet连接"><a href="#检查Internet连接" class="headerlink" title="检查Internet连接"></a>检查Internet连接</h5><p>通过<strong>ping –c 5 <a href="http://www.mediatek.com" target="_blank" rel="noopener">www.mediatek.com</a></strong> 在终端窗口中输入来检查您是否建立了互联网连接。，结果如下图那么您已连接到Wi-Fi网络的AP。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_17-52-56.png" alt="Snipaste_2018-12-08_17-52-56"></p><h4 id="使用板级支持包安装Arduino-IDE"><a href="#使用板级支持包安装Arduino-IDE" class="headerlink" title="使用板级支持包安装Arduino IDE"></a>使用板级支持包安装Arduino IDE</h4><p>由于MT7688 Duo板载ATmega32U4，因此可以使用  Arduino IDE开发环境</p><ul><li>安装Arduino IDE 1.6.4或更高版本。</li><li>安装板支撑包。</li><li>ARDUINO：<a href="https://www.arduino.cc/en/Main/Software" target="_blank" rel="noopener">https://www.arduino.cc/en/Main/Software</a></li></ul><h5 id="安装Arduino-IDE"><a href="#安装Arduino-IDE" class="headerlink" title="安装Arduino IDE"></a>安装Arduino IDE</h5><p>下载Arduino IDE 并且解压到安装目录，找到arduino.exe,快捷至桌面即可。</p><h5 id="安装板支撑包"><a href="#安装板支撑包" class="headerlink" title="安装板支撑包"></a>安装板支撑包</h5><ul><li>打开Arduino IDE，在“  <strong>文件”</strong> 菜单上单击  <strong>“首选项”</strong>。在<strong>Additional Boards Manager</strong> <strong>URL中</strong>添加  ，如下所示。   <code>http://download.labs.mediatek.com/package_mtk_linkit_smart_7688_index.json</code></li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_18-28-26.png" alt="Snipaste_2018-12-08_18-28-26"></p><ul><li>确保您的计算机已连接到互联网。</li><li>在“  <strong>工具”</strong> 菜单中指向“  <strong>板”，</strong> 然后单击“  <strong>板卡管理器”</strong>。</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_18-40-54.png" alt="Snipaste_2018-12-08_18-40-54">板卡管理器自动下载储库。Boards Manager可能需要几秒钟才能下载存储库。 </p><p>选择LinkIt Smart 7688版本，然后单击“  <strong>安装”</strong>。（由于已经安装因此显示为删除）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_18-47-13.png" alt="Snipaste_2018-12-08_18-47-13"></p><ul><li>安装完成后，Board Manager会指示已安装软件包，如下所示。</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-08_18-49-53.png" alt="Snipaste_2018-12-08_18-49-53"></p><h4 id="安装LinkIt-Smart-7688-Duo-COM端口驱动程序"><a href="#安装LinkIt-Smart-7688-Duo-COM端口驱动程序" class="headerlink" title="安装LinkIt Smart 7688 Duo COM端口驱动程序"></a>安装LinkIt Smart 7688 Duo COM端口驱动程序</h4><h5 id="将LinkIt-Smart-7688-Duo开发板连接到计算机"><a href="#将LinkIt-Smart-7688-Duo开发板连接到计算机" class="headerlink" title="将LinkIt Smart 7688 Duo开发板连接到计算机"></a>将LinkIt Smart 7688 Duo开发板连接到计算机</h5><p>将micro USB线插入LinkIt Smart 7688 Duo板的Power / MCU连接器，另一端插入计算机。</p><h5 id="安装驱动程序"><a href="#安装驱动程序" class="headerlink" title="安装驱动程序"></a>安装驱动程序</h5><ul><li>从文件夹安装串行COM端口INF驱动程序  ：<br><code>{ARDUINO_IDE_PREFERENCE_LOCATION}/packages/LinkIt/hardware/avr/0.1.5/driver/linkit_smart_7688.inf</code> </li><li>您可以 从“ <strong>文件”</strong>菜单项<strong>“首选项”中</strong>找到ARDUINO_IDE_PREFERENCE_LOCATION。请参阅<strong>preference.txt</strong>路径，如下所示（图1）单击红线部分即会跳转（图2）。 </li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-09_11-40-16.png" alt="Snipaste_2018-12-09_11-40-16"></p><p>图1</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-09_11-42-38.png" alt="Snipaste_2018-12-09_11-42-38"></p><p>图2</p><p>按照<code>{ARDUINO_IDE_PREFERENCE_LOCATION}/packages/LinkIt/hardware/avr/0.1.5/driver/linkit_smart_7688.inf</code> 找到linkit_smart_7688.inf</p><ul><li>找到  后右点击<code>linkit_smart_7688.inf</code> 快捷菜单上后，单击“  <strong>安装”</strong>。会出现安装错误，如下所示，</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-09_11-50-10.png" alt="Snipaste_2018-12-09_11-50-10"></p><h4 id="禁用“驱动程序签名强制”功能"><a href="#禁用“驱动程序签名强制”功能" class="headerlink" title="禁用“驱动程序签名强制”功能"></a>禁用“驱动程序签名强制”功能</h4><p>详细教程：<a href="https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html</a></p><p>再次点击安装，如下图。单击“  <strong>安装此驱动程序软件”</strong>。这样就完成了驱动安装。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-09_12-13-11.png" alt="Snipaste_2018-12-09_12-13-11"></p><p>MT7688的入门环境配置基本完成，接下来开始MT7688的软件编程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：由于使用的开发板为LinkIt Smart 7688 Duo，因此后续不会有LinkIt Smart 7688。或一笔带过。&lt;/p&gt;
&lt;h3 id=&quot;程序设计环境向导&quot;&gt;&lt;a href=&quot;#程序设计环境向导&quot; class=&quot;headerlink&quot; title=&quot;程序设计环境向导&quot;&gt;&lt;/a&gt;程序设计环境向导&lt;/h3&gt;&lt;p&gt;这一章介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本平台使用的操作系统&lt;/li&gt;
&lt;li&gt;LinkIt Smart 7688开发平台提供的程序设计环境&lt;/li&gt;
&lt;li&gt;各种程序设计模型以及如何在开发板上使用&lt;/li&gt;
&lt;li&gt;用于与开发板进行Wi-Fi通信的网络环境&lt;/li&gt;
&lt;li&gt;使用C/C++、Python和Node.js创建应用程序的方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MT7688入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/MT7688%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="MT7688" scheme="https://github.com/SetCalm/setcalm.github.io/tags/MT7688/"/>
    
  </entry>
  
</feed>
