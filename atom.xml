<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/SetCalm/setcalm.github.io/"/>
  <updated>2018-12-18T18:59:46.584Z</updated>
  <id>https://github.com/SetCalm/setcalm.github.io/</id>
  
  <author>
    <name>Jeff Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cs</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-19-cs.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-19-cs.html</id>
    <published>2022-12-18T18:58:59.000Z</published>
    <updated>2018-12-18T18:59:46.584Z</updated>
    
    <content type="html"><![CDATA[<p>由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。</p><p>另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。</p><p>谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。&lt;/p&gt;
&lt;p&gt;另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。&lt;/p&gt;
&lt;p&gt;谢谢！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重要说明</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/重要说明.html</id>
    <published>2019-12-28T13:37:19.000Z</published>
    <updated>2019-02-23T08:32:34.454Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。</p><p>博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。&lt;/p&gt;
&lt;p&gt;博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>unix下输入与输出(I/0)</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/unix%E4%B8%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA-I-0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html</id>
    <published>2019-02-28T03:31:17.000Z</published>
    <updated>2019-02-28T12:32:08.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本章节主要讲解Linux下如何对文件操作，包括两部分：</p><p>文件I/O和标准I/O</p><p>他们有什么区别，该部分将使用一个专门都一下节去讲解。</p><h1 id="第一节：文件I-O和标准I-O的比较"><a href="#第一节：文件I-O和标准I-O的比较" class="headerlink" title="第一节：文件I/O和标准I/O的比较"></a>第一节：文件I/O和标准I/O的比较</h1><p>来源说明</p><p>作者：zqixiao_09 </p><p>原文地址：<a href="https://blog.csdn.net/zqixiao_09/article/details/50444465" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50444465</a> </p><h2 id="什么是文件I-O和标准I-O"><a href="#什么是文件I-O和标准I-O" class="headerlink" title="什么是文件I/O和标准I/O"></a>什么是文件I/O和标准I/O</h2><p>文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。</p><p>标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。</p><ul><li>全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 </li><li>行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 </li><li>不带缓存：stderr就是了。</li></ul><h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><ul><li><p>文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。</p></li><li><p>通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。</p></li><li><p>文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。</p><p><em>注：Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。</em></p></li></ul><h2 id="文件I-O和标准I-O使用的函数比较"><a href="#文件I-O和标准I-O使用的函数比较" class="headerlink" title="文件I/O和标准I/O使用的函数比较"></a>文件I/O和标准I/O使用的函数比较</h2><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_11-57-29.png" alt="Snipaste_2019-02-28_11-57-29"></p><h3 id="fopen与open比较"><a href="#fopen与open比较" class="headerlink" title="fopen与open比较"></a>fopen与open比较</h3><p><strong>标准I/O使用fopen函数打开一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span> *mod)</span><br></pre></td></tr></table></figure><ul><li>path：文件名。</li><li>mod：用于指定文件打开的模式的字符串，比如”r”,”w”,”w+”,”a”等等，可以加上字母b用以指定以二进制模式打开。</li><li>返回值：如果成功打开，返回一个FILE文件指针，如果失败返回NULL。（这里的文件指针并不是指向实际的文 件，而是一个关于文件信息的数据包，其中包括文件使用的缓冲区信息。）</li></ul><p><strong>文件IO使用open函数用于打开一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd=open(<span class="keyword">char</span> *name,<span class="keyword">int</span> how);</span><br></pre></td></tr></table></figure><ul><li>name：文件名字符串</li><li>how指定打开的模式：O_RDONLY(只读),O_WRONLY(只写）,O_RDWR （可读可写)。（其他模式请man 2 open）。</li><li>返回值：成功返回一个正整数称为文件描述符，这与标准I/O显著不同，失败的话返回-1，与标准I/O返回NULL也是不同的。</li></ul><h3 id="fclose与close比较"><a href="#fclose与close比较" class="headerlink" title="fclose与close比较"></a>fclose与close比较</h3><p>标准I/O使用fclose关闭文件，将文件指针传入即可，如果成功关闭，返回0，否则返回EOF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fclose(fp)!=<span class="number">0</span>)  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error in closing file"</span>);</span><br></pre></td></tr></table></figure><p>文件IO使用close用于关闭open打开的文件，与fclose类似，只不过当错误发生时返回的是-1，而不是EOF，成功关闭同样是返回0。</p><h3 id="读文件比较：getc-fscanf-fgets和read"><a href="#读文件比较：getc-fscanf-fgets和read" class="headerlink" title="读文件比较：getc,fscanf,fgets和read"></a>读文件比较：getc,fscanf,fgets和read</h3><p><strong>标 准I/O中进行文件读取</strong></p><ul><li>可以使用 <strong>getc</strong>，一个字符一个字符的读取，也可以使用gets（读取标准io读入的）</li><li>fgets以字符串单位进行读取（读到遇 到的第一个换行字符的后面）</li></ul><p>gets（接受一个参数，文件指针）不判断目标数组是否能够容纳读入的字符，可能导致存储溢出(不建议使用），而fgets使用三个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数和gets一样，用于存储输入的地址，第二个参数为整数，表示输入字符串的最大长度，最后一个参数就是文件指针，指向要读取的文件。</p><ul><li>最 后是fscanf，与scanf类似，只不过增加了一个参数用于指定操作的文件，比如fscanf(fp,”%s”,words)</li></ul><p><strong>文件I/O中进行文件读取</strong></p><p>文件IO中使用read函数用于读取open函数打开的文件，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> numread=read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> qty);</span><br></pre></td></tr></table></figure><p>其中fd就是open返回的文件描述符，buf用于存储数据的目的缓冲区，而qty指定要读取的字节数。如果成功读取，就返回读取的字节数目（小于等于qty）</p><h3 id="判断文件结尾比较"><a href="#判断文件结尾比较" class="headerlink" title="判断文件结尾比较"></a>判断文件结尾比较</h3><p>如果尝试读取达到文件结尾，标准IO的getc会返回特殊值EOF，而fgets碰到EOF会返回NULL,而对于unix的read函数，情况有所不 同。read读取qty指定的字节数，最终读取的数据可能没有你所要求的那么多（qty），而当读到结尾再要读的话，read函数将返回0.</p><h3 id="写文件比较：putc-fputs-fprintf和write"><a href="#写文件比较：putc-fputs-fprintf和write" class="headerlink" title="写文件比较：putc,fputs,fprintf和write"></a>写文件比较：putc,fputs,fprintf和write</h3><p><strong>标准I/O中进行文件写入</strong></p><p>使用putc写入字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putc(ch,fp);</span><br><span class="line"><span class="comment">//第一个参数是字符，第二个是文件指针。</span></span><br></pre></td></tr></table></figure><p>使用fputs写入字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(buf,fp);</span><br><span class="line"><span class="comment">//仅仅是第一个参数换成了字符串地址。</span></span><br></pre></td></tr></table></figure><p>使用fprintf写入字符</p><p>fprintf与printf类似，增加了一个参数用于指定写入的文件，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello %s.\n"</span>,<span class="string">"dennis"</span>);</span><br></pre></td></tr></table></figure><p>切记fscanf和fprintf将FILE指针作为第一个参数，而putc,fputs则是作为第二个参数。</p><p><strong>文件I/O中进行文件写入</strong></p><p>在文件IO中提供write函数用于写入文件，原型与read类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result=write(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf ,<span class="keyword">size_t</span> amt);</span><br></pre></td></tr></table></figure><p>fd：文件描述符</p><p>buf：是将要写入的内存数据</p><p>amt：是要写的字节数。</p><p>返回值：如果写入成功返回写入的字节数，通过result与amt的比较可以判断是否写入正常，如果写入失败返回-1</p><h3 id="随机存取比较：fseek-、ftell-和lseek"><a href="#随机存取比较：fseek-、ftell-和lseek" class="headerlink" title="随机存取比较：fseek()、ftell()和lseek()"></a>随机存取比较：fseek()、ftell()和lseek()</h3><p><strong>标准I/O中进行随机存取</strong></p><p>标准I/O使用fseek和ftell用于文件的随机存取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fseek函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数：是文件指针</p><p>第二个参数：是一个long类型的偏移量（offset），表示从起始点开始移动的距离。</p><p>第三个参数：是用于指定起始点的模式，stdio.h指定了下列模式常量：</p><p>SEEK_SET            文件开始处<br>​    SEEK_CUR            当前位置<br>​    SEEK_END            文件结尾处</p><p>看几个调用例子： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_SET); <span class="comment">//找到文件的开始处 </span></span><br><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END); <span class="comment">//定位到文件结尾处 </span></span><br><span class="line">fseek(fp,<span class="number">2L</span>,SEEK_CUR); <span class="comment">//文件当前位置向前移动2个字节数</span></span><br></pre></td></tr></table></figure><p>而ftell函数用于返回文件的当前位置，返回类型是一个long类型，比如下面的调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END);<span class="comment">//定位到结尾 </span></span><br><span class="line"><span class="keyword">long</span> last=ftell(fp); <span class="comment">//返回当前位置</span></span><br></pre></td></tr></table></figure><p>那么此时的last就是文件指针fp指向的文件的字节数。</p><p><strong>文件I/O中进行随机存取</strong></p><p>与标准I/O类似，unix系统提供了lseek来完成fseek的功能，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型如下：</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><p>fildes:是文件描述符</p><p>offset:也是偏移量</p><p>whence:同样是指定起始点模式</p><p>唯一的不同是lseek有返回值，如果成功就 返回指针变化前的位置，否则返回-1。whence的取值与fseek相同：SEEK_SET,SEEK_CUR,SEEK_END，但也可以用整数 0,1,2相应代替。</p><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>​    上面我们一直在讨论文件I/O与标准I/O的区别，其实可以这样说，文件I/O是系统调用、标准I/O是库函数，看下面这张图：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_12-42-29.png" alt="Snipaste_2019-02-28_12-42-29"></p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>操作系统负责管理和分配所有的计算机资源。为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用。通过这组接口用户程序可以使用操作系统内核提供的各种功能。例如分配内存、创建进程、实现进程之间的通信等。</p><p>   为什么不允许程序直接访问计算机资源？答案是不安全。单片机开发中，由于不需要操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，程序访问资源的方式都发生了改变。操作系统基本上都支持多任务，即同时可以运行多个程序。如果允许程序直接访问系统资源，肯定会带来很多问题。因此，所有软硬件资源的管理和分配都有操作系统负责。程序要获取资源（如分配内存，读写串口）必须由操作系统来完成，即用户程序向操作系统发出服务请求，操作系统收到请求后执行相关的代码来处理。</p><p>   用户程序向操作系统提出请求的接口就是系统调用。所有的操作系统都会提供系统调用接口，只不过不同的操作系统提供的系统调用接口各不相同。Linux 系统调用接口非常精简，它继承了Unix 系统调用中最基本的和最有用的部分。这些系统调用按照功能大致可分为进程控制、进程间通信、文件系统控制、存储管理、网络管理、套接字控制、用户管理等几类。</p><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">库函数可以说是对系统调用的一种封装，因为系统调用是面对的是操作系统，系统包括Linux、Windows等，如果直接系统调用，会影响程序的移植性，所以这里使用了库函数，比如说C库，这样只要系统中安装了C库，就都可以使用这些函数，比如printf()  scanf()等，C库相当于对系统函数进行了翻译，使我们的APP可以调用这些函数；</span><br></pre></td></tr></table></figure><h4 id="用户编程接口API"><a href="#用户编程接口API" class="headerlink" title="用户编程接口API"></a>用户编程接口API</h4><pre><code>前面提到利用系统调用接口程序可以访问各种资源，但在实际开发中程序并不直接使用系统调用接口，而是使用用户编程接口（API）。为什么不直接使用系统调用接口呢？</code></pre><p>原因如下：</p><p>1）系统调用接口功能非常简单，无法满足程序的需求。</p><p>2）不同操作系统的系统调用接口不兼容，程序移植时工作量大。</p><pre><code>用户编程接口通俗的解释就是各种库（最重要的就是C库）中的函数。为了提高开发效率，C库中实现了很多函数。这些函数实现了常用的功能，供程序员调用。这样一来，程序员不需要自己编写这些代码，直接调用库函数就可以实现基本功能，提高了代码的复用率。使用用户编程接口还有一个好处：程序具有良好的可移植性。几乎所有的操作系统上都实现了C库，所以程序通常只需要重新编译一下就可以在其他操作系统下运行。用户编程接口（API）在实现时，通常都要依赖系统调用接口。例如，创建进程的API函数fork()对应于内核空间的sys_fork()系统调用。很多API函数西亚我哦通过多个系统调用来完成其功能。还有一些API函数不要调用任何系统调用。 在Linux 中用户编程接口（API）遵循了在Unix中最流行的应用编程界面标准——POSIX标准。POSIX标准是由IEEE和ISO/IEC共同开发的标准系统。该标准基于当时想用的Unix 实践和经验，描述了操作系统的系统调用编程接口（实际上就是API），用于保证应用程序可以在源代码一级商多种操作系统上运行。这些系统调用编程接口主要是通过C库（libc )实现的。</code></pre><h2 id="一句话理解文件I-O和标准I-O"><a href="#一句话理解文件I-O和标准I-O" class="headerlink" title="一句话理解文件I/O和标准I/O"></a>一句话理解文件I/O和标准I/O</h2><ul><li>文件I/O更接近于底层硬件的I/O。其使用是通过是系统调用实现的。</li><li>标准I/O可以说是对文件I/O的一种封装，是基于库函数。</li><li>文件I/O多针于操作系统而标准I/O多针对于应用程序</li></ul><h1 id="第二节：文件I-O"><a href="#第二节：文件I-O" class="headerlink" title="第二节：文件I/O"></a>第二节：文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX 系统文件 I/ O 函数的操作有—— 打开 文件、 读 文件、 写 文件 等。 UNIX 系统 中的 大多数 文件 I/ O 只需 用到 5 个 函数： open、 read、 write、 lseek 以及 close。</p><p>本章 描述 的 函数 经常 被称为 不带 缓冲 的 I/ O，术语 不带 缓冲 指的 是 每个 read 和 write 都 调用 内核 中的 一个 系统 调用。</p><p>只要 涉及 在 多个 进程 间 共享 资源， 原子 操作 的 概念 就 变得 非常 重要。 我们将 通过 文件 I/ O 和 open 函数 的 参数 来 讨论 此 概念。</p><p>本章 还将 进一步 讨论 在 多个 进程 间 如何 共享 文件， 以及 所 涉及 的 内核 有关 数据 结构。 在 描述 了 这些 特征 后， 将 说明 dup、 fcntl、 sync、 fsync 和 ioctl 函数。</p><h2 id="文件-描述-符"><a href="#文件-描述-符" class="headerlink" title="文件 描述 符"></a>文件 描述 符</h2><p>对于 内核 而言， 所有 打开 的 文件 都 通过 文件 描述 符 引用。 文件 描述 符 是 一个 非 负 整数。 当 打开 一个 现有 文件 或 创建 一个 新 文件 时， 内核 向 进程 返回 一个 文件 描述 符。当 读、 写 一个 文件 时， 使用 open 或 creat 返回 的 文件 描述 符 标识 该 文件， 将其 作为 参数 传送 给 read 或 write。</p><p>按照 惯例， UNIX 系统 shell 把 文件 描述 符 0 与 进程 的 标准 输入 关联， 文件 描述 符 1 与 标准 输出 关联， 文件 描述 符 2 与 标准 错误 关联。</p><p>文件 描述 符 的 变化 范围是 0 ～ OPEN_ MAX- 1（ 见图 2- 11）。 早期 的 UNIX 系统 实现 采用 的 上 限值 是 19（ 允许 每个 进程 最多 打开 20 个 文件）， 但 现在 很多 系统 将其 上限 值 增加 至 63。</p><h2 id="文件的打开和关闭及-创建"><a href="#文件的打开和关闭及-创建" class="headerlink" title="文件的打开和关闭及 创建"></a>文件的打开和关闭及 创建</h2><h3 id="函数-open"><a href="#函数-open" class="headerlink" title="函数 open"></a>函数 open</h3><p>调用 open 或 openat 函数 可以 打开 或 创建 一个 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>pathname ：</strong>是待打开/创建文件的路径名（如 C:/cpp/a.cpp）。</p><p><strong>oflag ：</strong>用于指定文件的打开/创建模式。</p><p>这个参数可由以下常量（定义于 fcntl.h）通过逻辑或构成。打开/创建文件时，至少得使用下述三个常量中的一个。</p><ul><li>O_RDONLY　　只读模式</li><li><p>O_WRONLY　　只写模式</p></li><li><p>O_RDWR　　读写模式</p></li></ul><p>以下常量是选用的：</p><ul><li>O_APPEND　　每次写操作都写入文件的末尾</li><li>O_CREAT　　如果指定文件不存在，则创建这个文件</li><li>O_EXCL　　如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li><li>O_TRUNC　　如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li><li>O_NOCTTY　　如果路径名指向终端设备，不要把这个设备用作控制终端。</li><li>O_NONBLOCK　　如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）</li></ul><p>以下三个常量同样是选用的，它们用于同步输入输出</p><ul><li>O_DSYNC　　等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。</li><li>O_RSYNC　　read 等待所有写入同一区域的写操作完成后再进行</li><li>O_SYNC　　等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li></ul><p><strong>第三个参数（…）</strong>仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。</p><p><strong>返回值：</strong>成功则返回文件描述符，否则返回 -1，open 返回的文件描述符一定是最小的未被使用的描述符。</p><p>函数 creat</p><p>也可 调用 creat 函数 创建 一个 新 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; fcntl. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *path, mode_ t mode)</span></span>;</span><br></pre></td></tr></table></figure><p>返回 值： 若 成功， 返回 为 只 写 打开 的 文件 描述 符； 若 出错， 返回 − 1 注意，</p><p> 此 函数 等效 于： open( path, O_ WRONLY ｜ O_ CREAT ｜ O_ TRUNC, mode)。 因此现在很少有使用creat()函数来创建新文件;</p><h3 id="函数-close"><a href="#函数-close" class="headerlink" title="函数 close"></a>函数 close</h3><p>调用 close 函数可以关闭 一个已打开的文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line">int close (int fd)；</span><br></pre></td></tr></table></figure><p> 返回 值： 若 成功， 返回 0； 若 出错， 返回 − 1 </p><p>关闭 一个 文件 时 还会 释放 该 进程 加在 该 文件 上 的 所有 记录 锁。 </p><p> 当 一个 进程 终止 时， 内核 自动 关闭 它 所有 的 打开 文件。 很多 程序 都 利用 了 这一 功能 而 不显 式 地 用 close 关闭 打开 文件。 </p><h3 id="实例：文件的打开与关闭"><a href="#实例：文件的打开与关闭" class="headerlink" title="实例：文件的打开与关闭"></a>实例：文件的打开与关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd；</span><br><span class="line">   <span class="keyword">if</span>((fd=open(“test.txt”,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>)&lt;<span class="number">0</span>);</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fail tpo open"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h4 id="函数-read"><a href="#函数-read" class="headerlink" title="函数 read"></a>函数 read</h4><p>调用 read 函数 从 打开 文件 中 读 数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回读到的字节数，若已到文件末尾则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:读取数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要读取的字节数</span></span><br></pre></td></tr></table></figure><p> 　　有几种情况可使实际读到的字节数少于要求读的字节数：</p><p>　　1）读普通文件时，在读到要求字节数之前就已经达到了文件末端。例如，若在到达文件末端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0（文件末端）。</p><p>　　2）当从终端设备读时，通常一次最多读一行。</p><p>　　3）当从网络读时，网络中的缓存机构可能造成返回值小于所要求读的字结束。</p><p>　　4）当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</p><p>　　5）当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。</p><p>　　6）当某一个信号造成中断，而已经读取了部分数据。</p><h4 id="函数-write"><a href="#函数-write" class="headerlink" title="函数 write"></a>函数 write</h4><p>write函数定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nb　write函数定义如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure><h3 id="实例：使用-read-和-write-函数-复制-一个-文件。"><a href="#实例：使用-read-和-write-函数-复制-一个-文件。" class="headerlink" title="实例：使用 read 和 write 函数 复制 一个 文件。"></a>实例：使用 read 和 write 函数 复制 一个 文件。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: copy_file.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd,to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断入参</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s fromfile tofile !\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">if</span>( (from_fd = open(argv[<span class="number">1</span>],O_RDONLY | O_CREAT ))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s Error!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建目的文件</span></span><br><span class="line">    <span class="keyword">if</span>( (to_fd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT))==<span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s error! \n"</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//测得文件大小</span></span><br><span class="line">    file_len=lseek(from_fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(from_fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from file size is %d!\n"</span>,file_len);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//进行文件拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(from_fd, buffer, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(to_fd, buffer, ret );</span><br><span class="line">        file_len = ret;</span><br><span class="line">        bzero( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"there are %d buyes data left without copy!\n"</span>,file_len);</span><br><span class="line">    close(from_fd);</span><br><span class="line">    close(to_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lseek文件定位"><a href="#lseek文件定位" class="headerlink" title="lseek文件定位"></a>lseek文件定位</h3><p>iseek函数对文件当位置进行定位。它只能对可定位（可随机 访问）文件操作。管道，套接字和大部分字符设备文件不支持该类操作。</p><p> 函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>函数功能：</strong> lseek系统调用用来移动读写指针的位置</p><p><strong>参数说明：</strong></p><p>​       fd:要操作的文件</p><p>​      offset：相对whence移动的位移数，允许负值</p><p>​      whence：起始指针，它有三个取值</p><p>​                   SEEK_SET 从文件开始处计算偏移量</p><p>​                     SEEK_CUR 从文件指针的当前位置开始计算偏移</p><p>​         ​             SEEK_END 从文件结尾处开始计算偏移量</p><p>​     文件指针值等于当前指针值加上offset的值。     </p><p><strong>返回值：</strong>调用成功时范围当前的读写位置，也就是距离文件开始处多少字节，若</p><p>​                有错误返回-1</p><p><strong>常见用法：</strong></p><ul><li>​    将文件读写指针移动到文件开头：</li><li>​       lseek(int fildes, 0, SEEK_SET);</li><li>​       将文件读写指针移动到文件结尾：</li><li>　　lseek(int fildes, 0, SEEK_END);</li><li>　　获取文件读写指针当前的位置</li><li>　　lseek(int fikdes, 0, SEEK_CUR);</li></ul><p><strong>实例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>  readfd, writefd;  </span><br><span class="line">    <span class="keyword">long</span> filelen=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span>  ret=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];  </span><br><span class="line">    <span class="keyword">char</span> *ptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*打开源文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((readfd=open(<span class="string">"test.txt"</span>, O_RDONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">      <span class="comment">/*创建目的文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((writefd=open(<span class="string">"dest.txt"</span>, O_WRONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*测得文件大小*/</span>  </span><br><span class="line">    filelen= lseek(readfd,<span class="number">0L</span>,SEEK_END);  </span><br><span class="line">    lseek(readfd,<span class="number">0L</span>,SEEK_SET);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read file size is %d\n"</span>,filelen);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进行文件拷贝*/</span>  </span><br><span class="line">    <span class="keyword">while</span>(ret)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret= read(readfd, buffer, BUFFER_SIZE);  </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read Error\n"</span>);   </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);          </span><br><span class="line">        &#125;  </span><br><span class="line">        write(writefd, buffer, ret);  </span><br><span class="line">        filelen-=ret;  </span><br><span class="line">        bzero(buffer,BUFFER_SIZE);  </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    close(readfd);   </span><br><span class="line">    close(writefd);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考实例：</strong></p><p><a href="https://www.cnblogs.com/mickole/p/3182033.html" target="_blank" rel="noopener">利用lseek()创建空洞文件</a></p><p><a href="https://www.cnblogs.com/zxysmalleyes/p/5321207.html" target="_blank" rel="noopener">用lseek拼接两个文件</a></p><h2 id="内核数据结构分析"><a href="#内核数据结构分析" class="headerlink" title="内核数据结构分析"></a>内核数据结构分析</h2><p>UNIX 系统 支持 在 不同 进程 间 共享 打开 文件。进程间的这种 共享是如何进行的，为此 先 介绍 内核 用于 所有 I/ O 的 数据 结构。 </p><p>内核 使用 3 种数 据 结构 表示 打开 文件， 它们 之间 的 关系 决定了 在 文件 共享 方面 一个 进程 对 另一个 进程 可能 产生 的 影响。 </p><p>（1） 每个 进程 在 进程表 中 都有 一个 记录 项（文件表项）， 记录 项 中 包含 一张 打开 文件 描述 符 表， 可将 其 视为 一个 矢量， 每个 描述 符 占用 一项。 与 每个 文件 描述 符 相 关联 的 是：</p><p> a． 文件 描述 符 标志（ close_ on_ exec， 参见 图 3- 7 和 3. 14 节）；</p><p> b． 指向 一个 文件 表项 的 指针。 </p><p>（2） 内核 为所 有打 开 文件 维持 一张 文件 表。 每个 文件 表项 包含：</p><p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等， 关于 这些 标志 的 更多 信息 参见 3. 14 节）；</p><p> b． 当前 文件 偏移量； c． 指向 该 文件 v 节点 表项 的 指针。</p><p> （3） 每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。 v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。 对于 大多数 文件， v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。 这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。 例如， i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等（ 4. 14 节 较 详细 地说 明了 典型 UNIX 系统 文件 系统， 并将 更多 地 介绍 i 节点）。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-34-56.png" alt="Snipaste_2019-02-28_16-34-56"></p><p>个人梳理：</p><ul><li><p>1.每个进程都会有一个进程表项，进程表项中包含一个文件描述符表，每个描述符占有一项，每个描述符对应一个指针。该指针指向文件表项。</p></li><li><p>2.内核会为所有的打开的文件创建 一张 文件表项。 每个文件表项包含：     </p><p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等）。</p><p>b． 当前 文件 偏移量；</p><p> c． 指向 该 文件 v 节点 表项 的 指针。</p></li><li><p>3.每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。</p><p> v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。</p><p>v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。</p><p> i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等。</p></li></ul><p>注：这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。</p><p>注意， 文件 描述 符 标志 和 文件 状态 标志 在作 用 范围 方面 的 区别， 前者 只用于 一个 进程 的 一个 描述 符， 而后 者 则应 用于 指向 该给 定 文件 表项 的 任何 进程 中的 所有 描述 符。</p><p><strong>两个 独立 进程 各自 打开 了 同一 文件</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-49-15.png" alt="Snipaste_2019-02-28_16-49-15"></p><p>第一个 进程 在 文件 描述 符 3 上 打开 该 文件， 而 另一个 进程 在 文件 描述 符 4 上 打开 该 文件。 打开 该 文件 的 两个 进程 都 获得 各自 的 一个 文件 表项， 但是对于一个 给定 的 文件只有 一个 v 节点表项。（为什么会创建有两个表项，而不指向欧安同意文件表项） 之所以 每个 进程 都 获得 自己的 文件 表项， 是因为 这可 以使 每个 进程 都有 它自己 的 对 该 文件 的 当前 偏移量。</p><h3 id="文件操作的进一步说明"><a href="#文件操作的进一步说明" class="headerlink" title="文件操作的进一步说明"></a>文件操作的进一步说明</h3><p>给出 了 这些 数据 结构 后， 现在 对 前面 所述 的 操作 进一步 说明。</p><ul><li>write：在 完成 每个 write 后， 在 文件 表项 中的 当前 文件 偏移量 即 增加 所 写入 的 字节数。 如果 这 导致 当前 文件 偏移量 超出 了 当前 文件 长度， 则 将 i 节点 表项 中的 当前 文件 长度 设置 为 当前 文件 偏移量（ 也就是 该文 件 加长 了）。</li><li>open：如果 用 O_ APPEND 标志 打开 一个 文件， 则 相应 标志 也 被 设置 到 文件 表项 的 文件 状态 标志 中。 每次 对这 种 具有 追加 写 标志 的 文件 执行 写 操作 时， 文件 表项 中的 当前 文件 偏移量 首先 会被 设置 为 i 节点 表项 中的 文件 长度。 这就 使得 每次 写入 的 数据 都 追加 到 文件 的 当前 尾端 处。</li><li>lseek：若 一个 文件 用 lseek 定位 到 文件 当前 的 尾端， 则 文件 表项 中的 当前 文件 偏移量 被 设置 为 i 节点 表项 中的 当前 文件 长度 </li></ul><p>注：lseek 函数 只 修改 文件 表项 中的 当前 文件 偏移量， 不进 行 任何 I/ O 操作。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>上面所秒述 的一切是对于多个进程读取同一文件的过程。 每个进程都有它自己的文件表项， 其中也有它自己 的当前文件偏移量。 但是，当多个进程写同一 文件时， 则可能产生预想不到的结果。 为了避免这种情况， 需要 理解原子操作的概念。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="追加数据到-一个-文件"><a href="#追加数据到-一个-文件" class="headerlink" title="追加数据到 一个 文件"></a>追加数据到 一个 文件</h4><p>早期 的 UNIX 系统 版本 并不 支持 open 的 O_ APPEND 选项， 所以 程序 被 编写 成 下列 形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek( fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) 　 　 　 　 　 　<span class="comment">/* position to EOF*/</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (write( fd, buf, <span class="number">100</span>) != <span class="number">100</span>) 　 　<span class="comment">/* and write*/</span> </span><br><span class="line">&#125;   </span><br><span class="line">        <span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" write error"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" lseek error"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个参数表示偏移量，字母L表示long 型，就是让编译器知道0是long型的</span></span><br><span class="line"><span class="comment">其中 int whence 为下列其中一种:（SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2）.</span></span><br><span class="line"><span class="comment">SEEK_SET 代表读写位置指向文件头</span></span><br><span class="line"><span class="comment">　　SEEK_CUR 代表目前的读写位置</span></span><br><span class="line"><span class="comment">　　SEEK_END 代表读写位置指向文件尾</span></span><br><span class="line"><span class="comment">这里的1和SEEK-CUR 是同一个意思。</span></span><br></pre></td></tr></table></figure><p>对 单个 进程 而言， 这段 程序 能 正常 工作， 但 若有 多个 进程 同时 使用 这种 方法 将 数据 追加 写到 同一 文件， 则 会 产生 问题.</p><h4 id="进程A和B对同一文件写操作"><a href="#进程A和B对同一文件写操作" class="headerlink" title="进程A和B对同一文件写操作"></a>进程A和B对同一文件写操作</h4><p>此时， 各 数据 结构 之间 的关系上节图 3- 8 中 所示。 每个 进程 都有 它自己 的 文件 表项， 但是 共享 一个 v 节点 表项。</p><ul><li>此时如果进程 A 调用了lseek， 它将进程 A 的 该文件当前偏移量设置为1500 字节</li><li>然后 内核 切换 进程， 进程 B 运行。 进程 B 执行 lseek， 也 将其 对 该 文件 的 当前 偏移量 设置 为 1 500 字节（ 当前 文件尾 端 处）。 然后 B 调用 write， 它将 B 的 该文 件 当前 文件 偏移量 增加 至 1 600。</li><li>然后， 内核 又 进行 进程 切换， 使 进程 A 恢复 运行。 当 A 调用 write 时， 就会从其当前文件偏移量（ 1 500） 处 开始 将 数据 写入 到 文件。</li></ul><p>这样 也就 覆盖 了 进程 B 刚才 写入 到 该文 件 中的 数据。</p><p><strong>问题 出在 逻辑 操作“ 先 定位 到 文件 尾端， 然后 写”， 它 使用 了 两个 分开 的 函数函调用。</strong> </p><p>解决问题 的 方法 是 使 这 两个 操作 对于 其他 进程 而言 成为 一个 原子 操作。 如果任何要求 多于 一个 函数 调用 的 操作 不 是 原子 操作， 则在 两个 函数 调用 之间， 内核 有可能 会 临时 挂起 进程（ 正如 我们 前面 所 假定 的）。 </p><p>UNIX 系统 为 这样 的 操作 提供 了 一种 原子 操作 方法， 即在 打开 文件 时 设置 O_ APPEND 标志（O_APPEND：每次写操作都写入文件的末尾）。  这样做 使得 内核 在 每次 写 操作 之前， 都将 进程 的 当前 偏移量 设置 到 该 文件 的 尾端 处， 于是 在 每次 写 之前 就不 再 需要 调用 lseek。</p><p><strong>原子操作：</strong>顾名思义，就是说像原子一样不可再细分不可被中途打断。一个操作是原子操作，意思就是说这个操作是以原子的方式被执行，要一口气执行完，执行过程不能够被OS的其他行为打断，是一个整体的过程，在其执行过程中，OS的其它行为是插不进来的。</p><h3 id="文件锁fctnl"><a href="#文件锁fctnl" class="headerlink" title="文件锁fctnl"></a>文件锁fctnl</h3><p>如何实现原子操作，这里就要用到文件锁fctnl().</p><p>该部分讨论文件在已经共享的情况下如何操作，也就是多个程序在操作同以稳健的情况下。，LInux中通常使用文件上锁的方法，来解决共享资源的竞争。</p><p>文件锁包括建议性锁（lockf（））和强制性锁（fcntl（））。fcntl不仅可以施加建议性锁还可以施加强制性锁，同时还能对为见额某一记录上锁，依旧是记录锁。</p><p>记录锁分为读取锁和写入锁。</p><p>略。。。</p><h2 id="重定向dup和dup2函数"><a href="#重定向dup和dup2函数" class="headerlink" title="重定向dup和dup2函数"></a>重定向dup和dup2函数</h2><p>函数dup和dup2提供了<strong>复制文件描述符的功能</strong>。</p><p>他们通常用于stdin,stdout或进程的stderr的重定向。一般来说，普通输出函数（如：printf），默认是将某信息写入到文件描述符为1的文件中，普通输入函数都默认从文件描述符为0的文件中读取数据。因此重定向操作实际上是关闭某个标准输入输出设备（文件描述符为0、1、2），而将另一个打开的普通文件的文件描述符设置为0、1、2.</p><ul><li>输入重定向：关闭标准输入设备，打开（或复制）某普通文件，使其文件描述符为0.</li><li>输出重定向：关闭标准输出设备，打开（或复制）某普通文件，使其文件描述符为1.    </li><li>错误输出重定向：关闭标准错误输入设备，打开（或复制）某普通文件，使其文件描述符为2.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">( <span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure><p>由 dup 返回 的 新 文件 描述 符 一定 是 当前 可用 文件 描述 符 中的 最小 数值。</p><p> 对于 dup2， 可 以用 fd2 参数 指定 新 描述 符 的 值。 如果 fd2 已经 打开， 则 先 将其 关闭。 如若 fd 等于 fd2， 则 dup2 返回 fd2， 而 不 关闭 它。 否则， fd2 的 FD_ CLOEXEC 文件 描述 符 标志 就被 清除， 这样 fd2 在 进程 调用 exec 时 是 打开 状态。</p><p>这些 函数 返回 的 新 文件 描述 符 与 参数 fd 共享 同一个 文件 表项</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_19-16-14.png" alt="Snipaste_2019-02-28_19-16-14"></p><h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure><p>对于函数dup 允许你复制一个oldfd文件描述符。存入一个已存在的文件描述符，它就会返回一个与该描述符“相同”的新的文件描述符。即这两个描述符共享相同的内部结构，共享所有的锁定，读写位置和各项权限或flags等等。例如：对一个文件描述符进行了lseek操作，另一个文件描述符的读写位置也会随之改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd,newfd;</span><br><span class="line">        <span class="keyword">char</span> *bufFD=<span class="string">"Advanced Programming! write by fd\n"</span>;</span><br><span class="line">        <span class="keyword">char</span> *bufNewFD=<span class="string">"Advanced Programming! write by NewFD\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开始复制了</span></span><br><span class="line">        newfd = dup(fd);</span><br><span class="line">        <span class="comment">//使用fd写</span></span><br><span class="line">        write(fd,bufFD,<span class="built_in">strlen</span>(bufFD));</span><br><span class="line">        close(fd);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用newfd写</span></span><br><span class="line">        write(newfd,bufNewFD,<span class="built_in">strlen</span>(bufNewFD));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(close(newfd)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，里面有两段字符串：</span></span><br><span class="line"><span class="comment">：Advanced Programming! write by fd</span></span><br><span class="line"><span class="comment">：Advanced Programming! write by newfd</span></span><br></pre></td></tr></table></figure><p>​    可以看出，对fd或newfd进行读写操作时对同一个文件操作，不会覆盖前面文件（共享读写位置）而且还可以看到fd关闭后，对newfd没有影响，使用newfd还可以操作打开的文件。</p><h3 id="dup2函数（该函数不是很懂）"><a href="#dup2函数（该函数不是很懂）" class="headerlink" title=".dup2函数（该函数不是很懂）"></a><strong>.dup2函数</strong>（该函数不是很懂）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 返回值：如成功则返回新的文件描述符，否则出错返回-1. </p><p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。</p><p>若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等等.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> refd;</span><br><span class="line">        <span class="keyword">char</span> *buf=<span class="string">"Advanced Programming!\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        refd = dup2(fd,fileno(<span class="built_in">stdout</span>));</span><br><span class="line">        <span class="keyword">if</span>(refd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"redirect standard out error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写数据，本应该写入到stdout的信息重定向而写入到目标文件中（test.txt）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dup2的返回值：%d\n"</span>,refd);</span><br><span class="line">        write(fileno(<span class="built_in">stdout</span>),buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，可以看到以下内容</span></span><br><span class="line"><span class="comment">：Advanced Programming!</span></span><br><span class="line"><span class="comment">：dup2的返回值：1</span></span><br></pre></td></tr></table></figure><h1 id="第三节：标准I-O"><a href="#第三节：标准I-O" class="headerlink" title="第三节：标准I/O"></a>第三节：标准I/O</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;本章节主要讲解Linux下如何对文件操作，包括两部分：&lt;/p&gt;
&lt;p&gt;文件I/O和标准I/O&lt;/p&gt;
&lt;p&gt;他们有什么区别，该部分将使用一个专门都一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/数据结构.html</id>
    <published>2019-02-27T04:41:05.000Z</published>
    <updated>2019-02-28T03:31:49.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：数据结构基数"><a href="#第一章：数据结构基数" class="headerlink" title="第一章：数据结构基数"></a>第一章：数据结构基数</h1><h2 id="第一节：数据与c"><a href="#第一节：数据与c" class="headerlink" title="第一节：数据与c"></a>第一节：数据与c</h2><h2 id="第二节：数组和指针"><a href="#第二节：数组和指针" class="headerlink" title="第二节：数组和指针"></a>第二节：数组和指针</h2><h2 id="第三节：结构体"><a href="#第三节：结构体" class="headerlink" title="第三节：结构体"></a>第三节：结构体</h2><h2 id="第四节：其他结构"><a href="#第四节：其他结构" class="headerlink" title="第四节：其他结构"></a>第四节：其他结构</h2><h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><p>联合（union） 是一种数据类型， 它能在同一个内存空间中储存不同的数据类型（不是同时储存） 。 其典型的用法是， 设计一种表以储存既无规律、 事先也不知道顺序的混合类型。 使用联合类型的数组， 其中的联合都大小相等， 每个联合可以储存各种数据类型。 </p><h4 id="创建联合体"><a href="#创建联合体" class="headerlink" title="创建联合体"></a>创建联合体</h4><p>创建联合和创建结构的方式相同， 需要一个联合模板和联合变量。 可以用一个步骤定义联合， 也可以用联合标记分两步定义。 下面是一个带标记的联合模板： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold &#123;</span><br><span class="line"><span class="keyword">int</span> digit;</span><br><span class="line"><span class="keyword">double</span> bigfl;</span><br><span class="line"><span class="keyword">char</span> letter;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h4 id="定义（声明）联合体变量"><a href="#定义（声明）联合体变量" class="headerlink" title="定义（声明）联合体变量"></a>定义（声明）联合体变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit; <span class="comment">// hold类型的联合变量</span></span><br><span class="line"><span class="keyword">union</span> hold save[<span class="number">10</span>]; <span class="comment">// 内含10个联合变量的数组</span></span><br><span class="line"><span class="keyword">union</span> hold * pu; <span class="comment">// 指向hold类型联合变量的指针</span></span><br></pre></td></tr></table></figure><ul><li>第1个声明创建了一个单独的联合变量fit。 编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。 在本例中， 占用空间最大的是 double类型的数据。 在我们的系统中， double类型占64位， 即8字节。 </li><li>第2个声明创建了一个数组save， 内含10个元素， 每个元素都是8字节。</li><li>第3个声明创建了一个指针， 该指针变量储存hold类型联合变量的地址。</li></ul><h4 id="初始化联合体"><a href="#初始化联合体" class="headerlink" title="初始化联合体"></a>初始化联合体</h4><p>需要注意的是， 联合只能储存一个值， 这与结构不同。</p><p> 有 3 种初始化的方法： 把一个联合初始化为另一个同类型的联合； 初始化联合的第1个元素； 或者根据C99标准， 使用指定初始化器：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold valA;</span><br><span class="line">valA.letter = <span class="string">'R'</span>;</span><br><span class="line"><span class="keyword">union</span> hold valB = valA; <span class="comment">// 用另一个联合来初始化</span></span><br><span class="line"><span class="keyword">union</span> hold valC = &#123;<span class="number">88</span>&#125;; <span class="comment">// 初始化联合的digit 成员</span></span><br><span class="line"><span class="keyword">union</span> hold valD = &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure><h4 id="使用联体"><a href="#使用联体" class="headerlink" title="使用联体"></a>使用联体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit.digit = <span class="number">23</span>; <span class="comment">//把 23 储存在 fit， 占2字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>; <span class="comment">// 清除23， 储存 2.0， 占8字节</span></span><br><span class="line">fit.letter = <span class="string">'h'</span>; <span class="comment">// 清除2.0， 储存h， 占1字节</span></span><br></pre></td></tr></table></figure><p>点运算符表示正在使用哪种数据类型。 在联合中， 一次只储存一个值。即使有足够的空间， 也不能同时储存一个char类型值和一个int类型值。 </p><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>略</p><h3 id="枚举（不懂）"><a href="#枚举（不懂）" class="headerlink" title="枚举（不懂）"></a>枚举（不懂）</h3><p>可以用枚举类型（enumerated type） 声明符号名称来表示整型常量。 使<br>用enum关键字， 可以创建一个新“类型”并指定它可具有的值（实际上， enum<br>常量是int类型， 因此， 只要能使用int类型的地方就可以使用枚举类型） 。 枚<br>举类型的目的是提高程序的可读性。 它的语法与结构的语法相同。</p><h4 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br></pre></td></tr></table></figure><p>第1个声明创建了spetrum作为标记名， 允许把enum spetrum作为一个类型名使用。 第2个声明使color作为该类型的变量。 第1个声明中花括号内的标<br>识符枚举了spectrum变量可能有的值。 因此， color 可能的值是 red、orange、 yellow 等。 这些符号常量被称为枚举符（enumerator） 。  </p><h4 id="枚举的使用（没懂）"><a href="#枚举的使用（没懂）" class="headerlink" title="枚举的使用（没懂）"></a>枚举的使用（没懂）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow)</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++)</span><br><span class="line">...;</span><br></pre></td></tr></table></figure><p>虽然枚举符（如red和blue） 是int类型， 但是枚举变量可以是任意整数类型， 前提是该整数类型可以储存枚举常量。 例如， spectrum的枚举符范围是<br>0～5， 所以编译器可以用unsigned char来表示color变量。 </p><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><h1 id="第二章：高级数据结构"><a href="#第二章：高级数据结构" class="headerlink" title="第二章：高级数据结构"></a>第二章：高级数据结构</h1><h2 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h2><p>计算机用户已经开发出的一些数据形式比我们提到过的数组和简单结构更有效地解决特定的问题。 这些形式包括队列、 二叉树、 堆、 哈希表和图表。 许多这样的形式都由链式结构（linked structure） 组成。 通<br>常， 每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。 这些指针把一个结构和另一个结构链接起来， 并提供一种路径能遍历整个彼此链接的结构。 </p><p>图14.3演示了一个二叉树结构， 每个单独的结构（或节点） 都和它下面的两个结构（或节点） 相连。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-27_12-56-40.png" alt="Snipaste_2019-02-27_12-56-40"></p><p>图14.3中显示的分级或树状的结构是否比数组高效？ 考虑一个有10级节点的树的情况。 它有210-1（或1023） 个节点， 可以储存1023个单词。 如果<br>这些单词以某种规则排列， 那么可以从最顶层开始， 逐级向下移动查找单词， 最多只需移动9次便可找到任意单词。 如果把这些单词都放在一个数组中， 最多要查找1023个元素才能找出所需的单词 。</p><h2 id="联合简介"><a href="#联合简介" class="headerlink" title="联合简介"></a>联合简介</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="typedef简介"><a href="#typedef简介" class="headerlink" title="typedef简介"></a>typedef简介</h2><h2 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h2><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章：数据结构基数&quot;&gt;&lt;a href=&quot;#第一章：数据结构基数&quot; class=&quot;headerlink&quot; title=&quot;第一章：数据结构基数&quot;&gt;&lt;/a&gt;第一章：数据结构基数&lt;/h1&gt;&lt;h2 id=&quot;第一节：数据与c&quot;&gt;&lt;a href=&quot;#第一节：数据与c&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C指针：基本概念、核心技术及最佳实践</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/C%E6%8C%87%E9%92%88%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/C指针：基本概念、核心技术及最佳实践.html</id>
    <published>2019-02-21T10:18:47.000Z</published>
    <updated>2019-02-23T08:24:51.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识</p><a id="more"></a><h2 id="1-内存与类型"><a href="#1-内存与类型" class="headerlink" title="1.内存与类型"></a>1.内存与类型</h2><ul><li>内存是一组以二进制方式存储信息的单元，存储容量取决于底层硬件或体系结构以及位长（1、2、4、8、16、32、64或128位）。</li><li>内存用于存储指令和数据序列。内存分为永久和临时存储两种类型，临时/非永久存储（如RAM、cache、寄存器等）。</li></ul><h3 id="1-2类型"><a href="#1-2类型" class="headerlink" title="1.2类型"></a>1.2类型</h3><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-31-53.png" alt="Snipaste_2019-02-21_18-31-53"></p><p>​                        图1.1 内存层次</p><h3 id="1-3内存排列"><a href="#1-3内存排列" class="headerlink" title="1.3内存排列"></a>1.3内存排列</h3><p>内存在空间呈线性序列排列，其中每个位置对应一个存储数据位置的地址。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-37-40.png" alt="Snipaste_2019-02-21_18-37-40"></p><p>内存地址是用于访问基本信息单元的数字。信息就是数据。图中显示了内存转储，在内存中数据存储在连续单元中。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-41-45.png" alt="Snipaste_2019-02-21_18-41-45"></p><h3 id="1-2数据与指令"><a href="#1-2数据与指令" class="headerlink" title="1.2数据与指令"></a>1.2数据与指令</h3><p>数据和指令是所有程序的固有部分。指令或程序逻辑操作与程序相关的数据（见图）。运行程序时，加载器首先加载程序到内存中，被加载程序称为进程（运行程序的实例）并由操作系统加载。<img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-46-23.png" alt="Snipaste_2019-02-21_18-46-23"></p><p>；3</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C primer Plus</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E7%AC%AC%E4%B8%80%E8%8A%82.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/第一节.html</id>
    <published>2019-02-20T12:38:47.000Z</published>
    <updated>2019-02-28T03:31:49.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：基数知识"><a href="#第一章：基数知识" class="headerlink" title="第一章：基数知识"></a>第一章：基数知识</h1><h2 id="第一节：数据和C"><a href="#第一节：数据和C" class="headerlink" title="第一节：数据和C"></a>第一节：数据和C</h2><h3 id="strlen和sizeof"><a href="#strlen和sizeof" class="headerlink" title="strlen和sizeof"></a>strlen和sizeof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>]=<span class="string">"wu"</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strlen= %d,sizeof=%d;"</span> , <span class="built_in">strlen</span>(name) , <span class="keyword">sizeof</span>(name));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">返回值为：<span class="built_in">strlen</span>= <span class="number">2</span>,<span class="keyword">sizeof</span>=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">sizeof</span> 运算符， 它以字节为单位给出对象的大小。 <span class="built_in">strlen</span>()函数给出字符串中的字符长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="常量和c预处理器"><a href="#常量和c预处理器" class="headerlink" title="常量和c预处理器"></a>常量和c预处理器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> taxrate;</span><br><span class="line">taxrate = <span class="number">0.015</span>;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span>常量名比数字表达的信息更多，便于阅读</span><br><span class="line"><span class="number">2.</span>多处使用一个常量， 有时需要改变它的值。 则只需更改符号常量的定义，便于修改。</span><br></pre></td></tr></table></figure><p>taxrate是一个变量， 程序可能会无意间改变它的值。 C语言还提供了一个更好的方案——C预处理器。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAXRATE 0.015</span></span><br><span class="line"></span><br><span class="line">注：编译程序时， 程序中所有的TAXRATE都会被直接替换成 <span class="number">0.015</span>。</span><br></pre></td></tr></table></figure><p>const限定符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MONTHS = <span class="number">12</span>; <span class="comment">// MONTHS在程序中不可更改， 值为12</span></span><br><span class="line"></span><br><span class="line">注：<span class="keyword">const</span>关键字，用于限定一个变量为只读 。它限定一个变量不允许被改变，产生静态作用。</span><br></pre></td></tr></table></figure><h3 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h3><p>C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相<br>关的详细信息。    </p><p>例如： limits.h头文件包含以下类似的代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN -32768</span></span><br><span class="line"><span class="comment">//这些明示常量代表int类型可表示的最大值和最小值。</span></span><br></pre></td></tr></table></figure><h3 id="printf-和scanf"><a href="#printf-和scanf" class="headerlink" title="printf()和scanf()"></a>printf()和scanf()</h3><p>请求printf()函数打印数据的指令要与待打印数据的类型相匹配。 例如，打印整数时使用%d， 打印字符时使用%c。 这些符号被称为转换说明 </p><p>​                        表4.3 转换说明及其打印的输出结果 <img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-26-20.png" alt="Snipaste_2019-02-20_21-26-20"></p><p>scanf()函数所用的转换说明与printf()函数几乎相同。 主要的区别是， 对于float类型和double类型， printf()都使用%f、 %e、 %E、 %g和%G转换说明。 而scanf()只把它们用于float类型， 对于double类型时要使用l修饰符。<br>​                    表4.6 ANSI C中scanf()的转换说明 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-42-14.png" alt="Snipaste_2019-02-20_21-42-14"></p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式（expression） 由运算符和运算对象组成（前面介绍过， 运算对象是运算符操作的对象） 。 最简单的表达式是一个单独的运算对象， 以此为基础可以建立复杂的表达式。 </p><p>运算对象可以是常量、 变量或二者的组合。 一些表达式由子表达式（subexpression） 组成（子表达式即较小的表达式） 。  </p><p>C 表达式的一个最重要的特性是， 每个表达式都有一个值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">-6</span> </span><br><span class="line"><span class="number">4</span>+<span class="number">21</span></span><br><span class="line">a*(b + c/d)/<span class="number">20</span></span><br><span class="line">q = <span class="number">5</span>*<span class="number">2</span></span><br><span class="line">x = ++q % <span class="number">3</span></span><br><span class="line">q &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>注意：int port /<em> 不是表达式， 没有值 </em>/ </p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句（statement） 是C程序的基本构建块。 一条语句相当于一条完整的计算机指令。 在C中， 大部分语句都以分号结尾。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">legs = <span class="number">4999999999999999999</span>KK</span><br><span class="line">只是一个表达式（它可能是一个较大表达式的一部分）  而下面的代码则是一条语句：</span><br><span class="line">legs = <span class="number">4</span>;</span><br><span class="line">最简单的语句是空语句：</span><br><span class="line">; <span class="comment">//空语句</span></span><br><span class="line">C把末尾加上一个分号的表达式都看作是一条语句（即， 表达式语</span><br><span class="line">句） 。 因此， 像下面这样写也没问题：</span><br><span class="line"><span class="number">3</span> + <span class="number">4</span>；</span><br><span class="line">x = <span class="number">25</span>;</span><br><span class="line">++x;</span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br></pre></td></tr></table></figure><h2 id="第二节：指针和数组"><a href="#第二节：指针和数组" class="headerlink" title="第二节：指针和数组"></a>第二节：指针和数组</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p><h4 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h4><p>int x;  //声明变量，申请整形4bit 的空间</p><p>x=40;  //将40存入整型变量 x 中              </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-03-28.png" alt="Snipaste_2019-02-22_01-03-28">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p><p>上图表示如何用整型变量 x 存储值 40。</p><p>变量 x 什么也不是，仅仅是某些内存地址的存储位置（x对应于地址）。在上述情况下，将值 40存储在 0x00394768 位置（40 存储于x对应地址的空间内），这个位置被变量 x 引用。这也意味着，程序中能使用某些变量引用某些地址。</p><p>内存地址也是数字或值。如果我们要在其他变量中存储这个数字（地址），那将是什么？</p><p>如果我们希望访问或以某个变量存储某个内存地址（如 0x00394768），就必须利用指针这种特殊变量及“取址”操作符。</p><h4 id="取址操作符"><a href="#取址操作符" class="headerlink" title="取址操作符"></a>取址操作符</h4><p>“取址”操作符（&amp;）返回操作数的内存地址。取址操作符是一元操作符，适应于变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr1.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Insert data\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;var_int);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例中，scanf 函数需要知道输入值应该存储的地址。函数 scanf 使用“取址”操作符（&amp;）得到存储用户输入值变量 var_int 的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr2.c</span><br><span class="line">Source code. Ptr2.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Address of variable \"var_int\": %p\n"</span>, &amp;var_int);</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Address of variable <span class="string">"var_int"</span>: <span class="number">00394768</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">源代码 Ptr3.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of node = %p\n"</span>,&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable a = %p\n"</span>, &amp;(p.a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable b = %p\n"</span>, &amp;(p.b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Output:</span><br><span class="line">Address of node = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable a = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable b = <span class="number">003</span>AFB04</span><br></pre></td></tr></table></figure><h4 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h4><p>现在你知道如何通过“取址”操作符获取地址。接下来让我们使用一个变量来存储这个地址。这个特定变量能存储和操作变量地址，称为指针变量。</p><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p><p>以下是声明指针变的一般形式 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 变量名 ;</span><br><span class="line"><span class="keyword">int</span>* intptr；</span><br><span class="line"><span class="keyword">char</span>* charptr；</span><br></pre></td></tr></table></figure><p>指针变量声明涉及一个名为解引用操作符 (*) ，用于帮助编译器识别他是一个指针变量。</p><h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>指针变量声明时没有指向。程序员必须在解引用它前让其指向有效的内存地址。</p><p>使用两种方式实现指针变量指向特定内存地址。</p><ol><li><p>利用指针地址（&amp;）分配变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 使用取址操作符获取变量 x 的地址</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-48-04.png" alt="Snipaste_2019-02-22_01-48-04"></p><p>2.让指针变量指向来自堆的动态分配内存 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line">ptr = ( <span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count );</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1550771326720.png" alt="1550771326720"></p></li></ol><p>数组由数据类型相同的一系列元素组成。使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和②这些元素的类型。 编译器根据这些信息正确地创建数组。 普通变量可以使用的类型， 数组元素都可以用。 </p><h4 id="指针的八种操作"><a href="#指针的八种操作" class="headerlink" title="指针的八种操作"></a>指针的八种操作</h4><p>可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作</p><p>程序清单10.13演示了指针变量的 8种基本操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.13</span> ptr_ops.c程序</span><br><span class="line"><span class="comment">// ptr_ops.c -- 指针操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　urn[<span class="number">5</span>]　=　&#123;　<span class="number">100</span>,　<span class="number">200</span>,　<span class="number">300</span>,　<span class="number">400</span>,　<span class="number">500</span>　&#125;;</span><br><span class="line"><span class="keyword">int</span> * ptr1, *ptr2, *ptr3;</span><br><span class="line">ptr1 = urn;　　　　　　　<span class="comment">// 把一个地址赋给指针 </span></span><br><span class="line">ptr2 = &amp;urn[<span class="number">2</span>];　　　　 <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line"><span class="comment">// 解引用指针，以及获得指针的地址 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pointer　value,　dereferenced　pointer,　pointer　address:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line"><span class="comment">// 指针加法</span></span><br><span class="line">    ptr3　=　ptr1　+　<span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nadding　an　int　to　a　pointer:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 + 4 = %p, *(ptr1 + 4) = %d\n"</span>, ptr1 + <span class="number">4</span>, *(ptr1 + <span class="number">4</span>));</span><br><span class="line">ptr1++;　　　　　　　　　<span class="comment">// 递增指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nvalues　after　ptr1++:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">ptr2--;　　　　　　　　　<span class="comment">// 递减指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nvalues　after　--ptr2:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n"</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class="line">--ptr1;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line">++ptr2;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nPointers　reset　to　original　values:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1　=　%p,　ptr2　=　%p\n"</span>,　ptr1,　ptr2);</span><br><span class="line"><span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nsubtracting　one　pointer　from　another:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\n"</span>,　</span><br><span class="line">ptr2,　ptr1,　ptr2　-　ptr1);</span><br><span class="line"><span class="comment">// 一个指针减去一个整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nsubtracting　an　int　from　a　pointer:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr3　=　%p,　ptr3　-　2　=　%p\n"</span>,　ptr3,　ptr3　-　<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">pointer value, dereferenced pointer, pointer address:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, *ptr1 =<span class="number">100</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">adding an <span class="keyword">int</span> to a pointer:</span><br><span class="line">ptr1 + <span class="number">4</span> = <span class="number">0x7fff5fbff8e0</span>, *(ptr1 + <span class="number">4</span>) = <span class="number">500</span></span><br><span class="line">values after ptr1++:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d4</span>, *ptr1 =<span class="number">200</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">values after --ptr2:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d4</span>, *ptr2 = <span class="number">200</span>, &amp;ptr2 = <span class="number">0x7fff5fbff8c0</span></span><br><span class="line">Pointers reset to original values:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 = <span class="number">0x7fff5fbff8d8</span></span><br><span class="line">subtracting one pointer from another:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d8</span>, ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 - ptr1 = <span class="number">2</span></span><br><span class="line">subtracting an <span class="keyword">int</span> from a pointer:</span><br><span class="line">ptr3 = <span class="number">0x7fff5fbff8e0</span>, ptr3 - <span class="number">2</span> = <span class="number">0x7fff5fbff8d8</span></span><br></pre></td></tr></table></figure><ol><li>解引用：<em>运算符给出指针指向地址上储存的值。因此，</em>ptr1的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。</li><li>取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地址。因此&amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。</li><li>指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 +4与&amp;urn[4]等价。如果相加结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li><li>递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_14-14-32.png" alt="Snipaste_2019-02-22_14-14-32"></p><ol><li>指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2&amp;urn[2]等价，因为ptr3指向的是&amp;arn[4]。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li><li>递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。</li><li>指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出<br>一个值，或者导致运行时错误。</li><li>比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li></ol><h4 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h4><p><strong>函数原型中的形参的两种形式</strong></p><p>直接把变量相关的两类信息（类型及值）传递给函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function1(x);</span><br><span class="line"></span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure><p>把变量的地址传递给函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function2(&amp;x);</span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> * ptr)</span></span></span><br></pre></td></tr></table></figure><p><strong>一个把x,y值交换的例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap3.c -- 使用指针解决交换函数的问题 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Originally x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">interchange(&amp;x, &amp;y); <span class="comment">// 把地址发送给函数</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">temp = *u; <span class="comment">// temp获得 u 所指向对象的值</span></span><br><span class="line">*u = *v;</span><br><span class="line">*v = temp;</span><br><span class="line">    </span><br><span class="line">    输出：Originally x = <span class="number">5</span> <span class="keyword">and</span> y = <span class="number">10.</span></span><br><span class="line"> Now x = <span class="number">10</span> <span class="keyword">and</span> y = <span class="number">5.</span></span><br></pre></td></tr></table></figure><p>分析函数：interchange(&amp;x, &amp;y);</p><p>该函数的声明void interchange (int <em> u, int </em> v)，其u和v是指向整数的指针。因此该函数传递的不是x和y的值，而是它们的地址。</p><p>接下来，在函数体中声明了一个交换值时必需的临时变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br></pre></td></tr></table></figure><p>通过下面的语句把x的值储存在temp中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = *u;</span><br><span class="line"><span class="comment">//u的值是&amp;x，所以u指向x。即temp = *u=*(&amp;x)这意味着用*u即可表示x的值，</span></span><br><span class="line"><span class="comment">//&amp;运算符访问地址，u=&amp;x即获得下的地址</span></span><br><span class="line"><span class="comment">//*运算符获得地址上的值，*u=*（&amp;x）即获得（&amp;x）地址上的值，即x值。</span></span><br><span class="line"><span class="comment">//所以temp=x；</span></span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line">temp = u; <span class="comment">/* 不要这样做 */</span></span><br></pre></td></tr></table></figure><h4 id="变量：名称、地址和值关系"><a href="#变量：名称、地址和值关系" class="headerlink" title="变量：名称、地址和值关系"></a>变量：名称、地址和值关系</h4><p>变量的名称、地址和变量的值之间关系密切。</p><ul><li>编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。</li><li>在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。</li><li>简而言之，普通变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。</li></ul><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  x=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span>* p;</span><br><span class="line">        p=&amp;x;</span><br><span class="line">                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x的地址p=&amp;x=%p\n"</span>, p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p地址的值*p=*(&amp;x)=%d"</span>, *p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">x的地址p=&amp;x=<span class="number">0xbf89c298</span></span><br><span class="line">p地址的值*p=*(&amp;x)=<span class="number">100</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">&amp;符号为取址符，可以获得变量的地址</span></span><br><span class="line"><span class="comment">    *指针操作符：能存储和操作变量地址，称为指针变量。同时能够用来读取地址内的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组由数据类型相同的一系列元素组成。 要使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和这些元素的②类型。 编译器根据这些信息正确地创建数组。  </p><p>声明数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一些数组声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; fl</span><br><span class="line">oat candy[<span class="number">365</span>]; <span class="comment">/* 内含365个float类型元素的数组 */</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">12</span>]; <span class="comment">/*内含12个char类型元素的数组*/</span></span><br><span class="line"><span class="keyword">int</span> states[<span class="number">50</span>]; <span class="comment">/*内含50个int类型元素的数组 */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>数组通常被用来储存程序需要的同一类数据。 例如， 一个内含12个整数元素的数组可以储存12个月的天数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>,<span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br></pre></td></tr></table></figure><p>程序清单10.1演示了一个小程序， 打印每个月的天数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.1</span> day_mon1.c程序</span><br><span class="line"><span class="comment">/* day_mon1.c -- 打印每个月的天数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; MONTHS; index++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Month %2d has %2d days.\n"</span>, index + <span class="number">1</span>, days[index]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Month <span class="number">1</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">2</span> has <span class="number">28</span> days.</span><br><span class="line">Month <span class="number">3</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">4</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">5</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">6</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">7</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">8</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">9</span> has <span class="number">30</span> days.</span><br></pre></td></tr></table></figure><h4 id="使用const声明数组"><a href="#使用const声明数组" class="headerlink" title="使用const声明数组"></a>使用const声明数组</h4><p>有时需要把数组设置为只读。 这样， 程序只能从数组中检索值， 不能把新值写入数组。 要创建只读数组， 应该用const声明和初始化数组。  </p><p>因此，程序清单10.1中初始化数组应改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h4><p>指定初始化器（designated initializer） 。 利用该特性可以初始化指定的数组元素。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212</span><br></pre></td></tr></table></figure><h4 id="给数组元素赋值"><a href="#给数组元素赋值" class="headerlink" title="给数组元素赋值"></a>给数组元素赋值</h4><p>声明数组后， 可以借助数组下标（或索引） 给数组元素赋值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给数组的元素赋值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> counter, evens[SIZE];</span><br><span class="line"><span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; SIZE; counter++)</span><br><span class="line">evens[counter] = <span class="number">2</span> * counter;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码中使用循环给数组的元素依次赋值。</span></span><br></pre></td></tr></table></figure><p><strong>一些错误的数组赋值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">oxen[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 初始化没问题 */</span></span><br><span class="line"><span class="keyword">int</span> yaks[SIZE];</span><br><span class="line">yaks = oxen; <span class="comment">/* 不允许 */</span></span><br><span class="line">yaks[SIZE] = oxen[SIZE]; <span class="comment">/* 数组下标越界 ,下表为0~(SIZE-1)*/</span></span><br><span class="line"> yaks[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 不起作用 */</span></span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>例如要分析5年内每个月的降水量数据，要如何表示数据。  </p><ul><li><p>一个方案是创建60个变量， 每个变量储存一个数据项（我们曾经提到过这一笨拙的方案， 和以前一样， 这个方案并不合适） 。</p></li><li><p>二个方案是把各年的数据分开储存会更好， 即创建5个数组， 每个数组12个元素。  </p><p><strong>第二方案该如何实现</strong>？</p><p>处理这种情况应该使用数组的数组。 主数组（master array） 有5个元素（每个元素表示一年） ， 每个元素是内含12个元素的数组（每个元素表示一个月） 。 下面是该数组的声明： </p></li></ul><h4 id="声明二维数组"><a href="#声明二维数组" class="headerlink" title="声明二维数组"></a>声明二维数组</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> rain[<span class="number">5</span>][<span class="number">12</span>]; <span class="comment">// 内含5个数组元素的数组， 每个数组元素内含12个float类型的元素</span></span><br></pre></td></tr></table></figure><p>  <img src="D:\MyBlog\图片\Snipaste_2019-02-21_21-55-01.png" alt="Snipaste_2019-02-21_21-55-01"></p><h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p><strong>初始化的两种方式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_22-03-42.png" alt="Snipaste_2019-02-21_22-03-42"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12 <span class="comment">// 一年的月份数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YEARS 5 <span class="comment">// 年数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//</span></span><br><span class="line">用<span class="number">2010</span>～<span class="number">2014</span>年的降水量数据初始化数组</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> rain[YEARS][MONTHS] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">2.4</span>, <span class="number">3.5</span>, <span class="number">6.6</span> &#125;,</span><br><span class="line">&#123; <span class="number">8.5</span>, <span class="number">8.2</span>, <span class="number">1.2</span>, <span class="number">1.6</span>, <span class="number">2.4</span>, <span class="number">0.0</span>, <span class="number">5.2</span>, <span class="number">0.9</span>, <span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">1.4</span>, <span class="number">7.3</span> &#125;,</span><br><span class="line">&#123; <span class="number">9.1</span>, <span class="number">8.5</span>, <span class="number">6.7</span>, <span class="number">4.3</span>, <span class="number">2.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">6.1</span>, <span class="number">8.4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.2</span>, <span class="number">9.9</span>, <span class="number">8.4</span>, <span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">1.7</span>, <span class="number">4.3</span>, <span class="number">6.2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.6</span>, <span class="number">5.6</span>, <span class="number">3.8</span>, <span class="number">2.8</span>, <span class="number">3.8</span>, <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.3</span>, <span class="number">2.6</span>, <span class="number">5.2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。</p><p>例子：数组名是数组首元素的地址。如果flizny是一个数组，下面的语句成立：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br><span class="line"><span class="comment">//flizny 和&amp;flizny[0]都表示数组首元素的内存地址（&amp;是地址运算符）。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　4</span></span><br><span class="line"><span class="keyword">short</span>　dates[SIZE];</span><br><span class="line"><span class="keyword">short</span> * pti;</span><br><span class="line"><span class="keyword">short</span>　index;</span><br><span class="line">pti = dates;　<span class="comment">// 把数组地址赋给指针</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_13-26-02.png" alt="Snipaste_2019-02-22_13-26-02"></p><h3 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h3><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = sum(marbles); <span class="comment">// 可能的函数调用</span></span><br></pre></td></tr></table></figure><p>该函数的原型是什么？由于数组名marbless是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式<br>参数，即该形参是一个指向int的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span></span>; <span class="comment">// 对应的函数原型</span></span><br></pre></td></tr></table></figure><p>sum()从该参数获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。<br>我们有两种方法让函数获得元素个数这一信息。第一种方法是，在函数代码中写上固定的数组小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span> <span class="comment">// 相应的函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)　　<span class="comment">// 假设数组有10个元素</span></span><br><span class="line">total += ar[i];　　　　<span class="comment">// ar[i] 与 *(ar + i) 相同</span></span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个比较灵活的方法是把数组大小作为第2个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar, <span class="keyword">int</span> n)</span>　　　 <span class="comment">// 更通用的方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)　　 <span class="comment">// 使用 n 个元素</span></span><br><span class="line">total += ar[i];　　　　<span class="comment">// ar[i] 和 *(ar + i) 相同</span></span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数要处理数组必须知道何时开始、何时结束。上面的sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）</p><p>还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　marbles[SIZE]　=　&#123;　<span class="number">20</span>,　<span class="number">10</span>,　<span class="number">5</span>,　<span class="number">39</span>,　<span class="number">4</span>,　<span class="number">16</span>,　<span class="number">19</span>,　<span class="number">26</span>,　</span><br><span class="line"><span class="number">31</span>,　<span class="number">20</span>　&#125;;</span><br><span class="line"><span class="keyword">long</span>　answer;</span><br><span class="line">answer　=　sump(marbles,　marbles　+　SIZE);<span class="comment">//marble为数组的首位，而marble+SIZE则为数组结束位置</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The　total　number　of　marbles　is　%ld.\n"</span>,　answer);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>　(start　&lt;　end)</span><br><span class="line">&#123;</span><br><span class="line">total += *start;　 <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">start++;　　　　　　<span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。</p><h3 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a>保护数组中的数据</h3><p>编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。(直接传递数值时使用的是原始数据的副本，不会意外修改原始数据。但是传递数值的指针的话使用原始数据，因此这样的函数可能修改原数组。)</p><p>如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p><p>处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的，但是要注意保护数组中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>　<span class="title">add_to</span><span class="params">(<span class="keyword">double</span>　ar[],　<span class="keyword">int</span>　n,　<span class="keyword">double</span>　val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">for</span>　(i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">ar[i]　+=　val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因此，调用该函数后，prices数组中的每个元素的值都增加了2.5：</span></span><br><span class="line">add_to(prices, <span class="number">100</span>, <span class="number">2.50</span>);</span><br><span class="line"><span class="comment">//该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。</span></span><br></pre></td></tr></table></figure><h4 id="对形式参数使用const"><a href="#对形式参数使用const" class="headerlink" title="对形式参数使用const"></a>对形式参数使用const</h4><p>为了避免修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span> <span class="comment">/* 函数定义 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(　i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">total　+=　ar[i];</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const的其他内容"><a href="#const的其他内容" class="headerlink" title="const的其他内容"></a>const的其他内容</h4><p>使用const创建过变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加<br>灵活。可以创建const数组、const指针和指向const的指针。</p><p>如何使用const关键字保护数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.const数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MONTHS　12</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">days[<span class="number">9</span>] = <span class="number">44</span>;　　 <span class="comment">/* 编译错误 ,程序无法改变数组元素的值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//coon身体指针</span></span><br><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pd = rates;　　 <span class="comment">// pd指向数组的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：</span></span><br><span class="line">*pd = <span class="number">29.89</span>;　　　<span class="comment">// 不允许</span></span><br><span class="line">pd[<span class="number">2</span>] = <span class="number">222.22</span>;　　<span class="comment">//不允许</span></span><br><span class="line">rates[<span class="number">0</span>] = <span class="number">99.99</span>; <span class="comment">// 允许，因为rates未被const限定</span></span><br></pre></td></tr></table></figure><h2 id="第三节：结构体和其他数据形式"><a href="#第三节：结构体和其他数据形式" class="headerlink" title="第三节：结构体和其他数据形式"></a>第三节：结构体和其他数据形式</h2><p>本章介绍以下内容：</p><p>关键字：</p><p> struct、 union、 typedef</p><p>运算符： .、 -&gt;</p><p>什么是C结构， 如何创建结构模板和结构变量</p><p>如何访问结构的成员， 如何编写处理结构的函数</p><p>联合和指向函数的指针 </p><p>设计程序时， 最重要的步骤之一是选择表示数据的方法。 在许多情况下， 简单变量甚至是数组还不够。 为此， C提供了结构变量（structure variable） 提高你表示数据的能力， 它能让你创造新的形式。  </p><h3 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h3><h4 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h4><p>定义：结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p><p>结构声明（structure declaration） 描述了一个结构的组织布局。 声明类似下面这样：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> book &#123;</span><br><span class="line"><span class="built_in">char</span> title[MAXTITL];</span><br><span class="line"><span class="built_in">char</span> author[MAXAUTL];</span><br><span class="line"><span class="built_in">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>该声明描述了一个由两个字符数组和一个float类型变量组成的结构。 该声明并未创建实际的数据对象， 只描述了该对象由什么组成。 〔 有时， 我们把结构声明称为模板， 因为它勾勒出结构是如何储存数据的。 〕</em>  </p><h4 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h4><p>结构体有两层含义。 一层含义是“结构布局”，  结构布局告诉编译器如何表示数据， 但是它并未让编译器为数据分配空间。 下一步是创建一个结构变量， 即是结构的另一层含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span> <span class="comment">//声明结构体变脸。</span></span><br><span class="line"><span class="comment">//这把library声明为一个使用book结构布局的结构体变量。 </span></span><br><span class="line"><span class="comment">//注：关键字 struct， 它表明跟在其后的是一个结构， 后面是一个可选的标记（该例中是 book）</span></span><br></pre></td></tr></table></figure><p> <em>编译器执行这行代码便创建了一个结构变量library。 编译器使用book模板为该变量分配空间： 一个内含MAXTITL个元素的char数组、 一个内含MAXAUTL个元素的char数组和一个float类型的变量。</em> 这些存储空间都与一个名称library结合在一起（见图14.1） </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_15-26-55.png" alt="Snipaste_2019-02-26_15-26-55"></p><p>在结构变量的声明中， struct book所起的作用相当于一般声明中的int或float。 例如， 可以定义两个struct book类型的变量， 或者甚至是指向structbook类型结构的指针： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">doyle</span>, <span class="title">panshin</span>, * <span class="title">ptbook</span>;</span></span><br></pre></td></tr></table></figure><p>结构变量doyle和panshin中都包含title、 author和value部分。 指针ptbook 可以指向doyle、 panshin或任何其他book类型的结构变量。 从本质上看，book结构声明创建了一个名为struct book的新类型。 </p><h4 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h4><p>初始化一个结构变量与初始化数组的语法类似： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line"><span class="string">"The Pious Pirate and the Devious Damsel"</span>,</span><br><span class="line"><span class="string">"Renee Vivotte"</span>,</span><br><span class="line"><span class="number">1.95</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结构体的初始化器"><a href="#结构体的初始化器" class="headerlink" title="结构体的初始化器"></a>结构体的初始化器</h4><p>C99和C11为结构提供了指定初始化器（designated initializer） [1]， 其语<br>法与数组的指定初始化器类似。 但是， 结构的指定初始化器使用点运算符和<br>成员名（而不是方括号和下标） 标识特定的元素 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只初始化book结构 的value成员， 可以这样做：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">surprise</span> = &#123;</span> .value = <span class="number">10.99</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可以按照任意顺序使用指定初始化器：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span> = &#123;</span> .value = <span class="number">25.99</span>,</span><br><span class="line"> .author = <span class="string">"James Broadfool"</span>,</span><br><span class="line"> .title = <span class="string">"Rue for the Toad"</span>,</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h4 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h4><p>使用结构成员运算符——点（.） 访问结构中的成员。  </p><p>例如， library.value即访问library的value部分。 可以像使用任何float类型变量那样使用library.value。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_gets(library.title, MAXTITL);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;library.value);</span><br></pre></td></tr></table></figure><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>上面结构体只能处理一本书，程序如何扩展成可以处理多本书。 </p><p>显然，每本书的基本信息都可以用一个 book 类型的结构变量来表示。 为描述两本书， 需要使用两个变量， 以此类推。 可以使用这一类型的结构数组来处理多本书。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBKS 100 <span class="comment">/* 书籍的最大数量 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> <span class="comment">/* 简历 book 模板 */</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">/* book 类型结构的数组 */</span></span><br></pre></td></tr></table></figure><h4 id="声明结构数组"><a href="#声明结构数组" class="headerlink" title="声明结构数组"></a>声明结构数组</h4><p>声明结构数组和声明其他类型的数组类似。 下面是一个声明结构数组的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct book library[MAXBKS];</span><br></pre></td></tr></table></figure><p>以上代码把library声明为一个内含MAXBKS个元素的数组。 数组的每个元素都是一个book类型的数组。 因此， library[0]是第1个book类型的结构变量， library[1]是第2个book类型的结构变量， 以此类推。  参看图14.2 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_20-50-51.png" alt="Snipaste_2019-02-26_20-50-51"></p><p><em>注：其实存储形式有点像而为数组</em></p><h4 id="标识结构数组的成员"><a href="#标识结构数组的成员" class="headerlink" title="标识结构数组的成员"></a>标识结构数组的成员</h4><p>为了标识结构数组中的成员， 可以采用访问单独结构的规则： 在结构名后面加一个点运算符， 再在点运算符后面写上成员名。 如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">0</span>].value <span class="comment">/* 第1个数组元素与value 相关联 */</span></span><br><span class="line">library[<span class="number">4</span>].title <span class="comment">/* 第5个数组元素与title 相关联 */</span></span><br></pre></td></tr></table></figure><p><em>注：其实和上面的结构体一样，只是多了下标来识别结构体数组中的第几个。</em></p><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>即在一个结构中包含另一个结构（即嵌套结构） 。 </p><p>例如，Shalala Pirosky创建了一个有关她朋友信息的结构。 显然， 结构中需要一个成员表示朋友的姓名。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.3</span> <span class="keyword">friend</span>.c程序</span><br><span class="line"><span class="comment">// friend.c -- 嵌套结构示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * msgs[<span class="number">5</span>] =</span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">"Thank you for the wonderful evening, "</span>,</span><br><span class="line"><span class="string">"You certainly prove that a "</span>,</span><br><span class="line"><span class="string">"is a special kind of guy.We must get together"</span>,</span><br><span class="line"><span class="string">"over a delicious "</span>,</span><br><span class="line"><span class="string">" and have a few laughs"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span> <span class="comment">// 第1个结构</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span> <span class="comment">// 第2个结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span> <span class="comment">// 嵌套结构</span></span><br><span class="line"><span class="keyword">char</span> favfood[LEN];</span><br><span class="line"><span class="keyword">char</span> job[LEN];</span><br><span class="line"><span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span> = &#123;</span> <span class="comment">// 初始化一个结构变量</span></span><br><span class="line">&#123; <span class="string">"Ewen"</span>, <span class="string">"Villard"</span> &#125;,</span><br><span class="line"><span class="string">"grilled salmon"</span>,</span><br><span class="line"><span class="string">"personality coach"</span>,</span><br><span class="line"><span class="number">68112.00</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Dear %s, \n\n"</span>, fellow.handle.first);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s.\n"</span>, msgs[<span class="number">0</span>], fellow.handle.first);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s\n"</span>, msgs[<span class="number">1</span>], fellow.job);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msgs[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s%s"</span>, msgs[<span class="number">3</span>], fellow.favfood, msgs[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">if</span> (fellow.income &gt; <span class="number">150000.0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"!!"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fellow.income &gt; <span class="number">75000.0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"!"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"See you soon,"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"Shalala"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的输出：</span></span><br><span class="line"><span class="comment">Dear Ewen,</span></span><br><span class="line"><span class="comment">Thank you for the wonderful evening, Ewen.</span></span><br><span class="line"><span class="comment">You certainly prove that a personality coach</span></span><br><span class="line"><span class="comment">is a special kind of guy.We must get together</span></span><br><span class="line"><span class="comment">over a delicious grilled salmon and have a few laughs.</span></span><br><span class="line"><span class="comment">See you soon,</span></span><br><span class="line"><span class="comment">Shalala </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>为什么喜欢使用指向结构的指针。</p><ul><li><p>第一， 就像指向数组的指针比数组本身更容易操控（如， 排序问题） 一样， 指向结构的指针通常比结构本身更容易操控。</p></li><li><p>第二， 在一些早期的C实现中， 结构不能作为参数传递给函数， 但是可以传递指向结构的指针。 </p></li><li><p>第三， 即使能传递一个结构， 传递指针通常更有效率。 </p></li><li><p>第四， 一些用于表示数据的结构中包含指向其他结构的指针。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.4</span> friends.c程序</span><br><span class="line"><span class="comment">/* friends.c -- 使用指向结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">char</span> favfood[LEN];</span><br><span class="line"><span class="keyword">char</span> job[LEN];</span><br><span class="line"><span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2] =</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123; <span class="string">"Ewen"</span>, <span class="string">"Villard"</span> &#125;,</span><br><span class="line"><span class="string">"grilled salmon"</span>,</span><br><span class="line"><span class="string">"personality coach"</span>,</span><br><span class="line"><span class="number">68112.00</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        &#123; <span class="string">"Rodney"</span>, <span class="string">"Swillbelly"</span> &#125;,</span><br><span class="line"><span class="string">"tripe"</span>,</span><br><span class="line"><span class="string">"tabloid editor"</span>,</span><br><span class="line"><span class="number">432400.00</span></span><br><span class="line">&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span> <span class="comment">/* 定义一个指向结构的指针 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address #1: %p #2: %p\n"</span>, &amp;fellow[<span class="number">0</span>], &amp;fellow[<span class="number">1</span>]);</span><br><span class="line">him = &amp;fellow[<span class="number">0</span>]; <span class="comment">/* 告诉编译器该指针指向何处 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pointer #1: %p #2: %p\n"</span>, him, him + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"him-&gt;income is $%.2f: (*him).income is $%.2f\n"</span>,him-&gt;income,(*him).income);</span><br><span class="line">him++; <span class="comment">/* 指向下一个结构 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"him-&gt;favfood is %s: him-&gt;handle.last is %s\n"</span>,him-&gt;favfood, him-&gt;handle.last);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出如下：</span></span><br><span class="line"><span class="comment">address #1: 0x7fff5fbff820 #2: 0x7fff5fbff874</span></span><br><span class="line"><span class="comment">pointer #1: 0x7fff5fbff820 #2: 0x7fff5fbff874</span></span><br><span class="line"><span class="comment">him-&gt;income is $68112.00: (*him).income is $68112.00</span></span><br><span class="line"><span class="comment">him-&gt;favfood is tripe: him-&gt;handle.last is Swillbelly</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="声明和初始化结构指针"><a href="#声明和初始化结构指针" class="headerlink" title="声明和初始化结构指针"></a>声明和初始化结构指针</h4><p>声明结构指针很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span>  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><p>首先是关键字 struct， 其次是结构标记 guy， 然后是一个星号（*） ， 其后跟着指针名。 这个语法和其他指针声明一样 。</p><p>该声明并未创建一个新的结构， 但是指针him现在可以指向任意现有的guy类型的结构。</p><p> 例如，对于结构体：如果barney是一个guy类型的结构， 可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney; <span class="comment">//初始化jie，</span></span><br></pre></td></tr></table></figure><p>在本例中， 对于结构体数组：fellow 是一个结构数组， 这意味着 fellow[0]是一个结构。 所以， 要让 him 指向fellow[0]， 可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;fellow[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="用指针访问成员"><a href="#用指针访问成员" class="headerlink" title="用指针访问成员"></a>用指针访问成员</h4><p>指针him指向结构变量fellow[0]， 如何通过him获得fellow[0]的成员的值？ </p><p>第1种方法也是最常用的方法： 使用-&gt;运算符。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<em>这里要着重理解him是一个指针， 但是hime-&gt;income是该指针所指向结构的一个成员。 所以在该例中， him-&gt;income是一个float类型的变量。</em> </p><p>第2种方法是， 以这样的顺序指定结构成员的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 总结：如果him是指向guy类型结构barney的指针， 下面的关系恒成立： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：barney.income == (*him).income == him-&gt;income <span class="comment">// 假设 him == &amp;barney</span></span><br></pre></td></tr></table></figure><h3 id="向函数传递结构的信息"><a href="#向函数传递结构的信息" class="headerlink" title="向函数传递结构的信息"></a>向函数传递结构的信息</h3><p>函数的参数把值传递给函数。 每个值都是一个数字——可能是int类型、float类型， 可能是ASCII字符码， 或者是一个地址。 </p><p>那么C时如何把结构体作为参数使用？</p><p>程序员可以选择是①传递结构本身， 还是②传递指向结构的指针。 如果你只关心结构中的某一部分， 也可以把③结构的成员作为参数。</p><h4 id="传递结构成员"><a href="#传递结构成员" class="headerlink" title="传递结构成员"></a>传递结构成员</h4><p>只知要结构成员是一个具有单个值的数据类型（即， int及其相关类型、char、 float、 double或指针） ， 便可把它作为参数传递给接受该特定类型的函数。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.5</span> funds1.c程序</span><br><span class="line"><span class="comment">/* funds1.c -- 把结构成员作为参数传递 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line"><span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line"><span class="number">4032.27</span>,</span><br><span class="line"><span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line"><span class="number">8543.94</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n</span></span><br><span class="line"><span class="string">sum(stan.bankfund, stan.savefund))</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 两个double类型的数相加 */</span></span><br><span class="line"><span class="string">double sum(double x, double y)</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">    return(x + y);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">运行该程序后输出如下：</span></span><br><span class="line"><span class="string">Stan has a total of $12576.21.</span></span><br></pre></td></tr></table></figure><h4 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h4><p>次把结构的地址作为参数。于函数要处理funds结构， 所以必须声明funds结构。  传递结构本身</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.6</span> funds2.c程序</span><br><span class="line"><span class="comment">/* funds2.c -- 传递指向结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>; <span class="comment">/* 参数是一个指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line"><span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line"><span class="number">4032.27</span>,</span><br><span class="line"><span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line"><span class="number">8543.94</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(&amp;stan));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>(money-&gt;bankfund + money-&gt;savefund);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行该程序后输出如下：</span></span><br><span class="line"><span class="comment">Stan has a total of $12576.21</span></span><br></pre></td></tr></table></figure><h4 id="传递结构本身"><a href="#传递结构本身" class="headerlink" title="传递结构本身"></a>传递结构本身</h4><p>对于允许把结构作为参数的编译器， 可以把程序清单14.6重写为程序清单14.7。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.7</span> funds3.c程序</span><br><span class="line"><span class="comment">/* funds3.c -- 传递一个结构 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span>; <span class="comment">/* 参数是一个结构 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line"><span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line"><span class="number">4032.27</span>,</span><br><span class="line"><span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line"><span class="number">8543.94</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(stan));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span>(moolah.bankfund + moolah.savefund);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是运行该程序后的输出：</span></span><br><span class="line"><span class="comment">Stan has a total of $12576.21.</span></span><br></pre></td></tr></table></figure><h4 id="结构和结构指针的选择"><a href="#结构和结构指针的选择" class="headerlink" title="结构和结构指针的选择"></a>结构和结构指针的选择</h4><p>假设要编写一个与结构相关的函数， 是用结构指针作为参数， 还是用结构作为参数和返回值？ 两者各有优缺点。</p><ul><li><p>把指针作为参数有两个优点： 无论是以前还是现在的C实现都能使用这种方法， 而且执行起来很快， 只需要传递一个地址。 缺点是无法保护数据。不过， ANSI C新增的const限定符解决了这个问题。</p></li><li><p>把结构作为参数传递的优点是， 函数处理的是原始数据的副本， 这保护了原始数据。 另外， 代码风格也更清楚。</p></li><li><p>传递结构的两个缺点是： 较老版本的实现可能无法处理这样的代码， 而且传递结构浪费时间和存储空间。 尤其是把大型结构传递给函数， 而它只使用结构中的一两个成员时特别浪费。 这种情况下传递指针或只传递函数所需的成员更合 </p><p>假设定义了下面的结构类型：struct vector {double x; double y;}; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"><span class="function">struct <span class="built_in">vector</span> <span class="title">sum_vect</span><span class="params">(struct <span class="built_in">vector</span>, struct <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">ans = sum_vect(a,b);</span><br><span class="line">对程序员而言， 上面的版本比用指针传递的版本更自然。 指针版本如</span><br><span class="line">下：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_vect</span><span class="params">(<span class="keyword">const</span> struct <span class="built_in">vector</span> *, <span class="keyword">const</span> struct <span class="built_in">vector</span> *, struct <span class="built_in">vector</span> *)</span></span>;</span><br><span class="line">...</span><br><span class="line">sum_vect(&amp;a, &amp;b, &amp;ans);</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体的其他结构特性"><a href="#结构体的其他结构特性" class="headerlink" title="结构体的其他结构特性"></a>结构体的其他结构特性</h3><p>1.许把一个结构赋值给另一个结构， 但是数组不能这样做。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果n_data和o_data都是相同类型的结构， 可以这样做： </span></span><br><span class="line">o_data = n_data; <span class="comment">// 把一个结构赋值给另一个结构</span></span><br><span class="line"><span class="comment">//这条语句把n_data的每个成员的值都赋给o_data的相应成员。 即使成员是数组， 也能完成赋值。</span></span><br></pre></td></tr></table></figure><p>2.还可以构初始化为相同类型的另一个结构 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> = &#123;</span><span class="string">"Ruthie"</span>, <span class="string">"George"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> = <span class="title">right_field</span>;</span> <span class="comment">// 把一个结构初始化为另一个结构</span></span><br></pre></td></tr></table></figure><p>3.函数不仅能把结构本身作为参数传递， 还能把结构作为返回值返回。 把结构作为函数参数可以把结构的信息传送给函数； 把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。 结构指针也允许这种双向通信。</p><h3 id="结构体中的字符数组和字符指针"><a href="#结构体中的字符数组和字符指针" class="headerlink" title="结构体中的字符数组和字符指针"></a>结构体中的字符数组和字符指针</h3><p>到目前为止， 我们在结构中都使用字符数组来储存字符串。 是否可以使用指向 char 的指针来代替字符数组？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.结构体中的字符数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.其中的结构声明也可以这样写：结构体中的字符指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * first;</span><br><span class="line"><span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> = &#123;</span><span class="string">"Talia"</span>, <span class="string">"Summers"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> = &#123;</span><span class="string">"Brad"</span>, <span class="string">"Fallingjaw"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s and %s\n"</span>, veep.first, treas.first);</span><br></pre></td></tr></table></figure><ul><li><p>对于struct names类型的结构变量veep， 以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。 </p></li><li><p>对于struct pnames类型的结构变量treas， 以上字符串储存在编译器储存常量的地方。</p></li><li><p>struct pnames结构不用为字符串分配任何存储空间（结构本身只储存了两个地址， 在我们的系统中共占16字节。 ）。 它使用的是储存在别处的字符串（如， 字符串常量或数组中的字符串） 。 简而言之， 在pnames结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。   </p></li></ul><p>（即字符指针 不会自动分配空间，需要在使用前初始化。如果使能赋值的话可能会占用到有效的代码段，如下面所示）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your accountant:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your attorney:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, attorney.last); <span class="comment">/* 这里有一个潜在的危险 */</span></span><br></pre></td></tr></table></figure><ul><li><p>对于会计师（accountant） ， 他的名储存在accountant结构变量的last成员中， 该结构中有一个储存字符串的数组。</p></li><li><p>对于律师（attorney） ， scanf()把字符串放到attorney.last表示的地址上。 由于这是未经初始化的变量， 地址可以是任何值， 因此程序可以把名放在任何地方。 如果走运的话， 程序不会出问题， 至少暂时不会出问题， 否则这一操作会导致程序崩溃。  </p></li></ul><h3 id="结构、-指针和malloc"><a href="#结构、-指针和malloc" class="headerlink" title="结构、 指针和malloc()"></a>结构、 指针和malloc()</h3><p>对于上面的问题，如果使用malloc()分配内存并使用指针储存该地址， 那么在结构中使用指针处理字符串就比较合理。 这种方法的优点是， 可以请求malloc()为字符串分配合适的存储空间。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * fname; <span class="comment">// 用指针代替数组</span></span><br><span class="line"><span class="keyword">char</span> * lname;</span><br><span class="line"><span class="keyword">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinfo</span> <span class="params">(struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har temp[SLEN];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter your first name.\n"</span>);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line"><span class="comment">// 分配内存储存名</span></span><br><span class="line">pst-&gt;fname = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 把名拷贝到已分配的内存</span></span><br><span class="line"><span class="built_in">strcpy</span>(pst-&gt;fname, temp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter your last name.\n"</span>);</span><br><span class="line">s_gets(temp, SLEN);</span><br></pre></td></tr></table></figure><p>要理解这两个字符串都未储存在结构中， 它们储存在 malloc()分配的内<br>存块中。 然而， 结构中储存着这两个字符串的地址， 处理字符串的函数通常<br>都要使用字符串的地址。  </p><p>下面就是一个使用字符指针的结构体对字符串处理的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">程序清单14.10 names3.c程序</span><br><span class="line">// names3.c -- 使用指针和 malloc()</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; // 提供 strcpy()、 strlen() 的原型</span><br><span class="line">#include &lt;stdlib.h&gt; // 提供 malloc()、 free() 的原型</span><br><span class="line">#define SLEN 81</span><br><span class="line"></span><br><span class="line">struct namect &#123;</span><br><span class="line">char * fname; // 使用指针</span><br><span class="line">char * lname;</span><br><span class="line">int letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void getinfo(struct namect *); // 分配内存</span><br><span class="line">void makeinfo(struct namect *);</span><br><span class="line">void showinfo(const struct namect *);</span><br><span class="line">void cleanup(struct namect *); // 调用该函数时释放内存</span><br><span class="line">char * s_gets(char * st, int n);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123; </span><br><span class="line">    struct namect person;</span><br><span class="line">getinfo(&amp;person);</span><br><span class="line">makeinfo(&amp;person);</span><br><span class="line">showinfo(&amp;person);</span><br><span class="line">cleanup(&amp;person);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getinfo(struct namect * pst)</span><br><span class="line">&#123; </span><br><span class="line">    char temp[SLEN];</span><br><span class="line">printf(&quot;Please enter your first name.\n&quot;);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line"></span><br><span class="line">    // 分配内存以储存名</span><br><span class="line">pst-&gt;fname = (char *) malloc(strlen(temp) + 1);</span><br><span class="line"></span><br><span class="line">    // 把名拷贝到动态分配的内存中</span><br><span class="line">strcpy(pst-&gt;fname, temp);</span><br><span class="line">printf(&quot;Please enter your last name.\n&quot;);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line">pst-&gt;lname = (char *) malloc(strlen(temp) + 1);</span><br><span class="line">strcpy(pst-&gt;lname, temp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void makeinfo(struct namect * pst)</span><br><span class="line">&#123;</span><br><span class="line">    pst-&gt;letters = strlen(pst-&gt;fname) +strlen(pst-&gt;lname);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void showinfo(const struct namect * pst)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s %s, your name contains %d letters.\n&quot;, pst-&gt;fname, pst-&gt;lname, pst-&gt;letters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cleanup(struct namect * pst)</span><br><span class="line">&#123; </span><br><span class="line">    free(pst-&gt;fname);</span><br><span class="line">free(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * s_gets(char * st, int n)</span><br><span class="line">&#123; </span><br><span class="line">    char * ret_val;</span><br><span class="line">char * find;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">        find = strchr(st, &apos;\n&apos;); // 查找换行符</span><br><span class="line">if (find) // 如果地址不是 NULL，</span><br><span class="line">*find = &apos;\0&apos;; // 在此处放置一个空字符</span><br><span class="line">else</span><br><span class="line">while (getchar() != &apos;\n&apos;)</span><br><span class="line">continue; // 处理输入行的剩余部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return ret_val;</span><br><span class="line">&#125; </span><br><span class="line">/*</span><br><span class="line">下面是该程序的输出：</span><br><span class="line">Please enter your first name.</span><br><span class="line">Floresiensis</span><br><span class="line">Please enter your last name.</span><br><span class="line">Mann</span><br><span class="line">Floresiensis Mann, your name contains 16 letters.</span><br></pre></td></tr></table></figure><h3 id="使用结构数组的函数"><a href="#使用结构数组的函数" class="headerlink" title="使用结构数组的函数"></a>使用结构数组的函数</h3><p>假设一个函数要处理一个结构数组。 由于数组名就是该数组的地址， 所以可以把它传递给函数。 </p><p>程序清单14.13把前面的金融程序扩展为两人， 所以需要一个内含两个funds结构的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.13</span> funds4.c程序</span><br><span class="line"><span class="comment">/* funds4.c -- 把结构数组传递给函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money [], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">jones</span>[<span class="title">N</span>] = &#123;</span></span><br><span class="line">&#123; <span class="string">"Garlic-Melon Bank"</span>, <span class="number">4032.27</span>, <span class="string">"Lucky's Savings and Loan"</span>, <span class="number">8543.94</span>&#125;,</span><br><span class="line">&#123; <span class="string">"Honest Jack's Bank"</span>, <span class="number">3620.88</span>, <span class="string">"Party Time Savings"</span>, <span class="number">3802.91</span>&#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The Joneses have a total of $%.2f.\n"</span>,sum(jones, N));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money [], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">double</span> total;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">total += money[i].bankfund + money[i].savefund;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(total);</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">The Joneses have a total of $<span class="number">20000.00</span>.</span><br></pre></td></tr></table></figure><h3 id="把结构内容保存到文件中"><a href="#把结构内容保存到文件中" class="headerlink" title="把结构内容保存到文件中"></a>把结构内容保存到文件中</h3><p>由于结构可以储存不同类型的信息， 所以它是构建数据库的重要工具。例如， 可以用一个结构储存雇员或汽车零件的相关信息。 最终， 我们要把这些信息储存在文件中， 并且能再次检索。  </p><p>数据库文件可以包含任意数量的此类数据对象。 储存在一个结构中的整套信息被称为记录（record） ， 单独的项被称为字段（field） 。</p><p>例如， 回忆程序book结构： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果pbook标识一个文件流， 那么通过下面这条语句可以把信息储存在struct book类型的结构变量primer中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(pbooks, <span class="string">"%s %s %.2f\n"</span>, primer.title,primer.author, primer.value);</span><br></pre></td></tr></table></figure><p><strong>保存结构的程序示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.14</span> booksave.c程序</span><br><span class="line"><span class="comment">/* booksave.c -- 在文件中保存结构中的内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBKS 10 <span class="comment">/* 最大书籍数量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> <span class="comment">/* 建立 book 模板 */</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">/* 结构数组 */</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index, filecount;</span><br><span class="line">FILE * pbooks;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct book);</span><br><span class="line"><span class="keyword">if</span> ((pbooks = fopen(<span class="string">"book.dat"</span>, <span class="string">"a+b"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line">       <span class="built_in">fputs</span>(<span class="string">"Can't open book.dat file\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">    rewind(pbooks); <span class="comment">/* 定位到文件开始 */</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; MAXBKS &amp;&amp; fread(&amp;library[count], size,<span class="number">1</span>, pbooks) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Current contents of book.dat:"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s by %s: $%.2f\n"</span>, library[count].title,</span><br><span class="line">library[count].author, library[count].value);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">    filecount = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == MAXBKS)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"The book.dat file is full."</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Please add new book titles."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Press [enter] at the start of a line to stop."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; MAXBKS &amp;&amp; s_gets(library[count].title, MAXTITL) !=<span class="literal">NULL</span>&amp;&amp; library[count].title[<span class="number">0</span>] != <span class="string">'\0'</span>)</span><br><span class="line">&#123; </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Now enter the author."</span>);</span><br><span class="line">s_gets(library[count].author, MAXAUTL);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Now enter the value."</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;library[count++].value);</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* 清理输入行 */</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; MAXBKS)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the next title."</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Here is the list of your books:"</span>);</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; count; index++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s by %s: $%.2f\n"</span>, library[index].title,</span><br><span class="line">library[index].author, library[index].value);</span><br><span class="line">fwrite(&amp;library[filecount], size, count - filecount,pbooks);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"No books? Too bad.\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Bye.\n"</span>);</span><br><span class="line">fclose(pbooks);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">char</span> * find;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">        find = <span class="built_in">strchr</span>(st, <span class="string">'\n'</span>); <span class="comment">// 查找换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (find) <span class="comment">// 如果地址不是 NULL，</span></span><br><span class="line">*find = <span class="string">'\0'</span>; <span class="comment">// 在此处放置一个空字符 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 清理输入行</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们先看几个运行示例， 然后再讨论程序中的要点。</span></span><br><span class="line"><span class="comment">$ booksave</span></span><br><span class="line"><span class="comment">Please add new book titles.</span></span><br><span class="line"><span class="comment">Press [enter] at the start of a line to stop.</span></span><br><span class="line"><span class="comment">Metric Merriment</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Polly Poetica</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">18.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">Deadly Farce</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Dudley Forse</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">15.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">[enter]</span></span><br><span class="line"><span class="comment">Here is the list of your books:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">Bye.</span></span><br><span class="line"><span class="comment">$ booksave</span></span><br><span class="line"><span class="comment">Current contents of book.dat:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">Please add new book titles.</span></span><br><span class="line"><span class="comment">The Third Jar</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Nellie Nostrum</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">22.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">[enter]</span></span><br><span class="line"><span class="comment">Here is the list of your books:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">The Third Jar by Nellie Nostrum: $22.99</span></span><br><span class="line"><span class="comment">Bye.</span></span><br><span class="line"><span class="comment">$</span></span><br><span class="line"><span class="comment">再次运行booksave.c程序把这3本书作为当前的文件记录打印出来。</span></span><br></pre></td></tr></table></figure><h1 id="第二章：输入与输出"><a href="#第二章：输入与输出" class="headerlink" title="第二章：输入与输出"></a>第二章：输入与输出</h1><h2 id="第一节：单字符输入-输出"><a href="#第一节：单字符输入-输出" class="headerlink" title="第一节：单字符输入/输出"></a>第一节：单字符输入/输出</h2><ol><li>介绍输入、 输出以及缓冲输入和无缓冲输入的区别 </li><li>如何使用重定向把程序和文件相连接</li><li>介绍如何设计与用户交互的界面 </li><li>创建更友好的用户界面 </li><li>演示一些与输入验证相关的问题和解决方案。 </li></ol><p>I/O函数（如printf()、 scanf()、 getchar()、 putchar()等） 负责把信息传送到程序中。  </p><h3 id="单字符I-O：getchar-和putchar"><a href="#单字符I-O：getchar-和putchar" class="headerlink" title="单字符I/O：getchar()和putchar()"></a>单字符I/O：getchar()和putchar()</h3><p>getchar()和 putchar()每次只处理一个字符。 </p><p>程序清单8.1。该程序获取从键盘输入的字符， 并把这些字符发送到屏幕上。 程序使用while 循环， 当读到#字符时停止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">8.1</span> echo.c程序</span><br><span class="line"><span class="comment">/* echo.c -- 重复输入 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'#'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户的交互如下：    </p><p><strong>Hello, there. I would[enter]</strong></p><p>Hello, there. I would</p><p><strong>like a #3 bag of potatoes.[enter]</strong></p><p>like a</p><p>例子中 “#” 作为结束输入， 就无法在文本中使用这个字符， 是否有更好的方法结束输入？， 是否有更好的方法结束输入？  要回答这些问题， 首先要了解 C程序如何处理键盘输入， 尤其是缓冲和标准输入文件的概念。 </p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>在老式系统运行程序清单8.1， 可能显示如下：</p><p>HHeelllloo,, tthheerree..II wwoouulldd[enter]</p><p>lliikkee aa #</p><p> 像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接） 输入， 即正在等待的程序可立即使用输入的字符。</p><p>大部分系统在用户按下Enter键之前不会重复打印刚输入的字符， 这种输入形式属于缓冲输入。 用户输入的字符被收集并储存在一个被称为缓冲区（buffer） 的临时存储区， 按下Enter键后， 程序才可使用用户输入的字符。 图8.1比较了这两种输入。 <img src="D:\MyBlog\图片\Snipaste_2019-02-21_09-53-53.png" alt="Snipaste_2019-02-21_09-53-53"></p><p><strong>为什么要有缓冲区？</strong></p><ul><li>把若干字符作为一个块进行传输比逐个发送这些字符节约时间</li><li>如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时， 传输的是正确的输入。</li></ul><p>虽然缓冲输入好处很多， 但是某些交互式程序也需要无缓冲输入。 例如， 在游戏中， 你希望按下一个键就执行相应的指令。 因此， 缓冲输入和无缓冲输入都有用武之地。 </p><p><strong>缓冲分为两类： 完全缓冲I/O和行缓冲I/O。</strong> </p><ul><li>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地） ， 通常出现在文件输入中。 缓冲区的大小取决于系统， 常见的大小是 512 字节和 4096字节。</li><li>行缓冲I/O指的是在出现换行符时刷新缓冲区。 键盘输入通常是行缓冲输入， 所以在按下Enter键后才刷新缓冲区 。</li></ul><h3 id="文件、流和键盘输入"><a href="#文件、流和键盘输入" class="headerlink" title="文件、流和键盘输入"></a>文件、流和键盘输入</h3><ul><li>文件（file） 是存储器中储存信息的区域。 通常， 文件都保存在某种永久存储器中（如， 硬盘、 U盘或DVD等） 。 </li><li>C可以使用主机操作系统的基本文件工具直接处理文件， 这些直接调用操作系统的函数被称为底层 I/O （low-level I/O） 。</li><li><strong>C程序处理的是流而不是直接处理文件。</strong> 流（stream） 是一个实际输入或输出映射的理想化数据流。 这意味着不同属性和不同种类的输入， 由属性更统一的流来表示。 于是， 打开文件的过程就是把流与文件相关联， 而且读写都通过流来完成。 从而达到屏蔽掉了不同系统的输入输出的差异， 以便用户使用统一的界面。 </li><li>C把输入和输出设备视为存储设备上的普通文件， 尤其是把键盘和显示设备视为每个C程序自动打开的文件。 stdin流表示键盘输入， stdout流表示屏幕输出。 getchar()、 putchar()、printf()和scanf()函数都是标准I/O包的成员， 处理这两个流。 </li></ul><p>总结：可以用处理文件的方式来处理键盘输入。 例如，程序读文件时要能检测文件的末尾才知应在何处停止。 因此， C 的输入函数内置了文件结尾检测器。 既然可以把键盘输入视为文件， 那么也应该能使用文件结尾检测器结束键盘输入。 </p><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><p>计算机操作系统要以某种方式判断文件的开始和结束。</p><ul><li><p>在文件末尾放一个特殊的字符标记文件结尾。 图8.2演示了这种方法</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_10-38-48.png" alt="Snipaste_2019-02-21_10-38-48"></p></li><li><p>另一种方法是储存文件大小的信息。  如果文件有3000字节， 程序在读到3000字节时便达到文件的末尾。 </p></li></ul><p>无论操作系统实际使用何种方法检测文件结尾， 在C语言中， 用getchar()读取文件检测到文件结尾时将返回一个特殊的值， 即EOF（end offile的缩写） 。 scanf()函数检测到文件结尾时也返回EOF。 通常， EOF定义在stdio.h文件中： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure><p>如何在程序中使用EOF？ 把getchar()的返回值和EOF作比较。 如果两值不同， 就说明没有到达文件结尾。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br></pre></td></tr></table></figure><p>绝大部分系统（不是全部） 都有办法通过键盘模拟文件结尾条件（Enter）。完整程序如下</p><p>程序清单8.2 echo_eof.c程序 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* echo_eof.c -- 重复输入， 直到文件结尾 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h4><p>输入和输出涉及函数、 数据和设备。 例如， 上面 echo_eof.c程序， 该程序使用输入函数 getchar()，输出函putchar()。 输入/输出数据流由字符组成。 输入设备是键盘 ，输出设备是屏幕。</p><p> 假设你希望输入函数和数据类型不变， 仅改变程序查找数据的位置。 那么， 程序如何知道去哪里查找输入？ </p><p>默认情况下， C程序使用标准I/O包查找标准输入作为输入源。 即：stdin流， 它是把数据读入计算机的常用方式。 它可以是键盘或者时一个过时的设备， 如磁带、 穿孔卡或电传打印机， 甚至是一些先进技术， 如语音输入。 然而， 现代计算机非常灵活， 可以让它到别处查找输入。 尤其是， 可以让一个程序从文件中查找输入， 而不是从键盘。 </p><p><strong>程序可以通过两种方式使用文件</strong></p><ul><li>第 1 种方法是， 显式使用特定的函数打开文件、 关闭文件、 读取文件、 写入文件， 诸如此类。 </li><li>第2种方法是， 设计能与键盘和屏幕互动的程序， 通过不同的渠道重定向输入至文件和从文件输出。 换言之， 把stdin流重新赋给文件。 继续使用getchar()函数从输入流中获取数据， 但它并不关心从流的什么位置获取数据。 这种重定向的方法在某些方面有些限制， 但是用起来比较简单， 而且能让读者熟悉普通的文件处理技术。 </li></ul><p>重定向输入让程序使用文件而不是键盘来输入， 重定向输出让程序输出至文件而不是屏幕。 </p><p>重定向输入</p><p> 假设已经编译了echo_eof.c 程序 </p><p>现在要该程序处理名为words的文本文件输出到屏幕上 </p><p>./echo_eof &lt; words  ：&lt;符号是UNIX和DOS/Windows的重定向运算符， words为文本文件保存有“1314”。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-07-57.png" alt="Snipaste_2019-02-21_14-07-57"></p><h4 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h4><p>在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。  </p><p>echo_eof&gt;mywords  ：&gt;符号是重定向运算符。 它创建了一个名为mywords的新文件， 然<br>后把echo_eof的输出 重定向至该文件中。  </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-18.png" alt="Snipaste_2019-02-21_14-15-18"></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-46.png" alt="Snipaste_2019-02-21_14-15-46"></p><p>注：在下一行的开始处按下Ctrl+D（UNIX） 或Ctrl+Z（DOS） 即可结束该程序。 </p><h4 id="组合重定向"><a href="#组合重定向" class="headerlink" title="组合重定向"></a>组合重定向</h4><p>现在， 假设你希望制作一份mywords文件的副本， 并命名为savewords。只需输入以下命令即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_eof &lt; mywords &gt; savewords</span><br><span class="line"><span class="comment">//下面的命令也起作用， 因为命令与重定向运算符的顺序无关：</span></span><br><span class="line">echo_eof &gt; savewords &lt; mywords</span><br></pre></td></tr></table></figure><p>注意： 在一条命令中， 输入文件名和输出文件名不能相同。 </p><p><strong>在UNIX、 Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;） 时， 要遵循以下原则。</strong></p><ul><li><p>重定向运算符连接一个可执行程序（包括标准操作系统命令） 和一个数据文件， 不能用于连接一个数据文件和另一个数据文件， 也不能用于连接一个程序和另一个程序。</p></li><li><p>使用重定向运算符不能读取多个文件的输入， 也不能把输出定向至多个<br>文件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fish &gt; beets ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; count ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; fish &lt; beets ←违反第<span class="number">2</span>条规则</span><br><span class="line">count &gt; beets fish ←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建更友好的用户界面"><a href="#创建更友好的用户界面" class="headerlink" title="创建更友好的用户界面"></a>创建更友好的用户界面</h3><p>学会避免编写一些中看不中用的程序，并创建更友好的用户界面， 让交互数据输入更方便， 减少错误输入的影响。 </p><p>略</p><h2 id="第二节：字符串符串输入-输出"><a href="#第二节：字符串符串输入-输出" class="headerlink" title="第二节：字符串符串输入/输出"></a>第二节：字符串符串输入/输出</h2><p>本章介绍以下内容：</p><ul><li><p>函数： gets_s()、 fgets()、 puts()、 fputs()、 strcat()、 strncat()、strcmp()、 strncmp()、 strcpy()、 strncpy()、 sprintf()、 strchr() </p></li><li><p>创建并使用字符串 </p></li><li>字符串是以空字符（\0）结尾的char类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过C也提供了许多专门用于处理字符串的函数</li><li>使用C库中的字符和字符串函数， 并创建自定义的字符串函数</li><li>使用命令行参数 </li></ul><p>字符串是以空字符（\0）结尾的char类型数组。 C提供了许多专门用于处理字符串的函数。本节将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。</p><p>程序清单11.1演示了在程序中表示字符串的几种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">//　 strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MSG　<span class="meta-string">"I　am　a　symbolic　string　constant."</span> <span class="comment">//方法一：即字符串常量（字符串常量）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MAXLENGTH　81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>　words[MAXLENGTH]　=　<span class="string">"I　am　a　string　in　an　array."</span>; <span class="comment">//方法二：、char类型数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>; <span class="comment">//放法三：指向char的指针</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here　are　some　strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line">    words[<span class="number">8</span>]　=　<span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Here are some strings:</span><br><span class="line">I am an old-fashioned symbolic <span class="built_in">string</span> constant.</span><br><span class="line">I am a <span class="built_in">string</span> in an <span class="built_in">array</span>.</span><br><span class="line">Something is pointing at me.</span><br><span class="line">I am a spring in an <span class="built_in">array</span>.</span><br></pre></td></tr></table></figure><p>程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向<br>char的指针）定义字符串。</p><h3 id="如何定义字符串"><a href="#如何定义字符串" class="headerlink" title="如何定义字符串"></a>如何定义字符串</h3><h4 id="1-字符串字面量（字符串常量）"><a href="#1-字符串字面量（字符串常量）" class="headerlink" title="1.字符串字面量（字符串常量）"></a>1.字符串字面量（字符串常量）</h4><p>定义：用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中。</p><p>所以<em>“I am a symbolic stringconstant.”</em>  、<em>“I739am a string in an array.”</em>  、<em>“Something is pointed at me.”</em> 、<em>“Here are somestrings:”</em>都是字符串字面量。</p><p>从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：</p><p><em>char greeting[50] = “Hello, and”</em></p><p><em>“ how are” “ you”</em></p><p><em>“ today!”;</em></p><p>与下面的代码等价：char greeting[50] = “Hello, and how are you today!</p><p><strong>注意：如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\“）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。</p><h4 id="2-字符串数组初始化"><a href="#2-字符串数组初始化" class="headerlink" title="2.字符串数组初始化"></a>2.字符串数组初始化</h4><p>定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种形式的初始化比标准的数组初始化形式简单得多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，让编译器确定数组的大小很方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。</p><p>##### </p><h4 id="3-指针和字符串"><a href="#3-指针和字符串" class="headerlink" title="3.指针和字符串"></a>3.指针和字符串</h4><p>实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5<br>中的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.5</span> p_and_s.c程序</span><br><span class="line"><span class="comment">/* p_and_s.c -- 指针和字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * mesg = <span class="string">"Don't be a fool!"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * copy;</span><br><span class="line">    copy = mesg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, copy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mesg = %s; &amp;mesg = %p; value = %p\n"</span>, mesg,&amp;mesg, mesg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"copy = %s; &amp;copy = %p; value = %p\n"</span>, copy,&amp;copy, copy);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line">Don't be a fool!</span><br><span class="line">mesg = Don't be a fool!; &amp;mesg = <span class="number">0x0012ff48</span>; value =<span class="number">0x0040a000</span></span><br><span class="line">copy = Don't be a fool!; &amp;copy = <span class="number">0x0012ff44</span>; value =<span class="number">0x0040a000</span></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li><p>首先第1项，mesg和copy都以字符串形式输出（%s转换说明）。这里没问题，两个字符串都是”Don’t be a fool!”。</p></li><li><p>第2项，打印两个指针的地址。如上输出所示，指针mesg和copy分别储存在地址为0x0012ff48和0x0012ff44的内存中。</p></li><li><p>意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。<em>语句copy = mesg;把mesg的值赋给copy，即让copy也指向mesg指向的字符。</em></p></li></ul><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。</p><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>字符串输入要做的第 1 件事是分配空间，以储存稍后读入的字符串。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">char</span> *name;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最简单的方法是，在声明时显式指明数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">81</span>];</span><br></pre></td></tr></table></figure><p>假设编写了如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">// strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"I am a symbolic string constant."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLENGTH 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har words[MAXLENGTH] = <span class="string">"I am a string in an array."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here are some strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line"> words[<span class="number">8</span>] = <span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的写法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="gets-函数"><a href="#gets-函数" class="headerlink" title="gets()函数"></a>gets()函数</h4><p>在读取字符串时， scanf()和转换说明%s只能读取一个单词。 可是在程序中经常要读取一整行输入， 而不仅仅是一个单词。 程序中读取一整行输入时需要使用gets()函数。</p><p> gets()函数简单易用， 它读取整行输入， 直至遇到换行符， 然后丢弃换行符， 储存其余字符， 并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。  </p><p><em>注：它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。（字符串输出介绍）</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.6</span> getsputs.c程序</span><br><span class="line"><span class="comment">/* getsputs.c -- 使用 gets() 和 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">gets(words); <span class="comment">// 典型用法，用于输入字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, words);</span><br><span class="line"><span class="built_in">puts</span>(words);<span class="comment">//用于输出字符串，效果和print相同。</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">Your <span class="built_in">string</span> twice:</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">Done.</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// gets整行输入（除了换行符） 都被储存在 words 中， puts(words) 和printf("%s\n, words")的效果相同。</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>gets()唯一的参数是 words，它无法检查数组是否装得下输入行。数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。</p><p>如果输入的字符串过长， 会导致缓冲区溢出（buffer overflow） ， 即多余的字符超出了指定的目标空间。 如果这些多余的字符只是占用了尚未使用的内存， 就不会立即出现问题； 如果它们擦写掉程序中的其他数据， 会导致程序异常中止； 或者还有其他情况。（问题和上面分配空间相似。）</p><h5 id="gets-的替代品"><a href="#gets-的替代品" class="headerlink" title="gets()的替代品"></a>gets()的替代品</h5><p>由于容易出现“Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的。因此C 编程社区的许多人都建议在编程时摒弃 gets()。</p><h5 id="1-fgets-函数"><a href="#1-fgets-函数" class="headerlink" title="1.fgets()函数"></a>1.fgets()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> bufsize, FILE *stream)</span></span>;</span><br><span class="line">参数</span><br><span class="line">*buf: 字符型指针，指向用来存储所得数据的地址。</span><br><span class="line">bufsize: 整型数据，指明存储数据的大小。</span><br><span class="line">*stream: 文件结构体指针，将要读取的文件流。</span><br></pre></td></tr></table></figure><p>fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。 该函数专门设计用于处理文件输入， 所以一般情况下可能不太好用。 </p><p><strong>fgets()和gets()的区别如下</strong></p><ul><li>fgets()函数的第2个参数指明了读入字符的最大数量。 如果该参数的值是n， 那么fgets()将读入n-1个字符， 或者读到遇到的第一个换行符为止。 </li><li>如果fgets()读到一个换行符， 会把它储存在字符串中。 （fgets()会保留换行符， gets()会丢弃换行符。 ）</li><li>fgets()函数的第3 个参数指明要读入的文件。 如果读入从键盘输入的数据， 则以stdin（标准输入） 作为参数。</li></ul><p>因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出） ， 通常要与 fputs()函数（和puts()类似） 配对使用， 除非该函数不在字符串末尾 添加换行符。 </p><p>fputs()函数的第2个参数指明它要写入的文件。 如果要显示在计算机显示器上， 应使用stdout（标准输出） 作为该参数。 （fputs后面介绍）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.7</span> fgets1.c程序</span><br><span class="line"><span class="comment">/* fgets1.c -- 使用 fgets() 和 fputs() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">fgets(words, STLEN, <span class="built_in">stdin</span>);<span class="comment">//words为写入内容，STLEN存储数据大小,stdin指向读取文件指针为标准输入。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter another string, please."</span>);</span><br><span class="line">fgets(words, STLEN, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">下面是该程序的输出示例：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">apple pie</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">apple pie</span><br><span class="line">apple pie</span><br><span class="line">Enter another <span class="built_in">string</span>, please.</span><br><span class="line">strawberry shortcake</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">strawberry sh</span><br><span class="line">strawberry shDone.</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>第1行输入， apple pie， 比fgets()读入的整行输入短， 因此， apple pie\n\0被储存在数组中。 所以当puts()显示该字符串时又在末尾添加了换行符， 因此apple pie后面有一行空行。 因为fputs()不在字符串末尾添加换行符， 所以并未打印出空行。</li><li>第2行输入， strawberry shortcake， 超过了大小的限制， 所以fgets()只读入了13个字符， 并把strawberry sh\0 储存在数组中。 再次提醒读者注意，puts()函数会在待输出字符串末尾添加一个换行符， 而fputs()不会这样做。 </li></ul><h5 id="2-gets-s-函数"><a href="#2-gets-s-函数" class="headerlink" title="2.gets_s()函数"></a>2.gets_s()函数</h5><p>过去通常用fgets()来代替gets()， fgets()函数稍微复杂些， 在处理输入方面与gets()略有不同。 C11标准新增的gets_s()函数也可代替gets()。 该函数与gets()函数更接近， 而且可以替换现有代码中的gets()。 但是， 它是stdio.h输入/输出函数系列中的可选扩展， 所以支持C11的编译器也不一定支持它。 </p><p>C11新增的gets_s()函数（可选） 和fgets()类似， 用一个参数限制读入的字符数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets_s</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">size_t</span> sizeInCharacters)</span></span>;</span><br></pre></td></tr></table></figure><p>gets_s()与fgets()的区别如下。</p><p>gets_s()只从标准输入中读取数据， 所以不需要第3个参数。</p><p>如果gets_s()读到换行符， 会丢弃它而不是储存它。</p><h5 id="3-s-gets-函数"><a href="#3-s-gets-函数" class="headerlink" title="3.s_gets()函数"></a>3.s_gets()函数</h5><p>程序清单11.9演示了fgets()函数的一种用法： 读取整行输入并用空字符<br>代替换行符， 或者读取一部分输入， 并丢弃其余部分。 既然没有处理这种情<br>况的标准函数， 我们就创建一个， 在后面的程序中会用得上。 程序清单<br>11.10提供了一个这样的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.10</span> s_gets()函数</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>); </span><br><span class="line"> <span class="keyword">if</span> (ret_val) <span class="comment">// 即， ret_val != NULL</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">st[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：如果 fgets()返回 NULL， 说明读到文件结尾或出现读取错误， s_gets()函数跳过了这个过程。 它模仿程序清单11.9的处理方法， 如果字符串中出现换行符， 就用空字符替换它； 如果字符串中出现空字符， 就丢弃该输入行的其余字符， 然后返回与fgets()相同的值。 </p><h4 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h4><p>scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾：scanf()更像是“获取单词”函数， 而不是“获取字符串”函数； 如果预留的存储区装得下输入行， gets()和fgets()会读取第1个换行符之前所有的字符。 </p><p>scanf()函数有两种方法确定输入结束。 无论哪种方法， 都从第1个非空白字符作为字符串的开始。 </p><ul><li>如果使用%s转换说明， 以下一个空白字符（空行、空格、 制表符或换行符） 作为字符串的结束（字符串不包括空白字符） 。</li><li>如果指定了字段宽度， 如%10s， 那么scanf()将读取10 个字符或读到第1个空白<br>字符停止（先满足的条件即是结束输入的条件） ， 见图11.3。 </li></ul><p><img src="D:\MyBlog\图片\Snipaste_2019-02-25_20-49-47.png" alt="Snipaste_2019-02-25_20-49-47"></p><p>scanf()函数返回一个整数值， 该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF） 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.11</span> scan_str.c程序</span><br><span class="line"><span class="comment">/* scan_str.c -- 使用 scanf() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> name1[<span class="number">11</span>], name2[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter 2 names.\n"</span>);</span><br><span class="line">count = <span class="built_in">scanf</span>(<span class="string">"%5s %10s"</span>, name1, name2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I read the %d names %s and %s.\n"</span>, count, name1,me2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的3个输出示例：</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Jesse Jukes</span></span><br><span class="line"><span class="comment">I read the 2 names Jesse and Jukes.</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Portensia Callowit</span></span><br><span class="line"><span class="comment">I read the 2 names Porte and nsia.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>分析：第1个输出示例， 两个名字的字符个数都未超过字段宽度。 第2个输出示例， 只读入了Applebottham的前10个字符Applebotth（因为使用了%10s转换说明） 。 第3个输出示例， Portensia的后4个字符nsia被写入name2中， 因为第2次调用scanf()时， 从上一次调用结束的地方继续读取数据。 在该例中， 读取的仍是Portensia中的字母。 </p><p>scanf()和gets()类似， 也存在一些潜在的缺点。 如果输入行的内容过长，scanf()也会导致数据溢出。 不过， 在%s转换说明中使用字段宽度可防止溢出。 </p><h3 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h3><p>C有3个标准库函数用于打印字符串： put()、 fputs()和printf() 。</p><h4 id="puts-函数"><a href="#puts-函数" class="headerlink" title="puts()函数"></a>puts()函数</h4><p>puts()函数很容易使用， 只需把字符串的地址作为参数传递给它即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.12</span> put_out.c程序</span><br><span class="line"><span class="comment">/* put_out.c -- 使用 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF <span class="meta-string">"I am a #defined string."</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">80</span>] = <span class="string">"An array was initialized to me."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * str2 = <span class="string">"A pointer was initialized to me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"I'm an argument to puts()."</span>);</span><br><span class="line"><span class="built_in">puts</span>(DEF);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="built_in">puts</span>(str2);</span><br><span class="line"><span class="built_in">puts</span>(&amp;str1[<span class="number">5</span>]);</span><br><span class="line"> <span class="built_in">puts</span>(str2 + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">I'm an argument to puts().</span><br><span class="line">I am a <span class="meta">#defined string.</span></span><br><span class="line">An <span class="built_in">array</span> was initialized to me.</span><br><span class="line">A pointer was initialized to me.</span><br><span class="line">ray was initialized to me.</span><br><span class="line">inter was initialized to me.</span><br></pre></td></tr></table></figure><p>注：每个字符串独占一行， 因为puts()在显示字符串时会自动在其末尾添加一个换行符。 （这点太舒服了，printf()还要自己加换行。）</p><p>puts()如何知道在何处停止？ 该函数在遇到换行符时就停止输出， 所以必须确保有换行符。 不要模仿程序清单11.13中的程序！ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.13</span> nono.c程序</span><br><span class="line"><span class="comment">/* nono.c -- 千万不要模仿！ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> side_a[] = <span class="string">"Side A"</span>;</span><br><span class="line"><span class="keyword">char</span> dont[] = &#123; <span class="string">'W'</span>, <span class="string">'O'</span>, <span class="string">'W'</span>, <span class="string">'!'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> side_b[] = <span class="string">"Side B"</span>;</span><br><span class="line"><span class="built_in">puts</span>(dont); <span class="comment">/* dont 不是一个字符串，是个wow！字节 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于dont缺少一个表示结束的空字符， 所以它不是一个字符串， 因此puts()不知道在何处停止。 它会一直打印dont后面内存中的内容， 直到发现一个空字符为止。 为了让puts()能尽快读到空字符， 我们把dont放在side_a和side_b之间。 下面是该程序的一个运行示例：<br>WOW!Side A </p><h4 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs()函数"></a>fputs()函数</h4><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line">（<span class="number">1</span>）str：这是一个数组，包含了要写入的以空字符终止的字符序列。</span><br><span class="line">（<span class="number">2</span>）stream：指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</span><br><span class="line">返回值：该函数返回一个非负值，如果发生错误则返回 EOF(<span class="number">-1</span>)。</span><br></pre></td></tr></table></figure><p>fputs()函数是puts()针对文件定制的版本。 </p><p>它们的区别如下：</p><ul><li>fputs()函数的第 2 个参数指明要写入数据的文件。 如果要打印在显示器上， 可以用定义在stdio.h中的stdout（标准输出） 作为该参数。  </li><li>与puts()不同， fputs()不会在输出的末尾添加换行符。 </li></ul><p>注意： gets()丢弃输入中的换行符， 但是puts()在输出中添加换行符。 另一方面， fgets()保留输入中的换行符， fputs()不在输出中添加换行符。 （好绕）</p><h3 id="常见字符串处理函数"><a href="#常见字符串处理函数" class="headerlink" title="常见字符串处理函数"></a>常见字符串处理函数</h3><p>C库提供了多个处理字符串的函数， ANSI C把这些函数的原型放在string.h头文件中。 其中最常用的函数strlen()、 strcat()、 strcmp()、strncmp()、 strcpy()和 strncpy()。 另外， 还有sprintf()函数， 其原型在stdio.h头文件中。 </p><p><strong>1.strlen()函数 ：用于统计字符串的长度。</strong> </p><p>略</p><p><strong>2.strcat()函数 ：用于拼接字符串</strong></p><p> 函数接受两个字符串作为参数。 该函数把第2个字符串的备份附加在第1个字符串末尾， 并把拼接后形成的新字符串作为第1个字符串， 第2个字符串不变。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.18</span> str_cat.c程序</span><br><span class="line"><span class="comment">/* str_cat.c -- 拼接两个字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* strcat()函数的原型在该头文件中 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line"><span class="keyword">char</span> addon [] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line"><span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line"><span class="built_in">puts</span>(flower);</span><br><span class="line"><span class="built_in">puts</span>(addon);</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">st[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出示例如下：</span></span><br><span class="line"><span class="comment">What is your favorite flower?</span></span><br><span class="line"><span class="comment">wonderflower</span></span><br><span class="line"><span class="comment">wonderflowers smell like old shoes.</span></span><br><span class="line"><span class="comment">s smell like old shoes.</span></span><br><span class="line"><span class="comment">bye</span></span><br><span class="line"><span class="comment">从以上输出可以看出， flower改变了， 而addon保持不变。</span></span><br></pre></td></tr></table></figure><p><strong>3.strcmp()函数</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">设这两个字符串为str1，str2，</span><br><span class="line">若str1=str2，则返回零；</span><br><span class="line">若str1&lt;str2，则返回负数；</span><br><span class="line">若str1&gt;str2，则返回正数。</span><br></pre></td></tr></table></figure><p><strong>4.sprintf()函数</strong></p><p> 是字符串格式化命令,主要功能是把格式化的数据写入某个字符串中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原型</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [ argument] … )</span></span>;</span><br><span class="line">参数列表</span><br><span class="line">buffer：<span class="keyword">char</span>型指针，指向将要写入的字符串的缓冲区。</span><br><span class="line">format：格式化字符串。</span><br><span class="line">[argument]...：可选参数，可以是任何类型的数据。nst <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crt_sprintf.c</span></span><br><span class="line"><span class="comment">// compile with: /W3</span></span><br><span class="line"><span class="comment">// This program uses sprintf to format various</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//data and place them in the string named buffer.</span></span><br><span class="line"><span class="comment">// 程序使用sprintf 将各种数据格式化后置于字符数组buffer中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">   <span class="keyword">int</span>   i = <span class="number">35</span>, j;</span><br><span class="line">   <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">   <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">   j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"   String:    %s\n"</span>, s ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Character: %c\n"</span>, c ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Integer:   %d\n"</span>, i ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Real:      %f\n"</span>, fp );<span class="comment">// C4996</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>, buffer, j );</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果 [<span class="number">1</span>]  ：</span><br><span class="line">Output:</span><br><span class="line">String: computer </span><br><span class="line">　　</span><br><span class="line">Character: l</span><br><span class="line">Integer: <span class="number">35</span></span><br><span class="line">Real: <span class="number">1.732053</span></span><br><span class="line">character count = <span class="number">79</span></span><br></pre></td></tr></table></figure><p><strong>其他字符串函数</strong> </p><ol><li><p>char <em>strcpy(char </em> restrict s1, const char * restrict s2);</p><p>该函数把s2指向的字符串（包括空字符） 拷贝至s1指向的位置， 返回值是s1。</p></li><li><p>char <em>strncpy(char </em> restrict s1, const char * restrict s2, size_t n);</p><p>该函数把s2指向的字符串拷贝至s1指向的位置， 拷贝的字符数不超过n， 其返回值是s1该函数不会拷贝空字符后面的字符， 如果源字符串的字符少于n个， 目标字符串就以拷贝的空字符尾； 如果源字符串有n个或超过n个字符， 就不拷贝空字符。</p></li><li><p>char <em>strcat(char </em> restrict s1, const char * restrict s2);</p><p>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 该函数返回s1。</p></li><li><p>char <em>strncat(char </em> restrict s1, const char * restrict s2, size_t n);</p><p>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 不会拷贝s2字符串中空字符和其后的字符， 并在拷贝字符的末尾添加一个空字符。 该函数返回s1。</p></li><li><p>int strcmp(const char <em> s1, const char </em> s2);</p><p>如果s1字符串在机器排序序列中位于s2字符串的后面， 该函数返回一个正数； 如果两个字符串相等， 则返回0； 如果s1字符串在机器排序序列中位于s2字符串的前面， 则返回一个负数。</p></li><li><p>int strncmp(const char <em> s1, const char </em> s2, size_t n);</p><p>该函数的作用和strcmp()类似， 不同的是， 该函数在比较n个字符后或遇到第1个空字符时停止比较。</p></li><li><p>char <em>strchr(const char </em> s, int c);</p><p>如果s字符串中包含c字符， 该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分， 所以在查找范围内） ； 如果在字符串s中  </p></li></ol><h3 id="输入-输出的应用技巧"><a href="#输入-输出的应用技巧" class="headerlink" title="输入/输出的应用技巧"></a>输入/输出的应用技巧</h3><h4 id="自定义输入-输出函数"><a href="#自定义输入-输出函数" class="headerlink" title="自定义输入/输出函数"></a>自定义输入/输出函数</h4><p>实际使用中，不一定非要使用C库中的标准函数， 如果无法使用这些函数或者想扩张输入/输出的某一功能， 完全可以在getchar()和putchar()的基础上自定义所需的函数。 </p><p>下面两个经典的自定义输入/输出函数 </p><p>1.字符串， 不添加\n </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.14</span> put1()函数</span><br><span class="line"><span class="comment">/* put1.c -- 打印字符串， 不添加\n */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span><span class="comment">/* 不会改变字符串 */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">string</span> != <span class="string">'\0'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向char的指针string最初指向传入参数的首元素。 因为该函数不会改变<br>传入的字符串， 所以形参使用了const限定符。 打印了首元素的内容后， 指<br>针递增1， 指向下一个元素。 while循环重复这一过程， 直到指针指向包含空<br>字符的元素。  </p><p>++的优先级高于<em>， 因此putchar(</em>string++)打印string指向的值， 递增的是string本身， 而不是递增它所指向的字符。 （即先比较厚打印，当比较到\0时退出）</p><p>2.设计一个类似puts()的函数， 而且该函数还给出待打印字符的个数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* put2.c -- 打印一个字符串， 并统计打印的字符数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">put2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">string</span>) <span class="comment">/* 常规用法 */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">count++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>); <span class="comment">/* 不统计换行符 */</span></span><br><span class="line"><span class="keyword">return</span>(count);</span><br><span class="line">&#125;</span><br><span class="line">num = put2(<span class="string">"pizza"</span>);<span class="comment">//调用将返回统计的字符数， 并将其赋给num</span></span><br></pre></td></tr></table></figure><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><p>我们来处理一个按字母表顺序排序字符串的实际问题。 准备名单表、 创建索引和许多其他情况下都会用到字符串排序。 该程序主要是用 strcmp()函数来确定两个字符串的顺序。 一般的做法是读取字符串函数、 排序字符串并打印出来。  </p><p>略</p><h4 id="把字符串转换为数字"><a href="#把字符串转换为数字" class="headerlink" title="把字符串转换为数字"></a>把字符串转换为数字</h4><p>数字既能以字符串形式储存， 也能以数值形式储存。 把数字储存为字符串就是储存数字字符。 例如， 数字213以’2’、 ‘1’、 ‘3’、 ‘\0’的形式被储存在字符串数组中。 以数值形式储存213， 储存的是int类型的值。 </p><p>略</p><h2 id="第三节：文件输入-输出"><a href="#第三节：文件输入-输出" class="headerlink" title="第三节：文件输入/输出"></a>第三节：文件输入/输出</h2><p>本章介绍以下内容函数：</p><ul><li>fopen()、 getc()、 putc()、 exit()、 fclose()</li><li>fprintf()、 fscanf()、 fgets()、 fputs()</li><li>rewind()、 fseek()、 ftell()、 fflush()</li><li>fgetpos()、 fsetpos()、 feof()、 ferror()</li><li>ungetc()、 setvbuf()、 fread()、 fwrite()</li></ul><p>如何使用C标准I/O系列的函数处理文件文件模式和二进制模式、 文本和二进制格式、 缓冲和无缓冲I/O<br>使用既可以顺序访问文件也可以随机访问文件的函数文件是当今计算机系统不可或缺的部分。 文件用于储存程序、 文档、 数据、 书信、 表格、 图形、 照片、 视频和许多其他种类的信息。 作为程序员，必须会编写创建文件和从文件读写数据的程序。 本章将介绍相关的内容。</p><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><ol><li><p><strong>文件（file）</strong></p><p>文件（file）： 通常是在磁盘或固态硬盘上的一段已命名的存储区。 对我们而言， stdio.h就是一个文件的名称， 该文件中包含一些有用的信息 。</p><p>C把文件看作是一系列连续的字节， 每个字节都能被单独读取。 C提供两种文件模式： 文本模式和二进制模式。 </p></li><li><p><strong>文本模式和二进制模式</strong> </p><p>所有文件的内容都以二进制形式（0或1） 储存。 但是， 如果文件最初使用二进制编码的字符（例如， ASCII或Unicode） 表示文本（就像C字符串那样） ， 该文件就是文本文件， 其中包含文本内容。 如果文件中的二进制值代<br>表机器语言代码或数值数据（使用相同的内部表示， 假设， 用于long或double类型的值） 或图片或音乐编码， 该文件就是二进制文件， 其中包含二进制内容。 </p></li><li><p><strong>I/O的级别</strong> </p><p>除了选择文件的模式， 大多数情况下， 还可以选择I/O的两个级别（即处理文件访问的两个级别） 。 底I/O（low-level I/O） 使用操作系统提供的基本I/O服务。 标准高级I/O（standard high-level I/O） 使用C库的标准包和stdio.h头文件定义。 </p></li><li><p><strong>标准文件</strong>  </p><p>C程序会自动打开3个文件， 它们被称为标准输入（standard input） 、 标准输出（standard output） 和标准错误输出（standard error output） 。 在默认情况下， 标准输入是系统的普通输入设备， 通常为键盘； 标准输出和标准错误输出是系统的普通输出设备， 通常为显示屏 </p><p>标准输入为程序提供输入， 它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出， 它是putchar()、 puts()和printf()使用的文件。  </p></li></ol><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>与底层I/O相比， 标准I/O包除了可移植以外还有两个好处。 </p><p>第一， 标准I/O有许多专门的函数简化了处理不同I/O的问题。 例如， printf()把不同形式的数据转换成与终端相适应的字符串输出。 </p><p>第二， 输入和输出都是缓冲的。也就是说， 一次转移一大块信息而不是一字节信息（通常至少512字节） 。 例如， 当程序读取文件时， 一块数据被拷贝到缓冲区（一块中介存储区域） 。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.1</span> count.c程序</span><br><span class="line"><span class="comment">/* count.c -- 使用标准 I/O */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // 提供 exit()的原型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ch; <span class="comment">// 读取文件时， 储存每个字符的地方</span></span><br><span class="line">FILE *fp; <span class="comment">// “文件指针”</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s filename\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = getc(fp)) != EOF)</span><br><span class="line">&#123; </span><br><span class="line">        putc(ch, <span class="built_in">stdout</span>); <span class="comment">// 与putchar(ch); 相同</span></span><br><span class="line">count++;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File %s has %lu characters\n"</span>, argv[<span class="number">1</span>], count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查命令行参数"><a href="#检查命令行参数" class="headerlink" title="检查命令行参数"></a>检查命令行参数</h4><p>程序清单中的程序检查argc的值， 查看是否有命令行参数。如果没有， 程序将打印一条消息并退出程序。 字符串 argv[0]是该程序的名称。 显式使用 argv[0]而不是程序名， 错误消息的描述会随可执行文件名的改变而自动改变。</p><p><em>补充：int main(int argc,char</em> argv[ ])</p><ul><li><em>argc：是命令行总的参数个数</em><br>​    argv[]是argc个参数，其中第0个参数是程序的全名，以后的参数命令行后面跟的用户输入的参数，</li><li><em>char </em>argv[]：是一个字符数组,其大小是int argc,<em><br>​       </em>主要用于命令行参数argv[]参数，数组里每个元素代表一个参数;*</li></ul><h4 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h4><p>程序使用fopen()函数打开文件。 该函数声明在stdio.h中。  </p><p>它的第1个参数是待打开文件的名称， 更确切地说是一个包含<br>改文件名的字符串地址。 第 2 个参数是一个字符串， 指定待打开文件的模<br>式。  下表列出了C库提供的一些模式。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_10-46-41.png" alt="Snipaste_2019-02-26_10-46-41"></p><p>**</p><p><em>注意：如果使用任何一种”w”模式（不带x字母） 打开一个现有文件， 该文件的内容会被删除， 以便程序在一个空白文件中开始操作。 然而， 如果使用带x字母的任何一种模式， 将无法打开一个现有文件。</em></p><p>序成功打开文件后， fopen()将返回文件指针（file pointer） ， 其他I/O 函数可以使用这个指针指定该文件。  </p><p>文件指针（该例中是fp） 的类型是指向FILE的指针， FILE是一个定义在stdio.h中的派生类型。 文件指针fp并不指向实际的文件， 它指向一个包含文件信息的数据对象， 其中包含操作文件的<br>I/O函数所用的缓冲区信息。</p><p><em>理解：好像是fopen的话 会创建一个FILE的数据结构，用于保存 打开的文件信息 ，然后使用指针指向该数据结构</em></p><h4 id="getc-和putc-函数"><a href="#getc-和putc-函数" class="headerlink" title="getc()和putc()函数"></a>getc()和putc()函数</h4><p>getc()和putc()函数与getchar()和putchar()函数类似。 所不同的是， 要告诉<br>getc()和putc()函数使用哪一个文件。 </p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch = getchar();<span class="comment">//从标准输入中获取一个字符，一般指键盘”： </span></span><br><span class="line">ch = getc(fp); <span class="comment">//从fp指定的文件中获取一个字符</span></span><br><span class="line">putc(ch, fpout);<span class="comment">//把字符ch放入FILE指针fpout指定的文件中</span></span><br><span class="line"><span class="comment">//第1个参数是待写入的字符， 第2个参数是文件指针。</span></span><br></pre></td></tr></table></figure><h4 id="文件结尾-1"><a href="#文件结尾-1" class="headerlink" title="文件结尾"></a>文件结尾</h4><p>读取数据时程序时如何知道文件结尾的，getc()函数在读取一个字符时发现是文件结尾， 它将返回一个特殊值EOF。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(<span class="string">"wacky.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">while</span> (( ch = getc(fp)) != EOF)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(ch); <span class="comment">//处理输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.fclose()函数   </p><p>fclose(fp)函数关闭fp指定的文件， 必要时刷新缓冲区。 对于较正式的程<br>序， 应该检查是否成功关闭文件。 如果成功关闭， fclose()函数返回0， 否则<br>返回EOF： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error in closing file %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//如果磁盘已满、 移动硬盘被移除或出现I/O错误， 都会导致调用fclose()函数失败。</span></span><br></pre></td></tr></table></figure><h4 id="应用：一个简单的文件压缩程序"><a href="#应用：一个简单的文件压缩程序" class="headerlink" title="应用：一个简单的文件压缩程序"></a>应用：一个简单的文件压缩程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.2</span> reducto.c程序</span><br><span class="line"><span class="comment">// reducto.c –把文件压缩成原来的1/3！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // 提供 exit()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // 提供 strcpy()、 strcat()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 40</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *in, *out; <span class="comment">// 声明两个指向 FILE 的指针</span></span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">char</span> name[LEN]; <span class="comment">// 储存输出文件名</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s filename\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//设置输入</span></span><br><span class="line"><span class="keyword">if</span> ((in = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"I couldn't open the file \"%s\"\n"</span>,</span><br><span class="line">argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//设置输出</span></span><br><span class="line"><span class="built_in">strncpy</span>(name, argv[<span class="number">2</span>], LEN - <span class="number">5</span>); <span class="comment">// 拷贝文件名</span></span><br><span class="line">name[LEN - <span class="number">5</span>] = <span class="string">'\0'</span>;<span class="comment">//参数LEN-5确保了预留有5个空字符添加.red后缀而不溢出</span></span><br><span class="line"><span class="built_in">strcat</span>(name, <span class="string">".red"</span>); <span class="comment">// 在文件名后添加.red</span></span><br><span class="line"> <span class="keyword">if</span> ((out = fopen(name, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 以写模式打开文件</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create output file.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//拷贝数据</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(in)) != EOF)</span><br><span class="line"><span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">putc(ch, out);<span class="comment">// 打印3个字符中的第1个字符</span></span><br><span class="line"><span class="comment">// 收尾工作</span></span><br><span class="line"><span class="keyword">if</span> (fclose(in) != <span class="number">0</span> || fclose(out) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in closing files\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设可执行文件名是reducto， 待读取的文件名为eddy， 该文件中包含下面一行内容：</span></span><br><span class="line"><span class="comment">So even Eddy came oven ready.</span></span><br><span class="line"><span class="comment">命令如下：</span></span><br><span class="line"><span class="comment">reducto eddy</span></span><br><span class="line"><span class="comment">待写入的文件名为eddy.red。 该程序把输出显示在eddy.red中， 而不是屏幕上。打开eddy.red， 内容如下：</span></span><br><span class="line"><span class="comment">Send money</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="文件I-O：-fprintf-、-fscanf-、-fgets-和fputs"><a href="#文件I-O：-fprintf-、-fscanf-、-fgets-和fputs" class="headerlink" title="文件I/O： fprintf()、 fscanf()、 fgets()和fputs()"></a>文件I/O： fprintf()、 fscanf()、 fgets()和fputs()</h3><p>文件I/O函数要用FILE指针指定待处理的文件。这些函数都要求用指向 FILE 的指针（如， stdout） 指定一个文件， 或者使用fopen()的返回值   fprintf()和fscanf()函数 </p><h4 id="fprintf-和fscanf-函数"><a href="#fprintf-和fscanf-函数" class="headerlink" title="fprintf()和fscanf()函数"></a>fprintf()和fscanf()函数</h4><p>文件I/O函数fprintf()和fscanf()函数的工作方式与printf()和scanf()类似，区别在于前者需要用第1个参数指定待处理的文件。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.3</span> addaword.c程序</span><br><span class="line"><span class="comment">/* addaword.c -- 使用 fprintf()、 fscanf() 和 rewind() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 41</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">char</span> words[MAX];</span><br><span class="line"><span class="keyword">if</span> ((fp = fopen(<span class="string">"wordy"</span>, <span class="string">"a+"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Can't open \"wordy\" file.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Enter words to add to the file; press the #"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"key at the beginning of a line to terminate."</span>);</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">"%40s"</span>, words) == <span class="number">1</span>) &amp;&amp; (words[<span class="number">0</span>] != <span class="string">'#'</span>))</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"%s\n"</span>, words);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"File contents:"</span>);</span><br><span class="line">rewind(fp); <span class="comment">/* 返回到文件开始处 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, words) == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error closing file\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fgets-和fputs-函数"><a href="#fgets-和fputs-函数" class="headerlink" title="fgets()和fputs()函数"></a>fgets()和fputs()函数</h4><h4 id="随机访问：-fseek-和ftell"><a href="#随机访问：-fseek-和ftell" class="headerlink" title="随机访问： fseek()和ftell()"></a>随机访问： fseek()和ftell()</h4><p>…待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章：基数知识&quot;&gt;&lt;a href=&quot;#第一章：基数知识&quot; class=&quot;headerlink&quot; title=&quot;第一章：基数知识&quot;&gt;&lt;/a&gt;第一章：基数知识&lt;/h1&gt;&lt;h2 id=&quot;第一节：数据和C&quot;&gt;&lt;a href=&quot;#第一节：数据和C&quot; class=&quot;headerlink&quot; title=&quot;第一节：数据和C&quot;&gt;&lt;/a&gt;第一节：数据和C&lt;/h2&gt;&lt;h3 id=&quot;strlen和sizeof&quot;&gt;&lt;a href=&quot;#strlen和sizeof&quot; class=&quot;headerlink&quot; title=&quot;strlen和sizeof&quot;&gt;&lt;/a&gt;strlen和sizeof&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&quot;stdio.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&quot;string.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; name[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]=&lt;span class=&quot;string&quot;&gt;&quot;wu&quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;strlen= %d,sizeof=%d;&quot;&lt;/span&gt; , &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(name) , &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(name));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回值为：&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注：&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; 运算符， 它以字节为单位给出对象的大小。 &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;()函数给出字符串中的字符长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://github.com/SetCalm/setcalm.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>linux环境配置</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/linux环境配置.html</id>
    <published>2018-12-29T09:01:14.000Z</published>
    <updated>2018-12-29T09:01:14.458Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1.移植U-Boot</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/1-%E7%A7%BB%E6%A4%8DU-Boot.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/1-移植U-Boot.html</id>
    <published>2018-12-28T14:52:31.000Z</published>
    <updated>2019-01-03T03:41:44.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移植-U-Boot"><a href="#移植-U-Boot" class="headerlink" title="移植 U-Boot"></a>移植 U-Boot</h2><h3 id="Bootloader-简介"><a href="#Bootloader-简介" class="headerlink" title="Bootloader 简介"></a>Bootloader 简介</h3><p>#### </p><h4 id="Bootload是什么"><a href="#Bootload是什么" class="headerlink" title="Bootload是什么"></a>Bootload是什么</h4><p>Bootloader是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备（关闭WATCHDOG、改变系统时钟、初始化存储控制器）、建立内存空间的映射表，将更多的代码复制到内存中等，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。 <em>它能将操作系统内核复制到内存中运行，我们将这段程序称为 Bootloader。</em></p><p>①Bootloader 就是这么一小段程序，它在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统</p><p>②我们还可以增强 Bootloader 的功能，比如增加网络功能、从 PC 上通过串口或网络下载文件、烧写文件、将 Flash 上压缩的文件解压后再运行等。</p><p>③Bootloader是基于特定硬件平台来实现的。因此，不可能有一个 Bootloader 支持所有的CPU、所有的电路板。即使是支持 CPU 架构比较多的 U-Boot，也不是一拿来就可以使用的，需要进行一些移植</p><h4 id="Bootloader是如何启动"><a href="#Bootloader是如何启动" class="headerlink" title="Bootloader是如何启动"></a>Bootloader是如何启动</h4><p>CPU 上电后，会从某个地址开始执行。比如 MIPS 结构的 CPU 会从 0xBFC00000 取第一条指令，而 ARM 结构的 CPU 则从地址 0x0000000 开始。嵌入式开发板中，需要把存储器件 ROM 或 Flash 等映射到这个地址，Bootloader 就存放在这个地址开始处，这样一上电就可以执行。<strong><em>(即将Bootloader 存放在0x0000000 这个地址开始处。这样一上电就可以执行Bootloader)</em></strong> </p><p>在开发时，通常可以使用各种命令操作 Bootloader，一般通过串口来连接 PC 和开发板，可以在串口上输入各种命令、观察运行结果等。</p><p>Bootloader 可以分为以下两种操作模式（Operation Mode）。<br>​    （1）启动加载（Boot loading）模式。<br>​    上电后，Bootloader 从板子上的某个固态存储设备上将操作系统加载到 RAM 中运行，整个过程并没有用户的介入。产品发布时，Bootloader 工作在这种模式下。<br>​    （2）下载（Downloading）模式。<br>​    在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（比如内核映象、文件系统映象），将它们直接放在内存运行或是烧入Flash 类固态存储设备中。<br>​    板子与主机间传输文件时，可以使用串口的 xmodem/ymodem/zmodem 协议，它们使用简单，只是速度比较慢；还可以使用网络通过 tftp、nfs 协议来传输，这时，主机上要开启 tftp、nfs 服务；还有其他方法，比如 USB 等。</p><h4 id="Bootloader-在linux中的分区"><a href="#Bootloader-在linux中的分区" class="headerlink" title="Bootloader 在linux中的分区"></a>Bootloader 在linux中的分区</h4><p>嵌入式 Linux 系统从软件的角度通常可以分为以下 4 个层次。</p><p>（1）引导加载程序。</p><p>包括固化在固件（firmware）中的 boot 代码（可选）和 Bootloader两大部分。有些 CPU 在运行 Bootloader 之前先运行一段固化的程序（固件，firmware），比如 x86结构的 CPU 就是先运行 BIOS 中的固件，然后才运行硬盘第一个分区（MBR）中的 Bootloader。在大多嵌入式系统中并没有固件，Bootloader 是上电后执行的第一程序。</p><p>（2）Linux 内核。</p><p>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由 Bootloader 传递给它的。</p><p>（3）文件系统。</p><p>包括根文件系统和建立于 Flash 内存设备之上的文件系统。里面包含了 Linux 系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux 的控制界面的 shell 程序、动态连接的程序运行时需要的 glibc 或 uClibc 库等。</p><p>（4）用户应用程序。<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间 可能还会包括一个嵌入式图形用户界面。常用的嵌入式 GUI 有：Qtopia 和 MiniGUI 等。 </p><p>嵌入系统的典型分区结构如下</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-28_23-39-14.png" alt="Snipaste_2018-12-28_23-39-14"></p><p><strong>“Boot parameters（参数）”</strong>分区中存放一些可设置的参数，比如 IP 地址、串口波特率、要传递给内核的命令行参数等。</p><p>正常启动过程中，Bootloader 首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会挂接（mount）根文件系统（“Root filesystem”），启动文件系统中的应用程序。</p><h4 id="Bootload启动步骤"><a href="#Bootload启动步骤" class="headerlink" title="Bootload启动步骤"></a>Bootload启动步骤</h4><p>汇编阶段 </p><ol><li><p>设置为SVC模式，关闭中断,MMU,看门狗</p></li><li><p>基本硬件设备初始化（初始化时钟，串口，flash,内存等）</p></li><li><p>自搬移到内存</p></li><li><p>设置好栈 跳转到C语言阶段 </p><p>C语言阶段</p></li><li><p>大部分硬件初始化</p></li><li><p>搬移内核到内存后，运行内核</p></li></ol><h4 id="常用-Bootloader-介绍"><a href="#常用-Bootloader-介绍" class="headerlink" title="常用 Bootloader 介绍"></a>常用 Bootloader 介绍</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-29_00-42-38.png" alt="Snipaste_2018-12-29_00-42-38"></p><p>本次使用的 S3C2410 开发板使用的Bootloader为U-Boot 。<br>​    U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p><h3 id="U-Boot-分析与移植"><a href="#U-Boot-分析与移植" class="headerlink" title="U-Boot 分析与移植"></a>U-Boot 分析与移植</h3><h4 id="U-Boot-简介"><a href="#U-Boot-简介" class="headerlink" title="U-Boot 简介"></a>U-Boot 简介</h4><p>U-Boot，全称为 Universal Boot Loader，即通用 Bootloader，是遵循 GPL 条款的开放源代码项目。</p><p><strong>U-Boot 有如下特性</strong></p><p>• 开放源码。</p><p>• 支持多种嵌入式操作系统内核，如 Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS。</p><p>• 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS、XScale。</p><p>• 较高的可靠性和稳定性。</p><p>• 高度灵活的功能设置，适合 U-Boot 调试、操作系统不同引导要求、产品发布等。</p><p>• 丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等。</p><p>• 较为丰富的开发调试文档与强大的网络技术支持。</p><p>• 支持 NFS 挂载、RAMDISK（压缩或非压缩）形式的根文件系统。</p><p>• 支持 NFS 挂载、从 Flash 中引导压缩或非压缩系统内核。</p><p>• 可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对 Linux 支持最为强劲。</p><p>• 支持目标板环境变量多种存储方式，如 Flash、NVRAM、EEPROM。</p><p>• CRC32 校验，可校验 Flash 中内核、RAMDISK 镜像文件是否完好。</p><p>• 上电自检功能：SDRAM、Flash 大小自动检测，SDRAM 故障检测，CPU 型号 。                            </p><p>• 上电自特殊功能：XIP 内核引导 。</p><h4 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h4><p>源码为U-Boot-1.1.6  版本。从 sourceforge 网站下载 U-Boot-1.1.6.tar.bz2后解压即得到全部源码。</p><p>U-Boot-1.1.6 根目录下共有 26 个子目录，可以分为 4 类。</p><p>（1）平台相关的或开发板相关的。<br>​    （2）通用的函数。<br>​    （3）通用的设备驱动程序。<br>​    （4）U-Boot 工具、示例程序、文档 。</p><p>这 26 个子目录的功能与作用如表  </p><p>详细参考：嵌入式Linux应用开发完全手册的15.2.2 U-Boot 源码结构部分</p><h4 id="U-Boot-的配置、编译、连接"><a href="#U-Boot-的配置、编译、连接" class="headerlink" title="U-Boot 的配置、编译、连接"></a>U-Boot 的配置、编译、连接</h4><p>要想了解对于某款开发板，使用哪些文件、哪个文件首先执行、可执行文件占用内存的情况，最好的方法就是阅读它的 Makefile。</p><p>如果要使用开发板 board/&lt;board_name&gt;，就先执行“make &lt;board_name&gt;_config”命令进行配置，然后执行“make all”，就可以生成如下 3个文件。</p><p>• U-Boot.bin：二进制可执行文件，它就是可以直接烧入 ROM、NOR Flash 的文件。<br>​    • U-Boot：ELF 格式的可执行文件。<br>​    • U-Boot.srec：Motorola S-Record 格式的可执行文件。</p><p>例如：S3C2410 的开发板，执行“make smdk2410_config”、“make all”后生成的 U-Boot.bin可以烧入 NOR Flash 中运行</p><h5 id="U-Boot-的配置"><a href="#U-Boot-的配置" class="headerlink" title="U-Boot 的配置"></a>U-Boot 的配置</h5><p>(1). S3C2410 的开发板，执行“make smdk2410_config”</p><p>在顶层 Makefile 中可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRCTREE := $(CURDIR) </span><br><span class="line">……</span><br><span class="line">MKCONFIG := $(SRCTREE)/mkconfig </span><br><span class="line">……</span><br><span class="line">smdk2410_config : unconfig </span><br><span class="line">  @$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>则其中的 MKCONFIG 就是根目录下的 mkconfig文件。$(@:_config=)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。</p><p>所以“make smdk2410fi”实际上就是执行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>补充：在 mkconfig 文件开头第 6 行给出了它的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span> # Parameters: Target Architecture CPU Board [VENDOR][SOC]</span><br></pre></td></tr></table></figure><p>对于 S3C2410、S3C2440，它们被称为 SoC(System on Chip)，上面除 CPU 外，还集成了包括 UART、USB 控制器、NAND Flash 控制器等设备（称为片内外设）。S3C2410/S3C2440 中的 CPU 为 ARM920T。</p><p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p><h5 id="U-Boot-的编译、连接"><a href="#U-Boot-的编译、连接" class="headerlink" title="U-Boot 的编译、连接"></a>U-Boot 的编译、连接</h5><p>配置完后，执行“make all”即可编译</p><p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p><h5 id="U-Boot-的使用"><a href="#U-Boot-的使用" class="headerlink" title="U-Boot 的使用"></a>U-Boot 的使用</h5><p>U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p><p>我们知道u-boot，可以运行可是命令，以及支持串口下载、网络下载等功能以方便开发中调式。但这篇文章中并不介绍u-boot 的用法。后续会补充详细 的u-boot常用命令以及开发中如何使用串口和网络下载功能。以及u-boot的实际使用操作。</p><h2 id="移植linux内核"><a href="#移植linux内核" class="headerlink" title="移植linux内核"></a>移植linux内核</h2><p>这部分我们主要了解熟悉linux内核。知道如何给内核打补丁，配置内核及编译内核等内容。</p><p>准备：</p><p>内核源码：2.6.22.6.tar.bz2</p><p>补丁文件：patch-2.6.22.bz2</p><h3 id="内核源码结构分析及Makefile分析"><a href="#内核源码结构分析及Makefile分析" class="headerlink" title="内核源码结构分析及Makefile分析"></a>内核源码结构分析及Makefile分析</h3><h4 id="内核源码结构分析"><a href="#内核源码结构分析" class="headerlink" title="内核源码结构分析"></a>内核源码结构分析</h4><p>略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移植-U-Boot&quot;&gt;&lt;a href=&quot;#移植-U-Boot&quot; class=&quot;headerlink&quot; title=&quot;移植 U-Boot&quot;&gt;&lt;/a&gt;移植 U-Boot&lt;/h2&gt;&lt;h3 id=&quot;Bootloader-简介&quot;&gt;&lt;a href=&quot;#Bootloader-简
      
    
    </summary>
    
      <category term="第二阶段" scheme="https://github.com/SetCalm/setcalm.github.io/categories/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下写一个简单的驱动程序</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-26-%E5%9C%A8Linux%E4%B8%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html</id>
    <published>2018-12-26T15:12:10.000Z</published>
    <updated>2018-12-26T16:46:47.600Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符设备驱动程序之概述</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-25-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%A6%82%E8%BF%B0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-25-字符设备驱动程序之概述.html</id>
    <published>2018-12-25T13:57:27.000Z</published>
    <updated>2018-12-26T15:11:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux程序启动过程"><a href="#Linux程序启动过程" class="headerlink" title="Linux程序启动过程"></a>Linux程序启动过程</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_22-01-25.png" alt="Snipaste_2018-12-25_22-01-25"></p><p>我们知道：通过U-boot启动内核，内核驱动应用程序。</p><p>应用程序通过open，read，write等API来实现读写文件，点灯，获取按键灯操作。它们是如何实现的呢。</p><p>API与驱动是如何实现对应如下关系的呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open--&gt;led_open</span><br><span class="line">read--&gt;led_read</span><br><span class="line">write--》led_write</span><br></pre></td></tr></table></figure><p>下面简单讨论如何实现的映射关系</p><p>一个简单的应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   fd=open(<span class="string">"/dev/led"</span>,O_RDWD);</span><br><span class="line">    write(fd1,&amp;val,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    fd2=open(<span class="string">"hello.txt"</span>,O_DWD);</span><br><span class="line">    write(fd2,&amp;va1,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开led的过程</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_22-48-27.png" alt="Snipaste_2018-12-25_22-48-27"></p><p>C库的open是如何进入内核的led.open</p><ol><li><p>open调用实际上是执行一个swi val汇编指令引发异常。当发生异常后，会进入内核的异常处理函数</p></li><li><p>system call Interface（系统调用接口）①根据异常处理函数发生原因val值，调用不同驱动函数（system_open）。</p></li><li><p>VFS(虚拟文件系统)最终根据打开的文件/dev/led）找到相应的驱动程序led_open。</p></li><li><p>执行led_open程序，打开led。</p></li></ol><h2 id="设备调用框架"><a href="#设备调用框架" class="headerlink" title="设备调用框架"></a>设备调用框架</h2><p>   <img src="D:\MyBlog\图片\Snipaste_2018-12-26_00-10-13.png" alt="Snipaste_2018-12-26_00-10-13"></p><ol><li>应用程序调用C库的函数（open，read，write）或直接使用Linux系统调用接口①</li><li>C库函数调(例：open)用实际上是执行一个swi val汇编指令引发异常。当发生异常后，会进入内核的异常处理函数②</li><li>Linux系统调用接口根据异常处理函数发生原因val值，调用VFS中不同驱动函数（system_open）。③</li><li>VFS(虚拟文件系统)最终根据打开文件的属性找到更底层的程序。</li><li>执行驱动程序</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_21-29-57.png" alt="Snipaste_2018-12-26_21-29-57"></p><p>应用层如何调用驱动</p><ol><li><p>应用层：Open(“/dev/xxx”,   )：打开”/dev/xxx”文件，参看属性：字符设备，及主设备号（major）：111。然后根据在VFS找到对应major的结构体;</p></li><li><p>内核层：VFS对应major的结构体保存有入口函数 register_chrdev();信息</p><p>​         register_chrdev()根据major调用相应的file_operations()，</p></li><li><p>驱动层：file调用相应的驱动程序函数led_open();</p></li></ol><p>用户空间</p><p>vfs major</p><p>内核空间</p><p>驱动</p><p>驱动程序：file_open</p><h2 id="驱动程序框架"><a href="#驱动程序框架" class="headerlink" title="驱动程序框架"></a>驱动程序框架</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_23-08-17.png" alt="Snipaste_2018-12-25_23-08-17"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_00-25-20.png" alt="Snipaste_2018-12-26_00-25-20"></p><h3 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h3><p>写出驱动程序led_open，led_write，led_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_leds_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buff, </span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp)</span></span>&#123;&#125;</span><br><span class="line">                                         <span class="function"><span class="keyword">static</span> ssize_t <span class="title">s3c24xx_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> * ppos)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>VFS:将驱动程序告诉内核的VFS。</p><p>​    定义一个结构体static struct file_operations()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">s3c24xx_leds_fops</span> = &#123;</span></span><br><span class="line">    .owner  =   THIS_MODULE,    <span class="comment">/* 这是一个宏，推向编译模块时自动创建的__this_module变量 */</span></span><br><span class="line">    .open   =   s3c24xx_leds_open,     </span><br><span class="line">.read=s3c24xx_leds_read,   </span><br><span class="line">.write=s3c24xx_leds_write,   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="system-call-Interface"><a href="#system-call-Interface" class="headerlink" title="system call Interface"></a>system call Interface</h3><p>注册到内核VFS：register_chrdev()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);</span><br></pre></td></tr></table></figure><p>谁调用驱动——&gt;驱动人口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">s3c24xx_leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);<span class="comment">//注册到内核VFS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(s3c24xx_leds_init);<span class="comment">//初始化函数</span></span><br></pre></td></tr></table></figure><p>int register_chrdev（unsigned int major，const char <em> name，struct file_operations </em> fops);</p><p>注册字符设备分配设备名。设备名注册到chrdev结构图内</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_01-24-07.png" alt="Snipaste_2018-12-26_01-24-07"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>open(“/dev/led”,O_RDWD);根据设备名major找到驱动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux程序启动过程&quot;&gt;&lt;a href=&quot;#Linux程序启动过程&quot; class=&quot;headerlink&quot; title=&quot;Linux程序启动过程&quot;&gt;&lt;/a&gt;Linux程序启动过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_20
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LS80-UBOOT</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-25-LS80-UBOOT.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-25-LS80-UBOOT.html</id>
    <published>2018-12-24T17:50:08.000Z</published>
    <updated>2018-12-25T13:57:42.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux如何启动"><a href="#linux如何启动" class="headerlink" title="linux如何启动"></a>linux如何启动</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_01-53-36.png" alt="Snipaste_2018-12-25_01-53-36"></p><p>bootload的目的：启动内核</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_04-00-13.png" alt="Snipaste_2018-12-25_04-00-13"></p><ol><li>u-boot功能：</li><li>关看门狗</li><li>初始化时钟</li><li>初始化SDRAM</li><li>从Flash读出内核</li><li>附加功能（开发功能：方便开发）<ul><li>烧写Flash</li><li>网卡</li><li>USB 串口</li></ul></li><li>启动内内核</li></ol><h2 id="u-boot体验"><a href="#u-boot体验" class="headerlink" title="u-boot体验"></a>u-boot体验</h2><p>uboot的四重奏</p><ol><li>解压缩</li><li>打补丁</li><li>配置</li><li>编译</li></ol><h3 id="0-文件"><a href="#0-文件" class="headerlink" title="0.文件"></a>0.文件</h3><p>源文件：u-boot-1.1.6.tar.bz2</p><p>补丁文件：u-boot-1.1.6_jz2440.patch</p><h3 id="1-解压缩"><a href="#1-解压缩" class="headerlink" title="1.解压缩"></a>1.解压缩</h3><p>解压u-boot-1.1.6.tar.bz2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>tar -xjf u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2</span><br><span class="line"><span class="number">2.</span>cd u-boot<span class="number">-1.1</span><span class="number">.6</span></span><br></pre></td></tr></table></figure><h3 id="2-打补丁"><a href="#2-打补丁" class="headerlink" title="2.打补丁"></a>2.打补丁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../u-boot-1.1.6_jz2440.patc</span><br></pre></td></tr></table></figure><ol><li><p>patch：打补丁命令</p></li><li><p>-p1:补丁打在哪里的位置：</p><p>打开u-boot-1.1.6_jz2440.patc</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_02-27-00.png" alt="Snipaste_2018-12-25_02-27-00"></p><p>红色为打补丁位置，因为在u-boot-1.1.6位置所以要忽略u-boot-1.1.6。此时使用-p1表示忽略一级忽略。</p><p>例：-p2：忽略u-boot-1.1.6/board/</p></li><li><p>../u-boot-1.1.6_jz2440.patc为指示补丁文件所在目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ ls<span class="comment">//0.查看源文件，补丁文件</span></span><br><span class="line">u-boot<span class="number">-1.1</span><span class="number">.6</span>_jz2440.patch  u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2</span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ tar -xjf u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2<span class="comment">//1.解压源文件</span></span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ cd u-boot<span class="number">-1.1</span><span class="number">.6</span>/  <span class="comment">//cd 到解压后源文件</span></span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot/u-boot<span class="number">-1.1</span><span class="number">.6</span>$ patch -p1 &lt; ../u-boot<span class="number">-1.1</span><span class="number">.6</span>_jz2440.patch  <span class="comment">//打补丁源文件</span></span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/<span class="number">100</span>ask24x0.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/boot_init.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/config.mk</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/flash.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/lowlevel_init.S</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/Makefile</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/u-boot.lds</span><br><span class="line">patching file board/MAI/bios_emulator/scitech/src/v86bios/lex.l</span><br><span class="line">patching file common/cmd_bootm.c</span><br><span class="line">patching file common/cmd_load.c</span><br><span class="line">patching file common/cmd_menu_bak.c</span><br><span class="line">patching file common/cmd_menu.c</span><br><span class="line">patching file common/cmd_nand.c</span><br><span class="line">patching file common/cmd_nand_legacy.c</span><br><span class="line">patching file common/cmd_suspend.c</span><br><span class="line">patching file common/cmd_usbslave.c</span><br><span class="line">patching file common/env_nand.c</span><br><span class="line">patching file common/main.c</span><br><span class="line">patching file common/Makefile</span><br><span class="line">patching file cpu/arm920t/cpu.c</span><br><span class="line">patching file cpu/arm920t/Makefile</span><br><span class="line">patching file cpu/arm920t/s3c24x0/interrupts.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/Makefile</span><br><span class="line">patching file cpu/arm920t/s3c24x0/nand_flash.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/nand_flash_legacy.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/speed.c</span><br><span class="line">patching file cpu/arm920t/start.S</span><br><span class="line">patching file cpu/arm920t/suspend.S</span><br><span class="line">patching file doc/README.SBC8560</span><br><span class="line">patching file drivers/cfi_flash.c</span><br><span class="line">patching file drivers/dm9000x.c</span><br><span class="line">patching file drivers/jedec_flash.c</span><br><span class="line">patching file drivers/Makefile</span><br><span class="line">patching file drivers/nand/nand_base.c</span><br><span class="line">patching file drivers/nand/nand_ids.c</span><br><span class="line">patching file drivers/nand/nand_util.c</span><br><span class="line">patching file drivers/nand_legacy/nand_legacy.c</span><br><span class="line">patching file drivers/usb/<span class="number">2440u</span>sb.h</span><br><span class="line">patching file drivers/usb/Makefile</span><br><span class="line">patching file drivers/usb/mrgtmp0</span><br><span class="line">patching file drivers/usb/usb.h</span><br><span class="line">patching file drivers/usb/usbin.c</span><br><span class="line">patching file drivers/usb/usbin.h</span><br><span class="line">patching file drivers/usb/usbinit.c</span><br><span class="line">patching file drivers/usb/usbinit.h</span><br><span class="line">patching file drivers/usb/usblib.c</span><br><span class="line">patching file drivers/usb/usblib.h</span><br><span class="line">patching file drivers/usb/usbmain.c</span><br><span class="line">patching file drivers/usb/usbmain.h</span><br><span class="line">patching file drivers/usb/usbout.c</span><br><span class="line">patching file drivers/usb/usbout.h</span><br><span class="line">patching file drivers/usb/usbsetup.c</span><br><span class="line">patching file drivers/usb/usbsetup.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/mach-types.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/types.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/u-boot-arm.h</span><br><span class="line">patching file include/configs/<span class="number">100</span>ask24x0.h</span><br><span class="line">patching file include/configs/SBC8560.h</span><br><span class="line">patching file include/def.h</span><br><span class="line">patching file include/flash.h</span><br><span class="line">patching file include/nand.h</span><br><span class="line">patching file include/s3c2410.h</span><br><span class="line">patching file include/s3c24x0.h</span><br><span class="line">patching file include/usb.h</span><br><span class="line">patching file lib_arm/armlinux.c</span><br><span class="line">patching file lib_arm/board.c</span><br><span class="line">patching file Makefile</span><br><span class="line">patching file net/net.c</span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot/u-boot<span class="number">-1.1</span><span class="number">.6</span>$</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="number">100</span>ask24x0_config</span><br></pre></td></tr></table></figure><h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>按上面执行即可获得u-boot.bin文件</p><h3 id="设置u-boot环境变量"><a href="#设置u-boot环境变量" class="headerlink" title="设置u-boot环境变量"></a>设置u-boot环境变量</h3><p>如下图4步走：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">100</span>ask Bootloader <span class="keyword">for</span> OpenJTAG #####</span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">[o] Download u-boot to Nor Flash</span><br><span class="line">[c] Re-scan Nor Flash</span><br><span class="line">[u] Copy bootloader from nand to nor</span><br><span class="line">[v] Copy bootloader from nor to nand</span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">[d] Download to SDRAM &amp; Run</span><br><span class="line">[z] Download zImage into RAM</span><br><span class="line">[g] Boot linux from RAM</span><br><span class="line">[f] Format the Nand Flash</span><br><span class="line">[s] Set the boot parameters</span><br><span class="line">[b] Boot the system</span><br><span class="line">[r] Reboot u-boot</span><br><span class="line">[q] Quit from menu</span><br><span class="line">Enter your selection: q <span class="comment">//1.退出</span></span><br><span class="line">OpenJTAG&gt; print  <span class="comment">//2.打印Uboot环境</span></span><br><span class="line">bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,<span class="number">115200</span></span><br><span class="line">bootcmd=nand read.jffs2 <span class="number">0x30007FC0</span> kernel; bootm <span class="number">0x30007FC0</span></span><br><span class="line">baudrate=<span class="number">115200</span></span><br><span class="line">ethaddr=<span class="number">08</span>:<span class="number">00</span>:<span class="number">3</span>e:<span class="number">26</span>:<span class="number">0</span>a:<span class="number">5b</span></span><br><span class="line">ipaddr=<span class="number">192.168</span><span class="number">.1</span><span class="number">.17</span></span><br><span class="line">serverip=<span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">netmask=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">mtdids=nand0=nandflash0</span><br><span class="line">mtdparts=mtdparts=nandflash0:<span class="number">256</span>k@<span class="number">0</span>(bootloader),<span class="number">128</span>k(params),<span class="number">2</span>m(kernel),-(root)</span><br><span class="line">bootdelay=<span class="number">5</span></span><br><span class="line"><span class="built_in">stdin</span>=serial</span><br><span class="line"><span class="built_in">stdout</span>=serial</span><br><span class="line"><span class="built_in">stderr</span>=serial</span><br><span class="line">partition=nand0,<span class="number">0</span></span><br><span class="line">mtddevnum=<span class="number">0</span></span><br><span class="line">mtddevname=bootloader</span><br><span class="line"></span><br><span class="line">Environment size: <span class="number">450</span>/<span class="number">131068</span> bytes</span><br><span class="line">OpenJTAG&gt; <span class="built_in">set</span> bootdelay <span class="number">10</span> <span class="comment">//3.重新配置启动计数时间</span></span><br><span class="line">OpenJTAG&gt; save <span class="comment">//4，保存</span></span><br><span class="line">Saving Environment to NAND...</span><br><span class="line">Erasing Nand...Writing to Nand... done</span><br><span class="line">OpenJTAG&gt;</span><br><span class="line">penJTAG&gt; reset<span class="comment">//5.复位重启</span></span><br></pre></td></tr></table></figure><h3 id="分析make-100ask24x0-config"><a href="#分析make-100ask24x0-config" class="headerlink" title="分析make 100ask24x0_config"></a>分析make 100ask24x0_config</h3><p>打开Makefile找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>ask24x0_config:unconfig</span><br><span class="line">@$(MKCONFIG) $(@:_config=) arm arm920t <span class="number">100</span>ask24x0 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>执行：make 100ask24x0_config</p><p>等于执行：@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0脚本语句。</p><p>分析：@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0</p><ol><li><p>MKCONFIG    := $(SRCTREE)/mkconfig //源文件所在的目录下的mkconfig</p></li><li><p>$(@:_config=)  100ask24x0_config</p><p>$(@   $:当前目标即100ask24x0_config</p><p>:_config= 表示替换空</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_05-15-26.png" alt="Snipaste_2018-12-25_05-15-26"></p></li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_05-31-01.png" alt="Snipaste_2018-12-25_05-31-01"></p><p>向mkconfig传递$1~$6参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux如何启动&quot;&gt;&lt;a href=&quot;#linux如何启动&quot; class=&quot;headerlink&quot; title=&quot;linux如何启动&quot;&gt;&lt;/a&gt;linux如何启动&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_2018-12-25
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-12-21-LS7-4-UART</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-LS7-4-UART.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-LS7-4-UART.html</id>
    <published>2018-12-21T13:11:40.000Z</published>
    <updated>2018-12-24T14:30:56.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="usart功能："><a href="#usart功能：" class="headerlink" title="usart功能："></a>usart功能：</h3><p>打印调式信息</p><p>外接各种模块：gps，蓝牙，WiFi….</p><p>结构简单，可靠。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_21-17-33.png" alt="Snipaste_2018-12-21_21-17-33"></p><h3 id="简单协议"><a href="#简单协议" class="headerlink" title="简单协议"></a>简单协议</h3><p>波特率</p><p>数据格式：数据位，停止位，校验位，流量控制。</p><p>如何发送字节</p><p>假如要发送一个字节’A’;</p><p>‘A’ :0x41:0b01000001</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-22-10.png" alt="Snipaste_2018-12-21_22-22-10"></p><p>①双方约定好每一位占据的时间（波特率）</p><p>​    假设每一单位时间ts，（t=1/baud（s））</p><p>②开始时txd为高电平，当开始发送数据时把数据线拉低，计时1t（s）为开始位。</p><p>③写：ARM根据数据’A’驱动TXD的电平</p><p>   读：通过在数据的中间时间段读取电平</p><p>当8位数据发送完毕，再发送一个检验位（奇/偶检验），但随着技术提高现在几乎都为0，不校验。</p><p>④一个字节（8bit）完成后发送一个停止位（高电平，一般设置占据1/1.5/2t（s）时间）。传送完成，此时txd高电平空闲状态，等待开始下个字节发送。</p><h3 id="关于逻辑电平表示"><a href="#关于逻辑电平表示" class="headerlink" title="关于逻辑电平表示"></a>关于逻辑电平表示</h3><p>1.TTL/CMOS表示</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-26-58.png" alt="Snipaste_2018-12-21_22-26-58"></p><p>0~0.7 (y) v表示逻辑“0”，x（2）~5v表示逻辑“1”</p><p>2.RS232表示</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-28-24.png" alt="Snipaste_2018-12-21_22-28-24"></p><p>+3~012v表示逻辑“0”，-3~-12v表示逻辑“1”</p><p>总结：cmos/ttl电平范围（0~5v）小，传输距离近，RS-232电平范围（-12~+12v）大，可以距离远。一般远距离使用RS232。</p><p>cmos/ttl和rs232电平波形相反。</p><h3 id="常见串口接口"><a href="#常见串口接口" class="headerlink" title="常见串口接口"></a>常见串口接口</h3><h4 id="直接引出"><a href="#直接引出" class="headerlink" title="直接引出"></a>直接引出</h4><h4 id="RS232接口、RS485"><a href="#RS232接口、RS485" class="headerlink" title="RS232接口、RS485"></a>RS232接口、RS485</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-44-39.png" alt="Snipaste_2018-12-21_22-44-39"></p><h4 id="usb接口"><a href="#usb接口" class="headerlink" title="usb接口"></a>usb接口</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-44-49.png" alt="Snipaste_2018-12-21_22-44-49"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>参考：<a href="https://www.cnblogs.com/Ph-one/p/3994797.html" target="_blank" rel="noopener">USB/232/485/TTL/CMOS（串口通信）</a></p><p>1.USB:电脑的USB口信号时USB信号，为差分信号，电压范围：+400mV~-400mV间变化；直流电压5V 驱动电流500MA</p><p>2.232电平：　　逻辑1(MARK)=-3V～-15V　　逻辑0(SPACE)=+3～+15V</p><p>3.485电平：　　它是<a href="http://www.baidu.com/s?wd=%E5%B7%AE%E5%88%86%E4%BF%A1%E5%8F%B7&amp;hl_tag=textlink&amp;tn=SE_hldp01350_v6v6zkg6" target="_blank" rel="noopener">差分信号</a>，两信号线 ＋2V～＋6V表示“0”，　　- 6V～- 2V表示“1”。</p><p>4.TTL电平：　　一般输出高电平是3.5V，输出低电平是0.2V。</p><p>5.CMOS  ：　　门闩值为0.3VCC和0.7VCC，比如对于5V供电器件，分别为1.5V和3.5V（大概）</p><p>对于TTL器件和CMOS器件相连，如果是CMOS器件输出到TTL器件，这个也是可以直接连的，因为CMOS电平的范围是TTL输入电平范围的子集。但如果反过来就不行，因为TTL电平的输出范围要比CMOS电平的范围大，有可能出现不确定的电平状态,引起电路出现不可预知的混乱。</p><h3 id="UART-结构框图"><a href="#UART-结构框图" class="headerlink" title="UART 结构框图"></a>UART 结构框图</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_23-01-04.png" alt="Snipaste_2018-12-21_23-01-04"></p><p>程序是如何把内存的数据发送到串口？</p><p>程序把内存的数据写入FITO(先进先出)存储器内，uart单元会把FIFI的数据写入移位器（Transmit Shifiter），然后移位器（Transmit Shifiter）按照设置好协议逐位发送给串口。</p><p>当内存接收完毕，uart单元产生中断给CPU</p><p>程序是如何接收串口的数据写到串口？</p><p>uart单元会逐位接收串口的数据，然后把接收到的数据写入移位器（Receiver Shifiter）内，然后程序会把FITO(先进先出)存储器内的数据写入内存。</p><p>当内存接收完毕，uart单元产生中断给CPU</p><h2 id="软件编程"><a href="#软件编程" class="headerlink" title="软件编程"></a>软件编程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>设置引脚用于串口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置引脚用于串口 */</span></span><br><span class="line"><span class="comment">/* GPH2,3用于TxD0, RxD0 */</span></span><br><span class="line">GPHCON&amp;=~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON&amp;=~((<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line"><span class="comment">//上拉</span></span><br><span class="line">GPHUP!=((<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置波特率</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-11-56.png" alt="Snipaste_2018-12-24_21-11-56"></p></li></ol><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置波特率 */</span></span><br><span class="line"><span class="comment">/* UBRDIVn = (int)( UART clock / ( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment"> *  UART clock = 50M</span></span><br><span class="line"><span class="comment"> *  UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 设置使用PCLK时钟50MHZ,中断/查询模式 */</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure><p>​    3.设置数据格式 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置数据格式 */</span></span><br><span class="line"></span><br><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure><p>uart0_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 115200,8n1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置引脚用于串口 */</span></span><br><span class="line"><span class="comment">/* GPH2,3用于TxD0, RxD0 */</span></span><br><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置波特率 */</span></span><br><span class="line"><span class="comment">/* UBRDIVn = (int)( UART clock / ( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment"> *  UART clock = 50M</span></span><br><span class="line"><span class="comment"> *  UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* PCLK,中断/查询模式 */</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置数据格式 */</span></span><br><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位, 无较验位, 1个停止位 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-46-03.png" alt="Snipaste_2018-12-24_21-46-03"></p><p><strong>输入字节</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-46-15.png" alt="Snipaste_2018-12-24_21-46-15"></p><p>由上可知：判断是否有数据：当上面该位为0，UTXH0寄存器里面有数据，等待发送，为1时：数据发送出去，为空，此时写入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UTRSTAT0 */</span></span><br><span class="line"><span class="comment">/* UTXH0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</span><br></pre></td></tr></table></figure><p>注意在上c2440_soc.h中添加</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_22-11-30.png" alt="Snipaste_2018-12-24_22-11-30"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_22-11-12.png" alt="Snipaste_2018-12-24_22-11-12"></p><p>UTXH0地址为0向0000020（L）</p><p>数据格式为byte</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     __REG_BYTE(x)(*(volatile unsigned char *)(x)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     UTXH0                    __REG_BYTE(0x50000020)  <span class="comment">//UART 0 transmission hold</span></span></span><br></pre></td></tr></table></figure><p><strong>输出字节：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出字符串：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">putchar</span>(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* UTRSTAT0 */</span></span><br><span class="line"><span class="comment">/* UTXH0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;h3 id=&quot;usart功能：&quot;&gt;&lt;a href=&quot;#usart功能：&quot; class=&quot;headerlink&quot; title=&quot;u
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-21-LS7-4-ARM芯片时钟体系</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-2018-12-21-LS7-4-ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-2018-12-21-LS7-4-ARM芯片时钟体系.html</id>
    <published>2018-12-21T13:10:58.000Z</published>
    <updated>2018-12-24T17:48:13.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LS6-3.ARM芯片时钟体系</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-LS6-3-ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-LS6-3-ARM芯片时钟体系.html</id>
    <published>2018-12-20T16:03:42.000Z</published>
    <updated>2018-12-21T13:13:06.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时钟体系架构"><a href="#时钟体系架构" class="headerlink" title="时钟体系架构"></a>时钟体系架构</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-10-02.png" alt="Snipaste_2018-12-21_00-10-02"></p><p>cpu：fclk</p><p>AHB:高速总线（HCLK）</p><p>APB:低速总线（PCLK）</p><h3 id="时钟最大范围"><a href="#时钟最大范围" class="headerlink" title="时钟最大范围"></a>时钟最大范围</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-14-33.png" alt="Snipaste_2018-12-21_00-14-33"></p><h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>可以通过①外部引脚提供和②晶振提供</p><h2 id="JZ2240开发板时钟选择"><a href="#JZ2240开发板时钟选择" class="headerlink" title="JZ2240开发板时钟选择"></a>JZ2240开发板时钟选择</h2><h3 id="jz2240时钟源"><a href="#jz2240时钟源" class="headerlink" title="jz2240时钟源"></a>jz2240时钟源</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-22-05.png" alt="Snipaste_2018-12-21_00-22-05"></p><p>时钟源可以由外部引脚提供或者12M晶振提供，通过OM[3:2]选择使用哪个作为时钟源，选择方式如下：</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-26-49.png" alt="Snipaste_2018-12-21_00-26-49"></p><h3 id="JZ2240开发板时钟选择-1"><a href="#JZ2240开发板时钟选择-1" class="headerlink" title="JZ2240开发板时钟选择"></a>JZ2240开发板时钟选择</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-28-56.png" alt="Snipaste_2018-12-21_00-28-56"></p><p>图中看出OM[3:2]都为00:注时钟源和USB时钟源都为12M晶振。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-18-58.png" alt="Snipaste_2018-12-21_00-18-58"></p><p>三者时钟源由12M晶振提供，通过PLL(锁相环)来倍频得到FCLK：400Mhz</p><h3 id="JZ2240时钟分析"><a href="#JZ2240时钟分析" class="headerlink" title="JZ2240时钟分析"></a>JZ2240时钟分析</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-41-25.png" alt="Snipaste_2018-12-21_00-41-25"></p><ul><li><p>由①OM[3,2]选择②MPLL（主时钟源）,③UPLL（USB时钟源）的时钟源，这里OM[3,2]=00，选择MPLL，UPLL时钟为OSC（外部12M晶振）（硬件）。</p></li><li><p>时钟源通过②MPLL锁相环倍频得到⑦FCLK：400Mmz,</p></li><li><p>通过CLKCNTL获的⑤HCLK,⑥PCLK时钟</p><p>FCLK：提供给CPU</p><p>HCLK:AHB(高速总线)</p><p>PCLK:APB(低速总线)</p></li></ul><h2 id="时钟系统总结"><a href="#时钟系统总结" class="headerlink" title="时钟系统总结"></a>时钟系统总结</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-53-58.png" alt="Snipaste_2018-12-21_00-53-58"></p><h2 id="软件编程"><a href="#软件编程" class="headerlink" title="软件编程"></a>软件编程</h2><h3 id="时钟设置原理"><a href="#时钟设置原理" class="headerlink" title="时钟设置原理"></a>时钟设置原理</h3><p>通过控制MPLL，HDIV和PDIV</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_01-10-41.png" alt="Snipaste_2018-12-21_01-10-41"></p><ol><li>电源启动，复位引脚维持一段时间等待电源稳定，才输出高电平。（专用复位芯片会使复位脚等待一段时间才会高电平）</li><li>根据OM[3:2]=00,选择FCLK=12Mhz晶振提供时钟，此时CPU未运行。</li><li>等复位脚松开高电平时，cpu开始运行。此时PLL锁存OM[3:2]的值</li><li>设置PLL，此时CPU停止工作，</li><li>PLL开始工作，等待PLL输出稳定频率，CPU 开始运行</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_19-53-38.png" alt="Snipaste_2018-12-21_19-53-38"></p><p>我们要设置S3C2440的FCLK=400Mhz，HCLK=100Mhz，PCLK=50Mhz</p><p>1.使  FCLK=400M:通过MPLLCON设置。</p><p>2.使HCLK=100Mhz，PCLK=50Mhz：设置CLKDIV</p><p>HCLK=FCLK/4</p><p>PCLK=FCLK/8=HCLK/2</p><h3 id="如何设置系统设置"><a href="#如何设置系统设置" class="headerlink" title="如何设置系统设置"></a>如何设置系统设置</h3><p>如何通过程序控制MPLL，HDIV和PDIV</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>1.使  FCLK=400M:通过MPLLCON设置</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-22-49.png" alt="Snipaste_2018-12-21_20-22-49"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-27-42.png" alt="Snipaste_2018-12-21_20-27-42"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-24-14.png" alt="Snipaste_2018-12-21_20-24-14"></p><p>从图看出要使FCLK=400M:<strong>MPLLCON=(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</strong></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>2.使HCLK=100Mhz，PCLK=50Mhz：设置CLKDIV</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-10-08.png" alt="Snipaste_2018-12-21_20-10-08"></p><p>HCLK=FCLK/4:CLKDIVN[2:1]=0b10</p><p>PCLK=FCLK/8=HCLK/2:CLKDIVN[0]=1</p><p>即：CLKDIVN=0b101=0x05  FCLK:HCLK:PCLK=1:4：8</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-46-14.png" alt="Snipaste_2018-12-21_20-46-14"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该命令是使处理器工作在异步模式下，</p><p>HDIV不等于0 ，需要设置在异步模式，否则CPU工作在HCLK=100时钟。</p><h3 id="开编程"><a href="#开编程" class="headerlink" title="开编程"></a>开编程</h3><p>由于时钟使用到汇编的协处理器指令，所以时钟程序使用汇编来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span></span><br><span class="line"><span class="comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000000</span></span><br><span class="line">ldr r1, =<span class="number">0xFFFFFFFF</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000014</span></span><br><span class="line">ldr r1, =<span class="number">0x5</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置CPU工作于异步模式 */</span></span><br><span class="line">mrc p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line">orr r0,r0,#<span class="number">0xc0000000</span>   <span class="comment">//R1_nF:OR:R1_iA</span></span><br><span class="line">mcr p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span></span><br><span class="line"><span class="comment"> *  m = MDIV+8 = 92+8=100</span></span><br><span class="line"><span class="comment"> *  p = PDIV+2 = 1+2 = 3</span></span><br><span class="line"><span class="comment"> *  s = SDIV = 1</span></span><br><span class="line"><span class="comment"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000004</span></span><br><span class="line">ldr r1, =(<span class="number">92</span>&lt;&lt;<span class="number">12</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span></span><br><span class="line"><span class="comment"> * 然后CPU工作于新的频率FCLK</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时钟体系架构&quot;&gt;&lt;a href=&quot;#时钟体系架构&quot; class=&quot;headerlink&quot; title=&quot;时钟体系架构&quot;&gt;&lt;/a&gt;时钟体系架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_2018-12-21_00-10-02.pn
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-20-LS5-2.key之led控制.md</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-20-LS5-2-key%E4%B9%8Bled%E6%8E%A7%E5%88%B6.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-20-LS5-2-key之led控制.html</id>
    <published>2018-12-20T09:39:31.000Z</published>
    <updated>2018-12-20T16:01:30.495Z</updated>
    
    <content type="html"><![CDATA[<p>简介：</p><p>通过开发板上的S2,S3,S4控制D10,D11,D12的亮灭</p><ul><li>按下S2，D10亮；松开S2，D10灭。</li><li>按下S3，D11亮；松开S3，D11灭。</li><li>按下S4，D12亮；松开S4，D12灭。</li></ul><p>原理图：</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-12-16.png" alt="Snipaste_2018-12-20_18-12-16"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-11-19.png" alt="Snipaste_2018-12-20_18-11-19"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-09-17.png" alt="Snipaste_2018-12-20_18-09-17"></p><p>通过原理图看出S2(GPF0)，S3(GPF2)，S4(GPG3)。D10(GPF4)，D11(GPF5)，D12(GPF6).</p><p>当按键松开时为高电平，按下为低电平。</p><p>当D10~D12输出低电平时亮，高电平时，灭</p><p>软件编程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * key控制LED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s3c2440_soc.h"</span><span class="comment">//引入头文件，寄存器定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val1;</span><br><span class="line"><span class="keyword">int</span> val2;</span><br><span class="line"><span class="comment">/*配置GPF4/5/6为输出引脚*/</span></span><br><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">12</span>));</span><br><span class="line">GPFCON |=  ((<span class="number">1</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置GPF0/2，GPG3为输入引脚*/</span></span><br><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">val1=GPFDAT;<span class="comment">//保存GPFDAT的值</span></span><br><span class="line">val2=GPGDAT;<span class="comment">//保存GPGDAT的值</span></span><br><span class="line"><span class="keyword">if</span>(val1&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val1&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val2&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介：&lt;/p&gt;
&lt;p&gt;通过开发板上的S2,S3,S4控制D10,D11,D12的亮灭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按下S2，D10亮；松开S2，D10灭。&lt;/li&gt;
&lt;li&gt;按下S3，D11亮；松开S3，D11灭。&lt;/li&gt;
&lt;li&gt;按下S4，D12亮；松开S4，D12灭。&lt;
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-%E9%98%BF%E9%87%8C%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-阿里图床测试.html</id>
    <published>2018-12-19T20:06:41.821Z</published>
    <updated>2018-12-20T06:21:11.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里图床测试"><a href="#阿里图床测试" class="headerlink" title="阿里图床测试"></a>阿里图床测试</h1><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-31-14.png" alt="Snipaste_2018-12-20_03-19-45"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阿里图床测试&quot;&gt;&lt;a href=&quot;#阿里图床测试&quot; class=&quot;headerlink&quot; title=&quot;阿里图床测试&quot;&gt;&lt;/a&gt;阿里图床测试&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://setcalm.oss-cn-zhangjiakou.aliyuncs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-12-14-LS1-开发之系统安装</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-18-LS2-%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-18-LS2-开发之系统安装.html</id>
    <published>2018-12-18T09:51:48.000Z</published>
    <updated>2018-12-20T06:20:58.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="烧录软件安装"><a href="#烧录软件安装" class="headerlink" title="烧录软件安装"></a>烧录软件安装</h2><h3 id="EasyOpenJTAG介绍及安装程序"><a href="#EasyOpenJTAG介绍及安装程序" class="headerlink" title="EasyOpenJTAG介绍及安装程序"></a>EasyOpenJTAG介绍及安装程序</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><a id="more"></a><p>该部分为win 8,10 系统需要设置，非win 8,10 系统略过。 </p><p>由于 Windows10 的安全机制，安装 EasyOpenJTAG 更麻烦一点： 需要更改 Windows 的<br>启动模式， 禁用“驱动程序签名强制”功能。</p><p>详细教程：<a href="https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html</a></p><p>点击桌面右下角的通知图标，选择“所有设置”，如图 4.11 所示。然后选择“更新和安全”，如图 4.12 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-50-55.png" alt="Snipaste_2018-12-17_17-50-55"></p><p>(1) 选择左边选项栏中的“恢复”，选择高级启动的“立即重启”，然后选择“更新和安全”，如图 4.13 所示。然后选择“疑难解答”，如图 4.14 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-52-03.png" alt="Snipaste_2018-12-17_17-52-03"></p><p>(2) 接着在“高级选项”里选择“启动设置”，如图 4.15 所示。在“启动设置”里面选择重启，如图 4.16 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-47-16.png" alt="Snipaste_2018-12-17_17-47-16">(3) 此时电脑会重启，重启之后不会直接进入系统界面，而是进入图 4.17 所示的“启<br>动设置“界面，按下键盘的” F7“，禁用驱动程序强制签名。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-52-59.png" alt="Snipaste_2018-12-17_17-52-59"></p><p>如下步骤是正常的驱动安装流程，非 win 8,10 系统(比如 winxp,win7 系统)直接从这里开始。 </p><h4 id="2-开始安装-EasyOpenJTAG驱动"><a href="#2-开始安装-EasyOpenJTAG驱动" class="headerlink" title="2.开始安装 EasyOpenJTAG驱动"></a>2.开始安装 EasyOpenJTAG驱动</h4><p>(1) 将 EasyOpenJTAG 插入电脑 USB 口。打开“设备管理器”。在设备管理器可以看到两个感叹号图标的设备，这表示 EasyOpenJTAG 未安装驱动。 选中第一个带感叹号的设备，右键鼠标，在弹出的菜单中选择“更新驱动程序”，如图 所示</p><p> <img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_18-07-57.png" alt="Snipaste_2018-12-17_18-07-57"></p><p>(2) 选择“浏览我的计算机以查找驱动程序软件”再选择驱动程序的路径，点击“下一步”，如图 4.21 所示。在弹出的 Windows 安全警告窗口里，选择“始终安装此驱动程序软件”，如图 4.22 所示 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_15-50-26.png" alt="Snipaste_2018-12-18_15-50-26"></p><p>（4）之后看到如图 4.23 所示的安装成功提示信息。同样的方法，点击第二个带感叹号的<br>设备。 这样一共重复三次即可更新完所有驱动，驱动安装好后设备管理器显示:一个“ US B<br>Serial Port” ,一个“100ASK JTAG”，一个“100ASK Serial Port”，如图 4.24 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_15-52-39.png" alt="Snipaste_2018-12-18_15-52-39"></p><p>（安装完成）</p><h4 id="3-安装-EasyOpenJTAG应用程序-（oflash）"><a href="#3-安装-EasyOpenJTAG应用程序-（oflash）" class="headerlink" title="3.安装 EasyOpenJTAG应用程序 （oflash）"></a>3.安装 EasyOpenJTAG应用程序 （oflash）</h4><p> （1） 双击“01.OpenOCD with GUI setup.exe “一路OK，就完成。【略】</p><p>（2）测试是否安装成功。 </p><p>打开 Windows 命令窗口，如图 4.9 所示。 在窗口输入“oflash”命令即可启动 oflash，如图 4.10 所示即表示安装成功 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_16-05-24.png" alt="Snipaste_2018-12-18_16-05-24"></p><h4 id="4-失败解决方法"><a href="#4-失败解决方法" class="headerlink" title="4.失败解决方法"></a>4.失败解决方法</h4><p>无法找到某环境，配置环境变量。</p><p>找到OpenJTAG的bin 目录，将其按照下面加入环境变量。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_16-21-55.png" alt="Snipaste_2018-12-18_16-21-55"></p><h3 id="EasyOpenJTAG烧录程序"><a href="#EasyOpenJTAG烧录程序" class="headerlink" title="EasyOpenJTAG烧录程序"></a>EasyOpenJTAG烧录程序</h3><ul><li>用于烧录.bin文件（uboot.bin，裸板程序），只能烧小文件，速度极慢。 </li><li>uboot文件可以烧录到–&gt;Nor,Nand。裸板文件只能烧录到–&gt;Nand。</li></ul><h4 id="烧录leds-bin文件（cmd下oflash）"><a href="#烧录leds-bin文件（cmd下oflash）" class="headerlink" title="烧录leds.bin文件（cmd下oflash）"></a>烧录leds.bin文件（cmd下oflash）</h4><ul><li><p>选择启动方式：Nand启动</p></li><li><p>选择要烧录的.bin 文件路径。</p><p>（D:\韦东山\1_ARM裸机1期加强版(新1期)\源码文档图片\源码\源码<em>20180321</em>添加传感器\001_led_on_008_003）</p></li><li><p>开始oflash烧录</p></li></ul><ol><li>打开cmdwindows+R：选择烧录文件盘符：D</li><li>cd 到烧录目录：cd:D:\韦东山\1_ARM裸机1期加强版(新1期)\源码文档图片\源码\源码<em>20180321</em>添加传感器\001_led_on_008_003</li><li>启动oflash并选择烧录.bin文件：oflash led_on.bin</li><li>选择烧录工具：enter the number：0</li><li>选择烧录芯片：enter the number：1</li><li>选择烧录地址：select the function to test：0（裸机文件只能从Nand启动）</li><li>再次确认烧录地址：select the function to test：0</li><li>烧录到第0块：input target block number：0</li></ol><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_17-15-08.png" alt="Snipaste_2018-12-18_17-15-08"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_17-21-51.png" alt="Snipaste_2018-12-18_17-21-51"></p><p>烧录成功ok.</p><p>拔掉OpenJTGA,重启开发板，观察led。</p><p>使用usbshaolu</p><h2 id="如何烧录系统"><a href="#如何烧录系统" class="headerlink" title="如何烧录系统"></a>如何烧录系统</h2><p>我们知道使用OpenJTGA烧录一个Uboot文件用了几分钟，烧写速度非常的慢。在实际开发中经常要修改编译，那有没有更快的烧写方法呢。因此引入使用Uboot通过usb烧写bin 文件。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Windows和linux系统启动比较"><a href="#Windows和linux系统启动比较" class="headerlink" title="Windows和linux系统启动比较"></a>Windows和linux系统启动比较</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-55-36.png" alt="Snipaste_2018-12-18_18-55-36"></p><p>图1-1</p><h4 id="jz2440v3的flash介绍"><a href="#jz2440v3的flash介绍" class="headerlink" title="jz2440v3的flash介绍"></a>jz2440v3的flash介绍</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-58-23.png" alt="Snipaste_2018-12-18_18-58-23"></p><p>图1-2</p><p>　Bootloader 即引导加载程序，是系统加电后运行的第一段<a href="https://www.baidu.com/s?wd=%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">软件代码</a>。简单的说u-boot是bootloader，它们所完成的任务也大同小异。</p><p>uboot可以烧录在Nor，Nand 上，一般u-boot烧录在Nor，用于系统启动引导。</p><p>Nand比较大，内核及文件系统存在于Nand Flash</p><h4 id="jz2440烧录框架"><a href="#jz2440烧录框架" class="headerlink" title="jz2440烧录框架"></a>jz2440烧录框架</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-45-45.png" alt="Snipaste_2018-12-18_18-45-45"></p><ol><li>将启动设置在Nor启动</li><li>将u-boot烧录在到Nor Flsh上</li><li>开机，Nor启动，uboot启动</li><li>使用uboot的usb下载功能，使用pc传文件给开发板（kernel及rootfs）</li><li>uboot收到文件后再烧录到flash</li></ol><h4 id="如何烧录系统-1"><a href="#如何烧录系统-1" class="headerlink" title="如何烧录系统"></a>如何烧录系统</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-59-59.png" alt="Snipaste_2018-12-18_18-59-59"></p><p>图1-3</p><ol><li>通过op、eop烧录U-boot到Nor</li><li>通过usb烧录Kernel和文件系统。</li></ol><h2 id="开始烧录系统"><a href="#开始烧录系统" class="headerlink" title="开始烧录系统"></a>开始烧录系统</h2><h3 id="设置启动方式"><a href="#设置启动方式" class="headerlink" title="设置启动方式"></a>设置启动方式</h3><p>将启动设置在Nor启动</p><h3 id="将u-boot烧录在到Nor-Flsh上"><a href="#将u-boot烧录在到Nor-Flsh上" class="headerlink" title="将u-boot烧录在到Nor Flsh上"></a>将u-boot烧录在到Nor Flsh上</h3><p>参考：上面<strong>EasyOpenJTAG烧录程序</strong></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-12-07.png" alt="Snipaste_2018-12-18_18-12-07"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-13-24.png" alt="Snipaste_2018-12-18_18-13-24"></p><p>## </p><h3 id="开机，Nor启动，uboot启动"><a href="#开机，Nor启动，uboot启动" class="headerlink" title="开机，Nor启动，uboot启动"></a>开机，Nor启动，uboot启动</h3><p>拔掉OpenJTAG,设置Nor启动，连接usb及com到pc，使用MobaXterm打开串口，重新启动。</p><p>让开发板运行于 UBOOT，不要让它启动进入内核（在 UBOOT 启动时在串口<br>工具里按下空格【计数三秒内】，阻止它启动 Linux ）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_20-43-46.png" alt="Snipaste_2018-12-18_20-43-46"></p><h3 id="usb传文件给开发板（kernel及rootfs）"><a href="#usb传文件给开发板（kernel及rootfs）" class="headerlink" title="usb传文件给开发板（kernel及rootfs）"></a>usb传文件给开发板（kernel及rootfs）</h3><h4 id="烧录内核"><a href="#烧录内核" class="headerlink" title="烧录内核"></a>烧录内核</h4><p>MobaXterm命令内输入：k</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_20-49-09.png" alt="Snipaste_2018-12-18_20-49-09"></p><p>打开DNW,选择烧录内核</p><p>（usb驱动和DNW安装在下面）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-08-49.png" alt="Snipaste_2018-12-18_21-08-49"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-12-14.png" alt="Snipaste_2018-12-18_21-12-14"></p><h4 id="烧录文件系统"><a href="#烧录文件系统" class="headerlink" title="烧录文件系统"></a>烧录文件系统</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-10-13.png" alt="Snipaste_2018-12-18_21-10-13"></p><h4 id="擦除分区"><a href="#擦除分区" class="headerlink" title="擦除分区"></a>擦除分区</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-17-25.png" alt="Snipaste_2018-12-18_21-17-25"></p><h4 id="完成重启并校准"><a href="#完成重启并校准" class="headerlink" title="完成重启并校准"></a>完成重启并校准</h4><p>启动，重启要求校准，校准失败执行下面命令。会再次校准。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-19-50.png" alt="Snipaste_2018-12-18_21-19-50"></p><h3 id="补充：usb驱动和DNW安装"><a href="#补充：usb驱动和DNW安装" class="headerlink" title="补充：usb驱动和DNW安装"></a>补充：usb驱动和DNW安装</h3><p>注意：一定要完成下面连点：</p><ol><li>连接usb线及com线到pc</li><li>使用MobaXterm打开串口，重新启动，让开发板运行于 UBOOT（在开发板启动时在串口<br>工具里按下空格【计数三秒内】，阻止它启动 Linux ）</li></ol><p>3.运行 zadig-2.3.exe，可以看到如下图 4.25 界面： </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-34-47.png" alt="Snipaste_2018-12-18_21-34-47"></p><p>注意，如果上图位置 1 处的下拉框中没有“SEC S3C2410X Text B/D”，可以点击菜单<br>“Options”，选中“List All Device”；再重接 USB线 。</p><p>4.安装好驱动程序， 设备管理器如图 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-37-32.png" alt="Snipaste_2018-12-18_21-37-32"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;烧录软件安装&quot;&gt;&lt;a href=&quot;#烧录软件安装&quot; class=&quot;headerlink&quot; title=&quot;烧录软件安装&quot;&gt;&lt;/a&gt;烧录软件安装&lt;/h2&gt;&lt;h3 id=&quot;EasyOpenJTAG介绍及安装程序&quot;&gt;&lt;a href=&quot;#EasyOpenJTAG介绍及安装程序&quot; class=&quot;headerlink&quot; title=&quot;EasyOpenJTAG介绍及安装程序&quot;&gt;&lt;/a&gt;EasyOpenJTAG介绍及安装程序&lt;/h3&gt;&lt;h4 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h4&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS4-1.1LED实现</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-15-LS4-1-1LED%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-15-LS4-1-1LED实现.html</id>
    <published>2018-12-15T14:32:25.000Z</published>
    <updated>2018-12-20T08:15:07.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="S3C2440框架"><a href="#S3C2440框架" class="headerlink" title="S3C2440框架"></a>S3C2440框架</h2><a id="more"></a><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_23-40-16.png" alt="Snipaste_2018-12-15_23-40-16"></p><p>Cpu：</p><p>SRAM：SOC内部集成有4K的SRAM片内内存</p><p>GPIO控制器：gpio（General Purpose：通用输入输出接口）</p><p>Nand控制器：外接256M的NandFlash</p><p>NorFlash：NorFlash直接接在Mcu上面（2M）</p><h2 id="S3C2440是如何启动"><a href="#S3C2440是如何启动" class="headerlink" title="S3C2440是如何启动"></a>S3C2440是如何启动</h2><h3 id="NOR启动"><a href="#NOR启动" class="headerlink" title="NOR启动"></a>NOR启动</h3><p>（NorFlash基本地址为0，此时片内SRAM 地址为0X4000 0000）</p><ol><li>程序（bin）烧录在NorFlash</li><li>Cpu从Nor上第一个地址开始（0）读出第一个指令（四字节）执行</li><li>Cpu连接读出其他指令执行</li></ol><p>(即：Nor启动：开机后Cpu从Nor上第一个地址 （0）字节开始连续读出指令并执行)</p><h3 id="Nand启动"><a href="#Nand启动" class="headerlink" title="Nand启动"></a>Nand启动</h3><p>（使用片内4KRAM，基地址为0，此时NorFlash不可可用）</p><ul><li>程序（bin）烧录在NandFlash</li><li>2440硬件首先把Nand前4K的内容复制到片内SRAM内</li><li>然后Cpu从 SRAM的0地址取出第一条指令并执行。</li></ul><p>(即：Nor启动：开机后硬件将Nand前4K的内容复制到片内SRAM，然后Cpu开始SRAM连续读出指令并执行)</p><h2 id="如何通过S3C2440控制led"><a href="#如何通过S3C2440控制led" class="headerlink" title="如何通过S3C2440控制led"></a>如何通过S3C2440控制led</h2><h3 id="GPIO管脚直接控制led"><a href="#GPIO管脚直接控制led" class="headerlink" title="GPIO管脚直接控制led"></a>GPIO管脚直接控制led</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_23-04-50.png" alt="Snipaste_2018-12-15_23-04-50"></p><p>R作用：根据I=U/R,而led电阻很小，如果不接R通过led的电流I会很大，从而烧掉led。这里R具有限流作用，保护led。</p><p>该电路缺点：有些主芯片可能只能输出1.5V或更低电压 或者该芯片只能输出很弱的电流。此时引脚的驱动能力就会不足。</p><p>此时需要改变电路是用三极管驱动，外部供电来实现更大的驱动能力，如下</p><h3 id="三极管驱动led"><a href="#三极管驱动led" class="headerlink" title="三极管驱动led"></a>三极管驱动led</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_23-06-06.png" alt="Snipaste_2018-12-15_23-06-06"></p><p>总结：主芯片引脚通过输出高电平、低电平改变led状态。</p><p>我们不关心GPIO输出的电压值，统一使用高电平和低电平称呼。简称：1/0</p><p>逻辑”1“  ：高电平</p><p>逻辑”0“  ：低电平</p><h2 id="JZ2440实现led控制"><a href="#JZ2440实现led控制" class="headerlink" title="JZ2440实现led控制"></a>JZ2440实现led控制</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_00-13-38.png" alt="Snipaste_2018-12-16_00-13-38"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_00-14-21.png" alt="Snipaste_2018-12-16_00-14-21"></p><h3 id="硬件分析"><a href="#硬件分析" class="headerlink" title="硬件分析"></a>硬件分析</h3><p>从原理图可以看出：当GPF4输出低电平时D10亮， 当GPF4输出高电平时D10灭。</p><p>那么如何控制GPF4输出高低电平呢。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-09-11.png" alt="Snipaste_2018-12-16_01-09-11"></p><h3 id="软件控制led原理"><a href="#软件控制led原理" class="headerlink" title="软件控制led原理"></a>软件控制led原理</h3><h4 id="GPIO配置寄存器"><a href="#GPIO配置寄存器" class="headerlink" title="GPIO配置寄存器"></a>GPIO配置寄存器</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-16-12.png" alt="Snipaste_2018-12-16_01-16-12"></p><h5 id="1-输入-输出状态配置"><a href="#1-输入-输出状态配置" class="headerlink" title="1.输入/输出状态配置"></a>1.输入/输出状态配置</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-22-12.png" alt="Snipaste_2018-12-16_01-22-12"></p><p><strong>配置GPF4为输出状态</strong></p><p>即把0x100写入GPFCON[地址：0x6000050内]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPFCONF[<span class="number">9</span>:<span class="number">8</span>]=<span class="number">0b01</span> ;<span class="comment">//设置GPF4引脚为输出状态，0b表示二进制</span></span><br></pre></td></tr></table></figure><h5 id="2-输入-输出电平设置"><a href="#2-输入-输出电平设置" class="headerlink" title="2.输入/输出电平设置"></a>2.输入/输出电平设置</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_01-29-52.png" alt="Snipaste_2018-12-16_01-29-52"></p><p><strong>配置GPF4输出高/低电平</strong></p><p>输出高电平，led熄灭：即把0x10写入GPFDAT[地址：0x6000054内]</p><p>输出高低平，led熄灭：即把0写入GPFDAT[地址：0x6000054内]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPFDAT[<span class="number">4</span>]=<span class="number">1</span> ;<span class="comment">//设置GPF4输出高电平，灯灭</span></span><br><span class="line">GPFDAT[<span class="number">4</span>]=<span class="number">0</span> ;<span class="comment">//设置GPF4输出低电平，灯亮</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>配置GPF4为输出状态</strong></p><p>即把0x100写入GPFCON[地址：0x6000050内]</p><p><strong>配置GPF4输出高/低电平</strong></p><p>输出高电平，led熄灭：即把0x10写入GPFDAT[地址：0x6000054内]</p><p>输出高低平，led熄灭：即把0写入GPFDAT[地址：0x6000054内]</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="汇编实现"><a href="#汇编实现" class="headerlink" title="汇编实现"></a>汇编实现</h3><h4 id="几条实用汇编代码"><a href="#几条实用汇编代码" class="headerlink" title="几条实用汇编代码"></a>几条实用汇编代码</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-22-51.png" alt="Snipaste_2018-12-18_23-22-51"></p><p>为甚麽引入伪指令：</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-31-14.png" alt="Snipaste_2018-12-18_23-31-14"></p><p>MOV R0, #0X12345678 //该指令为64位指令，而ARM指令为32位，剩下的无法保存。所以引入伪指令。</p><h4 id="开始汇编点亮led"><a href="#开始汇编点亮led" class="headerlink" title="开始汇编点亮led"></a>开始汇编点亮led</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 点亮LED1: gpf4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//汇编默认的开始处</span></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置GPF4为输出引脚</span></span><br><span class="line"><span class="comment"> * 把0x100写到地址0x56000050</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r1, =<span class="number">0x56000050</span></span><br><span class="line">ldr r0, =<span class="number">0x100</span><span class="comment">/* mov r0, #0x100 */</span></span><br><span class="line">str r0, [r1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置GPF4输出高电平 </span></span><br><span class="line"><span class="comment"> * 把0写到地址0x56000054</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r1, =<span class="number">0x56000054</span></span><br><span class="line">ldr r0, =<span class="number">0</span><span class="comment">/* mov r0, #0 */</span></span><br><span class="line">str r0, [r1]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 死循环 相当while（1）*/</span></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>编译led_on.S文件：  arm-linux-gcc -c -o led_on led_on.S </p><p>补充：安装交叉编译工具</p><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><h4 id="led-c"><a href="#led-c" class="headerlink" title="led.c"></a>led.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 点亮LED1: gpf4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义寄存器地址，从手册</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFCON(*(volatile unsigned long *)0xe0200060)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFDAT(*(volatile unsigned long *)0xe0200064)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 配置GPF4CON为输出引脚</span></span><br><span class="line"><span class="comment"> * 把0x100写到地址0x56000050</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> GPFCON=<span class="number">0X100</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置GPF4DAT输出高电平 </span></span><br><span class="line"><span class="comment"> * 把0写到地址0x56000054</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  GPFDAT=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a. 我们写出了main函数, 谁来调用它?<br>​    b. main函数中变量保存在内存中, 这个内存地址是多少?<br>​    答: 我们还需要写一个汇编代码, 给main函数设置内存, 调用main函数,下面代码。</p><p>汇编代码周一功能：设置内存，调用main函数。</p><h4 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置内存: sp 栈 */</span></span><br><span class="line">ldr sp, =<span class="number">4096</span>  <span class="comment">/* nand启动 */</span></span><br><span class="line"><span class="comment">//ldr sp, =0x40000000+4096  /* nor启动 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用main */</span></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>作者：mymainn<br>​    原文：<a href="https://blog.csdn.net/xiaodingqq/article/details/79182402" target="_blank" rel="noopener">https://blog.csdn.net/xiaodingqq/article/details/79182402</a> </p><p>为什么要nand启动设置成4096，nor启动设置为0x40000000+4096？</p><p>1.SDRAM的地址是 0x30000000 - 0x40000000。</p><p>2.Nand启动时，片内4K RAM基地址为0（在0地址处），Nor Flash不可访问。我们把栈设在这4k内存的顶部</p><p>3.Nor启动时，片内RAM地址为0x4000 0000，片内RAM在0x4000 0000往后的4k 此时的栈顶可以设置到内存的顶部：0x40000000 + 4k（4096）。</p><ol start="4"><li>调用C函数时，返回地址、局部变量一般都保存在栈里，所以调用C程序时要设置栈指针</li><li>之所以设成4096，是由于S4C2410、S3C2440从NAND Flash启动时，它的内部4K RAM的地址为0～4095，可以把栈指针指向最后──其实你也可以指向0～4095中间某个位置，只要不破坏要运行的代码就可以</li></ol><h4 id="start-s优化"><a href="#start-s优化" class="headerlink" title="start.s优化"></a>start.s优化</h4><p>添加：关闭看门狗，以及自动识别是nor/nand启动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">ldr r0, =<span class="number">0x53000000</span></span><br><span class="line">ldr r1, =<span class="number">0</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置内存: sp 栈 */</span></span><br><span class="line"><span class="comment">/* 分辨是nor/nand启动</span></span><br><span class="line"><span class="comment"> * 写0到0地址, 再读出来</span></span><br><span class="line"><span class="comment"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span></span><br><span class="line"><span class="comment"> * 否则就是nor启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mov r1, #<span class="number">0</span></span><br><span class="line">ldr r0, [r1] <span class="comment">/* 读出原来的值备份 */</span></span><br><span class="line">str r1, [r1] <span class="comment">/* 0-&gt;[0] */</span> </span><br><span class="line">ldr r2, [r1] <span class="comment">/* r2=[0] */</span></span><br><span class="line">cmp r1, r2   <span class="comment">/* r1==r2? 如果相等表示是NAND启动 */</span></span><br><span class="line">ldr sp, =<span class="number">0x40000000</span>+<span class="number">4096</span> <span class="comment">/* 先假设是nor启动 */</span></span><br><span class="line">moveq sp, #<span class="number">4096</span>  <span class="comment">/* nand启动 */</span></span><br><span class="line">streq r0, [r1]   <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b hal</span><br></pre></td></tr></table></figure><h4 id="led-c优化"><a href="#led-c优化" class="headerlink" title="led.c优化"></a>led.c优化</h4><p>上面的led.c在配置寄存器时会在配置某位时会会破坏该寄存器的其它位数据。因此需要使用位操作寄存器以避免影响其他位。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_15-28-08.png" alt="Snipaste_2018-12-20_15-28-08"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_15-27-16.png" alt="Snipaste_2018-12-20_15-27-16"></p><p><strong>/<em> 配置GPF4位输出：配置GPF4CON的9，8位为01</em>/</strong></p><p>第一步：将8，9清0</p><p>GPFCON &amp;= ~(3&lt;&lt;8);//8,9位清0</p><p>第一步：将8位置1</p><p>GPFCON |=  (1&lt;&lt;8);</p><p><strong>原理解析</strong></p><p><strong>GPFCON &amp;= ~(3&lt;&lt;8)//8,9位清0</strong></p><p>//1.(3&lt;&lt;8)，3二进制位11，（3&lt;&lt;8）数据左移8位：0000 0000 0000 0000 0000 0011 0000 0000,</p><p>//2.~(3&lt;&lt;8）取反：此时：1111 1111 1111 1111 1111 1100 1111 1111</p><p>//3.GPFCON &amp;= ~(3&lt;&lt;8); 与0</p><table><thead><tr><th>a&amp;b</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>从表看出 ，b=0：a会被清0，但是b=1；a不变，因此达到清0指定位：</p><p>假如：GPFCON=1010 1111 0000 1111 0010 10<strong>11</strong> 1101 0011</p><p>GPFCON &amp;= ~(3&lt;&lt;8)= 1010 1111 0000 1111 0010 10<strong>00</strong> 1101 0011，从而达到清0指定位，而不改变其它位。</p><p><strong>GPFCON |=  (1&lt;&lt;8)</strong></p><p>//1.(3&lt;&lt;8)，（1&lt;&lt;8）数据左移8位：0000 0000 0000 0000 0000 001 0000 0000,</p><p>//2.GPFCON |=  (1&lt;&lt;8) 或1</p><table><thead><tr><th>a\</th><th>b</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>从表看出 ，b=1：a会被☞1，但是b=0；a不变，因此达到置1指定位：</p><p>假如：GPFCON=1010 1111 0000 1111 0010 10<strong>00</strong> 1101 0011</p><p>GPFCON &amp;= ~(3&lt;&lt;8)= 1010 1111 0000 1111 0010 10<strong>001</strong> 1101 0011，从而达到置1指定位，而不改变其它位</p><p>总结：通过上面两步：&amp;0，|1达到将9，8 位变为01。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 点亮LED1: gpf4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义寄存器地址，从手册</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFCON(*(volatile unsigned long *)0xe0200060)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFDAT(*(volatile unsigned long *)0xe0200064)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 配置GPF4CON为输出引脚</span></span><br><span class="line"><span class="comment"> * 把0x100写到地址0x56000050</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">8</span>);<span class="comment">//8,9位清0</span></span><br><span class="line">GPFCON |=  (<span class="number">1</span>&lt;&lt;<span class="number">8</span>);<span class="comment">//9置1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置GPF4DAT输出高电平 </span></span><br><span class="line"><span class="comment"> * 把0写到地址0x56000054</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//4位清0;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：安装交叉编译工具"><a href="#补充：安装交叉编译工具" class="headerlink" title="补充：安装交叉编译工具"></a>补充：安装交叉编译工具</h2><p>教程：<a href="https://blog.csdn.net/dearwind153/article/details/39017131" target="_blank" rel="noopener">https://blog.csdn.net/dearwind153/article/details/39017131</a></p><p>网上下载 arm-linux-gcc-4.4.3.tar.gz</p><p><a href="http://pan.baidu.com/s/1bpEq2Mr" target="_blank" rel="noopener">arm-linux-gcc-4.4.3.tar.gz</a> （百度云盘，密码：1gtt）</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>1、解压交叉编译开发工具包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sudo tar xvzf arm-linux-gcc<span class="number">-4.4</span><span class="number">.3</span>.tar.gz -C /</span><br><span class="line"><span class="comment">//解压工具链到根目录，这里的解压目录可以任意指定。系统中会增加目录/opt/FriendlyARM/toolschain/4.4.3/</span></span><br></pre></td></tr></table></figure><p>2、修改环境变量，把交叉编译器的路径加入到PATH</p><p>  采用修改/etc/bash.bashrc文件的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①用vim打开文件：</span></span><br><span class="line">  <span class="meta">#sudo vim /etc/bash.bashrc</span></span><br><span class="line"><span class="comment">//②在最后面新建一行加上:</span></span><br><span class="line">  <span class="keyword">export</span>  PATH=$PATH:/opt/FriendlyARM/toolschain/<span class="number">4.4</span><span class="number">.3</span>/bin</span><br></pre></td></tr></table></figure><hr><p>3、立即使新的环境变量生效，不用重启电脑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#source /etc/bash.bashrc</span></span><br></pre></td></tr></table></figure><p>4、检查是否将路径加入到PATH</p><pre><code>#echo $PATH若显示的内容中有刚刚添加的交叉编译器所在目录，则证明编译环境安装成功。</code></pre><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-19_02-24-41.png" alt="Snipaste_2018-12-19_02-24-41"></p><p>5、测试是否安装成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#arm-linux-gcc -v</span></span><br></pre></td></tr></table></figure><p>上面的指令会显示arm-linux-gcc信息和版本，显示的内容信息：</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-19_02-25-28.png" alt="Snipaste_2018-12-19_02-25-28"></p><p>此时，证明安装成功。</p><p>6，编译实验</p><p>写个HelloWorld程序，测试交叉工具连</p><p>新建一个hello.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行下面的指令：</p><p>   #arm-linux-gcc -o hello hello.c</p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>尝试烧录到Nor，和Nand都行前面说法只能烧录Nand是说我说法，但烧录N偶然会导致Nor启动无法进入系统，因此建议烧录在Nand下，再次说明。</p><p><strong>要是不报错说明安装成功。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;S3C2440框架&quot;&gt;&lt;a href=&quot;#S3C2440框架&quot; class=&quot;headerlink&quot; title=&quot;S3C2440框架&quot;&gt;&lt;/a&gt;S3C2440框架&lt;/h2&gt;
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS2_JZ2440V3开发之开发板硬件连接及驱动安装</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-14-LS3-JZ2440V3%E5%BC%80%E5%8F%91%E4%B9%8B%E8%AE%A4%E8%AF%86%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8F%8A%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-14-LS3-JZ2440V3开发之认识开发板及驱动安装.html</id>
    <published>2018-12-14T11:09:34.000Z</published>
    <updated>2018-12-20T06:20:21.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="熟悉开发板步骤"><a href="#熟悉开发板步骤" class="headerlink" title="熟悉开发板步骤"></a>熟悉开发板步骤</h2><h3 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h3><p>板载 USB 串口、 JTAG、 usb下载口(dnw) </p><a id="more"></a><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_19-24-58.png" alt="Snipaste_2018-12-14_19-24-58"></p><p>​            图 4.1 接口介绍<br>①为板载 USB串口；②为 USB下载口，又名 dnw；③是 JTAG 口。 </p><p>三接口与PC模型</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_19-50-53.png" alt="Snipaste_2018-12-14_19-50-53"></p><ul><li><p><strong>烧写：</strong></p><p>PC 使用eop通过JTAG烧写口实现烧写。(可靠但速度很慢，大文件使用USB 烧录)</p></li><li><p><strong>调式信息</strong></p><p>一般开发板使用串口打印实现调式。PC通过串口把命令发给开发板，而开发板通过串口把结果发给PC。</p></li><li><p><strong>USB Device</strong></p><p>烧写大文件（kernel，rootfs）使用USB设备，前提是板子运行有支持USB 下载程序的u-boot。</p></li></ul><h2 id="裸机开发步骤"><a href="#裸机开发步骤" class="headerlink" title="裸机开发步骤"></a>裸机开发步骤</h2><h3 id="不同系统下应用程序开发比较"><a href="#不同系统下应用程序开发比较" class="headerlink" title="不同系统下应用程序开发比较"></a>不同系统下应用程序开发比较</h3><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_20-43-03.png" alt="Snipaste_2018-12-14_20-43-03"></p><p><strong>Ubuntu</strong></p><p>名词解释：gcc</p><ul><li>gcc是linux系统下主要的编译软件，</li><li>gcc的全称是GNU编译器套件（GNU Compiler Collection），</li><li>除了可以编译c语言开发的程序外，还可以开发C++、Java等多个语言的程序。</li><li>GCC的初衷是为GNU操作系统专门编写的一款编译器。</li></ul><p><strong>使用gcc的原因：</strong>功能强大、稳定、开源免费。</p><p><strong>gcc版本查看：</strong>gcc  -v  </p><p><strong>ARM裸机开发</strong></p><p>交叉编译模式：<br>​    通常编译嵌入式程序的平台称为宿主机（如：PC的ubuntu系统，CPU架构为X86架构），运行嵌入式程序的平台成为目标机（如：某款ARM开发板，CPU架构为ARM架构）。在X86平台编辑和通过编译器arm-linux-gcc编译的ARM架构的程序，两者属于不同的架构平台，从而属于交叉编译模式。然后将程序烧写到ARM开发板中（下载方式有：JTAG、USB、SD卡、网络等多种方式），然后在开发板上运行该程序。</p><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p>推荐使用windows平台的source insight和notepad。<br>source insight在查看代码、编辑代码等功能时非常好用。</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>推荐使用arm-linux-gcc<br>arm-linux-gcc是基于linux平台的arm编译器。它是开源免费的编译器。<br>arm-linux-gcc功能强大、稳定、支持的arm芯片众多、更新速度快。</p><h4 id="入门误区：使用ads、MDK"><a href="#入门误区：使用ads、MDK" class="headerlink" title="入门误区：使用ads、MDK"></a>入门误区：使用ads、MDK</h4><p>ads（停止更新）、MDK，是windows平台的编译器，功能较弱。<br>1）只适合个人或者小团队的开发，不适合于中型、大型团队的协作开发。<br>2）是收费软件。</p><h3 id="安装source-insight"><a href="#安装source-insight" class="headerlink" title="安装source insight"></a>安装source insight</h3><p>略</p><h3 id="安装notepad"><a href="#安装notepad" class="headerlink" title="安装notepad"></a>安装notepad</h3><p>略</p><h3 id="安装free-hex-edtor"><a href="#安装free-hex-edtor" class="headerlink" title="安装free-hex-edtor"></a>安装free-hex-edtor</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;熟悉开发板步骤&quot;&gt;&lt;a href=&quot;#熟悉开发板步骤&quot; class=&quot;headerlink&quot; title=&quot;熟悉开发板步骤&quot;&gt;&lt;/a&gt;熟悉开发板步骤&lt;/h2&gt;&lt;h3 id=&quot;接口介绍&quot;&gt;&lt;a href=&quot;#接口介绍&quot; class=&quot;headerlink&quot; title=&quot;接口介绍&quot;&gt;&lt;/a&gt;接口介绍&lt;/h3&gt;&lt;p&gt;板载 USB 串口、 JTAG、 usb下载口(dnw) &lt;/p&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>LS1_JZ2440V3开发之环境搭建</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-14-LS1-JZ2440V3%E5%BC%80%E5%8F%91%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-14-LS1-JZ2440V3开发之环境搭建.html</id>
    <published>2018-12-14T11:07:11.000Z</published>
    <updated>2018-12-20T06:20:00.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>嵌入式开发者中一般需要用的软件、工具如下：<br>✓ 虚拟机 Workstation Player                                                                            ✓ Linux系统     Ubuntu 16.04 LTS<br>✓ 远程登录/远程传输/串口三合一软件 MobaXterm<br>✓ FTP 传输工具 FileZilla<br>✓ TFTP 服务器软件 tftpd.exe</p><a id="more"></a><p>(1) 为什么要使用虚拟机?                                                                 </p><p>后续开发都是在 Windows 下编辑代码,在 Linux 下编译代码。要么安装双系统，要么使用虚拟机。我们推荐后者。</p><p>（其实更希望搭建NAS装个Ubuntu，然后在哪里都能开发，以免换电脑啥的得重新搭建环境（环境搭建很麻烦人）。年后会尝试搭建个NAS服务器，用于资料存储。）</p><p>(2) 在 Windows 操作 Linux 有两种方式：</p><p>一是切换到虚拟机 ubuntu，在虚拟机中操作ubuntu；另一种是远程登录 ubuntu，开发中更多使用后者。 在 Windows 上远程登录 ubuntu并执行各种命令时，使用 ssh 工具； 在 Windows 和 ubuntu 之间传输文件时，通常使用 FTP工具。</p><p>(3) 要观察开发板打印的调试信息时，最方便的方法是使用串口。<br>以上远程登录、 FTP 传输、串口传输都可以使用一个软件实现——MobaXterm(目录在资料光盘-》 工具和驱动\串口和远程登录工具)</p><p>(4) 虽然 MobaXterm 也有 FTP 功能， 但使用另一个 FTP 工具 FileZilla 在Windows 与 ubuntu 之间的传输文件更方便。 </p><h3 id="安装虚拟机-Workstation-Player"><a href="#安装虚拟机-Workstation-Player" class="headerlink" title="安装虚拟机 Workstation Player"></a>安装虚拟机 Workstation Player</h3><p>略（已安装过，以后更新）</p><h3 id="使用虚拟机安装-Ubuntu"><a href="#使用虚拟机安装-Ubuntu" class="headerlink" title="使用虚拟机安装 Ubuntu"></a>使用虚拟机安装 Ubuntu</h3><p>略（已安装过，以后更新）</p><h3 id="Ubuntu配置"><a href="#Ubuntu配置" class="headerlink" title="Ubuntu配置"></a>Ubuntu配置</h3><h4 id="安装完整版本的-VIM"><a href="#安装完整版本的-VIM" class="headerlink" title="安装完整版本的 VIM"></a>安装完整版本的 VIM</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><h4 id="VI的个性设置"><a href="#VI的个性设置" class="headerlink" title="VI的个性设置"></a>VI的个性设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：vi`~/.vimrc</span><br></pre></td></tr></table></figure><h4 id="安装-SSH"><a href="#安装-SSH" class="headerlink" title="安装 SSH"></a>安装 SSH</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure><ul><li>SSH的英文全称是Secure SHell。通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS和IP欺骗。</li><li>SSH传输的数据是经过压缩的，所以可以加快传输的速度。</li><li>SSH有很多功能，它既可以代替telnet，又可以为ftp、 pop、甚至ppp提供一个安全的”通道”。</li><li>SSH客户端与服务器端通讯时，用户名及口令均进行了加密，有效防止了对口令的窃听。</li></ul><h4 id="启用-root密码"><a href="#启用-root密码" class="headerlink" title="启用 root密码"></a>启用 root密码</h4><p>启用 root 帐号 (也就是 设置一个口令) 使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>如何在终端机模式下切换到 root 身份?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s -H</span><br><span class="line">Password: &lt;在这注明您的密码&gt;</span><br></pre></td></tr></table></figure><h4 id="更新ubuntu的源"><a href="#更新ubuntu的源" class="headerlink" title="更新ubuntu的源"></a>更新ubuntu的源</h4><p>参考网站：</p><p>1.如何在/etc/apt/sources.list添加新内容：<a href="https://blog.csdn.net/qq_31811537/article/details/79310567" target="_blank" rel="noopener">https://blog.csdn.net/qq_31811537/article/details/79310567</a></p><p>2.如何在/etc/apt/sources.list添加新内容：<a href="https://blog.csdn.net/xiayaobo/article/details/46970663" target="_blank" rel="noopener">https://blog.csdn.net/xiayaobo/article/details/46970663</a></p><p>如果apt-get安装软件包的时候，速度很慢可以根据ubuntu的版本，百度里面查找更换为国内163的源</p><p><strong>编辑(更新)源命令：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><strong>通知ubuntu启用新的更新源:</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><strong>更新软件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h4 id="ubuntu版本查询"><a href="#ubuntu版本查询" class="headerlink" title="ubuntu版本查询"></a>ubuntu版本查询</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsb_release -a</span><br></pre></td></tr></table></figure><h4 id="查询ubuntu是32位还是64位版本"><a href="#查询ubuntu是32位还是64位版本" class="headerlink" title="查询ubuntu是32位还是64位版本"></a>查询ubuntu是32位还是64位版本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname -m</span><br><span class="line"><span class="comment">// 如果显示i686,你安装了32位操作系统</span></span><br><span class="line"><span class="comment">//如果显示 x86_64，你安装了64位操作系统</span></span><br></pre></td></tr></table></figure><h3 id="ubuntu设置静态ip"><a href="#ubuntu设置静态ip" class="headerlink" title="ubuntu设置静态ip"></a>ubuntu设置静态ip</h3><h4 id="windows设置静态ip"><a href="#windows设置静态ip" class="headerlink" title="windows设置静态ip"></a>windows设置静态ip</h4><p>win10怎么把电脑的IP地址设置成固定IP地址：<a href="https://jingyan.baidu.com/album/ac6a9a5e295f842b653eacfa.html?picindex=2" target="_blank" rel="noopener">https://jingyan.baidu.com/album/ac6a9a5e295f842b653eacfa.html?picindex=2</a></p><h4 id="Ubuntu网络设置"><a href="#Ubuntu网络设置" class="headerlink" title="Ubuntu网络设置"></a>Ubuntu网络设置</h4><h5 id="VMware中网络的设置（设置为：桥接模式）"><a href="#VMware中网络的设置（设置为：桥接模式）" class="headerlink" title="VMware中网络的设置（设置为：桥接模式）"></a>VMware中网络的设置（设置为：桥接模式）</h5><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_13-43-55.png" alt="Snipaste_2018-12-17_13-43-55"></p><h5 id="查看ip网络信息"><a href="#查看ip网络信息" class="headerlink" title="查看ip网络信息"></a>查看ip网络信息</h5><p>用ifconfig命令</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_13-49-29.png" alt="Snipaste_2018-12-17_13-49-29"></p><h5 id="修改网络配置文件"><a href="#修改网络配置文件" class="headerlink" title="修改网络配置文件"></a>修改网络配置文件</h5><ul><li>打开网络配置文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>配置如下信息，然后保存退出</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-00-30.png" alt="Snipaste_2018-12-17_14-00-30"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="keyword">auto</span> eth0</span><br><span class="line">iface eth0 inet <span class="keyword">static</span></span><br><span class="line">address <span class="number">192.168</span><span class="number">.31</span><span class="number">.99</span>  <span class="comment">// //设置本机IP地址</span></span><br><span class="line">gateway <span class="number">192.168</span><span class="number">.31</span><span class="number">.1</span>  <span class="comment">//网关</span></span><br><span class="line">netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>    <span class="comment">//掩码</span></span><br></pre></td></tr></table></figure><h5 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h5 id="检查ip是否配置成功"><a href="#检查ip是否配置成功" class="headerlink" title="检查ip是否配置成功"></a>检查ip是否配置成功</h5><p>先用ifconfig检查一下ip</p><p> 用ping命令检查本机与windows系统是否连通：ping 192.168.31.101（windows IP）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-45-15.png" alt="Snipaste_2018-12-17_14-45-15"></p><h5 id="ping不通解决方法"><a href="#ping不通解决方法" class="headerlink" title="ping不通解决方法"></a>ping不通解决方法</h5><p>如果出现如下这种情况</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-32-40.png" alt="Snipaste_2018-12-17_14-32-40"></p><p>参考：Ubuntu虚拟机无法ping通windows，反之可以ping通解决方法：<a href="https://blog.csdn.net/qq_26822029/article/details/80428138" target="_blank" rel="noopener">https://blog.csdn.net/qq_26822029/article/details/80428138</a></p><ul><li>打开“网络和共享中心”</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-51-03.png" alt="Snipaste_2018-12-17_14-51-03"></p><ul><li>选择<strong>windiws防火墙</strong>选项</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-55-01.png" alt="Snipaste_2018-12-17_14-55-01"></p><ul><li>选择<strong>“高级设置”</strong></li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-53-43.png" alt="Snipaste_2018-12-17_14-53-43"></p><ul><li>选择“入站规则”，找到名称为“文件和打印机共享（回显请求-ICMPv4-In）”（配置文件为“专用，公用的那个”）勾上。</li></ul><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_14-57-44.png" alt="Snipaste_2018-12-17_14-57-44"></p><h5 id="配置DNS-域名解析-服务器"><a href="#配置DNS-域名解析-服务器" class="headerlink" title="配置DNS(域名解析)服务器"></a>配置DNS(域名解析)服务器</h5><p>打开DNS服务器配置文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/resolvconf/resolv.conf.d/tail</span><br></pre></td></tr></table></figure><p>写入以下信息   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">192.168</span><span class="number">.31</span> <span class="comment">//和windowsDNS相同</span></span><br></pre></td></tr></table></figure><p>重启本地服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/resolvconf restart</span><br></pre></td></tr></table></figure><h5 id="ping网址"><a href="#ping网址" class="headerlink" title="ping网址"></a>ping网址</h5><p>ping  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_15-20-11.png" alt="Snipaste_2018-12-17_15-20-11"></p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="安装-MobaXterm-（SSH，FTP，Serial）"><a href="#安装-MobaXterm-（SSH，FTP，Serial）" class="headerlink" title="安装 MobaXterm （SSH，FTP，Serial）"></a>安装 MobaXterm （SSH，FTP，Serial）</h4><p>MobaXterm 在资料光盘\工具和驱动\串口和远程登录工具目录，解压文件MobaXterm_Portable_v10.4 即可 。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-16_22-48-43.png" alt="Snipaste_2018-12-16_22-48-43"></p><h5 id="新建-SSH连接"><a href="#新建-SSH连接" class="headerlink" title="新建 SSH连接"></a>新建 SSH连接</h5><p>打开 MobaXterm， 点击左上角的 Session（会话控制），在弹出的窗口中选择 SSH，<br>如图 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_15-38-50.png" alt="Snipaste_2018-12-17_15-38-50"></p><p>在新窗口中输入账号 和密码 ，回车登陆 ubuntu 。此时界面分为两块，左边的是主机的文件，右边是终端。 勾选左下角的“Follow terminal folder”可以让它们的工作路径保持一致 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_15-40-46.png" alt="Snipaste_2018-12-17_15-40-46"></p><h5 id="新建FTP连接"><a href="#新建FTP连接" class="headerlink" title="新建FTP连接"></a>新建FTP连接</h5><p>失败(略)</p><h5 id="新建串口连接"><a href="#新建串口连接" class="headerlink" title="新建串口连接"></a>新建串口连接</h5><p>点击session选择serial</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_22-12-48.png" alt="Snipaste_2018-12-15_22-12-48"></p><p>选择COM口（我的为COM12）及波特率和3框中的控制流为None（参考下图设置）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-15_22-16-34.png" alt="Snipaste_2018-12-15_22-16-34"></p><p>点击OK,输入<strong>ls</strong>使用串口观察打印信息（打印信息为系统目录结构）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-14_20-17-22.png" alt="Snipaste_2018-12-14_20-17-22"></p><h4 id="FTP传输工具-FileZill"><a href="#FTP传输工具-FileZill" class="headerlink" title="FTP传输工具 FileZill"></a>FTP传输工具 FileZill</h4><p>略</p><h4 id="TFTP服务器-tftp"><a href="#TFTP服务器-tftp" class="headerlink" title="TFTP服务器 tftp"></a>TFTP服务器 tftp</h4><p>用的软件是 tftpd.exe<br>     开发板与电脑之间用网线直接连接并使用 TFTP 下载 </p><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;p&gt;嵌入式开发者中一般需要用的软件、工具如下：&lt;br&gt;✓ 虚拟机 Workstation Player                                                                            ✓ Linux系统     Ubuntu 16.04 LTS&lt;br&gt;✓ 远程登录/远程传输/串口三合一软件 MobaXterm&lt;br&gt;✓ FTP 传输工具 FileZilla&lt;br&gt;✓ TFTP 服务器软件 tftpd.exe&lt;/p&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
</feed>
