<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/SetCalm/setcalm.github.io/"/>
  <updated>2018-12-18T18:59:46.584Z</updated>
  <id>https://github.com/SetCalm/setcalm.github.io/</id>
  
  <author>
    <name>Jeff Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cs</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-19-cs.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-19-cs.html</id>
    <published>2022-12-18T18:58:59.000Z</published>
    <updated>2018-12-18T18:59:46.584Z</updated>
    
    <content type="html"><![CDATA[<p>由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。</p><p>另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。</p><p>谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于以前准备用七牛作为图床，发现测试域名只有一月试用期，需要绑定域名。暂时没有好的图床，年后准备搭建个NAS做图床，网站暂时只能看无图的。&lt;/p&gt;
&lt;p&gt;另外暂时文章都没有仔细排版，现在抓紧学习嵌入式ARM开发阶段，提后有时间再排版。&lt;/p&gt;
&lt;p&gt;谢谢！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重要说明</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/重要说明.html</id>
    <published>2019-12-28T13:37:19.000Z</published>
    <updated>2019-02-23T08:32:34.454Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。</p><p>博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章内容缭乱，不忍直视，没有章理。以后需要会有条理的在学习中整理学习内容，并笔记。其中以前学习笔记为摸索中因此缭乱。&lt;/p&gt;
&lt;p&gt;博客为C语言学习，Linux驱动学习。以后希望能够深入学习云服务 物联网 python  ASP.NET Core等。到时增加其他分类。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux设备驱动开发详解：基于最新的Linux4.0内核</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%9C%80%E6%96%B0%E7%9A%84Linux4-0%E5%86%85%E6%A0%B8.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/Linux设备驱动开发详解：基于最新的Linux4-0内核.html</id>
    <published>2019-03-06T10:39:46.000Z</published>
    <updated>2019-03-12T13:33:40.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-Linux设备驱动概述"><a href="#第1章-Linux设备驱动概述" class="headerlink" title="第1章 Linux设备驱动概述"></a>第1章 Linux设备驱动概述</h1><h2 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h2><p><strong>作用：</strong></p><p>对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具<br>体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的<br>映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。</p><p>驱动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应用软件工程师之间的<br>沟通</p><p><strong>角色：</strong> </p><ul><li>作为一个程序员, 你能够对你的驱动作出你自己的选择, 并且在所需的编程时间和结果的<br>灵活性之间, 选择一个可接受的平衡 ，而一个驱动程序的角色是提供机制, 而不是策略。</li><li>大部分的编程问题其实可以<br>划分为 2 部分:” 提供什么能力”(机制) 和 “如何使用这些能力”(策略). 如果这两方面<br>由程序的不同部分来表达, 或者甚至由不同的程序共同表达, 软件包是非常容易开发和适<br>应特殊的需求. </li><li>在编写驱动时, 程序员应当特别注意这个基础的概念: 编写内核代码来存取硬件, 不能强加特别的策略给用户, 因为不同的用户有不同的需求. 驱动应当做到使硬件可用, 将<br>所有关于如何使用硬件的事情留给应用程序. 一个驱动, 这样, 就是灵活的, 如果它提供<br>了对硬件能力的存取, 没有增加约束. 然而, 有时必须作出一些策略的决定. 例如, 一个<br>数字 I/O 驱动也许只提供对硬件的字符存取, 以便避免额外的代码处理单个位. （驱动负责机制（提供什么能力），而策略（如何使用这些能力）应交于应用。驱动不应强加策略。）</li><li>驱动: 是一个存在于应用程序和实际设备间的软件层. 驱<br>动的这种特权的角色允许驱动程序员严密地选择设备应该如何表现: 不同的驱动可以提供<br>不同的能力, 甚至是同一个设备. 实际的驱动设计应当是在许多不同考虑中的平衡. </li></ul><h2 id="内核划分"><a href="#内核划分" class="headerlink" title="内核划分"></a>内核划分</h2><p><strong>内核的角色可以划分成下列几个部分 ：</strong></p><ul><li><p><strong>进程管理</strong> </p><p>内核负责创建和销毁进程, 并处理它们与外部世界的联系(输入和输出). 不同进程<br>间通讯(通过信号, 管道, 或者进程间通讯原语)对整个系统功能来说是基本的, 也<br>由内核处理. 另外, 调度器, 控制进程如何共享 CPU, 是进程管理的一部分. 更通<br>常地, 内核的进程管理活动实现了多个进程在一个单个或者几个 CPU 之上的抽象.</p></li><li><p><strong>内存管理</strong></p><p>计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的. 内核为<br>所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间. 内核的不同部<br>分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更<br>复杂的功能.<br>文件系统<br>Unix 在很大程度上基于</p></li><li><p><strong>文件系统的概念</strong></p><p>几乎 Unix 中的任何东西都可看作一个<br>文件. 内核在非结构化的硬件之上建立了一个结构化的文件系统, 结果是文件的抽<br>象非常多地在整个系统中应用. 另外, Linux 支持多个文件系统类型, 就是说, 物<br>理介质上不同的数据组织方式. 例如, 磁盘可被格式化成标准 Linux 的 ext3 文<br>件系统, 普遍使用的 FAT 文件系统, 或者其他几个文件系统.</p></li><li><p><strong>设备控制</strong></p><p>几乎每个系统操作最终都映射到一个物理设备上. 除了处理器, 内存和非常少的别<br>的实体之外, 全部中的任何设备控制操作都由特定于要寻址的设备相关的代码来进<br>行. 这些代码称为设备驱动. 内核中必须嵌入系统中出现的每个外设的驱动, 从硬<br>盘驱动到键盘和磁带驱动器. 内核功能的这个方面是本书中的我们主要感兴趣的地<br>方. </p></li><li><p><strong>网络</strong></p><p>网络必须由操作系统来管理, 因为大部分网络操作不是特定于某一个进程: 进入系<br>统的报文是异步事件. 报文在某一个进程接手之前必须被收集, 识别, 分发. 系统<br>负责在程序和网络接口之间递送数据报文, 它必须根据程序的网络活动来控制程序<br>的执行. 另外, 所有的路由和地址解析问题都在内核中实现. </p></li></ul><h2 id="设备的分类及特点"><a href="#设备的分类及特点" class="headerlink" title="设备的分类及特点"></a>设备的分类及特点</h2><p>以 Linux 的将设备区分为 3 种基本设备类型.  </p><p><strong>字符设备</strong></p><p>字符( char ) 设备是一种可以当作一个字节流来存取的设备( 如同一个文<br>件 )。这样的驱动常常至少实现 open, close, read, 和 write 系统调用。文本控制台( /dev/console )和串口( /dev/ttyS0 及<br>其友 )是字符设备的例子，因为它们很好地展现了流的抽象。 字符设备通过文件系<br>统结点来存取， 例如 /dev/tty1 和 /dev/lp0。</p><p><strong>块设备</strong></p><p>如同字符设备, 块设备通过位于 /dev 目录的文件系统结点来存取. 一个块设备<br>(例如一个磁盘)应该是可以驻有一个文件系统的. 在大部分的 Unix 系统, 一个块<br>设备只能处理这样的 I/O 操作, 传送一个或多个长度经常是 512 字节( 或一个更<br>大的 2 的幂的数 )的整块. Linux, 相反, 允许应用程序读写一个块设备象一个字<br>符设备一样 – 它允许一次传送任意数目的字节. 结果就是, 块和字符设备的区别<br>仅仅在内核在内部管理数据的方式上, 并且因此在内核/驱动的软件接口上不同.<br>如同一个字符设备, 每个块设备都通过一个文件系统结点被存取的, 它们之间的区<br>别对用户是透明的. 块驱动和字符驱动相比, 与内核的接口完全不同.</p><p><strong>网络接口</strong></p><p>任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设<br>备. 通常, 一个接口是一个硬件设备, 但是它也可能是一个纯粹的软件设备, 比如<br>环回接口. 一个网络接口负责发送和接收数据报文, 在内核网络子系统的驱动下,<br>不必知道单个事务是如何映射到实际的被发送的报文上的. 很多网络连接( 特别那<br>些使用 TCP 的)是面向流的, 但是网络设备却常常设计成处理报文的发送和接收.<br>一个网络驱动对单个连接一无所知; 它只处理报文. </p><h2 id="Linux设备驱动与整个软硬件系统的关系"><a href="#Linux设备驱动与整个软硬件系统的关系" class="headerlink" title="Linux设备驱动与整个软硬件系统的关系"></a>Linux设备驱动与整个软硬件系统的关系</h2><p>除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open（）、write（）、read（）、close（）等即可访问字符设备和块设备。所有字符<br>设备和块设备都统一呈现给用户。</p><p>Linux的块设备有两种访问方法：</p><ul><li>一种是类似dd命令对应的原始块设<br>备，如“/dev/sdb1”等；</li><li>另外一种方法是在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径<br>如“/home/barry/hello.txt”的形式进行访问。</li></ul><p>在Linux中，针对NOR、NAND等提供了独立的内存技术设备<br>（Memory Technology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡<br>能力的文件系统。针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文<br>件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-06_20-02-51.png" alt="Snipaste_2019-03-06_20-02-51"></p><p>字符设备与块设备都被映射到Linux文件系统。可通过文件系统的系统调用接口（open（）、write（）、read（）、close（））来访问</p><p>字符设备，块设备与存技术设备子系统则通过虚拟文件系统（VFS）对其进行抽象。</p><h1 id="第2章：Linux内核模块程序结构"><a href="#第2章：Linux内核模块程序结构" class="headerlink" title="第2章：Linux内核模块程序结构"></a>第2章：Linux内核模块程序结构</h1><h2 id="Linux内核模块简介"><a href="#Linux内核模块简介" class="headerlink" title="Linux内核模块简介"></a>Linux内核模块简介</h2><p><strong>我们是怎样把需要的部分都包含在内</strong><br><strong>核中呢？</strong></p><ul><li><p>一种方法：是把所有需要的功能都编译到Linux内核中。这会导致两个问题。</p><p>（1）一是生成的内核会很大。</p><p>（2）二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核</p></li><li><p>另一种：机制可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时<br>候，其对应的代码被动态地加载到内核中，这种机制被称为模块（Module）.模块具有这样的特点。</p><p>（1）模块本身不被编译入内核映像，从而控制了内核的大小。</p><p>（2）模块一旦被加载，它就和内核中的其他部分完全一样。</p></li></ul><h2 id="Linux内核模块程序结构"><a href="#Linux内核模块程序结构" class="headerlink" title="Linux内核模块程序结构"></a>Linux内核模块程序结构</h2><p>一个Linux内核模块主要由如下几个部分组成</p><p>一个Linux内核模块主要由如下几个部分组成。</p><p><strong>（1）模块加载函数</strong></p><p>当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相<br>关初始化工作。</p><p><strong>（2）模块卸载函数</strong></p><p>当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功<br>能。</p><p><strong>（3）模块许可证声明</strong></p><p>许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到<br>内核被污染（Kernel Tainted）的警告。</p><p>在Linux内核模块领域，可接受的LICENSE包括“GPL”、“GPL v2”、“GPL and additional rights”、“Dual<br>BSD/GPL”、“Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary”，这<br>个在学术界和法律界都有争议）。<br>大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以<br>MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。</p><p><strong>（4）模块参数（可选）</strong></p><p>模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。</p><p><strong>（5）模块导出符号（可选）</strong></p><p>内核模块可以导出的符号（symbol，对应于内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的<br>变量或函数。</p><p><strong>（6）模块作者等信息声明（可选）</strong></p><h2 id="内核模块函数详解"><a href="#内核模块函数详解" class="headerlink" title="内核模块函数详解"></a>内核模块函数详解</h2><h3 id="模块加载函数"><a href="#模块加载函数" class="headerlink" title="模块加载函数"></a>模块加载函数</h3><p>Linux内核模块加载函数一般以__init标识声明， 典型的模块加载函数的形式如代码清单4.2所示。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单4.2 内核模块加载函数</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="keyword">int</span> _ _<span class="function">init <span class="title">initialization_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="comment">/* 初始化代码 */</span></span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> module_init(initialization_function);</span><br></pre></td></tr></table></figure><p>在Linux内核中， 可以使用request_module（const char*fmt， …） 函数加载内核模块， 驱动开发人员可<br>以通过调用下列代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_module(module_name);</span><br></pre></td></tr></table></figure><p>在Linux中， 所有标识为__init的函数如果直接编译进入内核， 成为内核镜像的一部分， 在连接的时候<br>都会放在.init.text这个区段内。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ _init     _ _attribute_ _ ((_ _section_ _ (<span class="meta-string">".init.text"</span>)))</span></span><br></pre></td></tr></table></figure><h3 id="模块卸载函数"><a href="#模块卸载函数" class="headerlink" title="模块卸载函数"></a>模块卸载函数</h3><p>Linux内核模块加载函数一般以__exit标识声明 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _ _<span class="function"><span class="built_in">exit</span> <span class="title">cleanup_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* 释放代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure><h3 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h3><p>我们可以用“module_param（参数名， 参数类型， 参数读/写权限） ”为模块定义一个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *book_name = <span class="string">"dissecting Linux Device Driver"</span>;</span><br><span class="line">module_param(book_name, charp, S_IRUGO);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> book_num = <span class="number">4000</span>;</span><br><span class="line">module_param(book_num, <span class="keyword">int</span>, S_IRUGO);</span><br></pre></td></tr></table></figure><h3 id="导出符号"><a href="#导出符号" class="headerlink" title="导出符号"></a>导出符号</h3><p>Linux的“/proc/kallsyms”文件对应着内核符号表， 它记录了符号以及符号所在的内存地址。<br>模块可以使用如下宏导出符号到内核符号表中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名);</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名);</span><br></pre></td></tr></table></figure><p>导出的符号可以被其他模块使用， 只需使用前声明一下即可。 </p><h3 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h3><p>在Linux内核模块中， 我们可以用MODULE_AUTHOR、 MODULE_DESCRIPTION、<br>MODULE_VERSION、 MODULE_DEVICE_TABLE、 MODULE_ALIAS分别声明模块的作者、 描述、 版<br>本、 设备表和别名，  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCRIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure><h1 id="第2章：字符设备驱动"><a href="#第2章：字符设备驱动" class="headerlink" title="第2章：字符设备驱动"></a>第2章：字符设备驱动</h1><h2 id="Linux字符设备驱动结构"><a href="#Linux字符设备驱动结构" class="headerlink" title="Linux字符设备驱动结构"></a>Linux字符设备驱动结构</h2><h3 id="cdev结构体"><a href="#cdev结构体" class="headerlink" title="cdev结构体"></a>cdev结构体</h3><p>在Linux内核中， 使用cdev结构体描述一个字符设备 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;</span><br><span class="line">struct kobject kobj; /* 内嵌的kobject对象 */</span><br><span class="line">struct module *owner; /* 所属模块*/</span><br><span class="line">struct file_operations *ops; /* 文件操作结构体*/</span><br><span class="line">struct list_head list;</span><br><span class="line">dev_t dev; /* 设备号*/</span><br><span class="line">unsigned int count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>成员dev_t</strong></p><p>cdev结构体的dev_t成员定义了设备号， 为32位， 其中12位为主设备号， 20位为次设备号。 使用下列<br>宏可以从dev_t获得主设备号和次设备号： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="keyword">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="keyword">dev_t</span> dev)</span><br></pre></td></tr></table></figure><p>而使用下列宏则可以通过主设备号和次设备号生成dev_t： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MKDEV(<span class="keyword">int</span> major, <span class="keyword">int</span> minor)</span><br></pre></td></tr></table></figure><p><strong>成员file_operations</strong></p><p>cdev结构体的另一个重要成员file_operations定义了字符设备驱动提供给虚拟文件系统的接口函数 </p><p>Linux内核提供了一组函数以用于操作cdev结构体： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *, struct file_operations *)</span></span>;</span><br><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_put</span><span class="params">(struct cdev *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *, <span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>cdev_init（） 函数用于初始化cdev的成员， 并建立cdev和file_operations之间的连接 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">cdev-&gt;ops = fops; <span class="comment">/* 将传入的文件操作结构体指针赋值给cdev的ops*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>cdev_alloc（ ） 函数用于动态申请一个cdev内存 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> = <span class="title">kzalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">cdev</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">INIT_LIST_HEAD(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cdev_add（ ） 函数和cdev_del（ ） 函数分别向系统添加和删除一个cdev， 完成字符设备的注册和注<br>销。 对cdev_add（ ） 的调用通常发生在字符设备驱动模块加载函数中， 而对cdev_del（ ） 函数的调用则通<br>常发生在字符设备驱动模块卸载函数中。 </p></li></ul><h3 id="分配和释放设备号"><a href="#分配和释放设备号" class="headerlink" title="分配和释放设备号"></a>分配和释放设备号</h3><p>在调用cdev_add（） 函数向系统注册字符设备之前， 应首先调用register_chrdev_region（） 或<br>alloc_chrdev_region（） 函数向系统申请设备号， 这两个函数的原型为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>register_chrdev_region（） 函数用于已知起始设备的设备号的情况， 而alloc_chrdev_region（） 用于设<br>备号未知， 向系统动态申请未被占用的设备号的情况， 函数调用成功之后， 会把得到的设备号放入第一个<br>参数dev中。 alloc_chrdev_region（） 相比于register_chrdev_region（） 的优点在于它会自动避开设备号重复<br>的冲突。 </p><p>相应地， 在调用cdev_del（） 函数从系统注销字符设备之后， unregister_chrdev_region（） 应该被调用<br>以释放原先申请的设备号， 这个函数的原型为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h3><p>file_operations结构体中的成员函数是字符设备驱动程序设计的主体内容， 这些函数实际会在应用程序<br>进行Linux的open（） 、 write（） 、 read（） 、 close（） 等系统调用时最终被内核调用。 file_operations结构<br>体目前已经比较庞大 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_operations结构体</span></span><br><span class="line"><span class="number">1</span>struct file_operations &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line"><span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line"><span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **);</span><br><span class="line"><span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line"><span class="keyword">loff_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>file_operations结构体中的主要成员进行分析 :</p><p>略</p><h2 id="Linux字符设备驱动的组成"><a href="#Linux字符设备驱动的组成" class="headerlink" title="Linux字符设备驱动的组成"></a>Linux字符设备驱动的组成</h2><p><strong>1.字符设备驱动模块加载与卸载函数</strong>    </p><p>在字符设备驱动模块加载函数中应该实现设备号的申请和cdev的注册， 而在卸载函数中应实现设备号<br>的释放和cdev的注销。 </p><p>Linux内核的编码习惯是为设备定义一个设备相关的结构体， 该结构体包含设备所涉及的cdev、 私有<br>数据及锁等信息。 常见的设备结构体、 模块加载和卸载函数形式 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 代码6.5 设备结构体</span><br><span class="line">struct xxx_dev_t &#123;</span><br><span class="line"> struct cdev cdev;</span><br><span class="line"> ...</span><br><span class="line">&#125; xxx_dev;</span><br><span class="line">/* 设备驱动模块加载函数</span><br><span class="line">static int _ _init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops); /* 初始化cdev */</span><br><span class="line"> xxx_dev.cdev.owner = THIS_MODULE;</span><br><span class="line">/* 获取字符设备号*/</span><br><span class="line">if (xxx_major) </span><br><span class="line">&#123;</span><br><span class="line">register_chrdev_region(xxx_dev_no, 1, DEV_NAME);</span><br><span class="line">&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, 1); /* 注册设备*/</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 设备驱动模块卸载函数*/</span><br><span class="line">static void _ _exit xxx_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">unregister_chrdev_region(xxx_dev_no, 1); /* 释放占用的设备号*/</span><br><span class="line">cdev_del(&amp;xxx_dev.cdev); /* 注销设备*/</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.字符设备驱动的file_operations结构体中的成员函数</strong> </p><p>ile_operations结构体中的成员函数是字符设备驱动与内核虚拟文件系统的接口， 是用户空间对Linux<br>进行系统调用最终的落实者。 大多数字符设备驱动会实现read（） 、 write（） 和ioctl（） 函数， 常见的字<br>符设备驱动的这3个函数的形式 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read = xxx_read,</span><br><span class="line">.write = xxx_write,</span><br><span class="line">.unlocked_ioctl= xxx_ioctl,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 读设备*/</span></span><br><span class="line"><span class="keyword">ssize_t</span> xxx_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,<span class="keyword">loff_t</span>*f_pos)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">copy_to_user(buf, ..., ...);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写设备*/</span></span><br><span class="line"><span class="keyword">ssize_t</span> xxx_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,<span class="keyword">loff_t</span> *f_pos)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">copy_from_user(..., buf, ...);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ioctl函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">xxx_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">case</span> XXX_CMD1:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> XXX_CMD2:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* 不能支持的命令 */</span></span><br><span class="line"><span class="keyword">return</span> - ENOTTY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设备驱动的读函数中， filp是文件结构体指针， buf是用户空间内存的地址， 该地址在内核空间不宜直<br>接读写， count是要读的字节数， f_pos是读的位置相对于文件开头的偏移。</p><p>设备驱动的写函数中， filp是文件结构体指针， buf是用户空间内存的地址， 该地址在内核空间不宜直<br>接读写， count是要写的字节数， f_pos是写的位置相对于文件开头的偏移。</p><p>由于用户空间不能直接访问内核空间的内存， 因此借助了函数copy_from_user（） 完成用户空间缓冲<br>区到内核空间的复制， 以及copy_to_user（） 完成内核空间到用户空间缓冲区的复制， 见代码第6行和第14<br>行。</p><p>完成内核空间和用户空间内存复制的copy_from_user（） 和copy_to_user（） 的原型分别为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> _ _user *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> _ _user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>上述函数均返回不能被复制的字节数， 因此， 如果完全复制成功， 返回值为0。 如果复制失败， 则返<br>回负值。 </p><p>如果要复制的内存是简单类型， 如char、 int、 long等， 则可以使用简单的put_user（） 和<br>get_user（） ， 如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val; <span class="comment">/* 内核空间整型变量</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">get_user(val, (int *) arg); /* 用户→内核， arg是用户空间的地址 */</span></span><br><span class="line">...</span><br><span class="line">put_user(val, (<span class="keyword">int</span> *) arg); <span class="comment">/* 内核→用户， arg是用户空间的地址 */</span></span><br></pre></td></tr></table></figure><p>在字符设备驱动中， 需要定义一个file_operations的实例， 并将具体设备驱动的函数赋值给<br>file_operations的成员 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.read = xxx_read,</span><br><span class="line">.write = xxx_write,</span><br><span class="line">.unlocked_ioctl= xxx_ioctl,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述xxx_fops在代码清单6.5的cdev_init（&amp;xxx_dev.cdev， &amp;xxx_fops） 的语句中建立与cdev的连接。 </p><p>图6.1所示为字符设备驱动的结构、 字符设备驱动与字符设备以及字符设备驱动与用户空间访问该设<br>备的程序之间的关系。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-08_22-29-27.png" alt="Snipaste_2019-03-08_22-29-27"></p><p>个人理解：由图可知，内核的所有操作都是基于cdv结构体操作。其中的重中之重为dev_t，file_operations()成员以及加载和卸载函数。</p><p>dev_t：定义了设备号， 为32位， 其中12位为主设备号， 20位为次设备号。</p><p>file_operations():定义了字符设备驱动提供给虚拟文件系统的接口函数 ，该函数结构体为Linux内核提供了一组函数以用于操作cdev结构体。</p><p>加载及卸载函数：应该实现设备号的申请和cdev的注册及现设备号<br>的释放和cdev的注销。</p><p>而用户则通过Linux系统调用file_operations()定义的字符设备驱动提供给虚拟文件系统的接口函数 来实现底层的内核操作。</p><p>总结这个图是我见过的最精辟的，非常容易理解，有的则用一堆的结构体及函数来表示，看的头晕。</p><h2 id="第三章：驱动编写"><a href="#第三章：驱动编写" class="headerlink" title="第三章：驱动编写"></a>第三章：驱动编写</h2><h3 id="1-头文件、-宏及设备结构体"><a href="#1-头文件、-宏及设备结构体" class="headerlink" title="1.头文件、 宏及设备结构体"></a>1.头文件、 宏及设备结构体</h3><p>在globalmem字符设备驱动中， 应包含它要使用的头文件， 并定义globalmem设备结构体及相关宏。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1， 增加头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dev_major;</span><br></pre></td></tr></table></figure><h3 id="2-加载与卸载设备驱动"><a href="#2-加载与卸载设备驱动" class="headerlink" title="2.加载与卸载设备驱动"></a>2.加载与卸载设备驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">dev_major = register_chrdev(<span class="number">0</span>, <span class="string">"hello_dev"</span>, &amp;hello_fops);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">unregister_chrdev(dev_major, <span class="string">"hello_dev"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载和卸载的入口函数</span></span><br><span class="line">module_init(hello_drv_init);</span><br><span class="line">module_exit(hello_drv_exit);</span><br></pre></td></tr></table></figure><h3 id="3-添加GPL认证"><a href="#3-添加GPL认证" class="headerlink" title="3.添加GPL认证"></a>3.添加GPL认证</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p><strong>最简单的一个驱动实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  1， 增加头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dev_major;</span><br><span class="line">   <span class="comment">//3， 实现模块加载和卸载的入口函数</span></span><br><span class="line"><span class="comment">//函数的原形：一定要是返回值为int， 参数为void</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">dev_major = register_chrdev(<span class="number">0</span>, <span class="string">"hello_dev"</span>, &amp;hello_fops);<span class="comment">//加载设备号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的原形：一定要是返回值为void， 参数为void</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line">unregister_chrdev(dev_major, <span class="string">"hello_dev"</span>);<span class="comment">//卸载设备号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(hello_drv_init);</span><br><span class="line">module_exit(hello_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p>装载和卸载模块命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># insmod  hello_drv.ko</span></span><br><span class="line"><span class="meta"># lsmod——显示已载入系统的模块</span></span><br><span class="line"><span class="meta"># rmmod hello_drv</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_01-50-17.png" alt="Snipaste_2019-03-09_01-50-17"></p><p>实际情况应该在装载及卸载时都打印出：——-^_^—–hello_dev—</p><p>注：lsmod——显示已载入系统的模块</p><p>​    申请主设备号是否成功：cat  /proc/devices</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_02-04-32.png" alt="Snipaste_2019-03-09_02-04-32"></p><p>​    </p><p><strong>函数讲解</strong></p><p>register_chrdev()</p><p>register_chrdev函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">const</span> struct file_operations *fops)</span></span></span><br></pre></td></tr></table></figure><p>* register_chrdev() -为字符设备注册一个主号码。</p><p>* @major:用于动态分配的主要设备号或0</p><p>* @name:这一系列设备的名称</p><p>* @fops:与此设备相关联的文件操作</p><p>*如果@major == 0，这个函数将动态分配一个main并返回它的号码。(静态注册主设备号)</p><p>*如果@major &gt; 0，此函数将尝试使用给定的设备保留设备，主要数字，将返回零成功。(动态注册主设备号)</p><h3 id="4-创建字符设备文件节点"><a href="#4-创建字符设备文件节点" class="headerlink" title="4. 创建字符设备文件节点"></a><strong>4. 创建字符设备文件节点</strong></h3><p>但是上面的驱动还是不完整的驱动，无法给用户使用的。</p><p>驱动为用户空间提供字符设备文件(设备文件/设备节点)：用户才能通过操作文件来操作驱动</p><p><strong>创建设备文件节点的两种方法</strong></p><p>1， 手动创建–mknod命令</p><p>mknod 文件名  类型  主设备号  次设备号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：</span></span><br><span class="line">mknod  /dev/hello_dev  c  <span class="number">257</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_02-42-08.png" alt="Snipaste_2019-03-09_02-42-08"></p><p>2， 代码中自动创建–驱动装载就创建，卸载就直接删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类--将设备归类</span></span><br><span class="line"><span class="comment">//参数1--类是又哪个模块创建的，一般直接填THIS_MODULE</span></span><br><span class="line"><span class="comment">//参数2--类的名字，一般自定义</span></span><br><span class="line">class_create(owner,name)</span><br><span class="line">==》 struct class *class_create(struct <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line"><span class="comment">//在该类中创建某个设备</span></span><br><span class="line"><span class="comment">//参数1--哪个类别中</span></span><br><span class="line"><span class="comment">//参数2--当前创建的设备对象的父类，一般直接填NULL</span></span><br><span class="line"><span class="comment">//参数3--设备文件的设备号</span></span><br><span class="line"><span class="comment">//参数4--设备的私有数据--一般直接填NULL</span></span><br><span class="line"><span class="comment">//参数5--设备节点的名字</span></span><br><span class="line">device_create(struct class * cls,struct device * parent,<span class="keyword">dev_t</span> devt,<span class="keyword">void</span> * drvdata,<span class="keyword">const</span> <span class="keyword">char</span> * fmt,...)</span><br></pre></td></tr></table></figure><p><strong>在上阶程序优化static int __init hello_drv_init(void)函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_drv_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1-向系统申请/注册主设备号--就是id，整数</span></span><br><span class="line">        <span class="comment">//参数1--指定的大于0主设备号--最大是12bit， 一般选256以上，或者直接填0， 表示动态系统分配</span></span><br><span class="line">        <span class="comment">//参数2--设备的名字--一般自定义</span></span><br><span class="line">        <span class="comment">//参数3--为应用空间提供的文件操作接口</span></span><br><span class="line">        <span class="comment">//返回值;正确为0， 错误为负数</span></span><br><span class="line">        ret = register_chrdev(dev_major, <span class="string">"hello_dev"</span>, &amp;hello_fops);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 2- 创建类--将设备归类</span></span><br><span class="line">        <span class="comment">//参数1--类是又哪个模块创建的，一般直接填THIS_MODULE</span></span><br><span class="line">        <span class="comment">//参数2--类的名字，一般自定义</span></span><br><span class="line">        <span class="comment">// 实际是创建了 /sys/class/led_cls</span></span><br><span class="line">        led_cls = class_create(THIS_MODULE, <span class="string">"led_cls"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在该类中创建某个设备文件--/dev/hello0</span></span><br><span class="line">        <span class="comment">//参数1--哪个类别中</span></span><br><span class="line">        <span class="comment">//参数2--当前创建的设备对象的父类，一般直接填NULL</span></span><br><span class="line">        <span class="comment">//参数3--设备文件的设备号</span></span><br><span class="line">        <span class="comment">//参数4--设备的私有数据--一般直接填NULL</span></span><br><span class="line">        <span class="comment">//参数5--设备节点的名字</span></span><br><span class="line">        led_dev = device_create(led_cls, <span class="literal">NULL</span>, MKDEV(dev_major, <span class="number">0</span>), <span class="literal">NULL</span>,  <span class="string">"%s%d"</span>, led_dev_name, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//模块加载函数正确的时候一定返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-03-09_03-39-00.png" alt="Snipaste_2019-03-09_03-39-00"></p><p>结果：加载驱动后，会在/sys/class/led_cls目录下建立led_dev文件节点。</p><h3 id="5-实现应用调用驱动文件io的方式"><a href="#5-实现应用调用驱动文件io的方式" class="headerlink" title="5.实现应用调用驱动文件io的方式"></a>5.实现应用调用驱动文件io的方式</h3><p>该部分为会为各户提供各种文件io接口（供应用APP系统调用实现底层操作）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.文件操作对象---为用户提供各种文件io接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_drv_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 read(fd, buf, size);</span></span><br><span class="line"><span class="keyword">ssize_t</span> hello_drv_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *fpos)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> hello_drv_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *fpos)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_drv_close</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"-------^_^-----%s---\n"</span>, __FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span></span><br><span class="line">.open = hello_drv_open,</span><br><span class="line">.read = hello_drv_read,</span><br><span class="line">.write = hello_drv_write,</span><br><span class="line">.release = hello_drv_close,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一个完整的字符设备驱动程序"><a href="#一个完整的字符设备驱动程序" class="headerlink" title="一个完整的字符设备驱动程序"></a>一个完整的字符设备驱动程序</h3><p> //  1， 增加头文件</p><p>#include &lt;linux/init.h&gt;</p><p>#include &lt;linux/module.h&gt;</p><p>#include &lt;linux/fs.h&gt;</p><p>#include &lt;linux/device.h&gt;</p><p>#include &lt;asm/io.h&gt;</p><p>static struct device <em>led_dev;<br>static char </em>led_dev_name = “led_dev”;<br>static struct class *led_cls;<br>static unsigned int dev_major;</p><p>//2.文件操作对象—为用户提供各种文件io接口</p><p>int hello_drv_open(struct inode <em>inode, struct file </em>filp)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);</p><p>​    return 0;<br>}</p><p>//应用 read(fd, buf, size);<br>ssize_t hello_drv_read(struct file <em>filp, char __user </em>buf, size_t count, loff_t *fpos)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}</p><p>ssize_t hello_drv_write(struct file <em>filp, const char __user </em>buf, size_t count, loff_t *fpos)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}</p><p>int hello_drv_close(struct inode <em>inode, struct file </em>filp)<br>{<br>    printk(“——-^_^—–%s—\n”, <strong>FUNCTION</strong>);<br>    return 0;<br>}<br>//文件操作对象—为用户提供各种文件io接口<br>const struct file_operations hello_fops = {<br>    .open = hello_drv_open,<br>    .read = hello_drv_read,<br>    .write = hello_drv_write,<br>    .release = hello_drv_close,</p><p>};</p><p>   //3， 实现模块加载和卸载的入口函数<br>//函数的原形：一定要是返回值为int， 参数为void<br>static int <strong>init hello_drv_init(void)<br>{<br>    printk(“——-^_^—–%s—\n”, </strong>FUNCTION__);</p><p>​    int ret;</p><p>​    //1-向系统申请/注册主设备号–就是id，整数<br>​    //参数1–指定的大于0主设备号–最大是12bit， 一般选256以上，或者直接填0， 表示动态系统分配<br>​    //参数2–设备的名字–一般自定义<br>​    //参数3–为应用空间提供的文件操作接口<br>​    //返回值;正确为0， 错误为负数<br>​    ret = register_chrdev(dev_major, “hello_dev”, &amp;hello_fops);</p><p>​    // 2- 创建类–将设备归类<br>​    //参数1–类是又哪个模块创建的，一般直接填THIS_MODULE<br>​    //参数2–类的名字，一般自定义<br>​    // 实际是创建了 /sys/class/led_cls<br>​    led_cls = class_create(THIS_MODULE, “led_cls”);<br>​<br>​    //3-在该类中创建某个设备文件–/dev/hello0<br>​    //参数1–哪个类别中<br>​    //参数2–当前创建的设备对象的父类，一般直接填NULL<br>​    //参数3–设备文件的设备号<br>​    //参数4–设备的私有数据–一般直接填NULL<br>​    //参数5–设备节点的名字<br>​    led_dev = device_create(led_cls, NULL, MKDEV(dev_major, 0), NULL,  “%s%d”, led_dev_name, 0);<br>​    //模块加载函数正确的时候一定返回0<br>​    return 0;</p><p>}<br>//函数的原形：一定要是返回值为void， 参数为void<br>static void hello_drv_exit(void)<br>{<br>    printk(“——-^_^—–%s—\n”);<br>    unregister_chrdev(dev_major, “hello_dev”);<br>}</p><p>module_init(hello_drv_init);<br>module_exit(hello_drv_exit);<br>MODULE_LICENSE(“GPL”);</p><p>碰见的一些问题：</p><p><strong>（1）问题:</strong></p><p>译模块出错：insmod: ERROR: could not insert module module.ko: Invalid parameters</p><p>选择错误头文件路径</p><p>解决：</p><p>uname -r查看当前运行的内核版本</p><p>ubuntu下内核路径：cd  /usr /src/</p><p><strong>（2）问题：</strong></p><p>Linux中终端显示的当前目录的绝对路径太长</p><p>解决：</p><p>只显示当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>找到位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$color_prompt&quot; = yes ]; then</span><br><span class="line">    PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &apos;</span><br><span class="line">else</span><br><span class="line">    PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>将这两个小写的w换成大写W，然后source ~/.bashrc即可</p><h2 id="第四章：平台总线"><a href="#第四章：平台总线" class="headerlink" title="第四章：平台总线"></a>第四章：平台总线</h2><p>平台总线简述：略</p><h3 id="小节一：I2C设备驱动"><a href="#小节一：I2C设备驱动" class="headerlink" title="小节一：I2C设备驱动"></a>小节一：I2C设备驱动</h3><h4 id="i2c协议说明"><a href="#i2c协议说明" class="headerlink" title="i2c协议说明"></a>i2c协议说明</h4><p>略</p><h4 id="Linux-I2C体系结构"><a href="#Linux-I2C体系结构" class="headerlink" title="Linux I2C体系结构"></a>Linux I2C体系结构</h4><p>查考：<a href="https://www.cnblogs.com/pingfandfy/p/5822813.html" target="_blank" rel="noopener">Linux操作系统的I2C驱动</a></p><p>Linux I2C体系结构分为3个组成部分：I2C核心 ，I2C总线驱动 ，I2C设备驱动 。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-11_12-19-25.png" alt="Snipaste_2019-03-11_12-19-25"></p><ul><li><p><strong>I2C核心</strong> </p><p>I2C核心为上层提供统一的接口和提供I2C总线驱动和设备驱动的注册、注销方法，I2C通信方法（即Algorithm） 上层的与具<br>体适配器无关的代码以及探测设备、 检测设备地址的上层代码等 </p></li><li><p><strong>I2C总线驱动</strong> </p><p>I2C总线驱动是对I2C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。I2C总线驱动主要包含了I2C适配器数据结构i2c_adapter、I2C适配器的algorithm数据结构i2c_algorithm和控制I2C适配器产生通信信号的函数。经由I2C总线驱动的代码，我们可以控制I2C适配器以主控方式产生开始位、停止位、读写周期，以及以从设备方式被读写、产生ACK等。</p></li><li><p><strong>I2C设备驱动</strong> </p><p>I2C设备驱动是对I2C硬件体系结构中设备端的实现，设备一般挂接在首CPU控制的I2C适配器上，通过I2C适配器与CPU交换数据。I2C设备驱动主要包含了数据结构i2c_driver和i2c_client，我们需要根据具体设备实现其中的成员函数。</p></li></ul><h4 id="Linux-I2C-驱动编程"><a href="#Linux-I2C-驱动编程" class="headerlink" title="Linux I2C 驱动编程"></a>Linux I2C 驱动编程</h4><h5 id="Linux-I2C适配器驱动"><a href="#Linux-I2C适配器驱动" class="headerlink" title="Linux I2C适配器驱动"></a>Linux I2C适配器驱动</h5><p>I2C适配器驱动的注册与注销 </p><p>I2C总线的通信方法 </p><h3 id="SPI设备驱动"><a href="#SPI设备驱动" class="headerlink" title="SPI设备驱动"></a>SPI设备驱动</h3><h3 id="PCI设备驱动"><a href="#PCI设备驱动" class="headerlink" title="PCI设备驱动"></a>PCI设备驱动</h3><h2 id="第五章：块设备"><a href="#第五章：块设备" class="headerlink" title="第五章：块设备"></a>第五章：块设备</h2><p>略</p><h2 id="第六章：网络设备"><a href="#第六章：网络设备" class="headerlink" title="第六章：网络设备"></a>第六章：网络设备</h2><p>略</p><p>## </p><h2 id="第七章：设备模型（补充）"><a href="#第七章：设备模型（补充）" class="headerlink" title="第七章：设备模型（补充）"></a>第七章：设备模型（补充）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章-Linux设备驱动概述&quot;&gt;&lt;a href=&quot;#第1章-Linux设备驱动概述&quot; class=&quot;headerlink&quot; title=&quot;第1章 Linux设备驱动概述&quot;&gt;&lt;/a&gt;第1章 Linux设备驱动概述&lt;/h1&gt;&lt;h2 id=&quot;Linux设备驱动&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/嵌入式Linux网络编程.html</id>
    <published>2019-03-04T05:07:52.000Z</published>
    <updated>2019-03-05T14:25:24.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式-Linux-网络编程"><a href="#嵌入式-Linux-网络编程" class="headerlink" title="嵌入式 Linux 网络编程"></a>嵌入式 Linux 网络编程</h1><h2 id="第一章：TCP-IP-协议简介"><a href="#第一章：TCP-IP-协议简介" class="headerlink" title="第一章：TCP/IP 协议简介"></a>第一章：TCP/IP 协议简介</h2><h3 id="TCP-IP-协议概述"><a href="#TCP-IP-协议概述" class="headerlink" title="TCP/IP 协议概述"></a>TCP/IP 协议概述</h3><h4 id="OSI-参考模型及-TCP-IP-参考模型"><a href="#OSI-参考模型及-TCP-IP-参考模型" class="headerlink" title="OSI 参考模型及 TCP/IP 参考模型"></a>OSI 参考模型及 TCP/IP 参考模型</h4><p>OSI 协议参考模型是基于国际标准化组织（ISO）的建议发展起来的，从上<br>到下共分为 7 层：应用层、表示层、会话层、传输 层、 网络层、<br>数据链路层及物理层。这个 7 层的协议模型虽然规 定得非常细<br>致和完善，但在实际中却得不到广泛的应用，其重 要的原因之<br>一就在于它过于复杂。但它仍是此后很多协议模型 的基础，这<br>种分层架构的思想在很多领域都得到了广泛的应 用。</p><a id="more"></a><p>与此相区别的 TCP/IP 协议模型从一开始就遵循简单明 确的设计思<br>路，它将 TCP/IP 的 7 层协议模型简化为 4 层，从而更 有利于实现<br>和使用。 TCP/IP 的协议参考模型和 OSI 协议参考模型 的对应关系<br>如图10.1 所示。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_13-23-01.png" alt="Snipaste_2019-03-04_13-23-01"></p><h4 id="TCP-IP-的-4-层模型进行简要介绍"><a href="#TCP-IP-的-4-层模型进行简要介绍" class="headerlink" title="TCP/IP 的 4 层模型进行简要介绍"></a>TCP/IP 的 4 层模型进行简要介绍</h4><p><strong>网络接口层：</strong>负责将二进制流转换为数据帧，并进行数据帧的发送和接收。要注意的是数据帧是<br>独立的网络信息传输单元。</p><p><strong>网络层：</strong>负责将数据帧封装成 IP 数据包，并运行必要的路由算法。</p><p><strong>传输层：</strong>负责端对端之间的通信会话连接与建立。传输协议的选择根据数据传输方式而定。</p><p><strong>应用层：</strong>负责应用程序的网络访问，这里通过端口号来识别各个不同的进程。 </p><h4 id="TCP-IP概述"><a href="#TCP-IP概述" class="headerlink" title="TCP/IP概述"></a>TCP/IP概述</h4><p>因特网在传输层有两种主要的协议：一种是面向连接的协议，一种是无连接的协议。传输控制协议TCP是(transmission control protocol)专门用于在不可靠的因特网上提供可靠的、端对端的字节流通信的协议。通过在发送方和接收方分别创建一个称为套接字的通信端口就可以获得TCP服务。所有的TCP 连接均是全双工的和点到点的。（tcp/ip提供可靠，全双工的和点到点连接）</p><p>TCP 数据传输实<br>现了从一个应用程序到另一个应用程序的数据传递。应用程序通过编程调用 TCP 并使用 TCP 服务，提供需要准<br>备发送的数据，用来区分接收数据应用的目的地址和端口号。 </p><p>通常应用程序通过打开一个 socket 来使用 TCP 服务， TCP 管理到其他 socket 的数据传递。</p><p>可以说：</p><ul><li>通过<br>IP 的源/目的可以惟一地区分网络中两个设备的连接</li><li>通过 socket 的源/目的可以惟一地区分网络中两个应<br>用程序的连接。 </li></ul><p>虽然 TCP/IP 名称只包含了两个协议，但实际上， TCP/IP 是 一 个 庞<br>大的协议族，它包括了各个层次上的众多协议，</p><p>图10.2 列 举 了 各<br>层中一些重要的协议， 并给出了各个协议在不同层次中所 处的位置，<br>如下所示。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_13-29-39.png" alt="Snipaste_2019-03-04_13-29-39"></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP数据报头"><a href="#TCP数据报头" class="headerlink" title="TCP数据报头"></a>TCP数据报头</h4><p>该部分参考自：<a href="https://www.cnblogs.com/renzimu/p/3868747.html" target="_blank" rel="noopener">TCP/IP原理、基础以及在Linux上的实现</a></p><p>发送和接收方TCP实体以数据报的形式交换数据。一个数据报包含一个固定的20字节的头、一个可选部分以及0或多字节的数据。对数据报的大小有两个限制条件：首先，每个数据报（包括TCP头在内）必须适合IP的载荷能力，不能超过65535字节；其次，每个网络都存在最大传输单元MTU（maximum transfer unit），要求每个数据报必须适合MTU。如果一个数据报进入了一个MTU小于该数据报长度的网络，那么处于网络边界上的路由器会把该数据报分解为多个小的数据报。</p><p>TCP实体所采用的基本协议是滑动窗口协议。当发送方传送一个数据报时，它将启动计时器。当该数据报到达目的地后，接收方的TCP实体向回发送一个数据报，其中包含有一个确认序号，它等于希望收到的下一个数据报的顺序号。如果发送方的定时器在确认信息到达之前超时，那么发送方会重发该数据报。</p><p>下图给出了TCP数据报头的格式。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_14-25-58.png" alt="Snipaste_2019-03-04_14-25-58"></p><p><strong>源端口、目的端口：</strong>16位长。标识出远端和本地的端口号。</p><p><strong>顺序号：</strong>32位长。表明了发送的数据报的顺序。</p><p><strong>确认号：</strong>32位长。希望收到的下一个数据报的序列号。</p><p><strong>TCP头长：</strong>4位长。表明TCP头中包含多少个32位字。</p><p>接下来的6位未用。 </p><p><strong>ACK（表示响应）：</strong>ACK位置1表明确认号是合法的。如果ACK为0，那么数据报不包含确认信息，确认字段被省略。</p><p><strong>PSH（表示有 DATA数据传输）：</strong>表示是带有PUSH标志的数据。接收方因此请求数据报一到便可送往应用程序而不必等到缓冲区装满时才传送。</p><p><strong>RST（表示连接重置）：</strong>用于复位由于主机崩溃或其它原因而出现的错误的连接。还可以用于拒绝非法的数据报或拒绝连接请求。</p><p><strong>SYN（表示建立连接）：</strong>用于建立连接。</p><p><strong>FIN（表示关闭连接）：</strong>用于释放连接。</p><p><strong>窗口大小：</strong>16位长。窗口大小字段表示在确认了字节之后还可以发送多少个字节。</p><p><strong>校验和：</strong>16位长。是为了确保高可靠性而设置的。它校验头部、数据和伪TCP头部之和。</p><p><strong>可选项：</strong>0个或多个32位字。包括最大TCP载荷，窗口比例、选择重发数据报等选项。</p><ol><li>最大TCP载荷：允许每台主机设定其能够接受的最大的TCP载荷能力。在建立连接期间，双方均声明其最大载荷能力，并选取其中较小的作为标准。如果一台主机未使用该选项，那么其载荷能力缺省设置为536字节。</li><li>窗口比例：允许发送方和接收方商定一个合适的窗口比例因子。这一因子使滑动窗口最大能够达到232字节。</li><li>选择重发数据报：这个选项允许接收方请求发送指定的一个或多个数据报。</li></ol><p><strong>注：</strong>其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，</p><p><em>如果只是单个的一个SYN，它表示的只是建立连接。</em></p><p><em>TCP的几次握手就是通过这样的ACK表现出来的。</em></p><p><em>但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。</em></p><p><em>RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。</em></p><p><em>一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。</em></p><p><em>PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。</em></p><h4 id="IP数据报头"><a href="#IP数据报头" class="headerlink" title="IP数据报头"></a>IP数据报头</h4><p>略</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><em>SYN</em>：同步序列编号（<em>Syn</em>chronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。表示建立连接。</p><p>seq是顺序号，ack是确认号，大小均为4字节</p><p>TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。</p><ul><li>初始化主机通过一个同步标志置位（SYN）的数据段发出会话请求，及随机顺序号(seq)。</li><li>接收主机通过发回具有以下项目的数据段表示回复：同步标志置位（SYN）、即将发送的数据段的起始字<br>节的顺序号(seq)、应答（ACK）并带有将收到的下一个数据段的字节顺序号。</li><li>请求主机再回送一个数据段，并带有确认顺序号和确认号。 </li></ul><p>完成三次握手，主机A与主机B开始传送数据。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_15-00-34.png" alt="Snipaste_2019-03-04_15-00-34"></p><h4 id="四步挥手"><a href="#四步挥手" class="headerlink" title="四步挥手"></a>四步挥手</h4><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>略</p><h2 id="第二章：网络编程基础"><a href="#第二章：网络编程基础" class="headerlink" title="第二章：网络编程基础"></a>第二章：网络编程基础</h2><p>我们熟悉了各种Linux 系统所提供的经典进程间通信 机制（ IPC）： 管道、 FIFO、 消息 队列、 信号量 以及共享存储。 这些机制允许在同一台计算 机上运行的进程可以相互通信。 本章将学会不同计算机（ 通过网络相连）上的进程相互通信的机制： 网络进程间通信（ network IPC）。</p><p>我们将熟悉套接字网络进程间通信接口， 进程用该 接口能够和其他进程通信， 无论它们是在同 一台计算机上还是在不同的计算机上。</p><h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接 字。套接字 描述符 在UNIX系统中被当作是一 种文件描述符。  许多 处理文件描述符的函数（ 如 read 和 write）也可以 用于处理套 接字描述符。 </p><p>创建一个套接字， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 socket 函数。 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//返回 值： 若 成功， 返回 文件（ 套 接 字） 描述 符； 若 出错， 返回 − 1</span></span><br></pre></td></tr></table></figure><h3 id="socket-概述"><a href="#socket-概述" class="headerlink" title="socket 概述"></a>socket 概述</h3><p><strong>socket 定义</strong> </p><p>在 Linux 中的网络编程是通过 socket 接口来进行的。人们常说的 socket 是一种特殊的 I/O 接口，它也是一<br>种文件描述符。 socket 是一种常用的进程之间通信机制，通过它不仅能实现本地机器上的进程之间的通信，<br>而且通过网络能够在不同机器上的进程之间进行通信。</p><p>每一个 socket 都用一个半相关描述{协议、本地地址、本地端口}来表示；一个完整的套接字则用一个相关<br>描述{协议、本地地址、本地端口、远程地址、远程端口}来表示。 socket 也有一个类似于打开文件的函数<br>调用，该函数返回一个整型的 socket 描述符，随后的连接建立、数据传输等操作都是通过 socket 来实现的。 </p><p><strong>socket 类型</strong> </p><p>常见的 socket 有 3 种类型如下。</p><ul><li><p><strong>流式 socket（SOCK_STREAM）</strong><br>流式套接字提供可靠的、面向连接的通信流；它使用 TCP 协议，从而保证了数据传输的正确性和顺序性。</p></li><li><p><strong>数据报 socket（SOCK_DGRAM）</strong><br>数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证是可<br>靠、无差错的。它使用数据报协议 UDP。</p></li><li><strong>原始 socket</strong> 原始套接字允许对底层协议如 IP 或 ICMP 进行直接访问，它功能强大但使用较为不便，主要用于一些协议<br>的开发。 </li></ul><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>在同一台计算机上的进程进行通信 时，一般不用考虑字节序。 字节序是 一个处理器架构特性，用 指示像整数这样的大数据类型内部的字节如何排序。</p><p>图 为一个32位整数的字节序</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_15-38-40.png" alt="Snipaste_2019-03-04_15-38-40"></p><p>如果处理器架构支持大端（ big- endian）字节序， 那么最大字节地址出现 在最低有效字节（ Least Significant Byte， LSB）上。</p><p> 小 端（ little- endian）字节序则相反：最低有效字节包含最小字节地址。</p><p>计算机数据存储有两种字节优先顺序：高位字节优先（称为大端模式）和低位字节优先（称为小端模式，<br>PC 机通常采用小端模式）。 Internet 上网络协议指定数据以高位字节优先顺序在网络上传输，所以应用程序有时需要在 处理器的字节序与网络字节序之间转换它们。这里用到了 4 个函数： htons()、 ntohs()、 htonl()和 ntohl()。这 4<br>个地址分别实现网络字节序和主机字节序的转化，这里的 h 代表 host， n 代表 network， s 代表 short， l 代<br>表 long。通常 16 位的 IP 端口号用 s 代表，而 IP 地址用 l 来代表  </p><p><strong>函数格式说明</strong> </p><p>下图列出了这 4 个函数的语法格式 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_16-18-06.png" alt="Snipaste_2019-03-04_16-18-06"></p><h3 id="IP地址格式"><a href="#IP地址格式" class="headerlink" title="IP地址格式"></a>IP地址格式</h3><h4 id="IP地址的作用"><a href="#IP地址的作用" class="headerlink" title="IP地址的作用"></a>IP地址的作用</h4><p>IP地址是用来标识网络中的一台 主机。 一个 IP地址包含两部分： 网络号 和主机号。 其中，网络号和主机号根据子网掩码来区分。 简单地说， 有了源IP和目标IP， 数据包就能在不同的主机之间传输。</p><p>IP地址有两种不同格式：十进制点分形式和32位二进制形式。 前者是用户所熟悉 的形式， 而后者则是网络传输中IP地址的存储方式。</p><p> IPv4地址转换函数有 inet_ aton()、 inet_ addr() 和 inet_ ntoa()，而 IPv4和IPv6兼容的函数有 inet_ pton() 和 inet_ ntop()。（IPv6不介绍）</p><h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><p><strong>IP地址相关结构体</strong></p><p>首先在介绍IP地址转换函数时可能会用到以下的数据结构</p><p>数据类型： sockaddr 和 sockaddr_in， 这两个结构类型都是用来保存 socket 信息的，<br>如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14 字节的协议地址，包含该socket 的IP 地址和端口号。 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP 地址*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*填充 0 以保持与 struct sockaddr 同样大小*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个数据类型是等效的，可以相互转化，通常 sockaddr_in 数据类型使用更为方便。在建立 socketadd 或<br>sockaddr_in 后，就可以对该 socket 进行适当的操作了。 </p><p><strong>下面列出了该结构 sa_family 字段可选的常见值</strong> </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_16-07-27.png" alt="Snipaste_2019-03-04_16-07-27"></p><p><strong>下面介绍地址格式转化函数</strong></p><p><strong>inet_ addr()</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_16-33-59.png" alt="Snipaste_2019-03-04_16-33-59"></p><hr><p><strong>inet_ pton()</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_16-34-11.png" alt="Snipaste_2019-03-04_16-34-11"></p><p><strong>inet_ ntop()</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_16-34-18.png" alt="Snipaste_2019-03-04_16-34-18"></p><h3 id="名字地址转化"><a href="#名字地址转化" class="headerlink" title="名字地址转化"></a>名字地址转化</h3><p>略</p><h2 id="第三章：socket编程实战"><a href="#第三章：socket编程实战" class="headerlink" title="第三章：socket编程实战"></a>第三章：socket编程实战</h2><p>推荐博客：<a href="https://www.cnblogs.com/PengfeiSong/p/6582998.html" target="_blank" rel="noopener">linux网络编程框架</a></p><h3 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h3><p>socket 编程的基本函数有 socket()、 bind()、 listen()、 accept()、 send()、 sendto()、 recv()以及 recvfrom()等，其<br>中根据客户端还是服务端，或者根据使用 TCP 协议还是 UDP 协议，这些函数的调用流程都有所区别，这里<br>先对每个函数进行说明，再给出各种情况下使用的流程图。</p><ul><li><p><strong>socket()：</strong> 该函数用于建立一个 socket 连接， 可指定 socket 类型等信息。 在建立了 socket 连接之后，<br>可对 sockaddr 或 sockaddr_in 结构进行初始化，以保存所建立的 socket 地址信息。</p></li><li><p><strong>bind()：</strong>该函数是用于将本地 IP 地址绑定到端口号，若绑定其他 IP 地址则不能成功。另外，它主<br>要用于 TCP 的连接，而在 UDP 的连接中则无必要。</p></li><li><p><strong>listen()：</strong>在服务端程序成功建立套接字和与地址进行绑定之后，还需要准备在该套接字上接收新<br>的连接请求。此时调用 listen()函数来创建一个等待队列，在其中存放未处理的客户端连接请求。</p></li><li><p><strong>accept()：</strong>服务端程序调用 listen()函数创建等待队列之后，调用 accept()函数等待并接收客户端的<br>连接请求。它通常从由 bind()所创建的等待队列中取出第一个未处理的连接请求。</p></li><li><p><strong>connect()：</strong>该函数在 TCP 中是用于 bind()的之后的 client 端，用于与服务器端建立连接，而在 UDP<br>中由于没有了 bind()函数，因此用 connect()有点类似 bind()函数的作用。</p></li><li><p><strong>send()和 recv()：</strong>这两个函数分别用于发送和接收数据，可以用在 TCP 中，也可以用在 UDP 中。<br>当用在 UDP 时，可以在 connect()函数建立连接之后再用。</p></li><li><p><strong>sendto()和 recvfrom()：</strong> 这两个函数的作用与 send()和 recv()函数类似， 也可以用在 TCP 和 UDP 中。<br>当用在 TCP 时，后面的几个与地址有关参数不起作用，函数作用等同于 send()和 recv()；当用在<br>UDP 时，可以用在之前没有使用 connect()的情况下，这两个函数可以自动寻找指定地址并进行连接。</p><p>服务器端和客户端使用 TCP 协议的流程如图 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_16-08-41.png" alt="Snipaste_2019-03-05_16-08-41"></p><p>服务器端和客户端使用 UDP 协议的流程如图 </p><p> <img src="D:\MyBlog\图片\Snipaste_2019-03-05_16-08-24.png" alt="Snipaste_2019-03-05_16-08-24"></p></li></ul><h3 id="函数格式分析"><a href="#函数格式分析" class="headerlink" title="函数格式分析"></a>函数格式分析</h3><p>socket() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-28-51.png" alt="Snipaste_2019-03-05_14-28-51"></p><p>bind() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-31-47.png" alt="Snipaste_2019-03-05_14-31-47"></p><p>listen() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-05.png" alt="Snipaste_2019-03-05_14-29-05"></p><p>accept() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-12.png" alt="Snipaste_2019-03-05_14-29-12"></p><p>connect() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-19.png" alt="Snipaste_2019-03-05_14-29-19"></p><p>send() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-27.png" alt="Snipaste_2019-03-05_14-29-27"></p><p>recv() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-33.png" alt="Snipaste_2019-03-05_14-29-33"></p><p>sendto() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-42.png" alt="Snipaste_2019-03-05_14-29-42"></p><p>recvfrom() </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_14-29-49.png" alt="Snipaste_2019-03-05_14-29-49"></p><h3 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h3><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><p>代码参考：<a href="https://www.cnblogs.com/lihaibo-Leao/p/3981955.html" target="_blank" rel="noopener">Linux C Socket编程原理及简单实例</a></p><p>程序为简单的“回射”，客户端将控制台输入的信息发送给服务器端，服务器原样返回信息。</p><p>服务器端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPORT  8887</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE   20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一步socket()</span></span><br><span class="line">    <span class="comment">///定义sockfd   </span></span><br><span class="line">    <span class="keyword">int</span> server_sockfd = socket(AF_INET,SOCK_STREAM, <span class="number">0</span>);<span class="comment">//ipv4，流式套接字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：bind()</span></span><br><span class="line">    <span class="comment">///定义sockaddr_in结构体参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_sockaddr</span>;</span></span><br><span class="line">    server_sockaddr.sin_family = AF_INET;  <span class="comment">//IPV4地址族</span></span><br><span class="line">    server_sockaddr.sin_port = htons(MYPORT);<span class="comment">//8887端口号，htons()将主机字节转为网络字节</span></span><br><span class="line">    server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">/*INADDR_ANY)：任意ip地址*/</span></span><br><span class="line">bzero(&amp;(server_sockaddr.sin_zero), <span class="number">8</span>);<span class="comment">/*填充 0 以保持与 struct sockaddr 同样大小*/</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">///bind，成功返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,<span class="keyword">sizeof</span>(server_sockaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：listen()</span></span><br><span class="line">    <span class="comment">///listen，成功返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(listen(server_sockfd,QUEUE) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步accept()</span></span><br><span class="line">    <span class="comment">///客户端套接字</span></span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///成功返回非负描述字，出错返回-1</span></span><br><span class="line">    <span class="keyword">int</span> conn = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length);</span><br><span class="line">    <span class="keyword">if</span>(conn&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第五到七步：recv()&amp;send()&amp;close();</span></span><br><span class="line">  <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(buffer));<span class="comment">//为申请的内存做初始化工作</span></span><br><span class="line">        <span class="keyword">int</span> len = recv(conn, buffer, <span class="keyword">sizeof</span>(buffer),<span class="number">0</span>);<span class="comment">//接收客户端数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buffer,<span class="string">"exit\n"</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(buffer, <span class="built_in">stdout</span>);<span class="comment">//把接受到数据打印到显示屏</span></span><br><span class="line">        send(conn, buffer, len, <span class="number">0</span>);<span class="comment">//重新发送接收收据到客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(conn);<span class="comment">//关闭客户端套接字描述符</span></span><br><span class="line">    close(server_sockfd);<span class="comment">//关闭服务端套接字描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客服端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPORT  8887</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步SOCKET();</span></span><br><span class="line">    <span class="comment">///定义sockfd</span></span><br><span class="line">    <span class="keyword">int</span> sock_cli = socket(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">///定义sockaddr_in</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET; <span class="comment">//IPV4</span></span><br><span class="line">    servaddr.sin_port = htons(MYPORT);  <span class="comment">///服务器端口:8887</span></span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);  <span class="comment">///服务器ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bind()一般不需要;客户端用bind的程序很容易出问题，指定的容易冲突？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：connect();</span></span><br><span class="line">    <span class="comment">///连接服务器，成功返回0，错误返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock_cli, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步到第五步：send()&amp;recv()&amp;close();</span></span><br><span class="line">    <span class="keyword">char</span> sendbuf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> recvbuf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span> (fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(sock_cli, sendbuf, <span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>); <span class="comment">///发送</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sendbuf,<span class="string">"exit\n"</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        recv(sock_cli, recvbuf, <span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>); <span class="comment">///接收</span></span><br><span class="line">        <span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock_cli);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：客户端发送数据给服务端，服务端收到数据显示并再次发送回客户端，客户端收到并显示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_16-23-50.png" alt="Snipaste_2019-03-05_16-23-50"></p><h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h4><p>参考：<a href="https://www.cnblogs.com/skyfsm/p/6287787.html" target="_blank" rel="noopener">Linux编程之UDP SOCKET全攻略</a></p><p>Server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_udp_msg</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFF_LEN];  <span class="comment">//接收缓冲区，1024字节</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clent_addr</span>;</span>  <span class="comment">//clent_addr用于记录发送方的地址信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">        len = <span class="keyword">sizeof</span>(clent_addr);</span><br><span class="line">        count = recvfrom(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;clent_addr, &amp;len);  <span class="comment">//recvfrom是拥塞函数，没有数据就一直拥塞</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recieve data fail!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client:%s\n"</span>,buf);  <span class="comment">//打印client发过来的信息</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"I have recieved %d bytes data!\n"</span>, count);  <span class="comment">//回复client</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server:%s\n"</span>,buf);  <span class="comment">//打印自己发送的信息给</span></span><br><span class="line">        sendto(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;clent_addr, len);  <span class="comment">//发送信息给client，注意使用了clent_addr结构体指针</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    server:</span></span><br><span class="line"><span class="comment">            socket--&gt;bind--&gt;recvfrom--&gt;sendto--&gt;close</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_fd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span> </span><br><span class="line"><span class="comment">//第一步：Socket();</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">//AF_INET:IPV4;SOCK_DGRAM:UDP</span></span><br><span class="line">    <span class="keyword">if</span>(server_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//IP地址，需要进行网络序转换，INADDR_ANY：本地地址</span></span><br><span class="line">    ser_addr.sin_port = htons(SERVER_PORT);  <span class="comment">//端口号，需要网络序转换</span></span><br><span class="line"><span class="comment">//第二步：bind();</span></span><br><span class="line">    ret = bind(server_fd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket bind fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第三，四步：recvfrom()&amp;sedto();</span></span><br><span class="line">    handle_udp_msg(server_fd);   <span class="comment">//处理接收到的数据</span></span><br><span class="line"><span class="comment">//第五步：close（）；</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_LEN 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"172.0.5.182"</span></span></span><br><span class="line"><span class="keyword">char</span> buf[BUFF_LEN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udp_msg_sender</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">src</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="keyword">while</span> (fgets(buf, BUFF_LEN, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(*dst);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client:%s\n"</span>,buf);  <span class="comment">//打印自己发送的信息</span></span><br><span class="line">        sendto(fd, buf, BUFF_LEN, <span class="number">0</span>, dst, len);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFF_LEN);</span><br><span class="line">         recvfrom(fd, buf, BUFF_LEN, <span class="number">0</span>, (struct sockaddr*)&amp;src, &amp;len);  <span class="comment">//接收来自server的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server:%s\n"</span>,buf);</span><br><span class="line">        sleep(<span class="number">1</span>);  <span class="comment">//一秒发送一次消息</span></span><br><span class="line">    &#125;</span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    client:</span></span><br><span class="line"><span class="comment">            socket--&gt;sendto--&gt;revcfrom--&gt;close</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    client_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(client_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket fail!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//ser_addr.sin_addr.s_addr = inet_addr(SERVER_IP);</span></span><br><span class="line">    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//注意网络序转换</span></span><br><span class="line">    ser_addr.sin_port = htons(SERVER_PORT);  <span class="comment">//注意网络序转换</span></span><br><span class="line"></span><br><span class="line">    udp_msg_sender(client_fd, (struct sockaddr*)&amp;ser_addr);</span><br><span class="line"></span><br><span class="line">    close(client_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-05_17-18-16.png" alt="Snipaste_2019-03-05_17-18-16"></p><h2 id="第四章：socket编程进阶"><a href="#第四章：socket编程进阶" class="headerlink" title="第四章：socket编程进阶"></a>第四章：socket编程进阶</h2><h3 id="多线程Socket"><a href="#多线程Socket" class="headerlink" title="多线程Socket"></a>多线程Socket</h3><p><a href="https://www.cnblogs.com/liangf27/p/9356837.html" target="_blank" rel="noopener">Linux下socket通信和多线程</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int Port = 8888;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int sock_fd;</span><br><span class="line">    struct sockaddr_in mysock;</span><br><span class="line">    struct sockaddr_in client_addr;</span><br><span class="line">    int new_fd;</span><br><span class="line">    socklen_t sin_size;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    char sedbuf[1024] = &quot;recv successfully.\n&quot;;</span><br><span class="line"></span><br><span class="line">    //初始化socket</span><br><span class="line">    sock_fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line"></span><br><span class="line">    //编辑地址信息</span><br><span class="line">    memset(&amp;mysock,0,sizeof(mysock));</span><br><span class="line">    mysock.sin_family = AF_INET;</span><br><span class="line">    mysock.sin_port = htons(Port);</span><br><span class="line">    mysock.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    //绑定地址，然后监听</span><br><span class="line">    bind(sock_fd,(struct sockaddr *)&amp;mysock,sizeof(struct sockaddr));</span><br><span class="line">    if(listen(sock_fd,10) &lt; -1)&#123;</span><br><span class="line">        printf(&quot;listen error.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sin_size = sizeof(struct sockaddr_in);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;listening...\n&quot;);</span><br><span class="line">    new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;sin_size);//accpet</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        int len = recv(new_fd,buf,sizeof(buf),0);</span><br><span class="line">        fputs(buf,stdout);</span><br><span class="line">        send(new_fd, sedbuf, sizeof(sedbuf), 0);</span><br><span class="line">        if(strcmp(buf,&quot;exit\n&quot;) == 0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_fd);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/PengfeiSong/p/6796338.html" target="_blank" rel="noopener">socket利用多线程实现一对多通信</a></p><p>服务端监听某个端口，客户端连接之后发送数据——&gt;客户端断开连接后，服务端也关闭了</p><p>服务端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;  //处理信号问题 应忽略socket 信号</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_IP     <span class="meta-string">"192.168.149.137"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_PORT  5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG  100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUF(X) printf(X)</span></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];    <span class="comment">//最大连接数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">char</span> recv_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> client_fd = (<span class="keyword">int</span>)arg;<span class="comment">//传参</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(recv_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = recv(client_fd,&amp;recv_buf,<span class="keyword">sizeof</span>(recv_buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == ret) <span class="keyword">break</span>;<span class="comment">//阻塞等待过程中断开则会返回0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,recv_buf); </span><br><span class="line">        send(client_fd,&amp;recv_buf,<span class="keyword">sizeof</span>(recv_buf),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(recv_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(recv_buf));        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"over \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span><span class="comment">//客户地址</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="number">0</span>;<span class="comment">//接收长度</span></span><br><span class="line">    <span class="keyword">char</span> recv_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> sock_fd = <span class="number">-1</span>;<span class="comment">//监听描述符</span></span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="number">-1</span>;<span class="comment">//连接fd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> th =<span class="number">-1</span> ;</span><br><span class="line">    </span><br><span class="line">    signal(SIGPIPE, SIG_IGN);<span class="comment">//忽略管道破裂信号</span></span><br><span class="line">    sock_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == sock_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sock_fd = %d.\n"</span>,sock_fd);</span><br><span class="line">    <span class="comment">//2.bind绑定socket 和本机IP 端口</span></span><br><span class="line">    server_addr.sin_family = AF_INET;<span class="comment">//IPV4</span></span><br><span class="line">    server_addr.sin_port = htons(MY_PORT);<span class="comment">//设置端口模式</span></span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(MY_IP);<span class="comment">//设置IP</span></span><br><span class="line">    ret = bind(sock_fd,(struct  sockaddr  *)&amp;server_addr,<span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUF(<span class="string">"bind ok\n"</span>);</span><br><span class="line">    <span class="comment">//3.listen 设 置监听</span></span><br><span class="line">    ret = listen(sock_fd, BACKLOG);<span class="comment">//BACKLOG为排队处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUF(<span class="string">"listen ok\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        client_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == client_fd)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"listen"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_create(&amp;th ,<span class="literal">NULL</span> , func , (<span class="keyword">void</span>*)client_fd);<span class="comment">//创建线程</span></span><br><span class="line">        DEBUF(<span class="string">"新用户加入\n"</span>);</span><br><span class="line">         <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pthread_create error \n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Port = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>], sendbuf[<span class="number">1024</span>], recvbuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//初始化socket</span></span><br><span class="line">    <span class="keyword">if</span>(sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));<span class="comment">//编辑服务端地址信息</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(Port);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = connect(sock_fd, (struct sockaddr *)(&amp;server_addr), </span><br><span class="line">        <span class="keyword">sizeof</span>(struct sockaddr));<span class="comment">//连接服务端socket</span></span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>);</span><br><span class="line">        send(sock_fd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sendbuf, <span class="string">"exit\n"</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        recv(sock_fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fputs</span>(recvbuf, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Port = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> g_mutext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_data</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">serveForClient</span><span class="params">(<span class="keyword">void</span> * arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">mysock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread_data</span> <span class="title">pdata</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">socklen_t</span> sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化socket</span></span><br><span class="line">    sock_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编辑地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;mysock, <span class="number">0</span>, <span class="keyword">sizeof</span>(mysock));</span><br><span class="line">    mysock.sin_family = AF_INET;</span><br><span class="line">    mysock.sin_port = htons(Port);</span><br><span class="line">    mysock.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定地址，然后监听</span></span><br><span class="line">    bind(sock_fd,(struct sockaddr *)&amp;mysock,<span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(listen(sock_fd,<span class="number">10</span>) &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen error.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listening...\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//accpet</span></span><br><span class="line">        new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;sin_size);</span><br><span class="line">        pdata.client_addr = client_addr;</span><br><span class="line">        pdata.sock_fd = new_fd;</span><br><span class="line">        pthread_create(&amp;pt, <span class="literal">NULL</span>, serveForClient, (<span class="keyword">void</span> *)&amp;pdata);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_fd);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">serveForClient</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread_data</span> *<span class="title">pdata</span> = (<span class="title">struct</span> <span class="title">pthread_data</span>*)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> new_fd = pdata-&gt;sock_fd;</span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">1024</span>] = <span class="string">"recv successfully.\n"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        recv(new_fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fputs</span>(recvbuf,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(sendbuf, recvbuf);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(recvbuf,<span class="string">"exit\n"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            send(new_fd, <span class="string">"connection close.\n"</span>, <span class="keyword">sizeof</span>(<span class="string">"connection close.\n"</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        send(new_fd, sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//close(new_fd);评论中指出多了一次close，所以这里不close了，留待main函数中统一close</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式-Linux-网络编程&quot;&gt;&lt;a href=&quot;#嵌入式-Linux-网络编程&quot; class=&quot;headerlink&quot; title=&quot;嵌入式 Linux 网络编程&quot;&gt;&lt;/a&gt;嵌入式 Linux 网络编程&lt;/h1&gt;&lt;h2 id=&quot;第一章：TCP-IP-协议简介&quot;&gt;&lt;a href=&quot;#第一章：TCP-IP-协议简介&quot; class=&quot;headerlink&quot; title=&quot;第一章：TCP/IP 协议简介&quot;&gt;&lt;/a&gt;第一章：TCP/IP 协议简介&lt;/h2&gt;&lt;h3 id=&quot;TCP-IP-协议概述&quot;&gt;&lt;a href=&quot;#TCP-IP-协议概述&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP 协议概述&quot;&gt;&lt;/a&gt;TCP/IP 协议概述&lt;/h3&gt;&lt;h4 id=&quot;OSI-参考模型及-TCP-IP-参考模型&quot;&gt;&lt;a href=&quot;#OSI-参考模型及-TCP-IP-参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 参考模型及 TCP/IP 参考模型&quot;&gt;&lt;/a&gt;OSI 参考模型及 TCP/IP 参考模型&lt;/h4&gt;&lt;p&gt;OSI 协议参考模型是基于国际标准化组织（ISO）的建议发展起来的，从上&lt;br&gt;到下共分为 7 层：应用层、表示层、会话层、传输 层、 网络层、&lt;br&gt;数据链路层及物理层。这个 7 层的协议模型虽然规 定得非常细&lt;br&gt;致和完善，但在实际中却得不到广泛的应用，其重 要的原因之&lt;br&gt;一就在于它过于复杂。但它仍是此后很多协议模型 的基础，这&lt;br&gt;种分层架构的思想在很多领域都得到了广泛的应 用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/进程与线程.html</id>
    <published>2019-03-01T11:08:20.000Z</published>
    <updated>2019-03-05T09:59:13.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：Linux-多任务-编程"><a href="#第一章：Linux-多任务-编程" class="headerlink" title="第一章：Linux 多任务 编程"></a>第一章：Linux 多任务 编程</h1><p> 本章 主要 内容： </p><p>简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。</p><a id="more"></a><h2 id="Linux下多任务简介"><a href="#Linux下多任务简介" class="headerlink" title="Linux下多任务简介"></a>Linux下多任务简介</h2><p><strong>什么叫多任务系统？</strong></p><p>多任务是指用户可以同一时间内运行多个应用程序，每个应用程序被称作一个任务。</p><p>多任务 操作系统 使用 某种 调度 策略 支持 多个 任务 并发 执行。由于 任务 会 频繁 地 切换 执行， 因此 给用户 多个 任务 同时 运行 的 感觉。</p><p><strong>任务定义:</strong></p><p>任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。</p><p><strong>进程定义:</strong></p><p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的最小单元。</p><p><strong>线程定义:</strong></p><p>线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以成为轻量级进程。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。通常一个任务是一个程序的一次执行，一个任务包含一个或多个完成独立功能的子任务，这个独立的子任务就是进程或线程。例如，一个杀毒软件的一次运行是一个任务，目的是从各种病毒的侵害中保护计算机系统，这个任务包含多个独立功能的子任务(进程或线程)，包括实时监控功能、定时查杀功能、防火墙功能及用户交互功能等。任务、进程和线程之间的关系如图3.1所示</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_19-41-09.png" alt="Snipaste_2019-03-01_19-41-09"></p><p>总结： ①一个操作系统可以执行多个任务（多个应用程序），一个任务指一个程序的一次执行。</p><p>​        ②一个任务包含一个或多个完成独立功能的子任务</p><p>​        ③子任务就是进程（一个）或线程（一个或多个）</p><p>一个任务为一个程序,一个程序由多个进程，每个进程又会有多个线程。而操作系统能运行多个程序（任务）。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程的基本概念</strong></p><p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的基本单元。一次任务的运行可以并发激活多个进程，这些进程相互合作来完成该任务的一个最终目标。</p><p>进程具有并发性、动态性、交互性、独立性和异步性等主要特性。</p><p>进程和程序是有本质区别的：①程序是静态的一段代码，是一些保存在非易失性存储器的指令的有序集合，没有任何执行的概念；②而进程是一个动态的概念，它是程序执行的过程，包括动态创建、调度和消亡的整个过程，它是程序执行和资源管理的最小单位。</p><p><strong>Linux下的进程结构</strong></p><p>进程不但包括程序的指令和数据，而且包括程序计数器和处理器的所有寄存器及存储临时数据的进程堆栈，因此，正在执行的进程包括处理器当前的一切活动。</p><p>因为linux是一个多任务多进程的操作系统，所以其他的进程必须等到系统将处理器使用权分配给自己之后才能运行。当正在运行的进程等待其他的系统资源时，linux内核将取得处理器的控制权，并将处理器分配给其他正在等待的进程，他按照内核中的调度算法决定将处理器分配给哪一个进程，也就是说，内核不会让处理器闲着。</p><p>内核将所有进程存放在双向循环链表（进程链表）中，其中链表的头是 init_task 描述符。链表的每一项都是类型为 task_struct，称为进程描述符的结构，该结构包含了一个进程相关的所有信息，定义&lt;include/linux/sched.h&gt;文件中。task_struct内核结构比较大，它能完整的描述一个进程，如进程的状态、进程的基本信息、进程标识符、内存相关信息、父进程相关信息、与进程相关的终端信息、当前工作目录、打开的文件信息、所接收的信号信息等。</p><p>下面详细讲解task_struct结构中最为重要的两个域：state（进程状态）和pid（进程标识符）</p><p>（1）进程状态</p><p>Linux中的进程有以下几种状态。</p><p>● 运行状态（TASK_RUNNING）:进程当前正在运行，或者正在运行队列中等待调度。</p><p>● 可中断的阻塞状态（TASK_INTERRUPTIBLE）：进程处于阻塞(睡眠)状态，正在等待某些事件发生或能够占用某些资源。处在这种状态下的进程可以被信号中断。接收到信号或被显式的唤醒呼叫（如调用 wake_up 系列宏:wake_up、wake_up_interruptible等）唤醒之后，进程将转变为 TASK_RUNNING 状态。</p><p>● 不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）:此进程状态类似于可中断的阻塞状态（TASK_INTERRUPTIBLE），只是它不会处理信号，把信号传递到这种状态下的进程不能改变它的状态。在一些特定的情况下（进程必须等待，直到某些不能被中断的事件发生），这种状态是很有用的。只有在它所等待的事件发生时，进程才被显示的唤醒呼叫唤醒。</p><p>● 可终止的阻塞状态（TASK_KILLABLE）:该状态的运行机制类似于TASK_UNINTERRUPTIBLE，只不过处在该状态下的进程可以响应致命信号。它可以替代有效但可能无法终止的不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）,以及易于唤醒但安全性欠佳的可中断的阻塞状态TASK_INTERRUPTIBLE）。</p><p>● 暂停状态（TASK_STOPPED）:进程的执行被暂停，当进程收到 SIGSTOP、SIGSTP、SIGTTIN、SIGTTOU等信号时，就会进入暂停状态。</p><p>● 跟踪状态（TASK_TRACED）:进程的执行被调试器暂停。当一个进程被另一个监控时（如调试器使用ptrace()系统调用监控测试程序），任何信号都可以把这个进程置于跟踪状态。</p><p>● 僵尸状态（EXIT_ZOMBIE）:进程运行结束，父进程尚未使用 wait 函数族(如调用 waitpid()函数)等系统调用来“收尸”，即等待父进程销毁它。处在该状态下的进程“尸体”已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的推出状态等信息供其他进程收集。</p><p>● 僵尸撤销状态（EXIT_DEAD）:这是最终状态，父进程调用 wait 函数族“收尸”后，进程彻底由系统删除。</p><p>它们之间的转换关系如图2所示：<img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-03-41.png" alt="Snipaste_2019-03-01_20-03-41"></p><p>进程可以使用 set_task_state 和 set_current_state 宏来改变指定进程的状态信息和当前进程的状态</p><p>（2）进程标识符</p><p>Linux内核通过唯一的进程标识符 PID 来标识每个进程(就和文件描述符一样)。PID存放在进程描述符的 pid 字段中，新创建的 PID 通常是前一个进程的 PID 加1，不过PID的值有上限（最大值=PID_MAX_DEFAULT-1，通常为32767），可以查看/proc/sys/kernel/pid_max 来确定该系统的进程数上限。</p><p>当系统启动后，内核通常作为某一个进程的代表。一个指向task_struct的宏current用来记录正在运行的进程。current经常作为进程描述符结构指针的形式出现在内核代码中，例如，current-&gt;pid 表示处理器正在执行的进程的PID。当系统需要查看所有的进程时，则调用for_each_process()宏，这将比系统搜索数组的速度要快的多。</p><p>在Linux中获得当前进程号的（PID）和父进程号（PPID）的系统调用函数分别为 getpid() 和 getppid()。</p><p><strong>进程的创建、执行、终止</strong></p><p>（1）进程的创建和执行</p><p>Linux 中进程的创建很特别，它把上述的步骤分解到两个单独的函数中去执行：fork()函数和exec函数族。</p><ul><li>首先，fork()函数通过复制当前进程创建一个子进程(注意此时资源还没有被复制过来，去了解一下写时复制页技术吧)，子进程于父进程的区别仅仅在于不同的PID、PPID和某些资源及统计量。</li><li>exec函数族负责读取可执行文件并将其载入地址空间开始运行。</li></ul><p>（2）进程的终止</p><p>进程终结也需要很多繁琐的工作，系统必须保证回收进程所占用的资源，并通知父进程。</p><ul><li>Linux首先把终止的进程设置为僵尸状态，这时，进程无法投入运行，它的存在只为父进程提供信息，申请死亡。</li><li>父进程得到信息后，开始调用 wait 函数族，最后终止子进程，子进程占用的所有资源被全部释放。</li></ul><p><strong>进程的内存结构</strong></p><p>Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该地址空间是大小为 4GB的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统</p><p>效果（用户不能直接访问物理地址），而且，更重要的是，用户程序可以使用比实际物理内存更大的地址空间。</p><p>4GB的进程地址空间会被分成两个部分：用户空间与内核空间。用户地址空间是从0到3GB(0xC000 0000),内核地址空间占据从3GB到4GB。</p><ul><li><p>用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。只有用户进程使用系统调用（代表用户进程在内核态执行）时可以访问到内核空间。每当进程切换时，用户空间就跟着变化;而内核空间由内核负责映射，它不会跟着进程改变，是固定的。</p></li><li><p>内核空间地址有自己对应的页表，用户进程各自有不同的页表。每个进程的用户空间都是完全独立、互不相干的。</p></li></ul><p>  <strong>进程的虚拟内存空间如图3所示，其中用户空间包括以下几个功能区域：</strong></p><ul><li><p>只读段: 包含程序代码(.init和.text)和只读数据(.rodata)。</p></li><li><p>数据段: 存放的是全局变量和静态变量。其中可读可写数据段(.data)存放已初始化的全局变量和静态变量，BSS数据段(.bss)存放未初始化的全局变量和静态变量。</p></li><li><p>堆: 由系统自动分配释放，存放函数的参数值、局部变量的值、返回地址等。</p></li><li><p>堆栈: 存放动态分配的数据，一般由程序员动态分配和释放。若程序员不释放，程序结束时可能由操作系统回收。</p></li><li><p>共享库的内存映射区域: 这是Linux动态链接器和其他共享代码库代码的映射区域。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-33-26.png" alt="Snipaste_2019-03-01_20-33-26"></p></li></ul><p>由于在Linux系统中每一个进程都会有/proc文件系统下与之对应的一个目录（如将init进程的相关信息在/proc/1 目录下的文件中描述），因此通过 proc 文件系统可以查看某个进程的地址空间的映射情况。例如，运行一个应用程序,如果它的进程号为13703,则输入“ cat /proc/13703/maps”命令，可以查看该进程的内存映射情况。</p><h2 id="进程控制符"><a href="#进程控制符" class="headerlink" title="进程控制符"></a>进程控制符</h2><p>进程控制符（PID），英文全称为Process Identifier。也常被称为进程标识符。顾名思义，它是各进程的身份标识,程序一运行系统就会自动分配给进程一个非 负 整型 表示 的 唯一 进程 ID 。 因为进程 ID标识符总是唯一的， 常将其用作其他标识符的一部分以保证其唯一性。 例如， 应用程序有时就把进程ID作为名字的一部分来创建一个唯一的文件名。</p><p>PID代表了各进程的进程ID,也就是说,PID就是各进程的身份标识。只要运行一程序，系统会自动分配一个标识，不过PID只是暂时唯一的，在进程中止后，这个号码就会被回收，并可能被分配给另一个新进程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>前面已经讲到，进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆栈段，这就造成了进程在进行切换等动作时需要较复杂的上下文切换等动作。为了进一步减少处理机的空闲时间，支持多处理器及减少上下文切换开销，进程在演化中出现了另一个概念—线程。</p><ul><li>线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以称为轻量级线程。</li><li>线程可以对进程的内存空间和资源分配进行访问，并与同一进程中的其他线程共享。因此，线程的上下文切换的开销比创建进程小得多。</li></ul><p>一个进程可以拥有多个线程，每个线程必须有一个父进程。线程不拥有系统资源，它只具有运行时所必须的一些数据结构，如堆栈/寄存器与线程控制块(TCB)，线程与其父进程的其他进程共享该进程所拥有的全部资源。要注意的是，由于线程共享了进程的资源和地址空间，因此，任何线程对系统资源的操作都会给其他进程带来影响。由此可知，多线程中的同步是一个非常重要的问题。在多线程系统中，进程与线程的关系如图</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-37-47.png" alt="Snipaste_2019-03-01_20-37-47"></p><h1 id="第二章：进程"><a href="#第二章：进程" class="headerlink" title="第二章：进程"></a>第二章：进程</h1><h2 id="第一节：创建新进程"><a href="#第一节：创建新进程" class="headerlink" title="第一节：创建新进程"></a>第一节：创建新进程</h2><h3 id="函数fork（创建）"><a href="#函数fork（创建）" class="headerlink" title="函数fork（创建）"></a>函数fork（创建）</h3><p>一个现有的进程可以调用fork函数创建一个新进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt;</span></span></span><br><span class="line"><span class="function">pid_ t <span class="title">fork</span><span class="params">( <span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>返回 值： 子 进程 返回 0， 父 进程 返回 的是子进程的PID； 若 出错， 返回 − 1</p><p>由 fork 创建 的 新 进程 被称为 子 进程（ child process）。 fork 函数 被 调用 一次， 但 返回 两次。 两次 返回 的 区 别是 子 进程 的 返回 值 是 0， 而 父 进程 的 返回 值 则是 新建 子 进程 的 进程 ID。</p><p>将 子 进程 ID 返回 给 父 进程 的 理由 是： 因为 一个 进程 的 子 进程 可以 有 多个， 并且 没有 一个 函数 使 一个 进程 可以 获得 其 所有 子 进程 的 进程 ID。 fork 使 子 进程 得到 返回 值 0 的 理由 是： 一个 进程 只会 有一个 父 进程， 所以 子 进程 总是 可以 调用 getppid 以 获得 其父 进程 的 进程 ID（ 进程 ID 0 总是 由 内核 交换 进程 使用， 所以 一个 子 进程 的 进程 ID 不可 能为 0）。(这句话好拗口)</p><p>子 进程 和 父 进程 继续 执行 fork 调用 之后 的 指令。 子 进程 是 父 进程 的 副本。 例如， 子 进程 获得 父 进程 数据 空间、 堆 和 栈 的 副本。 注意， 这是 子 进程 所 拥有 的 副本。 父 进程 和 子 进程 并不 共享 这些 存储 空间 部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line"><span class="keyword">pid_t</span> ret;</span><br><span class="line">ret=fork();</span><br><span class="line"><span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_23-43-25.png" alt="Snipaste_2019-03-01_23-43-25"></p><p>分析：子进程的返回值为ret=0，父进程的返回值ret为子进程的pid。且子进程和父进程都为7,因此可见父，子进程不资源共享，子进程只是简单的对父进程复制。子 进程 获得 父 进程 数据 空间、 堆 和 栈 的 副本。</p><h3 id="函数-vfork（创建）"><a href="#函数-vfork（创建）" class="headerlink" title="函数 vfork（创建）"></a>函数 vfork（创建）</h3><p>函数 的 调用 序列 和 返回 值 与 fork 相同， 但 两者 的 语义 不同。</p><p> vfork 函数 用于 创建 一个 新 进程， 而 该 新 进程 的 目的 是 exec 一个 新 程序（。 vfork 与 fork 一样 都 创建 一个 子 进程， 但是 它 并不 将 父 进程 的 地址 空间 完全 复制 到 子 进程 中， 因为 子 进程 会 立即 调用 exec（ 或 exit）， 于是 也就 不会 引用 该地 址 空间。 不过 在 子 进程 调用 exec 或 exit 之前， 它在 父 进程 的 空间 中 运行。 这种 优化 工作 方式 在 某些 UNIX 系统 的 实现 中 提高 了 效率， 但如 果子 进程 修改 数据（ 除了 用于 存放 vfork 返回 值 的 变量）、 进行 函数 调用、 或者 没有 调用 exec 或 exit 就 返回 都 可能 会 带来 未知 的 结果。</p><p>vfork 和 fork 之间 的 另一个 区别 是： vfork 保证 子 进程 先 运行， 在 它 调用 exec 或 exit 之后 父 进程 才可 能被 调度 运行， 当子 进程 调用 这 两个 函数 中的 任意 一个 时， 父 进程 会 恢复 运行。（ 如果 在 调用 这 两个 函数 之前 子 进程 依赖于 父 进程 的 进一步 动作， 则 会 导致 死锁。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line"><span class="keyword">pid_t</span> ret;</span><br><span class="line">ret=vfork();</span><br><span class="line"><span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-28-17.png" alt="Snipaste_2019-03-02_00-28-17"></p><h3 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h3><p>提及 用 fork 函数 创建 新的 子 进程 后， 子 进程 往往 要 调用 一种 exec 函数 以 执行 另一个 程序。 当 进程 调用 一种 exec 函数 时， 该 进程 执行 的 程序 完全 替换 为 新 程序， 而 新 程序 则从 其 main 函数 开始 执行。 因为 调用 exec 并不 创建 新 进程， 所以 前后 的 进程 ID 并未 改变。 exec 只是 用 磁盘 上 的 一个 新 程序 替换 了 当前 进程 的 正文 段、 数据 段、 堆 段 和 栈 段。</p><p>略</p><p>函数 exit（退出）</p><p>进程 有 5 种 正常 终止 及 3 种 异常 终止 方式。 5 种 正常 终止 方式 具体 如下。</p><ul><li>（1） 在 main 函数 内 执行 return 语句， 这 等效 于 调用 exit。 </li><li>（2） 调用 exit 函数。  其 操作 包括 调用 各 终止 处理 程序， 然后 关闭 所有 标准 I/ O 流 等。</li><li>（3） 调用_ exit 或_ Exit 函数 </li><li>（4） 进程 的 最后 一个 线程 在 其 启动 例程 中 执行 return 语句。 但是， 该 线程 的 返回 值 不用 作 进程 的 返回 值。 当 最后 一个 线程 从其 启动 例程 返回 时， 该 进程 以 终止 状态 0 返回。</li><li><p>（5） 进程 的 最后 一个 线程 调用 pthread_ exit 函数。 </p><p>3 种 异常 终止 具体 如下。</p><p>（1） 调用 abort。 它 产生 SIGABRT 信号， 这是 下一 种 异常 终止 的 一种 特例。</p><p>（2） 当 进程 接收 到 某些 信号 时。 信号 可由 进程 自身（ 如 调用 abort 函数）、 其他 进程 或 内核 产生。 例如， 若 进程 引用 地址 空间 之外 的 存储 单元、 或者 除以 0， 内核 就 会为 该 进程 产生 相应 的 信号。</p><p>（3） 最后 一个 线程 对“ 取消”（ cancellation） 请求 作出 响应。 默认 情况下，“ 取消” 以 延迟 方式 发生： 一个 线程 要求 取消 另一个 线程， 若干 时间 之后， 目标 线程 终止。</p></li></ul><p><strong>exit() 和_ exit() 函数 说明。</strong></p><p>exit() 和_ exit() 函数 都是 用来 终止 进程 的。 当 程序 执行 到 exit() 或_ exit() 时， 进程 会 无条件 地 停止 剩下 的 所有 操作， 清除 各种 数据 结构， 并 终止 本 进程 的 运行。 但是， 这 两个 函数 还是 有区别 的， 这 两个 函数 的 调用 过程 如图</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-53-30.png" alt="Snipaste_2019-03-02_00-53-30"></p><p>从 图 3. 5 中 可以 看出，_ exit() 函数 的 作用 是 直接 使 进程 停止 运行， 清除 其 使用 的 内存 空间， 并 清除 其 在内 核 中的 各种 数据 结构； exit() 函数 则在 这些 基础上 做了 一些 包装， 在 执行 退出 之前 加了 若干 道 工序。 exit() 函数 与_ exit() 函数 最大 的 区别 就在于 exit() 函数 在 终止 当前 进程 之前 要 检查 该 进程 打开 了 哪些 文件， 并把 文件 缓冲区 中的 内容 写回 文件， 就是 图中 的“ 清理 I/ O 缓冲” 一项。</p><p><strong>exit() 和_ exit() 函数 语法。</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-56-22.png" alt="Snipaste_2019-03-02_00-56-22"></p><h3 id="函数-wait-和-waitpid（阻塞）"><a href="#函数-wait-和-waitpid（阻塞）" class="headerlink" title="函数 wait 和 waitpid（阻塞）"></a>函数 wait 和 waitpid（阻塞）</h3><p><strong>wait() 和 waitpid() 函数 说明</strong>。</p><p> wait() 函数 用于 使 父 进程（ 也就是 调用 wait() 的 进程） 阻塞， 直到 一个 子 进程 结束 或者 该 进程 接到 了 一个 指定 的 信号 为止。 如果 该 父 进程 没有 子 进程 或者 他的 子 进程 已经 结束， 则 wait() 会 立即 返回- 1。 </p><p>waitpid() 的 作用 和 wait() 一样， 但它 并不 一定 等待 第一个 终止 的 子 进程。 waitpid() 有若 干 选项， 可 提供 一个 非 阻塞 版本 的 wait() 功能。 实际上 wait() 函数 只是 waitpid() 函数 的 一个 特例， 在 Linux 内部 实现 wait() 函数 时 直接 调用 的 就是 waitpid() 函数。 </p><p> <strong>wait() 和 waitpid() 函数 格式 说明。</strong> </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-59-51.png" alt="Snipaste_2019-03-02_00-59-51"></p><p><strong>waitpid() 函数 的 语法 规范。</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_01-00-39.png" alt="Snipaste_2019-03-02_01-00-39"></p><h2 id="第二节：守护进程"><a href="#第二节：守护进程" class="headerlink" title="第二节：守护进程"></a>第二节：守护进程</h2><p>守护进程（ daemon） 是生存期长的一种进程。 它们 常常在系统引导装入时启动， 仅在系统关闭时才终止。 因为它们没有控制终端， 所以说它们是在后台运行 的。 UNIX系统有很多守护进程， 它们执行日常事务 活动。</p><h3 id="编写守护进程"><a href="#编写守护进程" class="headerlink" title="编写守护进程"></a>编写守护进程</h3><p>编写守护进程看似复杂，但实际上也是遵循一个特定的流程。下面就分5个步骤来讲解怎样创建一个简单的守护进程。</p><p><strong>1．创建子进程，父进程退出</strong></p><p>这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在shell 终端里造成一种程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在shell 终端里则可以执行其<br>他的命令，从而在形式上做到了与控制终端的脱离。</p><p>父进程创建了子进程之后退出，父进程会先于子进程退出，会造成子进程没有父进程，从<br>而变成一个孤儿进程。在Linux 中，每当系统发现一个孤儿进程，就会自动由1 号进程（也就是init 进程）<br>收养它，这样，原先的子进程就会变成init 进程的子进程了。</p><p>其关键代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/*父进程退出*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2．在子进程中创建新会话</strong></p><p>这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用<br>的是系统函数setsid()，在具体介绍setsid()之前，读者首先要了解两个概念：进程组和会话期。</p><p><strong>进程组：</strong>进程组是一个或多个进程的集合。进程组由进程组 ID 来惟一标识。除了进程号（PID）之外，进程组ID<br>也是一个进程的必备属性。</p><p>每个进程组都有一个组长进程，其组长进程的进程号等于进程组 ID。且该进程ID 不会因组长进程的退出而受到影响。</p><p><strong>会话期：</strong> 会话组是一个或多个进程组的集合。通常，一个会话开 始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期，它们之间的关系如图7.6 所示。<br>接下来就可以具体介绍 setsid()的相关内容。<br>（1）setsid()函数作用。<br>setsid()函数用于创建一个新的会话，并担任该会话组的组长。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_23-36-05.png" alt="Snipaste_2019-03-02_23-36-05"></p><p><strong>(a) 调用</strong><br><strong>setsid()有下面的3 个作用。</strong></p><ul><li>让进程摆脱原会话的控制。</li><li>让进程摆脱原进程组的控制。</li><li>让进程摆脱原控制终端的控制</li></ul><p><em>那么，在创建守护进程时为什么要调用setsid()函数呢？</em></p><p>在创建守护进程的第一步，调用fork()函数来创建子进程后再令父进程退出时。由于在调用fork()函数时，子进程全盘复制了父进程的会<br>话期、进程组和控制终端等，虽然父进程退出了，但原先的会话期、进程组和控制终端等并没有改变，因<br>此，还不是真正意义上的独立，而setsid()函数能够使进程完全独立出来，从而脱离所有其他进程的控制。</p><p><strong>(b) setsid()函数格式</strong></p><p>当进程是会话的领头进程时setsid()调用失败并返回（-1）。setsid()调用成功后，返回新的会话的ID，调用setsid函数的进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，进程同时与控制终端脱离。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_23-38-38.png" alt="Snipaste_2019-03-02_23-38-38"></p><p><strong>3．改变当前目录为根目录</strong></p><p>这一步也是必要的步骤。使用fork()创建的子进程继承了父进程的当前工作目录。由于在进程运行过程中，<br>当前目录所在的文件系统（比如“/mnt/usb”等）是不能卸载的，这对以后的使用会造成诸多的麻烦（比<br>如系统由于某种原因要进入单用户模式）。因此，通常的做法是让“/”作为守护进程的当前工作目录，这<br>样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变<br>工作目录的常见函数是chdir()。</p><p><strong>4．重设文件权限掩码</strong></p><p>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有一个文件权限掩码是050，它就屏蔽了文件组拥<br>有者的可读与可执行权限。由于使用fork()函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为 0，可以大大增强该守护进程的灵活性。<br>设置文件权限掩码的函数是umask()。在这里，通常的使用方法为umask(0)。</p><p><strong>5．关闭文件描述符</strong></p><p>同文件权限掩码一样，用fork()函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打<br>开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法<br>被卸载。<br>在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守<br>护进程，守护进程中用常规方法（如printf()）输出的字符也不可能在终端上显示出来。所以，文件描述符<br>为0、1 和2 的3 个文件（常说的输入、输出和报错这3 个文件）已经失去了存在的价值，也应被关闭。<br>通常按如下方式关闭文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXFILE; i++)</span><br><span class="line">&#123;</span><br><span class="line">close(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解：第一步让字进程称为孤儿进程，第二步：调用setsid函数使子进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，从而使子进程同时与控制终端脱离。后面主要用于释放从父进程继承过来的紫瑶及从设参数。（第三步。释放子从父进程继承的当前工作目录。第四步：重设文件权限掩码0为umask(0，大大增强该守护进程的灵活性。第五步：关闭文件描述符。如过子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但是不关闭的它们一样消耗系统资源，而且可能导致所在的文件系统无法<br>被卸载。</p><p>这样，一个简单的守护进程就建立起来了，创建守护进程的 流程图如图</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-00-11.png" alt="Snipaste_2019-03-03_00-00-11"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid; </span><br><span class="line"><span class="keyword">int</span> i, fd; </span><br><span class="line"><span class="keyword">char</span> *buf= <span class="string">"This is a Daemon\n"</span>;</span><br><span class="line">pid = fork(); <span class="comment">/* 第一步 */</span> </span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Error fork\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* 父 进程 退出 */</span> </span><br><span class="line">&#125;</span><br><span class="line">setsid(); <span class="comment">/*第 二步*/</span> </span><br><span class="line">chdir(<span class="string">"/tmp"</span>); <span class="comment">/*第三步*/</span> </span><br><span class="line">umask(<span class="number">0</span>); <span class="comment">/*第四 步*/</span> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; getdtablesize(); i++) <span class="comment">/*第五 步*/</span> </span><br><span class="line">&#123; </span><br><span class="line">close(i);</span><br><span class="line">&#125; <span class="comment">/*这时 创建 完 守护 进程， 以下 开始 正式 进入 守护 进程 工作*/</span> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>((fd = open(<span class="string">"daemon. log"</span>, O_CREAT|O_WRONLY|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open file error\n"</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">close(fd);</span><br><span class="line">sleep(<span class="number">2</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="守护进程调式"><a href="#守护进程调式" class="headerlink" title="守护进程调式"></a>守护进程调式</h3><p>由于守护进程完全脱离了控制终端，因此，不能像其<br>他普通进程一样将错误信息输出到控制终端来通知程序员，即使使用gdb 也无法正常调试。那么，守护进<br>程的进程要如何调试呢？一种通用的办法是使用syslog 服务，将程序中的出错信息输入到系统日志文件中</p><p>略</p><h3 id="实例1：编写多进程程序"><a href="#实例1：编写多进程程序" class="headerlink" title="实例1：编写多进程程序"></a>实例1：编写多进程程序</h3><p>1．实验目的<br>通过编写多进程程序，使读者熟练掌握fork()、exec()、wait()和waitpid()等函数的使用，进一步理解在Linux<br>中多进程编程的步骤。<br>2．实验内容<br>该实验有3 个进程，其中一个为父进程，其余两个是该父进程创建的子进程，其中一个子进程运行“ls -l”<br>指令，另一个子进程在暂停5s 之后异常退出，父进程先用阻塞方式等待第一个子进程的结束，然后用非阻<br>塞方式等待另一个子进程的退出，待收集到第二个子进程结束的信息，父进程就返回。<br>3．实验步骤<br>（1）画出该实验流程图。<br>该实验流程图如图 7.8 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-09-06.png" alt="Snipaste_2019-03-03_00-09-06"></p><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//略</span></span><br></pre></td></tr></table></figure><h3 id="实例2：创建守护进程"><a href="#实例2：创建守护进程" class="headerlink" title="实例2：创建守护进程"></a>实例2：创建守护进程</h3><p>先建立起一个守护进程，然后在该守护进程中新建一个子进程，该子进程暂停10s，<br>然后自动退出，并由守护进程收集子进程退出的消息。在这里， 子进程和<br>守护进程的退出消息都在系统日志文件（ 例如<br>“/var/log/messages”，日志文件的全路径名因版本的不同可能会有所不同）<br>中输出。子进程退出后，守护进程循环暂停，其间隔时间为10s。<br>3．实验步骤<br>（1）画出该实验流程图。<br>该程序流程图如图 7.9 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-14-10.png" alt="Snipaste_2019-03-03_00-14-10"></p><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h2 id="第三节：进程间通信"><a href="#第三节：进程间通信" class="headerlink" title="第三节：进程间通信"></a>第三节：进程间通信</h2><p>进程是一个程序的一次执行。这里所说的进程一般是指运行在用户态的进程，<br>而由于处于用户态的不同进程之间是彼此隔离的，它们必须通过某种方式来进<br>行通信。本章就是讲述如何建立这些不同的通话方式。</p><p>Linux 下的进程通信手段基本上是从UNIX 平台上的进程通信手段继承而来的。而对UNIX 发展做出重大<br>贡献的两大主力AT&amp;T 的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）。</p><ul><li><p>前者（AT&amp;T 的贝尔实验室）是对UNIX 早期的进程间通信手段进行了系统的改进和扩充，形成了<br>“system V IPC”，其通信进程主要局限在单个计算机内；</p></li><li><p>后者（BSD）则跳过了该限制，形成了基于套接口（socket）<br>的进程间通信机制。</p><p><strong>Linux则把两者的优势都继承了下来，如图所示。</strong></p></li></ul><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-48-00.png" alt="Snipaste_2019-03-03_00-48-00"></p><p>UNIX 进程间通信（IPC）方式：包括管道、FIFO 以及信号。</p><p>System V 进程间通信（IPC）包括：System V 消息队列、System V 信号量以及System V 共享内存<br>区。</p><p> Posix 进程间通信（IPC）包括：Posix 消息队列、Posix 信号量以及Posix 共享内存区。</p><p>现在在Linux 中使用较多的进程间通信方式主要有以下几种。</p><p><strong>（1）管道（Pipe）及有名管道（named pipe）：</strong>管道可用于具有亲缘关系进程间的通信，有名管道，除具<br>有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p><strong>（2）信号（Signal）：</strong>信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知<br>进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一样的。</p><p><strong>（3）消息队列（Messge Queue）：</strong>消息队列是消息的链接表，包括Posix 消息队列SystemV 消息队列。<br>它克服了前两种通信方式中信息量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中<br>添加新消息；对消息队列有读权限的进程则可以从消息队列中读取消息。</p><p><strong>（4）共享内存（Shared memory）：</strong>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块<br>内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种通信方式需要依靠某种同步<br>机制，如互斥锁和信号量等。</p><p><strong>（5）信号量（Semaphore）：</strong>主要作为进程之间以及同一进程的不同线程之间的同步和互斥手段。</p><p><strong>（6）套接字（Socket）：</strong>这是一种更为一般的进程间通信机制，它可用于网络中不同机器之间的进程间通<br>信，应用非常广泛。</p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><h4 id="管道概述"><a href="#管道概述" class="headerlink" title="管道概述"></a>管道概述</h4><p>管道是Linux中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和有名管道。 </p><p> <strong>无名管道</strong></p><p>无名管道是Linux中管道通信的一种原始方法， 如图 4. 2（ a） 所示， 它具有如下特点。</p><ul><li>它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）。</li><li>它是一个半双工的通信模式，具有固定的读端和写端。</li><li>管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的read()和write()等函数。但<br>是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中。</li></ul><p>有名管道 </p><p>有名管道（ FIFO）是对无名管道的一种改进，如图 4.2（ b）所示， 它具有 如下特点。 </p><p>（1）它可以使互不相关的两个进程实现彼此通信。</p><p>（2）该 管道可以通过路径名来指出，并且在文件系统中是可见 的。在建立 了管道之后，两个进程就可以把它当作普通文件一样进行读写操作，使用 非常方便。 </p><p>（3）FIFO严格地遵循先进先出规则，对管道及FIFO的读总是从开始处返回 数据， 对它们的写则把数据添加到末尾。 有名管道不支持如 lseek() 等文件 定位操作。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-37-18.png" alt="Snipaste_2019-03-03_01-37-18"></p><h4 id="无名管道系统编程"><a href="#无名管道系统编程" class="headerlink" title="无名管道系统编程"></a>无名管道系统编程</h4><h5 id="无名管道创建与关闭说明"><a href="#无名管道创建与关闭说明" class="headerlink" title="无名管道创建与关闭说明"></a>无名管道创建与关闭说明</h5><p>无名管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fds[0]和fds[1]，其中fds[0]<br>固定用于读管道，而fd[1]固定用于写管道，如图8.3 所示，这样就构成了一个半双工的通道。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-40-33.png" alt="Snipaste_2019-03-03_01-40-33"></p><p>管道关闭时只需将这两个文件描述符关闭即可，可使用普通的close()函数逐个关闭各个文件描述符。</p><p><em>注意：</em>当一个管道共享多对文件描述符时，若将其中的一对读写文件描述符都删除，则该<br>管道就失效。</p><h5 id="无名管道创建函数pipe"><a href="#无名管道创建函数pipe" class="headerlink" title="无名管道创建函数pipe()"></a>无名管道创建函数pipe()</h5><p>创建管道可以通过调用pipe()来实现，表8.1 列出了pipe()函数的语法要点。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-44-13.png" alt="Snipaste_2019-03-03_01-44-13"></p><h5 id="无名管道读写说明"><a href="#无名管道读写说明" class="headerlink" title="无名管道读写说明"></a>无名管道读写说明</h5><p>用pipe()函数创建的管道两端处于一个进程中，由于管道是主要用于在不同进程间通信的，因此这在实际<br>应用中没有太大意义。实际上，通常先是创建一个管道，再通过fork()函数创建一子进程，该子进程会继承<br>父进程所创建的管道，这时，父子进程管道的文件描述符对应关系如图8.4 所示。</p><p>此时的关系看似非常复杂，实际上却已经给不同进程之间的读写创造了很好的条件。父子进程分别拥有自己的读写通道，为了实现父子进程之间的读写，只需把无关的读端或写端的文件描述符关闭即可。例如在<br>图8.5 中将父进程的写端fd[1]和子进程的读端fd[0]关闭。此时，父子进程之间就建立起了一条“子进程写“同样，也可以关闭父进程的fd[0]和子进程的fd[1]，这样就可以建立一条“父进程写入子进程读取”的通<br>道。另外，父进程还可以创建多个子进程，各个子进程都继承了相应的fd[0]和fd[1]，这时，只需要关闭<br>相应端口就可以建立其各子进程之间的通道。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_16-13-53.png" alt="Snipaste_2019-03-03_16-13-53"></p><p>总结：首先在父进程创建pipe()管道，然后fork()子进程，子进程会继承父进程的pipe()管道，</p><p>管道fd[0]为读端,fd[1]为写端。</p><p>父进程读入子进程写：将父进程的写端fd[1]和子进程的读端fd[0]关闭即可</p><p>父进程写入子进程读：将关闭父进程的读端fd[0]和子进程的写端fd[1]即可</p><h5 id="无名管道使用实例"><a href="#无名管道使用实例" class="headerlink" title="无名管道使用实例"></a>无名管道使用实例</h5><p>首先创建管道，之后父进程使用fork()函数创建子进程，之后通过关闭父进程的读描述符和子<br>进程的写描述符，建立起它们之间的父进程写入子进程读管道通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_DATA_LEN 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> buf[MAX_DATA_LEN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> data[] = <span class="string">"Pipe Test Program"</span>;</span><br><span class="line"><span class="keyword">int</span> real_read, real_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span>*)buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建管道 */</span></span><br><span class="line"><span class="keyword">if</span> (pipe(pipe_fd) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 创建一子进程 */</span></span><br><span class="line"><span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 子进程关闭写描述符，并通过使子进程暂停3s 等待父进程已关闭相应的读描述符 */</span></span><br><span class="line">close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">sleep(DELAY_TIME * <span class="number">3</span>);</span><br><span class="line"><span class="comment">/* 子进程读取管道内容 */</span></span><br><span class="line"><span class="keyword">if</span> ((real_read = read(pipe_fd[<span class="number">0</span>], buf, MAX_DATA_LEN)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d bytes read from the pipe is '%s'\n"</span>, real_read, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 关闭子进程读描述符 */</span></span><br><span class="line">close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 父进程关闭读描述符，并通过使父进程暂停1s 等待子进程已关闭相应的写描述符 */</span></span><br><span class="line">close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">sleep(DELAY_TIME);</span><br><span class="line"><span class="keyword">if</span>((real_write = write(pipe_fd[<span class="number">1</span>], data, <span class="built_in">strlen</span>(data))) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Parent wrote %d bytes : '%s'\n"</span>, real_write, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭父进程写描述符*/</span></span><br><span class="line">close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">/*收集子进程退出信息*/</span></span><br><span class="line">waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_16-39-41.png" alt="Snipaste_2019-03-03_16-39-41"></p><ul><li>只有在管道的读端存在时，向管道写入数据才有意义（故上面父进程延时后1s写，子进程3S后读，从而保证管道有写入数据）。否则，向管道写入数据的进程将收到内核<br>传来的SIGPIPE 信号（通常为Broken pipe 错误）。</li><li>向管道写入数据时，Linux 将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读取管道缓冲区中的数据，那么写操作将会一直阻塞。</li><li>父子进程在运行时，它们的先后次序并不能保证，因此，在这里为了保证父子进程已经关闭了相<br>应的文件描述符，可在两个进程中调用sleep()函数，当然这种调用不是很好的解决方法，在后面<br>学到进程之间的同步与互斥机制。</li></ul><h4 id="有名管道-FIFO-编程"><a href="#有名管道-FIFO-编程" class="headerlink" title="有名管道(FIFO)编程"></a>有名管道(FIFO)编程</h4><h5 id="有名管道说明"><a href="#有名管道说明" class="headerlink" title="有名管道说明"></a>有名管道说明</h5><p>无名管道它只能用于具有亲缘关系的进程之间，这就大大地限制了管道的使用。有名管道的出现突破了这种限制，它可以使互不相关的两个进程实现彼此通信。该管道可以通过路径名来指出，<br>并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当作普通文件一样进行读写操作，<br>使用非常方便。</p><p>不过值得注意的是，FIFO 是严格地遵循先进先出规则的，对管道及FIFO 的读总是从开始<br>处返回数据，对它们的写则把数据添加到末尾，它们不支持如lseek()等文件定位操作。</p><p>有名管道的创建可以使用函数mkfifo()，该函数类似文件中的open()操作，可以指定管道的路径和打开的<br>模式。在创建管道成功之后，就可以使用open()、read()和write()这些函数了。</p><p>与普通文件的开发设置一样，对于为读而打开的管道可在open()中设置O_RDONLY，对于为写而打开的管道可在open()中设置O_WRONLY，<br>在这里与普通文件不同的是阻塞问题。由于普通文件的读写时不会出现阻塞问题，而在管道的读写中却有<br>阻塞的可能，这里的非阻塞标志可以在open()函数中设定为O_NONBLOCK。下面分别对阻塞打开和非阻<br>塞打开的读写进行讨论。</p><p><strong>对于读进程</strong></p><ul><li>若该管道是阻塞打开，且当前FIFO 内没有数据，则对读进程而言将一直阻塞到有数据写入。</li><li>若该管道是非阻塞打开，则不论FIFO 内是否有数据，读进程都会立即执行读操作。即如果FIFO<br>内没有数据，则读函数将立刻返回0。</li></ul><p><strong>对于写进程</strong></p><ul><li>若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。</li><li>若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。</li></ul><h5 id="mkfifo-函数格式"><a href="#mkfifo-函数格式" class="headerlink" title="mkfifo()函数格式"></a>mkfifo()函数格式</h5><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_17-13-26.png" alt="Snipaste_2019-03-03_17-13-26"></p><h5 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h5><p>实例包含了两个程序，一个用于读管道，另一个用于写管道。其中在读管道的程序里创建管道，并<br>且作为main()函数里的参数由用户输入要写入的内容。读管道的程序会读出用户写入到管道的内容，这两<br>个程序采用的是阻塞式读写管道模式。</p><p>写管道的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_write.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/tmp/myfifo"</span> <span class="comment">/* 有名管道文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF <span class="comment">/*定义在于limits.h 中*/</span></span></span><br><span class="line">i</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> <span class="comment">/*参数为即将写入的字符串*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> nwrite;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: ./fifo_write string\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%s"</span>, buff);</span><br><span class="line"><span class="comment">/* 以只写阻塞方式打开FIFO 管道 */</span></span><br><span class="line">fd = open(MYFIFO, O_WRONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*向管道中写入字符串*/</span></span><br><span class="line"><span class="keyword">if</span> ((nwrite = write(fd, buff, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Write '%s' to FIFO\n"</span>, buff);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读管道程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_read.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/tmp/myfifo"</span> <span class="comment">/* 有名管道文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF <span class="comment">/*定义在于limits.h 中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> nread;</span><br><span class="line"><span class="comment">/* 判断有名管道是否已存在，若尚未创建，则以相应的权限创建*/</span></span><br><span class="line"><span class="keyword">if</span> (access(MYFIFO, F_OK) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((mkfifo(MYFIFO, <span class="number">0666</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Cannot create fifo file\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 以只读阻塞方式打开有名管道 */</span></span><br><span class="line">fd = open(MYFIFO, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line"><span class="keyword">if</span> ((nread = read(fd, buff, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Read '%s' from FIFO\n"</span>, buff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-06-52.png" alt="Snipaste_2019-03-03_18-06-52"></p><h3 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。信号可以直接进行<strong>用户空间进程和内核进程之间的交互</strong>，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。它可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它为止；如果一个<br>信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</p><p>信号值在32 之前的则有不同的名称，而信号值在32 以后的都是用“SIGRTMIN”或<br>“SIGRTMAX”开头的，这就是两类典型的信号。前者是从UNIX 系统中继承下来的信号，为不可靠<br>信号（也称为非实时信号）；后者是为了解决前面“不可靠信号”的问题而进行了更改和扩充的信号，<br>称为“可靠信号”（也称为实时信号）。</p><p>一个完整的信号生命周期可以分为3 个重要阶段，这3 个阶段由4 个重要事件来刻画的：信号产生、<br>信号在进程中注册、信号在进程中注销、执行信号处理函数，如图8.6 所示。相邻两个事件的时间<br>间隔构成信号生命周期的一个阶段。要注意这里的信号处理有多种方式，一般是由内核完成的，当<br>然也可以由用户进程来完成，故在此没有明确画出</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-12-38.png" alt="Snipaste_2019-03-03_18-12-38"></p><p>一个不可靠信号的处理过程是这样的：如果发现该信号已经在进程中注册，那么就忽略该信号。<br>因此，若前一个信号还未注销又产生了相同的信号就会产生信号丢失。而当可靠信号发送给一个进<br>程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号就不会丢失。所有可靠信<br>号都支持排队，而所有不可靠信号都不支持排队。</p><p>信号事件的产生有硬件来源（ 比如按下了键盘或者其他硬件故障）和软件来源，常用的信号相关函数 有 kill()、 raise()、 alarm()、 setitimer() 和 sigqueue() 等， 软件来源还包括一些非法 运算等操作。</p><p><strong>用户进程对信号的响应（处理）可以有3 种方式。</strong></p><ul><li>忽略信号，即对信号不做任何处理，但是有两个信号不能忽略，即SIGKILL 及SIGSTOP。</li><li>捕捉信号，定义信号处理函数，当信号发生时，执行相应的自定义处理函数。</li><li>执行缺省操作，Linux 对每种信号都规定了默认操作。</li></ul><p>Linux 中的大多数信号是提供给内核的，表8.6 列出了Linux 中最为常见信号的含义及其默认操作。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-23-38.png" alt="Snipaste_2019-03-03_18-23-38"></p><h4 id="信号发送与捕捉"><a href="#信号发送与捕捉" class="headerlink" title="信号发送与捕捉"></a>信号发送与捕捉</h4><p>发送信号的函数主要有 kill()、raise()、alarm()以及pause()</p><h5 id="kill-和raise"><a href="#kill-和raise" class="headerlink" title="kill()和raise()"></a>kill()和raise()</h5><p><strong>函数说明</strong></p><p>kill()函数同读者熟知的kill 系统命令一样，可以发送信号给进程或进程组（实际上，kill 系统命令只是kill()<br>函数的一个用户接口）。这里需要注意的是，它不仅可以中止进程（实际上发出SIGKILL 信号），也可以向<br>进程发送其他信号。</p><p>与kill()函数所不同的是，raise()函数允许进程向自身发送信号。</p><p><strong>kill()函数格式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-11-22.png" alt="Snipaste_2019-03-03_19-11-22"></p><p><strong>raise()函数格式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-13-57.png" alt="Snipaste_2019-03-03_19-13-57"></p><h5 id="实例kill-raise-c"><a href="#实例kill-raise-c" class="headerlink" title="实例kill_raise.c"></a>实例kill_raise.c</h5><p>首先使用fork()创建了一个子进程，接着为了保证子进程不在父进程调用kill()之前退出，在<br>子进程中使用raise()函数向自身发送SIGSTOP 信号，使子进程暂停。接下来再在父进程中调用kill()向子<br>进程发送信号，在该示例中使用的是SIGKILL，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kill_raise.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">/* 创建一子进程 */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fork error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 在子进程中使用raise()函数发出SIGSTOP 信号,使子进程暂停 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child(pid : %d) is waiting for any signal\n"</span>, getpid());</span><br><span class="line">raise(SIGSTOP);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 在父进程中收集子进程发出的信号，并调用kill()函数进行相应的操作 */</span></span><br><span class="line"><span class="keyword">if</span> ((waitpid(pid, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((ret = kill(pid, SIGKILL)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Parent kill %d\n"</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-34-36.png" alt="Snipaste_2019-03-03_19-34-36"></p><h5 id="alarm-和pause"><a href="#alarm-和pause" class="headerlink" title="alarm()和pause()"></a>alarm()和pause()</h5><p><strong>函数说明</strong></p><p>alarm()也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它就向进程发送<br>SIGALARM 信号。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm()之前已设置过闹钟时<br>间，则任何以前的闹钟时间都被新值所代替。</p><p>pause()函数是用于将调用进程挂起直至捕捉到信号为止。这个函数很常用，通常可以用于判断信号是否已<br>到。</p><p><strong>alarm()函数格式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-40-34.png" alt="Snipaste_2019-03-03_19-40-34"></p><p><strong>pause()函数格式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-40-40.png" alt="Snipaste_2019-03-03_19-40-40"></p><h5 id="实例：alarm-pause-c"><a href="#实例：alarm-pause-c" class="headerlink" title="实例：alarm_ pause. c"></a>实例：alarm_ pause. c</h5><p>该实例实际上已完成了一个简单的sleep()函数的功能，由于SIGALARM 默认的系统动作为终止该进程，<br>因此程序在打印信息之前，就会被结束了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alarm_pause.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*调用alarm 定时器函数*/</span></span><br><span class="line"><span class="keyword">int</span> ret = alarm(<span class="number">5</span>);</span><br><span class="line">pause();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have been waken up：%d.\n"</span>,ret); <span class="comment">/* 此语句不会被执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-50-30.png" alt="Snipaste_2019-03-03_19-50-30"></p><p>总结：pause()函数会将进程挂起直至捕捉到信号为止，而aiarm(5)函数会在进程中设置一个定时，5s后它就向进程发送<br>SIGALARM 信号终止进程。因此进程在pause()时会挂机不会打印信息，而5秒后记时到alarm(5)会发送SIGALARM终止进程。</p><h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>一个进程可以决定在该进程中需要对哪些信号进行什么样的操作(忽略，捕抓，以及缺省操作)。，另外，一个进程还可以选择如何处理信号(信号的处理)。</p><h5 id="函数说明-signal-amp-gaction"><a href="#函数说明-signal-amp-gaction" class="headerlink" title="函数说明(signal&amp;gaction)"></a>函数说明(signal&amp;gaction)</h5><p>使用signal()函数处理时，只需要指出要处理的信号和处理函数即可。它主要是用于前32 种非实时信号的<br>处理，不支持信号传递信息，但是由于使用简单、易于理解，因此也受到很多程序员的欢迎。</p><p>Linux 还支持一个更健壮、更新的信号处理函数sigaction()，推荐使用该函数。</p><h5 id="函数格式"><a href="#函数格式" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>signal()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-07-56.png" alt="Snipaste_2019-03-03_20-07-56"></p><p>这里需要对这个函数原型进行说明。这个函数原型有点复杂。可先用如下的typedef 进行替换说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里需要对这个函数原型进行说明。这个函数原型有点复杂。可先用如下的<span class="keyword">typedef</span> 进行替换说明：</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">sign *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, handler *)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>gaction()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-16-54.png" alt="Snipaste_2019-03-03_20-16-54"></p><p>sigaction()函数中第2 个和第3 个参数中使用到sigaction 结构。这是一个看似非常复杂的结<br>构，要注意初始化。</p><p>sigaction 的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span> signo);</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line"><span class="keyword">int</span> sa_flags;</span><br><span class="line"><span class="keyword">void</span> (*sa_restore)(<span class="keyword">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sa_handler ：</strong>是一个函数指针，指定信号处理函数，这里除可以是用户自定义的处理函数外，还可以为<br>SIG_DFL（采用缺省的处理方式）或SIG_IGN（忽略信号）。它的处理函数只有一个参数，即信号值(signum)。</p><p><strong>sa_mask:</strong> 是一个信号集，它可以指定在信号处理程序执行过程中哪些信号应当被屏蔽，在调用信号捕获函<br>数之前，该信号集要加入到信号的信号屏蔽字中。</p><p><strong>sa_flags:</strong> 中包含了许多标志位，是对信号进行处理的各个选择项。它的常见可选值如表8.13 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-28-23.png" alt="Snipaste_2019-03-03_20-28-23"></p><h5 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h5><p>第一个实例表明了如何使用signal()函数捕捉相应信号，并做出给定的处理。这里，my_func 就是信号处理<br>的函数指针。读者还可以将其改为SIG_IGN 或SIG_DFL 查看运行结果。第二个实例是用sigaction()函数<br>实现同样的功能。</p><p><strong>signal()函数实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*自定义信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sign_no == SIGINT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sign_no == SIGQUIT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or SIGQUIT...\n"</span>);</span><br><span class="line"><span class="comment">/* 发出相应的信号，并跳转到信号处理函数处 */</span></span><br><span class="line">signal(SIGINT, my_func);</span><br><span class="line">signal(SIGQUIT, my_func);</span><br><span class="line">pause();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-34-15.png" alt="Snipaste_2019-03-03_20-34-15"></p><p>SIGINT （按ctrl-c 组合键触发）</p><p>SIGQUIT （按ctrl-\ 组合键触发）</p><p>详细参考上面：表8.6 Linux 常见信号的含义及其默认操作</p><p>sigaction()函数实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*自定义信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sign_no == SIGINT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sign_no == SIGQUIT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or SIGQUIT...\n"</span>);</span><br><span class="line"><span class="comment">/* sigaction 结构初始化 */</span></span><br><span class="line">action.sa_handler = my_func;</span><br><span class="line">sigemptyset(&amp;action.sa_mask);</span><br><span class="line">action.sa_flags = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 发出相应的信号，并跳转到信号处理函数处 */</span></span><br><span class="line">sigaction(SIGINT, &amp;action, <span class="number">0</span>);</span><br><span class="line">sigaction(SIGQUIT, &amp;action, <span class="number">0</span>);</span><br><span class="line">pause();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果同上</p><h4 id="信号集函数组"><a href="#信号集函数组" class="headerlink" title="信号集函数组"></a>信号集函数组</h4><p>略</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量的使用主要是用来保护共享资源,使得资源在一个时刻只有一个进程(线程)所拥有，</p><h4 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h4><p>　在多线程或者多进程编程中，有一个非常需要关注的东西，那就是同步以及互斥问题。</p><p>　　同步是指多个进程之间的协作，而互斥是指多个进程之间，为了争夺有限的资源，而进行的竞争。</p><p>​    进程之间的互斥与同步关系存在的根源在于临界资源。临界资源是在同一个时刻只允许有限个（通常只有<br>一个）进程可以访问（读）或修改（写）的资源，通常包括硬件资源（处理器、内存、存储器以及其他外<br>围设备等）和软件资源（共享代码段，共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本<br>身也会成为临界资源。</p><p>​    信号量就是用来解决进程之间的同步与互斥问题的一种进程之间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（PV 操作）。其中信号量对应于某一<br>种资源，取一个非负的整型值。<strong>信号量值指的是当前可用的该资源的数量，若它等于0 则意味着目前没有可</strong><br><strong>用的资源。</strong></p><p><strong>PV 原子操作的具体定义如下：</strong></p><p>P 操作：如果有可用的资源（信号量值&gt;0），则占用一个资源（给信号量值减去一，进入临界区代码）;如<br>果没有可用的资源（信号量值等于0），则被阻塞到，直到系统将资源分配给该进程（进入等待队列，一直<br>等到资源轮到该进程）。</p><p>V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程。如果没有进程等待它，<br>则释放一个资源（给信号量值加一）。</p><h4 id="信号量的编程"><a href="#信号量的编程" class="headerlink" title="信号量的编程"></a>信号量的编程</h4><h5 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h5><p>在Linux 系统中，使用信号量通常分为以下几个步骤。</p><p>​    （1）创建信号量或获得在系统已存在的信号量，此时需要调用semget()函数。不同进程通过使用同一个信<br>号量键值来获得同一个信号量。</p><p>​    （2）初始化信号量，此时使用semctl()函数的SETVAL 操作。当使用二维信号量时，通常将信号量初始化<br>为1。</p><p>​    （3）进行信号量的PV 操作，此时调用semop()函数。这一步是实现进程之间的同步和互斥的核心工作部<br>分。</p><p>​    （4）如果不需要信号量，则从系统中删除它，此时使用semclt()函数的IPC_RMID 操作。此时需要注意，<br>在程序中不应该出现对已经被删除的信号量的操作</p><h5 id="函数格式-1"><a href="#函数格式-1" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>semget()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-20-27.png" alt="Snipaste_2019-03-03_21-20-27"></p><p><strong>semctl()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-22-47.png" alt="Snipaste_2019-03-03_21-22-47"></p><p><strong>semop()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-23-31.png" alt="Snipaste_2019-03-03_21-23-31"></p><h5 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><h4 id="共享内存概述"><a href="#共享内存概述" class="headerlink" title="共享内存概述"></a>共享内存概述</h4><p>​    共享内存是一种最为高效的进程间通信方式。因为进程可以直接读写内存，不需要任何数据<br>的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进<br>程将其映射到自己的私有地址空间。因此，进程就可以直接读写这一内存区而不需要进行数据的复制，<br>从而大大提高了效率。当然，由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁<br>和信号量等（请参考本章的共享内存实验）。其原理示意图如图8.8 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-36-13.png" alt="Snipaste_2019-03-03_21-36-13"></p><h4 id="共享内存编程"><a href="#共享内存编程" class="headerlink" title="共享内存编程"></a>共享内存编程</h4><h5 id="编程步骤-1"><a href="#编程步骤-1" class="headerlink" title="编程步骤"></a>编程步骤</h5><p>共享内存的实现分为两个步骤：</p><ul><li><p>第一步是创建共享内存，这里用到的函数是shmget()，也就是从内存中获<br>得一段共享内存区域，</p></li><li><p>第二步映射共享内存，也就是把这段创建的共享内存映射到具体的进程空间中，这<br>里使用的函数是shmat()。</p><p>到这里，就可以使用这段共享内存了，也就是可以使用不带缓冲的I/O 读写命令<br>对其进行操作。除此之外，当然还有撤销映射的操作，其函数为shmdt()。这里就主要介绍这3 个函数。</p></li></ul><h5 id="函数格式-2"><a href="#函数格式-2" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>shmget()函</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-12.png" alt="Snipaste_2019-03-03_21-40-12"></p><p><strong>shmat()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-23.png" alt="Snipaste_2019-03-03_21-40-23"></p><p><strong>shmdt()函</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-28.png" alt="Snipaste_2019-03-03_21-40-28"></p><h5 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h5><p>该实例说明如何使用基本的共享内存函数。</p><p>首先是创建一个共享内存区（采用的共享内存的键值为<br>IPC_PRIVATE，是因为本实例中创建的共享内存是父子进程之间的共用部分），之后创建子进程，在<br>父子两个进程中将共享内存分别映射到各自的进程地址空间之中。<br>父进程先等待用户输入，然后将用户输入的字符串写入到共享内存，之后往共享内存的头部写入<br>“WROTE” 字符串表示父进程已成功写入数据。子进程一直等到共享内存的头部字符串为<br>“WROTE”，然后将共享内存的有效数据（在父进程中用户输入的字符串）在屏幕上打印。父子两<br>个进程在完成以上工作之后，分别解除与共享内存的映射关系。<br>最后在子进程中删除共享内存。因为共享内存自身并不提供同步机制，所以应该额外实现不同进程之间的<br>同步（例如：信号量）。为了简单起见，在本实例中用标志字符串来实现非常简单的父子进程之间的同步。<br>这里要介绍的一个命令是ipcs，这是用于报告进程间通信机制状态的命令。它可以查看共享内存、消息队<br>列等各种进程间通信机制的情况，这里使用了system()函数用于调用shell 命令“ipcs”。</p><p>程序源代码如下所<br>示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* shmem.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">char</span> *shm_addr;</span><br><span class="line"><span class="keyword">char</span> flag[] = <span class="string">"WROTE"</span>;</span><br><span class="line"><span class="keyword">char</span> *buff;</span><br><span class="line"><span class="comment">/* 创建共享内存 */</span></span><br><span class="line"><span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, BUFFER_SIZE, <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmget"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create shared-memory: %d\n"</span>,shmid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 显示共享内存情况 */</span></span><br><span class="line">system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"fork"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">/* 子进程处理 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*映射共享内存*/</span></span><br><span class="line"><span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"Child: shmat"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child: Attach shared-memory: %p\n"</span>, shm_addr);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"ipcs -m"</span>);</span><br><span class="line"><span class="comment">/* 通过检查在共享内存的头部是否标志字符串"WROTE"来确认</span></span><br><span class="line"><span class="comment">父进程已经向共享内存写入有效数据 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">strncmp</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child: Wait for enable data...\n"</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取共享内存的有效数据并显示 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buff, shm_addr + <span class="built_in">strlen</span>(flag));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child: Shared-memory :%s\n"</span>, buff);</span><br><span class="line"><span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line"><span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"shmdt"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child: Deattach shared-memory\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"ipcs -m"</span>);</span><br><span class="line"><span class="comment">/* 删除共享内存 */</span></span><br><span class="line"><span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"Child: shmctl(IPC_RMID)\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Delete shared-memory\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 父进程处理 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*映射共享内存*/</span></span><br><span class="line"><span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"Parent: shmat"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Parent: Attach shared-memory: %p\n"</span>, shm_addr);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nInput some string:\n"</span>);</span><br><span class="line">fgets(buff, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(shm_addr + <span class="built_in">strlen</span>(flag), buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"><span class="built_in">strncpy</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag));</span><br><span class="line"><span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line"><span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"Parent: shmdt"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Parent: Deattach shared-memory\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Finished\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，这章也不是很懂</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>略吧。</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>重点，开单独一章讲</p><h1 id="第三章：线程"><a href="#第三章：线程" class="headerlink" title="第三章：线程"></a>第三章：线程</h1><h2 id="Linux-线程概述"><a href="#Linux-线程概述" class="headerlink" title="Linux 线程概述"></a>Linux 线程概述</h2><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><p>​    进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆<br>栈段，这就造成了进程在进行切换等操作时都需要有比较复杂的上下文切换等动作。为了进一步减少处理机<br>的空转时间，支持多处理器以及减少上下文切换开销，进程在演化中出现了另一个概念——线程。</p><ul><li>线程<br>内独立的一条运行路线，处理器调度的最小单元，也可以称为轻量级进程。</li><li>线程可以对进程的内存空间和资<br>源进行访问，并与同一进程中的其他线程共享。因此，线程的上下文切换的开销比创建进程小很多。</li><li>同进程一样，线程也将相关的执行状态和存储变量放在线程控制表内。一个进程可以有多个线程，也就是有<br>多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。</li></ul><p>要注意的是，由于线程共享了进程的资源和地<br>址空间，因此，任何线程对系统资源的操作都会给其他线程带来影响。由此可知，多线程中的同步是非常重要的问题。在多线程系统中，进程与进程的关系如图9.1 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_22-56-29.png" alt="Snipaste_2019-03-03_22-56-29"></p><h3 id="线程机制的分类和特性"><a href="#线程机制的分类和特性" class="headerlink" title="线程机制的分类和特性"></a>线程机制的分类和特性</h3><p>线程按照其调度者可以分为用户级线程和核心级线程两种。</p><p>（1）用户级线程。<br>用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行<br>时不需要特定的内核支持。在这里，操作系统往往会提供一个用户空间的<strong>线程库</strong>，该线程库提供了线程的<br>创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞<br>的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是<br>在一个进程中的多个线程的调度中无法发挥多处理器的优势。</p><p>（2）轻量级进程。<br>轻量级进程是内核支持的用户线程，是内核线程的一种抽象对象。每个线程拥有一个或多个轻量级线程，<br>而每个轻量级线程分别被绑定在一个内核线程上。</p><p>（3）内核线程。<br>这种线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优<br>势。</p><h2 id="Linux-线程编程"><a href="#Linux-线程编程" class="headerlink" title="Linux 线程编程"></a>Linux 线程编程</h2><p>在Linux 中，使用的read 线程库是一套通用的线<br>程库，是由POSIX 提出的，因此具有很好的可移植性。(线程开发并非内核提供，而是由POSIX 提供的线程库支持的。）</p><h3 id="线程函数说明"><a href="#线程函数说明" class="headerlink" title="线程函数说明"></a>线程函数说明</h3><p><strong>1. pthread_create()：创建线程</strong></p><p>​    创建线程实际上就是确定调用该线程函数的入口点，这里通常使用的函数是 pthread_create()。在线程创建<br>以后，就开始运行相关的线程函数，在该函数运行完之后，该线程也就退出了，这也是线程退出一种方法。<br>另一种退出线程的方法是使用函数pthread_exit()，这是线程的主动行为。</p><p><strong>*注意：</strong>在使用线程函<em></em>数时，不能随意使用exit()退出函数进行出错处理，由于exit()的作用是使调用进程终止，往往一个进程包<em></em>含多个线程，因此，在使用exit()之后，该进程中的所有线程都终止了。因此，在线程中就可以使用<em></em>pthread_exit()来代替进程中的exit()。*</p><p><strong>2. pthread_join()可以用于将当前线程挂起来等待线程的结束</strong></p><p>​    由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放。正如进程之间可以用wait()系统调用来同步终止并释放资源一样，线<br>程之间也有类似机制，那就是pthread_join()函数。</p><p>​    pthread_join()可以用于将当前线程挂起来等待线程的结束。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函<br>数返回时，被等待线程的资源就被收回。</p><p><strong>3. 线程调用 pthread_exit()函数主动终止自身线程</strong></p><p><strong>4.调用pthread_cancel()函数终止另一个线程</strong></p><p>​    线程调用 pthread_exit()函数主动终止自身线程。但是在很多线程应用中，经常会遇到在别的线<br>程中要终止另一个线程的执行的问题。此时调用pthread_cancel()函数实现这种功能，但在被取消的线程的<br>内部需要调用pthread_setcancel()函数和pthread_setcanceltype()函数设置自己的取消状态，例如被取消的线<br>程接收到另一个线程的取消请求之后，是接受还是忽略这个请求；如果接受，是立刻进行终止操作还是等<br>待某个函数的调用等。</p><h3 id="函数格式-3"><a href="#函数格式-3" class="headerlink" title="函数格式"></a><strong>函数格式</strong></h3><p><strong>pthread_create()</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-13-26.png" alt="Snipaste_2019-03-03_23-13-26"></p><p><strong>pthread_exit()</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-13-53.png" alt="Snipaste_2019-03-03_23-13-53"></p><p><strong>pthread_join()</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-14-04.png" alt="Snipaste_2019-03-03_23-14-04"></p><p><strong>pthread_cancel</strong>()</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-14-12.png" alt="Snipaste_2019-03-03_23-14-12"></p><h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><p>创建最简单对三线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sharedi = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num3</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">pthread_t</span> thrd1, thrd2, thrd3;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;thrd1, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)increse_num1, <span class="literal">NULL</span>);</span><br><span class="line">    ret = pthread_create(&amp;thrd2, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)increse_num2, <span class="literal">NULL</span>);</span><br><span class="line">    ret = pthread_create(&amp;thrd3, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)increse_num3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(thrd1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thrd2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thrd3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num1</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"线程1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"线程2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"线程3\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下实例中创建了 3 个线程，为了更好地描述线程之间的并行执行，让3 个线程重用同一个执行函数。每<br>个线程都有5 次循环（可以看成5 个小任务），每次循环之间会随机等待1～10s 的时间，意义在于模拟每<br>个任务的到达时间是随机的，并没有任何特定规律。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER 3 <span class="comment">/*线程数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER 5 <span class="comment">/*每个线程中的小任务数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS 10.0 <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 线程函数例程 */</span></span><br><span class="line"><span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line"><span class="keyword">int</span> delay_time = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++)</span><br><span class="line">&#123;</span><br><span class="line">delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">sleep(delay_time);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>,</span><br><span class="line">thrd_num, count, delay_time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line"><span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line"><span class="keyword">void</span> * thrd_ret;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 创建多线程 */</span></span><br><span class="line">res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line"><span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line"><span class="built_in">exit</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 等待线程结束 */</span></span><br><span class="line">res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;//随机1~10 的一个数给delay_time</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-01-24.png" alt="Snipaste_2019-03-04_00-01-24"></p><h2 id="线程之间的同步与互斥"><a href="#线程之间的同步与互斥" class="headerlink" title="线程之间的同步与互斥"></a>线程之间的同步与互斥</h2><p>​    由于线程共享进程的资源和地址空间，因此在对这些资源进行操作时，必须考虑到线程间资源访问的同步<br>与互斥问题。这里主要介绍 POSIX 中两种线程同步机制，分别为互斥锁和信号量。这两个同步机制可以互<br>相通过调用对方来实现，<strong>但互斥锁更适合用于同时可用的资源是惟一的情况；信号量更适合用于同时可用</strong><br><strong>的资源为多个的情况。</strong></p><h3 id="互斥锁线程控制"><a href="#互斥锁线程控制" class="headerlink" title="互斥锁线程控制"></a>互斥锁线程控制</h3><p>函数说明</p><p>​    互斥锁是用一种简单的加锁方法来控制对共享资源的原子操作。这个互斥锁只有两种状态，也就是上锁和<br>解锁，可以把互斥锁看作某种意义上的全局变量。</p><p>​    在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作。若其他线程希望<strong>上锁一个已经被上锁的互斥锁</strong>，则该线程就会挂起，<br>直到上锁的线程释放掉互斥锁为止。可以说，这把互斥锁保证让每个线程对共享资源按顺序进行原子操作</p><p>互斥锁机制主要包括下面的基本函数。</p><ul><li>互斥锁初始化：pthread_mutex_init()</li><li>互斥锁上锁：pthread_mutex_lock()</li><li>互斥锁判断上锁：pthread_mutex_trylock()</li><li>互斥锁解锁：pthread_mutex_unlock()</li><li>消除互斥锁：pthread_mutex_destroy()</li></ul><p>互斥锁可以分为快速互斥锁、递归互斥锁和检错互斥锁。</p><p>这3 种锁的区别主要在于其他未占有互斥<br>锁的线程在希望得到互斥锁时是否需要阻塞等待。</p><ul><li>快速锁是指调用线程会阻塞直至拥有互斥锁的线程解锁<br>为止。</li><li>递归互斥锁能够成功地返回，并且增加调用线程在互斥上加锁的次数，</li><li>而检错互斥锁则为快速互斥<br>锁的非阻塞版本，它会立即返回并返回一个错误信息。默认属性为快速互斥锁。</li></ul><p><strong>函数格式</strong></p><p><strong>pthread_mutex_init()函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-33-34.png" alt="Snipaste_2019-03-04_00-33-34"></p><p><strong>pthread_mutex_lock()等函数</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-33-41.png" alt="Snipaste_2019-03-04_00-33-41"></p><h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>下面的实例是在 上面示例代码的基础上增加互斥锁功能，实现原本独立与无序的多个线程能够按顺<br>序执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*thread_mutex.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER 3 <span class="comment">/* 线程数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER 3 <span class="comment">/* 每个线程的小任务数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS 10.0 <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line"><span class="keyword">int</span> delay_time = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="comment">/* 互斥锁上锁 */</span></span><br><span class="line">res = pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d lock failed\n"</span>, thrd_num);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++)</span><br><span class="line">&#123;</span><br><span class="line">delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">sleep(delay_time);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>,</span><br><span class="line">thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line"><span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line"><span class="keyword">void</span> * thrd_ret;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">/* 互斥锁初始化 */</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">&#123;</span><br><span class="line">res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line"><span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line"><span class="built_in">exit</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">&#123;</span><br><span class="line">res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 互斥锁解锁 */</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失败：后面线程没信息，原因不明，</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_01-09-37.png" alt="Snipaste_2019-03-04_01-09-37"></p><p>正确结果应该：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span>: job <span class="number">0</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">1</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">2</span> delay = <span class="number">6</span></span><br><span class="line">Thread <span class="number">0</span> finished</span><br><span class="line">Thread <span class="number">0</span> joined</span><br><span class="line">Thread <span class="number">1</span> is starting</span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">0</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">1</span> delay = <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">2</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">1</span> finished</span><br><span class="line">Thread <span class="number">1</span> joined</span><br><span class="line">Thread <span class="number">2</span> is starting</span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">0</span> delay = <span class="number">6</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">1</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">2</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">2</span> finished</span><br><span class="line">Thread <span class="number">2</span> joined</span><br></pre></td></tr></table></figure><h3 id="信号量线程控制"><a href="#信号量线程控制" class="headerlink" title="信号量线程控制"></a>信号量线程控制</h3><h4 id="信号量说"><a href="#信号量说" class="headerlink" title="信号量说"></a>信号量说</h4><p>​    信号量也就是操作系统中所用到的PV 原子操作，它广泛用于进程或线程间的同步与互斥。信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。这里先来简单复习一<br>下PV 原子操作的工作原理。<br>PV 原子操作是对整数计数器信号量sem 的操作。一次P 操作使sem 减一，而一次V 操作使sem 加一。<br>进程（或线程）根据信号量的值来判断是否对公共资源具有访问权限。当信号量sem 的值大于等于零<br>时，该进程（或线程）具有公共资源的访问权限；相反，当信号量sem 的值小于零时，该进程（或线<br>程）就将阻塞直到信号量sem 的值大于等于0 为止。<br>PV 原子操作主要用于进程或线程间的同步和互斥这两种典型情况。若用于互斥，几个进程（或线程）往<br>往只设置一个信号量sem，它们的操作流程如图9.2 所示。<br>当信号量用于同步操作时，往往会设置多个信号量，并安排不同的初始值来实现它们之间的顺序执行，它<br>们的操作流程如图9.3 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_01-14-08.png" alt="Snipaste_2019-03-04_01-14-08"></p><p>略</p><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章：Linux-多任务-编程&quot;&gt;&lt;a href=&quot;#第一章：Linux-多任务-编程&quot; class=&quot;headerlink&quot; title=&quot;第一章：Linux 多任务 编程&quot;&gt;&lt;/a&gt;第一章：Linux 多任务 编程&lt;/h1&gt;&lt;p&gt; 本章 主要 内容： &lt;/p&gt;
&lt;p&gt;简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>unix下输入与输出(I/0)</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/unix%E4%B8%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA-I-0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/unix下输入与输出-I-0.html</id>
    <published>2019-02-28T03:31:17.000Z</published>
    <updated>2019-03-03T17:26:44.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本章节主要讲解Linux下如何对文件操作，包括两部分：</p><p>文件I/O和标准I/O</p><p>他们有什么区别，该部分将使用一个专门都一下节去讲解。</p><a id="more"></a><h1 id="第一节：文件I-O和标准I-O的比较"><a href="#第一节：文件I-O和标准I-O的比较" class="headerlink" title="第一节：文件I/O和标准I/O的比较"></a>第一节：文件I/O和标准I/O的比较</h1><p>来源说明</p><p>作者：zqixiao_09 </p><p>原文地址：<a href="https://blog.csdn.net/zqixiao_09/article/details/50444465" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50444465</a> </p><h2 id="什么是文件I-O和标准I-O"><a href="#什么是文件I-O和标准I-O" class="headerlink" title="什么是文件I/O和标准I/O"></a>什么是文件I/O和标准I/O</h2><p>文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。</p><p>标准I/O：标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存。</p><ul><li>全缓存：当填满标准I/O缓存后才进行实际的I/O操作。 </li><li>行缓存：当输入或输出中遇到新行符时，标准I/O库执行I/O操作。 </li><li>不带缓存：stderr就是了。</li></ul><h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><ul><li><p>文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。</p></li><li><p>通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。</p></li><li><p>文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。而标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。</p><p><em>注：Linux 中使用的是GLIBC，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O）。</em></p></li></ul><h2 id="文件I-O和标准I-O使用的函数比较"><a href="#文件I-O和标准I-O使用的函数比较" class="headerlink" title="文件I/O和标准I/O使用的函数比较"></a>文件I/O和标准I/O使用的函数比较</h2><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_11-57-29.png" alt="Snipaste_2019-02-28_11-57-29"></p><h3 id="fopen与open比较"><a href="#fopen与open比较" class="headerlink" title="fopen与open比较"></a>fopen与open比较</h3><p><strong>标准I/O使用fopen函数打开一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span> *mod)</span><br></pre></td></tr></table></figure><ul><li>path：文件名。</li><li>mod：用于指定文件打开的模式的字符串，比如”r”,”w”,”w+”,”a”等等，可以加上字母b用以指定以二进制模式打开。</li><li>返回值：如果成功打开，返回一个FILE文件指针，如果失败返回NULL。（这里的文件指针并不是指向实际的文 件，而是一个关于文件信息的数据包，其中包括文件使用的缓冲区信息。）</li></ul><p><strong>文件IO使用open函数用于打开一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd=open(<span class="keyword">char</span> *name,<span class="keyword">int</span> how);</span><br></pre></td></tr></table></figure><ul><li>name：文件名字符串</li><li>how指定打开的模式：O_RDONLY(只读),O_WRONLY(只写）,O_RDWR （可读可写)。（其他模式请man 2 open）。</li><li>返回值：成功返回一个正整数称为文件描述符，这与标准I/O显著不同，失败的话返回-1，与标准I/O返回NULL也是不同的。</li></ul><h3 id="fclose与close比较"><a href="#fclose与close比较" class="headerlink" title="fclose与close比较"></a>fclose与close比较</h3><p>标准I/O使用fclose关闭文件，将文件指针传入即可，如果成功关闭，返回0，否则返回EOF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fclose(fp)!=<span class="number">0</span>)  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error in closing file"</span>);</span><br></pre></td></tr></table></figure><p>文件IO使用close用于关闭open打开的文件，与fclose类似，只不过当错误发生时返回的是-1，而不是EOF，成功关闭同样是返回0。</p><h3 id="读文件比较：getc-fscanf-fgets和read"><a href="#读文件比较：getc-fscanf-fgets和read" class="headerlink" title="读文件比较：getc,fscanf,fgets和read"></a>读文件比较：getc,fscanf,fgets和read</h3><p><strong>标 准I/O中进行文件读取</strong></p><ul><li>可以使用 <strong>getc</strong>，一个字符一个字符的读取，也可以使用gets（读取标准io读入的）</li><li>fgets以字符串单位进行读取（读到遇 到的第一个换行字符的后面）</li></ul><p>gets（接受一个参数，文件指针）不判断目标数组是否能够容纳读入的字符，可能导致存储溢出(不建议使用），而fgets使用三个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数和gets一样，用于存储输入的地址，第二个参数为整数，表示输入字符串的最大长度，最后一个参数就是文件指针，指向要读取的文件。</p><ul><li>最 后是fscanf，与scanf类似，只不过增加了一个参数用于指定操作的文件，比如fscanf(fp,”%s”,words)</li></ul><p><strong>文件I/O中进行文件读取</strong></p><p>文件IO中使用read函数用于读取open函数打开的文件，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> numread=read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> qty);</span><br></pre></td></tr></table></figure><p>其中fd就是open返回的文件描述符，buf用于存储数据的目的缓冲区，而qty指定要读取的字节数。如果成功读取，就返回读取的字节数目（小于等于qty）</p><h3 id="判断文件结尾比较"><a href="#判断文件结尾比较" class="headerlink" title="判断文件结尾比较"></a>判断文件结尾比较</h3><p>如果尝试读取达到文件结尾，标准IO的getc会返回特殊值EOF，而fgets碰到EOF会返回NULL,而对于unix的read函数，情况有所不 同。read读取qty指定的字节数，最终读取的数据可能没有你所要求的那么多（qty），而当读到结尾再要读的话，read函数将返回0.</p><h3 id="写文件比较：putc-fputs-fprintf和write"><a href="#写文件比较：putc-fputs-fprintf和write" class="headerlink" title="写文件比较：putc,fputs,fprintf和write"></a>写文件比较：putc,fputs,fprintf和write</h3><p><strong>标准I/O中进行文件写入</strong></p><p>使用putc写入字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putc(ch,fp);</span><br><span class="line"><span class="comment">//第一个参数是字符，第二个是文件指针。</span></span><br></pre></td></tr></table></figure><p>使用fputs写入字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(buf,fp);</span><br><span class="line"><span class="comment">//仅仅是第一个参数换成了字符串地址。</span></span><br></pre></td></tr></table></figure><p>使用fprintf写入字符</p><p>fprintf与printf类似，增加了一个参数用于指定写入的文件，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello %s.\n"</span>,<span class="string">"dennis"</span>);</span><br></pre></td></tr></table></figure><p>切记fscanf和fprintf将FILE指针作为第一个参数，而putc,fputs则是作为第二个参数。</p><p><strong>文件I/O中进行文件写入</strong></p><p>在文件IO中提供write函数用于写入文件，原型与read类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result=write(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf ,<span class="keyword">size_t</span> amt);</span><br></pre></td></tr></table></figure><p>fd：文件描述符</p><p>buf：是将要写入的内存数据</p><p>amt：是要写的字节数。</p><p>返回值：如果写入成功返回写入的字节数，通过result与amt的比较可以判断是否写入正常，如果写入失败返回-1</p><h3 id="随机存取比较：fseek-、ftell-和lseek"><a href="#随机存取比较：fseek-、ftell-和lseek" class="headerlink" title="随机存取比较：fseek()、ftell()和lseek()"></a>随机存取比较：fseek()、ftell()和lseek()</h3><p><strong>标准I/O中进行随机存取</strong></p><p>标准I/O使用fseek和ftell用于文件的随机存取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fseek函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数：是文件指针</p><p>第二个参数：是一个long类型的偏移量（offset），表示从起始点开始移动的距离。</p><p>第三个参数：是用于指定起始点的模式，stdio.h指定了下列模式常量：SEEK_SET ：文件开始处， SEEK_CUR ：当前位置<br>，    SEEK_END： 文件结尾处</p><p>看几个调用例子： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_SET); <span class="comment">//找到文件的开始处 </span></span><br><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END); <span class="comment">//定位到文件结尾处 </span></span><br><span class="line">fseek(fp,<span class="number">2L</span>,SEEK_CUR); <span class="comment">//文件当前位置向前移动2个字节数</span></span><br></pre></td></tr></table></figure><p>而ftell函数用于返回文件的当前位置，返回类型是一个long类型，比如下面的调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">0L</span>,SEEK_END);<span class="comment">//定位到结尾 </span></span><br><span class="line"><span class="keyword">long</span> last=ftell(fp); <span class="comment">//返回当前位置</span></span><br></pre></td></tr></table></figure><p>那么此时的last就是文件指针fp指向的文件的字节数。</p><p><strong>文件I/O中进行随机存取</strong></p><p>与标准I/O类似，unix系统提供了lseek来完成fseek的功能，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型如下：</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><p>fildes:是文件描述符</p><p>offset:也是偏移量</p><p>whence:同样是指定起始点模式</p><p>唯一的不同是lseek有返回值，如果成功就 返回指针变化前的位置，否则返回-1。whence的取值与fseek相同：SEEK_SET,SEEK_CUR,SEEK_END，但也可以用整数 0,1,2相应代替。</p><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>上面我们一直在讨论文件I/O与标准I/O的区别，其实可以这样说，文件I/O是系统调用、标准I/O是库函数，看下面这张图：</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_12-42-29.png" alt="Snipaste_2019-02-28_12-42-29"></p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>操作系统负责管理和分配所有的计算机资源。为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用。通过这组接口用户程序可以使用操作系统内核提供的各种功能。例如分配内存、创建进程、实现进程之间的通信等。</p><p>   为什么不允许程序直接访问计算机资源？答案是不安全。单片机开发中，由于不需要操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，所以开发人员可以编写代码直接访问硬件。而在32位嵌入式系统中通常都要运行操作系统，程序访问资源的方式都发生了改变。操作系统基本上都支持多任务，即同时可以运行多个程序。如果允许程序直接访问系统资源，肯定会带来很多问题。因此，所有软硬件资源的管理和分配都有操作系统负责。程序要获取资源（如分配内存，读写串口）必须由操作系统来完成，即用户程序向操作系统发出服务请求，操作系统收到请求后执行相关的代码来处理。</p><p>   用户程序向操作系统提出请求的接口就是系统调用。所有的操作系统都会提供系统调用接口，只不过不同的操作系统提供的系统调用接口各不相同。Linux 系统调用接口非常精简，它继承了Unix 系统调用中最基本的和最有用的部分。这些系统调用按照功能大致可分为<strong>进程控制、进程间通信、文件系统控制、存储管理、网络管理、套接字控制、用户管理等几类。</strong></p><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>库函数可以说是对系统调用的一种封装，因为系统调用是面对的是操作系统，系统包括Linux、Windows等，如果直接系统调用，会影响程序的移植性，所以这里使用了库函数，比如说C库，这样只要系统中安装了C库，就都可以使用这些函数，比如printf()  scanf()等，C库相当于对系统函数进行了翻译，使我们的APP可以调用这些函数；</p><h4 id="用户编程接口API"><a href="#用户编程接口API" class="headerlink" title="用户编程接口API"></a>用户编程接口API</h4><p> 前面提到利用系统调用接口程序可以访问各种资源，但在实际开发中程序并不直接使用系统调用接口，而是使用用户编程接口（API）。为什么不直接使用系统调用接口呢？</p><p>原因如下：</p><p>1）系统调用接口功能非常简单，无法满足程序的需求。</p><p>2）不同操作系统的系统调用接口不兼容，程序移植时工作量大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户编程接口通俗的解释就是各种库（最重要的就是C库）中的函数。为了提高开发效率，C库中实现了很多函数。这些函数实现了常用的功能，供程序员调用。这样一来，程序员不需要自己编写这些代码，直接调用库函数就可以实现基本功能，提高了代码的复用率。使用用户编程接口还有一个好处：程序具有良好的可移植性。几乎所有的操作系统上都实现了C库，所以程序通常只需要重新编译一下就可以在其他操作系统下运行。</span><br><span class="line"></span><br><span class="line">用户编程接口（API）在实现时，通常都要依赖系统调用接口。例如，创建进程的API函数fork()对应于内核空间的sys_fork()系统调用。很多API函数西亚我哦通过多个系统调用来完成其功能。还有一些API函数不要调用任何系统调用。</span><br><span class="line"></span><br><span class="line"> 在Linux 中用户编程接口（API）遵循了在Unix中最流行的应用编程界面标准——POSIX标准。POSIX标准是由IEEE和ISO/IEC共同开发的标准系统。该标准基于当时想用的Unix 实践和经验，描述了操作系统的系统调用编程接口（实际上就是API），用于保证应用程序可以在源代码一级商多种操作系统上运行。这些系统调用编程接口主要是通过C库（libc )实现的。</span><br></pre></td></tr></table></figure><h2 id="一句话理解文件I-O和标准I-O"><a href="#一句话理解文件I-O和标准I-O" class="headerlink" title="一句话理解文件I/O和标准I/O"></a>一句话理解文件I/O和标准I/O</h2><ul><li>文件I/O更接近于底层硬件的I/O。其使用是通过是系统调用实现的。</li><li>标准I/O可以说是对文件I/O的一种封装，是基于库函数。</li><li>文件I/O多针对于操作系统而标准I/O多针对于应用程序</li></ul><h1 id="第二节：文件I-O"><a href="#第二节：文件I-O" class="headerlink" title="第二节：文件I/O"></a>第二节：文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX 系统文件 I/ O 函数的操作有—— 打开 文件、 读 文件、 写 文件 等。 UNIX 系统 中的 大多数 文件 I/ O 只需 用到 5 个 函数： open、 read、 write、 lseek 以及 close。</p><p>本章 描述 的 函数 经常 被称为 不带 缓冲 的 I/ O，术语 不带 缓冲 指的 是 每个 read 和 write 都 调用 内核 中的 一个 系统 调用。</p><p>只要 涉及 在 多个 进程 间 共享 资源， 原子 操作 的 概念 就 变得 非常 重要。 我们将 通过 文件 I/ O 和 open 函数 的 参数 来 讨论 此 概念。</p><p>本章 还将 进一步 讨论 在 多个 进程 间 如何 共享 文件， 以及 所 涉及 的 内核 有关 数据 结构。 在 描述 了 这些 特征 后， 将 说明 dup、 fcntl、 sync、 fsync 和 ioctl 函数。</p><h2 id="文件-描述-符"><a href="#文件-描述-符" class="headerlink" title="文件 描述 符"></a>文件 描述 符</h2><p>对于 内核 而言， 所有 打开 的 文件 都 通过 文件 描述 符 引用。 文件 描述 符 是 一个 非 负 整数。 当 打开 一个 现有 文件 或 创建 一个 新 文件 时， 内核 向 进程 返回 一个 文件 描述 符。当 读、 写 一个 文件 时， 使用 open 或 creat 返回 的 文件 描述 符 标识 该 文件， 将其 作为 参数 传送 给 read 或 write。</p><p>按照 惯例， UNIX 系统 shell 把 文件 描述 符 0 与 进程 的 标准 输入 关联， 文件 描述 符 1 与 标准 输出 关联， 文件 描述 符 2 与 标准 错误 关联。</p><p>文件 描述 符 的 变化 范围是 0 ～ OPEN_ MAX- 1（ 见图 2- 11）。 早期 的 UNIX 系统 实现 采用 的 上 限值 是 19（ 允许 每个 进程 最多 打开 20 个 文件）， 但 现在 很多 系统 将其 上限 值 增加 至 63。</p><h2 id="文件的打开和关闭及-创建"><a href="#文件的打开和关闭及-创建" class="headerlink" title="文件的打开和关闭及 创建"></a>文件的打开和关闭及 创建</h2><h3 id="函数-open"><a href="#函数-open" class="headerlink" title="函数 open"></a>函数 open</h3><p>调用 open 或 openat 函数 可以 打开 或 创建 一个 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>pathname ：</strong>是待打开/创建文件的路径名（如 C:/cpp/a.cpp）。</p><p><strong>oflag ：</strong>用于指定文件的打开/创建模式。</p><p>这个参数可由以下常量（定义于 fcntl.h）通过逻辑或构成。打开/创建文件时，至少得使用下述三个常量中的一个。</p><ul><li>O_RDONLY　　只读模式</li><li>O_WRONLY　　只写模式</li><li>O_RDWR　　读写模式</li></ul><p>以下常量是选用的：</p><ul><li>O_APPEND　　每次写操作都写入文件的末尾</li><li>O_CREAT　　如果指定文件不存在，则创建这个文件</li><li>O_EXCL　　如果要创建的文件已存在，则返回 -1，并且修改 errno 的值</li><li>O_TRUNC　　如果文件存在，并且以只写/读写方式打开，则清空文件全部内容</li><li>O_NOCTTY　　如果路径名指向终端设备，不要把这个设备用作控制终端。</li><li>O_NONBLOCK　　如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）</li></ul><p>以下三个常量同样是选用的，它们用于同步输入输出</p><ul><li>O_DSYNC　　等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。</li><li>O_RSYNC　　read 等待所有写入同一区域的写操作完成后再进行</li><li>O_SYNC　　等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</li></ul><p><strong>第三个参数（…）</strong>仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。</p><p><strong>返回值：</strong>成功则返回文件描述符，否则返回 -1，open 返回的文件描述符一定是最小的未被使用的描述符。</p><p>函数 creat</p><p>也可 调用 creat 函数 创建 一个 新 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; fcntl. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *path, mode_ t mode)</span></span>;</span><br></pre></td></tr></table></figure><p>返回 值： 若 成功， 返回 为 只 写 打开 的 文件 描述 符； 若 出错， 返回 − 1 注意，</p><p> 此 函数 等效 于： open( path, O_ WRONLY ｜ O_ CREAT ｜ O_ TRUNC, mode)。 因此现在很少有使用creat()函数来创建新文件;</p><h3 id="函数-close"><a href="#函数-close" class="headerlink" title="函数 close"></a>函数 close</h3><p>调用 close 函数可以关闭 一个已打开的文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line">int close (int fd)；</span><br></pre></td></tr></table></figure><p> 返回 值： 若 成功， 返回 0； 若 出错， 返回 − 1 </p><p>关闭 一个 文件 时 还会 释放 该 进程 加在 该 文件 上 的 所有 记录 锁。 </p><p> 当 一个 进程 终止 时， 内核 自动 关闭 它 所有 的 打开 文件。 很多 程序 都 利用 了 这一 功能 而 不显 式 地 用 close 关闭 打开 文件。 </p><h3 id="实例：文件的打开与关闭"><a href="#实例：文件的打开与关闭" class="headerlink" title="实例：文件的打开与关闭"></a>实例：文件的打开与关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd；</span><br><span class="line">   <span class="keyword">if</span>((fd=open(“test.txt”,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0666</span>)&lt;<span class="number">0</span>);</span><br><span class="line">      &#123;</span><br><span class="line">          perror(<span class="string">"fail tpo open"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h3 id="函数-read"><a href="#函数-read" class="headerlink" title="函数 read"></a>函数 read</h3><p>调用 read 函数 从 打开 文件 中 读 数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回读到的字节数，若已到文件末尾则返回0，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:读取数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要读取的字节数</span></span><br></pre></td></tr></table></figure><p> 　　有几种情况可使实际读到的字节数少于要求读的字节数：</p><p>　　1）读普通文件时，在读到要求字节数之前就已经达到了文件末端。例如，若在到达文件末端之前还有30个字节，而要求读100个字节，则read返回30，下一次再调用read时，它将返回0（文件末端）。</p><p>　　2）当从终端设备读时，通常一次最多读一行。</p><p>　　3）当从网络读时，网络中的缓存机构可能造成返回值小于所要求读的字结束。</p><p>　　4）当从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</p><p>　　5）当从某些面向记录的设备（例如磁带）读时，一次最多返回一个记录。</p><p>　　6）当某一个信号造成中断，而已经读取了部分数据。</p><h3 id="函数-write"><a href="#函数-write" class="headerlink" title="函数 write"></a>函数 write</h3><p>write函数定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nb　write函数定义如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure><h3 id="实例：使用-read-和-write-函数-复制-一个-文件。"><a href="#实例：使用-read-和-write-函数-复制-一个-文件。" class="headerlink" title="实例：使用 read 和 write 函数 复制 一个 文件。"></a>实例：使用 read 和 write 函数 复制 一个 文件。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: copy_file.c</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from_fd,to_fd;</span><br><span class="line">    <span class="keyword">long</span> file_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断入参</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s fromfile tofile !\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">if</span>( (from_fd = open(argv[<span class="number">1</span>],O_RDONLY | O_CREAT ))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s Error!\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建目的文件</span></span><br><span class="line">    <span class="keyword">if</span>( (to_fd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT))==<span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open %s error! \n"</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//测得文件大小</span></span><br><span class="line">    file_len=lseek(from_fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(from_fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"from file size is %d!\n"</span>,file_len);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//进行文件拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(from_fd, buffer, BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(to_fd, buffer, ret );</span><br><span class="line">        file_len = ret;</span><br><span class="line">        bzero( buffer, BUFFER_SIZE );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"there are %d buyes data left without copy!\n"</span>,file_len);</span><br><span class="line">    close(from_fd);</span><br><span class="line">    close(to_fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lseek文件定位"><a href="#lseek文件定位" class="headerlink" title="lseek文件定位"></a>lseek文件定位</h2><p>lseek函数对文件当位置进行定位。它只能对可定位（可随机 访问）文件操作。管道，套接字和大部分字符设备文件不支持该类操作。</p><p> 函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><p> <strong>函数功能：</strong> lseek系统调用用来移动读写指针的位置</p><p><strong>参数说明：</strong></p><p>fd:要操作的文件</p><p>  offset：相对whence移动的位移数，允许负值</p><p>  whence：起始指针，它有三个取值</p><ul><li><p>SEEK_SET 从文件开始处计算偏移量</p></li><li><p>​         SEEK_CUR 从文件指针的当前位置开始计算偏移</p></li><li><p>SEEK_END 从文件结尾处开始计算偏移量</p><p>文件指针值等于当前指针值加上offset的值。     </p></li></ul><p><strong>返回值：</strong>调用成功时范围当前的读写位置，也就是距离文件开始处多少字节，若 有错误返回-1</p><p><strong>常见用法：</strong></p><ul><li>将文件读写指针移动到文件开头：lseek(int fildes, 0, SEEK_SET);</li><li>将文件读写指针移动到文件结尾：lseek(int fildes, 0, SEEK_END);</li><li>获取文件读写指针当前的位置：lseek(int fikdes, 0, SEEK_CUR);</li></ul><p><strong>实例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>  readfd, writefd;  </span><br><span class="line">    <span class="keyword">long</span> filelen=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span>  ret=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];  </span><br><span class="line">    <span class="keyword">char</span> *ptr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*打开源文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((readfd=open(<span class="string">"test.txt"</span>, O_RDONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">      <span class="comment">/*创建目的文件*/</span>   </span><br><span class="line">    <span class="keyword">if</span>((writefd=open(<span class="string">"dest.txt"</span>, O_WRONLY|O_CREAT)) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error\n"</span>);   </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*测得文件大小*/</span>  </span><br><span class="line">    filelen= lseek(readfd,<span class="number">0L</span>,SEEK_END);  </span><br><span class="line">    lseek(readfd,<span class="number">0L</span>,SEEK_SET);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read file size is %d\n"</span>,filelen);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进行文件拷贝*/</span>  </span><br><span class="line">    <span class="keyword">while</span>(ret)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret= read(readfd, buffer, BUFFER_SIZE);  </span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read Error\n"</span>);   </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);          </span><br><span class="line">        &#125;  </span><br><span class="line">        write(writefd, buffer, ret);  </span><br><span class="line">        filelen-=ret;  </span><br><span class="line">        bzero(buffer,BUFFER_SIZE);  </span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    close(readfd);   </span><br><span class="line">    close(writefd);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考实例：</strong></p><p><a href="https://www.cnblogs.com/mickole/p/3182033.html" target="_blank" rel="noopener">利用lseek()创建空洞文件</a></p><p><a href="https://www.cnblogs.com/zxysmalleyes/p/5321207.html" target="_blank" rel="noopener">用lseek拼接两个文件</a></p><h1 id="第三节：内核数据结构分析"><a href="#第三节：内核数据结构分析" class="headerlink" title="第三节：内核数据结构分析"></a>第三节：内核数据结构分析</h1><p>UNIX 系统 支持 在 不同 进程 间 共享 打开 文件。进程间的这种 共享是如何进行的，为此 先 介绍 内核 用于 所有 I/ O 的 数据 结构。 </p><p>内核 使用 3 种数 据 结构 表示 打开 文件， 它们 之间 的 关系 决定了 在 文件 共享 方面 一个 进程 对 另一个 进程 可能 产生 的 影响。 </p><p>（1）每个 进程 在 进程表 中 都有 一个 记录 项（文件表项）， 记录 项 中 包含 一张 打开 文件 描述 符 表， 可将 其 视为 一个 矢量， 每个 描述 符 占用 一项。 与 每个 文件 描述 符 相 关联 的 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a． 文件 描述 符 标志（ close_ on_ exec， 参见 图 3- 7 和 3. 14 节）；</span><br><span class="line"></span><br><span class="line">b． 指向 一个 文件 表项 的 指针。</span><br></pre></td></tr></table></figure><p>（2） 内核 为所 有打 开 文件 维持 一张 文件 表。 每个 文件 表项 包含：</p><p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等， 关于 这些 标志 的 更多 信息 参见 3. 14 节）；</p><p> b． 当前 文件 偏移量； </p><p>c． 指向 该 文件 v 节点 表项 的 指针。</p><p> （3） 每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。 v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。 对于 大多数 文件， v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。 这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。 例如， i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等（ 4. 14 节 较 详细 地说 明了 典型 UNIX 系统 文件 系统， 并将 更多 地 介绍 i 节点）。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-34-56.png" alt="Snipaste_2019-02-28_16-34-56"></p><p>个人梳理：</p><ul><li><p>1.每个进程都会有一个进程表项，进程表项中包含一个文件描述符表，每个描述符占有一项，每个描述符对应一个指针。该指针指向文件表项。</p></li><li><p>2.内核会为所有的打开的文件创建 一张 文件表项。 每个文件表项包含：     </p><p>a． 文件 状态 标志（ 读、 写、 添 写、 同步 和 非 阻塞 等）。</p><p>b． 当前 文件 偏移量；</p><p> c． 指向 该 文件 v 节点 表项 的 指针。</p></li><li><p>3.每个 打开 文件（ 或 设备） 都有 一个 v 节点（ v- node） 结构。</p><p>v 节点 包含 了 文件 类型 和 对此 文件 进行 各种 操作 函数 的 指针。</p><p>v 节点 还 包含 了 该 文件 的 i 节点（ i- node， 索引 节点）。</p><p> i 节点 包含 了 文件 的 所有者、 文件 长度、 指向 文件 实际 数据 块 在 磁盘 上 所在 位置 的 指针 等。</p></li></ul><p>注：这些 信息 是在 打开 文件 时 从 磁盘 上 读入 内存 的， 所以， 文件 的 所有 相关 信息 都是 随时 可用 的。</p><p>注意， 文件 描述 符 标志 和 文件 状态 标志 在作 用 范围 方面 的 区别， 前者 只用于 一个 进程 的 一个 描述 符， 而后 者 则应 用于 指向 该给 定 文件 表项 的 任何 进程 中的 所有 描述 符。</p><p><strong>两个 独立 进程 各自 打开 了 同一 文件</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_16-49-15.png" alt="Snipaste_2019-02-28_16-49-15"></p><p>第一个 进程 在 文件 描述 符 3 上 打开 该 文件， 而 另一个 进程 在 文件 描述 符 4 上 打开 该 文件。 打开 该 文件 的 两个 进程 都 获得 各自 的 一个 文件 表项， 但是对于一个 给定 的 文件只有 一个 v 节点表项。（为什么会创建有两个表项，而不指向欧安同意文件表项） 之所以 每个 进程 都 获得 自己的 文件 表项， 是因为 这可 以使 每个 进程 都有 它自己 的 对 该 文件 的 当前 偏移量。</p><h2 id="文件操作的进一步说明"><a href="#文件操作的进一步说明" class="headerlink" title="文件操作的进一步说明"></a>文件操作的进一步说明</h2><p>给出 了 这些 数据 结构 后， 现在 对 前面 所述 的 操作 进一步 说明。</p><ul><li>write：在 完成 每个 write 后， 在 文件 表项 中的 当前 文件 偏移量 即 增加 所 写入 的 字节数。 如果 这 导致 当前 文件 偏移量 超出 了 当前 文件 长度， 则 将 i 节点 表项 中的 当前 文件 长度 设置 为 当前 文件 偏移量（ 也就是 该文 件 加长 了）。</li><li>open：如果 用 O_ APPEND 标志 打开 一个 文件， 则 相应 标志 也 被 设置 到 文件 表项 的 文件 状态 标志 中。 每次 对这 种 具有 追加 写 标志 的 文件 执行 写 操作 时， 文件 表项 中的 当前 文件 偏移量 首先 会被 设置 为 i 节点 表项 中的 文件 长度。 这就 使得 每次 写入 的 数据 都 追加 到 文件 的 当前 尾端 处。</li><li>lseek：若 一个 文件 用 lseek 定位 到 文件 当前 的 尾端， 则 文件 表项 中的 当前 文件 偏移量 被 设置 为 i 节点 表项 中的 当前 文件 长度 </li></ul><p>注：lseek 函数 只 修改 文件 表项 中的 当前 文件 偏移量， 不进 行 任何 I/ O 操作。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>上面所秒述 的一切是对于多个进程读取同一文件的过程。 每个进程都有它自己的文件表项， 其中也有它自己 的当前文件偏移量。 但是，当多个进程写同一 文件时， 则可能产生预想不到的结果。 为了避免这种情况， 需要 理解原子操作的概念。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="追加数据到-一个-文件"><a href="#追加数据到-一个-文件" class="headerlink" title="追加数据到 一个 文件"></a>追加数据到 一个 文件</h4><p>早期 的 UNIX 系统 版本 并不 支持 open 的 O_ APPEND 选项， 所以 程序 被 编写 成 下列 形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek( fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) 　 　 　 　 　 　<span class="comment">/* position to EOF*/</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (write( fd, buf, <span class="number">100</span>) != <span class="number">100</span>) 　 　<span class="comment">/* and write*/</span> </span><br><span class="line">&#125;   </span><br><span class="line">        <span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" write error"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">err_ <span class="title">sys</span><span class="params">(<span class="string">" lseek error"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二个参数表示偏移量，字母L表示long 型，就是让编译器知道0是long型的</span></span><br><span class="line"><span class="comment">其中 int whence 为下列其中一种:（SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2）.</span></span><br><span class="line"><span class="comment">SEEK_SET 代表读写位置指向文件头</span></span><br><span class="line"><span class="comment">　　SEEK_CUR 代表目前的读写位置</span></span><br><span class="line"><span class="comment">　　SEEK_END 代表读写位置指向文件尾</span></span><br><span class="line"><span class="comment">这里的1和SEEK-CUR 是同一个意思。</span></span><br></pre></td></tr></table></figure><p>对 单个 进程 而言， 这段 程序 能 正常 工作， 但 若有 多个 进程 同时 使用 这种 方法 将 数据 追加 写到 同一 文件， 则 会 产生 问题.</p><h4 id="进程A和B对同一文件写操作"><a href="#进程A和B对同一文件写操作" class="headerlink" title="进程A和B对同一文件写操作"></a>进程A和B对同一文件写操作</h4><p>此时， 各 数据 结构 之间 的关系上节图 3- 8 中 所示。 每个 进程 都有 它自己 的 文件 表项， 但是 共享 一个 v 节点 表项。</p><ul><li>此时如果进程 A 调用了lseek， 它将进程 A 的 该文件当前偏移量设置为1500 字节</li><li>然后 内核 切换 进程， 进程 B 运行。 进程 B 执行 lseek， 也 将其 对 该 文件 的 当前 偏移量 设置 为 1 500 字节（ 当前 文件尾 端 处）。 然后 B 调用 write， 它将 B 的 该文 件 当前 文件 偏移量 增加 至 1 600。</li><li>然后， 内核 又 进行 进程 切换， 使 进程 A 恢复 运行。 当 A 调用 write 时， 就会从其当前文件偏移量（ 1 500） 处 开始 将 数据 写入 到 文件。</li></ul><p>这样 也就 覆盖 了 进程 B 刚才 写入 到 该文 件 中的 数据。</p><p><strong>问题 出在 逻辑 操作“ 先 定位 到 文件 尾端， 然后 写”， 它 使用 了 两个 分开 的 函数函调用。</strong> </p><p>解决问题 的 方法 是 使 这 两个 操作 对于 其他 进程 而言 成为 一个 原子 操作。 如果任何要求 多于 一个 函数 调用 的 操作 不 是 原子 操作， 则在 两个 函数 调用 之间， 内核 有可能 会 临时 挂起 进程（ 正如 我们 前面 所 假定 的）。 </p><p>UNIX 系统 为 这样 的 操作 提供 了 一种 原子 操作 方法， 即在 打开 文件 时 设置 O_ APPEND 标志（O_APPEND：每次写操作都写入文件的末尾）。  这样做 使得 内核 在 每次 写 操作 之前， 都将 进程 的 当前 偏移量 设置 到 该 文件 的 尾端 处， 于是 在 每次 写 之前 就不 再 需要 调用 lseek。</p><p><strong>原子操作：</strong>顾名思义，就是说像原子一样不可再细分不可被中途打断。一个操作是原子操作，意思就是说这个操作是以原子的方式被执行，要一口气执行完，执行过程不能够被OS的其他行为打断，是一个整体的过程，在其执行过程中，OS的其它行为是插不进来的。</p><h3 id="文件锁fctnl"><a href="#文件锁fctnl" class="headerlink" title="文件锁fctnl"></a>文件锁fctnl</h3><p>如何实现原子操作，这里就要用到文件锁fctnl().</p><p>该部分讨论文件在已经共享的情况下如何操作，也就是多个程序在操作同以稳健的情况下。，LInux中通常使用文件上锁的方法，来解决共享资源的竞争。</p><p>文件锁包括建议性锁（lockf（））和强制性锁（fcntl（））。fcntl不仅可以施加建议性锁还可以施加强制性锁，同时还能对为见额某一记录上锁，依旧是记录锁。</p><p>记录锁分为读取锁和写入锁。</p><p>略。。。</p><h2 id="重定向dup和dup2函数"><a href="#重定向dup和dup2函数" class="headerlink" title="重定向dup和dup2函数"></a>重定向dup和dup2函数</h2><p>函数dup和dup2提供了<strong>复制文件描述符的功能</strong>。</p><p>他们通常用于stdin,stdout或进程的stderr的重定向。一般来说，普通输出函数（如：printf），默认是将某信息写入到文件描述符为1的文件中，普通输入函数都默认从文件描述符为0的文件中读取数据。因此重定向操作实际上是关闭某个标准输入输出设备（文件描述符为0、1、2），而将另一个打开的普通文件的文件描述符设置为0、1、2.</p><ul><li>输入重定向：关闭标准输入设备，打开（或复制）某普通文件，使其文件描述符为0.</li><li>输出重定向：关闭标准输出设备，打开（或复制）某普通文件，使其文件描述符为1.    </li><li>错误输出重定向：关闭标准错误输入设备，打开（或复制）某普通文件，使其文件描述符为2.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">( <span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure><p>由 dup 返回 的 新 文件 描述 符 一定 是 当前 可用 文件 描述 符 中的 最小 数值。</p><p> 对于 dup2， 可 以用 fd2 参数 指定 新 描述 符 的 值。 如果 fd2 已经 打开， 则 先 将其 关闭。 如若 fd 等于 fd2， 则 dup2 返回 fd2， 而 不 关闭 它。 否则， fd2 的 FD_ CLOEXEC 文件 描述 符 标志 就被 清除， 这样 fd2 在 进程 调用 exec 时 是 打开 状态。</p><p>这些 函数 返回 的 新 文件 描述 符 与 参数 fd 共享 同一个 文件 表项</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-28_19-16-14.png" alt="Snipaste_2019-02-28_19-16-14"></p><h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure><p>对于函数dup 允许你复制一个oldfd文件描述符。存入一个已存在的文件描述符，它就会返回一个与该描述符“相同”的新的文件描述符。即这两个描述符共享相同的内部结构，共享所有的锁定，读写位置和各项权限或flags等等。例如：对一个文件描述符进行了lseek操作，另一个文件描述符的读写位置也会随之改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd,newfd;</span><br><span class="line">        <span class="keyword">char</span> *bufFD=<span class="string">"Advanced Programming! write by fd\n"</span>;</span><br><span class="line">        <span class="keyword">char</span> *bufNewFD=<span class="string">"Advanced Programming! write by NewFD\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开始复制了</span></span><br><span class="line">        newfd = dup(fd);</span><br><span class="line">        <span class="comment">//使用fd写</span></span><br><span class="line">        write(fd,bufFD,<span class="built_in">strlen</span>(bufFD));</span><br><span class="line">        close(fd);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用newfd写</span></span><br><span class="line">        write(newfd,bufNewFD,<span class="built_in">strlen</span>(bufNewFD));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(close(newfd)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，里面有两段字符串：</span></span><br><span class="line"><span class="comment">：Advanced Programming! write by fd</span></span><br><span class="line"><span class="comment">：Advanced Programming! write by newfd</span></span><br></pre></td></tr></table></figure><pre><code>可以看出，对fd或newfd进行读写操作时对同一个文件操作，不会覆盖前面文件（共享读写位置）而且还可以看到fd关闭后，对newfd没有影响，使用newfd还可以操作打开的文件。</code></pre><h3 id="dup2函数（该函数不是很懂）"><a href="#dup2函数（该函数不是很懂）" class="headerlink" title="dup2函数（该函数不是很懂）"></a>dup2函数（该函数不是很懂）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dup2 函数定义在 &lt;unistd.h&gt; 中，函数原形为：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">( <span class="keyword">int</span> filedes, <span class="keyword">int</span> filedes2 )</span></span></span><br></pre></td></tr></table></figure><p> 返回值：如成功则返回新的文件描述符，否则出错返回-1. </p><p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。</p><p>若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags等等.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">int</span> refd;</span><br><span class="line">        <span class="keyword">char</span> *buf=<span class="string">"Advanced Programming!\n"</span>;</span><br><span class="line">        fd = open(<span class="string">"test.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"open file error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        refd = dup2(fd,fileno(<span class="built_in">stdout</span>));</span><br><span class="line">        <span class="keyword">if</span>(refd==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"redirect standard out error:%m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写数据，本应该写入到stdout的信息重定向而写入到目标文件中（test.txt）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dup2的返回值：%d\n"</span>,refd);</span><br><span class="line">        write(fileno(<span class="built_in">stdout</span>),buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">查看test.txt文件，可以看到以下内容</span></span><br><span class="line"><span class="comment">Advanced Programming!</span></span><br><span class="line"><span class="comment">dup2的返回值：1</span></span><br></pre></td></tr></table></figure><h1 id="第四节：标准I-O"><a href="#第四节：标准I-O" class="headerlink" title="第四节：标准I/O"></a>第四节：标准I/O</h1><p>标准 I/ O 的 由来</p><ul><li>标准 I/ O 指的 是 ANSI C 中 定义 的 用于 I/ O 操作 的 一系列 函数。 </li><li>只要 操作系统 中 安装 了 C 库， 标准 I/ O 函数 就可以 调用。即: 如果 程序 中 使 用的 是 标准 I/ O 函数， 那么 源 代码 不需要 修改 就可 以在 其他 操作系统 下 编译 运行， 具有 更好 的 可移植性。 </li><li>使用 标准 I/ O 可以 减少 系统 调用 的 次数， 提高 系统 效率。 标准 I/ O 函数 在 执行 时 也会 用到 系统 调用。 </li></ul><h2 id="流-和-FILE-对象"><a href="#流-和-FILE-对象" class="headerlink" title="流 和 FILE 对象"></a>流 和 FILE 对象</h2><p>标准 I/ O 的 核心 对象 就是 流。 当 用 标准 I/ O 打开 一个 文件 时， 就会 创建 一个 FILE 结构 体文件描述符，我们 把 这个 FILE 结构 体 形象 地 称为 流。然后 该文 件 描述 符 就用 于 后续 的 I/ O 操作。</p><p>标准 I/ O 文件 流 可用 于 单 字节 或 多 字节（“ 宽”） 字符 集。 流的 定向（ stream’ s orientation） 决定了 所 读、 写的 字符 是 单字 节 还是 多 字节 的。</p><p>标准 I/ O 函数 都 基于 流进 行 各种 操作。 标准 I/ O 中的 流的 缓冲 类型 有 以下 三种。 </p><p>（1） 全 缓冲： 在 这种 情况下， 当 填满 标准 I/ O 缓冲区 后才 进行 实际 I/ O 操作。 对于 存放 在 磁盘 上 的 普通 文件 用 标准 I/ O 打开 时 默认 是 全 缓冲 的。 当 缓冲区 已满 或 执行 flush 操作 时 才会 进行 磁盘 操作。</p><p> （2） 行 缓冲： 在 这种 情况下， 当 在 输入 和 输出 中 遇到 换行符 时 执行 I/ O 操作。 标准 输 入流 和 标准 输出 流 就是 使用 行 缓冲 的 典型 例子。 </p><p>（3） 无 缓冲： 不对 I/ O 操作 进行 缓冲， 即在 对流 的 读写 时会 立刻 操作 实际 的 文件。 标准 出错 流 是 不带 缓冲 的， 这就 使得 出错 信息 可以 立刻 显示 在 终端 上， 而 不管 输出 的 内容 是否 包含 换行符。</p><p>标准 I/ O 库 提供 缓冲 的 目的 是 尽可能 减少 使用 read 和 write 调用 的 次数。 它 也对 每个 I/ O 流 自动 地 进行 缓冲 管理， 从而 避免 了 应用 程序 需要 考虑 这一点 所带 来的 麻烦。 遗憾的是， 标准 I/ O 库 最 令人 迷惑 的 也是 它的 缓冲。</p><h2 id="标准输入-输出和标准错误"><a href="#标准输入-输出和标准错误" class="headerlink" title="标准输入,输出和标准错误"></a>标准输入,输出和标准错误</h2><p> 对 一个 进程 预 定义 了 3 个 流， 并且 这 3 个 流 可以 自动 地 被 进程 使用， 它们 是： 标准 输入、 标准输出和标准错误。 这些 流 文件 描述 符 STDIN_ FILENO、 STDOUT_ FILENO 和 STDERR_ FILENO 所。</p><p> 这 3 个 标准 I/ O 流通 过 预定 义 文件 指针 stdin、 stdout 和 stderr 加以 引用。 这 3 个 文件 指针 定义 在 头 文件&lt; stdio. h&gt; 中。</p><h2 id="标准-I-O-编程"><a href="#标准-I-O-编程" class="headerlink" title="标准 I/ O 编程"></a>标准 I/ O 编程</h2><h3 id="流的-打开"><a href="#流的-打开" class="headerlink" title="流的 打开"></a>流的 打开</h3><p>使用 标准 I/ O 打开 文件 的 函数 有 fopen()、 fdopen() 和 freopen()。</p><p> 它们 可以 以 不同 的 模式 打开 文件， 都 返回 一个 指向 FILE 的 指针， 该 指针 指向 对应 的 I/ O 流。 此后， 对 文件 的 读写 都是 通过 这个 FILE 指针 来 进行。</p><ul><li><p>fopen() 可以 指定 打开 文件 的 路径 和 模式，</p></li><li><p>fdopen() 可以 指定 打开 的 文件 描述 符 和 模式，</p></li><li><p>freopen() 除 可指 定 打开 的 文件、 模式 外， 还可 指定 特定 的 I/ O 流。</p><p>fopen() 函数 格式 如表 1. 1 所示。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-19-47.png" alt="Snipaste_2019-03-01_17-19-47"></p></li></ul><p>其中， mode 用于 指定 打开 文件 的 方式。 表 1. 2 说明了 fopen() 中 mode 的 各种 取值。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-20-03.png" alt="Snipaste_2019-03-01_17-20-03"></p><h3 id="流的-关闭"><a href="#流的-关闭" class="headerlink" title="流的 关闭"></a>流的 关闭</h3><p>关闭 流的 函数 为 fclose()， 该 函数 将 流的 缓冲区 内 的 数据 全部 写入 文件 中， 并 释放 相关 资源。 fclose() 函数 格式 如表 1. 3 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-22-18.png" alt="Snipaste_2019-03-01_17-22-18"></p><h3 id="错误-处理"><a href="#错误-处理" class="headerlink" title="错误 处理"></a>错误 处理</h3><p>标准 I/ O 函数 执行 时 如果 出现 错误， 会把 错误 码 保存 在 errno 中。 程序员 可以 通过 相应 的 函数 打印 错误 信息。</p><p>方发一</p><p>错误 处理 相关 函数 perror 如表 1. 4 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-24-15.png" alt="Snipaste_2019-03-01_17-24-15"></p><p>错误 处理 相关 函数 strerror 如表 1. 5 所示。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-31-44.png" alt="Snipaste_2019-03-01_17-31-44"></p><h3 id="实例：打开关闭文件和错误处理"><a href="#实例：打开关闭文件和错误处理" class="headerlink" title="实例：打开关闭文件和错误处理"></a>实例：打开关闭文件和错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp; <span class="comment">// 定义流 指针 </span></span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>） <span class="comment">//NULL是系统定义的宏， 其值为0</span></span><br><span class="line">    &#123; </span><br><span class="line">        perror（＂ fail to fopen＂）; <span class="comment">// 输出 错误 信息 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose（ fp）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果文件1.txt不存在，程序执行时会打印如下信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *fp; </span><br><span class="line">    <span class="keyword">if</span> （（ fp = fopen（＂ <span class="number">1.</span> txt＂, ＂r＂）） == <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>（＂ fail to fopen: %s\ n＂, strerror（ errno））; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    fclose（ fp）;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果 文件 1. txt 不存在， 程序 执行 时会 打印 如下 信息： fail to fopen: No such file or directory</span></span><br></pre></td></tr></table></figure><h3 id="流的读写"><a href="#流的读写" class="headerlink" title="流的读写"></a>流的读写</h3><h4 id="1-字符-节）输入-输出"><a href="#1-字符-节）输入-输出" class="headerlink" title="1.字符(节）输入/输出"></a>1.字符(节）输入/输出</h4><p>一次 读 或 写 一个 字符， 如果 流 是 带 缓冲 的， 则 标准 I/ O 函数 处理 所有 缓冲。</p><p><strong>读取</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-29.png" alt="Snipaste_2019-03-01_17-39-29"></p><p>getc() 和 fgetc ()从 指 定的 流 中 读取 一个 字符（ 节）， getchar() 从 stdin 中 读取 一个 字符（ 节）。</p><p><strong>输出</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-39-57.png" alt="Snipaste_2019-03-01_17-39-57"></p><p>putc() 和 fputc() 向 指 定的 流 输出 一个 字符（ 节）， putchar() 向 stdout 输出 一个 字符（ 节）。 </p><p><strong>实例</strong></p><p>下面 这个 实例 结合 fputc() 和 fgetc()， 循环 从 标准 输入 读取 任意 个 字符 并将 其中 的 数字 输出 到 标准 输出。</p><p>华清远见嵌入式学院; 曾宏安; 冯利美. 嵌入式应用程序设计综合教程 (高等院校嵌入式人才培养规划教材) (Kindle 位置 217-218). 人民邮电出版社. Kindle 版本. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fput. c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c; </span><br><span class="line">    <span class="keyword">while</span>（ <span class="number">1</span> ） </span><br><span class="line">    &#123;</span><br><span class="line">        c = fgetc（ <span class="built_in">stdin</span>）; <span class="comment">// 从 键盘 读取 一个 字符 </span></span><br><span class="line">        <span class="keyword">if</span> （（ c &gt;= <span class="string">'0'</span>） &amp;&amp; （c &lt;= <span class="string">'9'</span>）） fputc（ c, <span class="built_in">stdout</span>）; <span class="comment">// 若 输入 的 是 数字，输出 if （c == '\n'） break; // 若 遇到 换行符， 跳出 循环</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行 结果 如下。 $ ./a. out abc98io# 4/ wm 984</span></span><br></pre></td></tr></table></figure><h4 id="2-行输入-输出"><a href="#2-行输入-输出" class="headerlink" title="2.行输入/输出"></a>2.行输入/输出</h4><p>行 输入/ 输出 函数 一次 操作 一行。如果 想要 一次 读 或 写 一行， 则 使用 fgets 和 fputs。 每 行都 以 一个 换行符 终止。 当 调用 fgets 时， 应 说明 能 处理 的 最大 行长。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-15.png" alt="Snipaste_2019-03-01_17-58-15"></p><p>gets 函数 容易 造成 缓冲区 溢出， 不 推荐 大家 使用。 fgets 从 指 定的 流 中 读取 一个 字符串， 当 遇到\ n 或 读取 了 size- 1 个 字符 后 返回。 注意， fgets 不能 保证 每次 都能 读出 一行。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_17-58-41.png" alt="Snipaste_2019-03-01_17-58-41"></p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 以 fgets() 为例 计算 一个 文本 文件 的 行数。 /*fgets. c*/ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; string. h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> main（ <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]） </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[ <span class="number">128</span>];</span><br><span class="line">    FILE *fp; <span class="keyword">if</span> （argc &lt; <span class="number">2</span>） </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>（＂ Usage : %s &lt; file&gt;\ n＂, argv[ <span class="number">0</span>]）;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> （（ fp = fopen（ argv[ <span class="number">1</span>], ＂r＂）） == <span class="literal">NULL</span>） </span><br><span class="line">&#123; </span><br><span class="line">perror（＂ fail to fopen＂）;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>（ fgets（ buf, <span class="number">128</span>, fp） != <span class="literal">NULL</span>）</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> （buf[ <span class="built_in">strlen</span>（ buf）- <span class="number">1</span>] == <span class="string">'\n'</span>） </span><br><span class="line">    line++;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>（＂ The line of %s is %d\ n＂, argv[ <span class="number">1</span>], line）; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行 该 程序， 结果 如下。 $ ./a. out test. txt The line of test. txt is 64</span></span><br></pre></td></tr></table></figure><h4 id="3-指定大小为单位读写文件"><a href="#3-指定大小为单位读写文件" class="headerlink" title="3.指定大小为单位读写文件"></a>3.指定大小为单位读写文件</h4><p>在 文件 流 被打 开 之后， 可 对 文件 流 按指 定 大小 为 单位 进行 读写 操作。fread 和 fwrite 函数 支持 这种 类型 的 I/ O。 每次 I/ O 操作 读 或 写 某种 数量 的 对象， 而每 个 对象 具有 指定 的 长度。 这 两个 函数 常 用于 从 二进制 文件 中 每次 读 或 写 一个 结构。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-27.png" alt="Snipaste_2019-03-01_18-13-27"></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-13-40.png" alt="Snipaste_2019-03-01_18-13-40"></p><h3 id="流的定位"><a href="#流的定位" class="headerlink" title="流的定位"></a>流的定位</h3><p>每个 打开 的 流 内部 都有 一个 当前 读写 位置。 流 在 打开 时， 当前 读写 位置 为 0， 表示 文件 的 开始 位置。 每 读写 一次 后， 当前 读写 位置 自动 增加 实际 读写 的 大小。 在 读写 流 之间 可 先 对流 进行 定位， 即 移动 到 指定 的 位置 再 操作。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-16-07.png" alt="Snipaste_2019-03-01_18-16-07"></p><h3 id="格式化-输入-输出"><a href="#格式化-输入-输出" class="headerlink" title="格式化 输入 输出"></a>格式化 输入 输出</h3><p>格式化 输入/ 输出 函数 可以 指定 输入/ 输出 的 具体 格式， 包括 读者 已经 非常 熟悉 的 printf()、 scanf() 等 函数。</p><p><strong>格式化输入</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-17-55.png" alt="Snipaste_2019-03-01_18-17-55"></p><p><strong>格式化输出</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_18-18-05.png" alt="Snipaste_2019-03-01_18-18-05"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;本章节主要讲解Linux下如何对文件操作，包括两部分：&lt;/p&gt;
&lt;p&gt;文件I/O和标准I/O&lt;/p&gt;
&lt;p&gt;他们有什么区别，该部分将使用一个专门都一下节去讲解。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/数据结构.html</id>
    <published>2019-02-27T04:41:05.000Z</published>
    <updated>2019-03-03T17:26:52.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：数据结构基数"><a href="#第一章：数据结构基数" class="headerlink" title="第一章：数据结构基数"></a>第一章：数据结构基数</h1><h2 id="第一节：数据与c"><a href="#第一节：数据与c" class="headerlink" title="第一节：数据与c"></a>第一节：数据与c</h2><h2 id="第二节：数组和指针"><a href="#第二节：数组和指针" class="headerlink" title="第二节：数组和指针"></a>第二节：数组和指针</h2><h2 id="第三节：结构体"><a href="#第三节：结构体" class="headerlink" title="第三节：结构体"></a>第三节：结构体</h2><h2 id="第四节：其他结构"><a href="#第四节：其他结构" class="headerlink" title="第四节：其他结构"></a>第四节：其他结构</h2><a id="more"></a><h3 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h3><p>联合（union） 是一种数据类型， 它能在同一个内存空间中储存不同的数据类型（不是同时储存） 。 其典型的用法是， 设计一种表以储存既无规律、 事先也不知道顺序的混合类型。 使用联合类型的数组， 其中的联合都大小相等， 每个联合可以储存各种数据类型。 </p><h4 id="创建联合体"><a href="#创建联合体" class="headerlink" title="创建联合体"></a>创建联合体</h4><p>创建联合和创建结构的方式相同， 需要一个联合模板和联合变量。 可以用一个步骤定义联合， 也可以用联合标记分两步定义。 下面是一个带标记的联合模板： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold &#123;</span><br><span class="line"><span class="keyword">int</span> digit;</span><br><span class="line"><span class="keyword">double</span> bigfl;</span><br><span class="line"><span class="keyword">char</span> letter;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h4 id="定义（声明）联合体变量"><a href="#定义（声明）联合体变量" class="headerlink" title="定义（声明）联合体变量"></a>定义（声明）联合体变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit; <span class="comment">// hold类型的联合变量</span></span><br><span class="line"><span class="keyword">union</span> hold save[<span class="number">10</span>]; <span class="comment">// 内含10个联合变量的数组</span></span><br><span class="line"><span class="keyword">union</span> hold * pu; <span class="comment">// 指向hold类型联合变量的指针</span></span><br></pre></td></tr></table></figure><ul><li>第1个声明创建了一个单独的联合变量fit。 编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。 在本例中， 占用空间最大的是 double类型的数据。 在我们的系统中， double类型占64位， 即8字节。 </li><li>第2个声明创建了一个数组save， 内含10个元素， 每个元素都是8字节。</li><li>第3个声明创建了一个指针， 该指针变量储存hold类型联合变量的地址。</li></ul><h4 id="初始化联合体"><a href="#初始化联合体" class="headerlink" title="初始化联合体"></a>初始化联合体</h4><p>需要注意的是， 联合只能储存一个值， 这与结构不同。</p><p> 有 3 种初始化的方法： 把一个联合初始化为另一个同类型的联合； 初始化联合的第1个元素； 或者根据C99标准， 使用指定初始化器：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold valA;</span><br><span class="line">valA.letter = <span class="string">'R'</span>;</span><br><span class="line"><span class="keyword">union</span> hold valB = valA; <span class="comment">// 用另一个联合来初始化</span></span><br><span class="line"><span class="keyword">union</span> hold valC = &#123;<span class="number">88</span>&#125;; <span class="comment">// 初始化联合的digit 成员</span></span><br><span class="line"><span class="keyword">union</span> hold valD = &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure><h4 id="使用联体"><a href="#使用联体" class="headerlink" title="使用联体"></a>使用联体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit.digit = <span class="number">23</span>; <span class="comment">//把 23 储存在 fit， 占2字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>; <span class="comment">// 清除23， 储存 2.0， 占8字节</span></span><br><span class="line">fit.letter = <span class="string">'h'</span>; <span class="comment">// 清除2.0， 储存h， 占1字节</span></span><br></pre></td></tr></table></figure><p>点运算符表示正在使用哪种数据类型。 在联合中， 一次只储存一个值。即使有足够的空间， 也不能同时储存一个char类型值和一个int类型值。 </p><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>略</p><h3 id="枚举（不懂）"><a href="#枚举（不懂）" class="headerlink" title="枚举（不懂）"></a>枚举（不懂）</h3><p>可以用枚举类型（enumerated type） 声明符号名称来表示整型常量。 使<br>用enum关键字， 可以创建一个新“类型”并指定它可具有的值（实际上， enum<br>常量是int类型， 因此， 只要能使用int类型的地方就可以使用枚举类型） 。 枚<br>举类型的目的是提高程序的可读性。 它的语法与结构的语法相同。</p><h4 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br></pre></td></tr></table></figure><p>第1个声明创建了spetrum作为标记名， 允许把enum spetrum作为一个类型名使用。 第2个声明使color作为该类型的变量。 第1个声明中花括号内的标<br>识符枚举了spectrum变量可能有的值。 因此， color 可能的值是 red、orange、 yellow 等。 这些符号常量被称为枚举符（enumerator） 。  </p><h4 id="枚举的使用（没懂）"><a href="#枚举的使用（没懂）" class="headerlink" title="枚举的使用（没懂）"></a>枚举的使用（没懂）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow)</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++)</span><br><span class="line">...;</span><br></pre></td></tr></table></figure><p>虽然枚举符（如red和blue） 是int类型， 但是枚举变量可以是任意整数类型， 前提是该整数类型可以储存枚举常量。 例如， spectrum的枚举符范围是<br>0～5， 所以编译器可以用unsigned char来表示color变量。 </p><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><h1 id="第二章：高级数据结构"><a href="#第二章：高级数据结构" class="headerlink" title="第二章：高级数据结构"></a>第二章：高级数据结构</h1><h2 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h2><p>计算机用户已经开发出的一些数据形式比我们提到过的数组和简单结构更有效地解决特定的问题。 这些形式包括队列、 二叉树、 堆、 哈希表和图表。 许多这样的形式都由链式结构（linked structure） 组成。 通<br>常， 每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。 这些指针把一个结构和另一个结构链接起来， 并提供一种路径能遍历整个彼此链接的结构。 </p><p>图14.3演示了一个二叉树结构， 每个单独的结构（或节点） 都和它下面的两个结构（或节点） 相连。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-27_12-56-40.png" alt="Snipaste_2019-02-27_12-56-40"></p><p>图14.3中显示的分级或树状的结构是否比数组高效？ 考虑一个有10级节点的树的情况。 它有210-1（或1023） 个节点， 可以储存1023个单词。 如果<br>这些单词以某种规则排列， 那么可以从最顶层开始， 逐级向下移动查找单词， 最多只需移动9次便可找到任意单词。 如果把这些单词都放在一个数组中， 最多要查找1023个元素才能找出所需的单词 。</p><h2 id="联合简介"><a href="#联合简介" class="headerlink" title="联合简介"></a>联合简介</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="typedef简介"><a href="#typedef简介" class="headerlink" title="typedef简介"></a>typedef简介</h2><h2 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h2><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章：数据结构基数&quot;&gt;&lt;a href=&quot;#第一章：数据结构基数&quot; class=&quot;headerlink&quot; title=&quot;第一章：数据结构基数&quot;&gt;&lt;/a&gt;第一章：数据结构基数&lt;/h1&gt;&lt;h2 id=&quot;第一节：数据与c&quot;&gt;&lt;a href=&quot;#第一节：数据与c&quot; class=&quot;headerlink&quot; title=&quot;第一节：数据与c&quot;&gt;&lt;/a&gt;第一节：数据与c&lt;/h2&gt;&lt;h2 id=&quot;第二节：数组和指针&quot;&gt;&lt;a href=&quot;#第二节：数组和指针&quot; class=&quot;headerlink&quot; title=&quot;第二节：数组和指针&quot;&gt;&lt;/a&gt;第二节：数组和指针&lt;/h2&gt;&lt;h2 id=&quot;第三节：结构体&quot;&gt;&lt;a href=&quot;#第三节：结构体&quot; class=&quot;headerlink&quot; title=&quot;第三节：结构体&quot;&gt;&lt;/a&gt;第三节：结构体&lt;/h2&gt;&lt;h2 id=&quot;第四节：其他结构&quot;&gt;&lt;a href=&quot;#第四节：其他结构&quot; class=&quot;headerlink&quot; title=&quot;第四节：其他结构&quot;&gt;&lt;/a&gt;第四节：其他结构&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C指针：基本概念、核心技术及最佳实践</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/C%E6%8C%87%E9%92%88%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/C指针：基本概念、核心技术及最佳实践.html</id>
    <published>2019-02-21T10:18:47.000Z</published>
    <updated>2019-02-23T08:24:51.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识</p><a id="more"></a><h2 id="1-内存与类型"><a href="#1-内存与类型" class="headerlink" title="1.内存与类型"></a>1.内存与类型</h2><ul><li>内存是一组以二进制方式存储信息的单元，存储容量取决于底层硬件或体系结构以及位长（1、2、4、8、16、32、64或128位）。</li><li>内存用于存储指令和数据序列。内存分为永久和临时存储两种类型，临时/非永久存储（如RAM、cache、寄存器等）。</li></ul><h3 id="1-2类型"><a href="#1-2类型" class="headerlink" title="1.2类型"></a>1.2类型</h3><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-31-53.png" alt="Snipaste_2019-02-21_18-31-53"></p><p>​                        图1.1 内存层次</p><h3 id="1-3内存排列"><a href="#1-3内存排列" class="headerlink" title="1.3内存排列"></a>1.3内存排列</h3><p>内存在空间呈线性序列排列，其中每个位置对应一个存储数据位置的地址。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-37-40.png" alt="Snipaste_2019-02-21_18-37-40"></p><p>内存地址是用于访问基本信息单元的数字。信息就是数据。图中显示了内存转储，在内存中数据存储在连续单元中。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-41-45.png" alt="Snipaste_2019-02-21_18-41-45"></p><h3 id="1-2数据与指令"><a href="#1-2数据与指令" class="headerlink" title="1.2数据与指令"></a>1.2数据与指令</h3><p>数据和指令是所有程序的固有部分。指令或程序逻辑操作与程序相关的数据（见图）。运行程序时，加载器首先加载程序到内存中，被加载程序称为进程（运行程序的实例）并由操作系统加载。<img src="D:\MyBlog\图片\Snipaste_2019-02-21_18-46-23.png" alt="Snipaste_2019-02-21_18-46-23"></p><p>；3</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;指针的概念是如此让人难以把握。如果你能在脑海中将其“可视化”，将会有助于你直观理解指针的概念。“可视化”是指能在心里表现其存储、生命周期、值等。在深入介绍指针细节前，读者需要先了解内存概念、程序实时内存管理、虚拟内存、执行模型与部分汇编语言知识&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C primer Plus</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/%E7%AC%AC%E4%B8%80%E8%8A%82.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/第一节.html</id>
    <published>2019-02-20T12:38:47.000Z</published>
    <updated>2019-02-28T03:31:49.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：基数知识"><a href="#第一章：基数知识" class="headerlink" title="第一章：基数知识"></a>第一章：基数知识</h1><h2 id="第一节：数据和C"><a href="#第一节：数据和C" class="headerlink" title="第一节：数据和C"></a>第一节：数据和C</h2><h3 id="strlen和sizeof"><a href="#strlen和sizeof" class="headerlink" title="strlen和sizeof"></a>strlen和sizeof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>]=<span class="string">"wu"</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strlen= %d,sizeof=%d;"</span> , <span class="built_in">strlen</span>(name) , <span class="keyword">sizeof</span>(name));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">返回值为：<span class="built_in">strlen</span>= <span class="number">2</span>,<span class="keyword">sizeof</span>=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">注：<span class="keyword">sizeof</span> 运算符， 它以字节为单位给出对象的大小。 <span class="built_in">strlen</span>()函数给出字符串中的字符长度。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="常量和c预处理器"><a href="#常量和c预处理器" class="headerlink" title="常量和c预处理器"></a>常量和c预处理器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> taxrate;</span><br><span class="line">taxrate = <span class="number">0.015</span>;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span>常量名比数字表达的信息更多，便于阅读</span><br><span class="line"><span class="number">2.</span>多处使用一个常量， 有时需要改变它的值。 则只需更改符号常量的定义，便于修改。</span><br></pre></td></tr></table></figure><p>taxrate是一个变量， 程序可能会无意间改变它的值。 C语言还提供了一个更好的方案——C预处理器。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAXRATE 0.015</span></span><br><span class="line"></span><br><span class="line">注：编译程序时， 程序中所有的TAXRATE都会被直接替换成 <span class="number">0.015</span>。</span><br></pre></td></tr></table></figure><p>const限定符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MONTHS = <span class="number">12</span>; <span class="comment">// MONTHS在程序中不可更改， 值为12</span></span><br><span class="line"></span><br><span class="line">注：<span class="keyword">const</span>关键字，用于限定一个变量为只读 。它限定一个变量不允许被改变，产生静态作用。</span><br></pre></td></tr></table></figure><h3 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h3><p>C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相<br>关的详细信息。    </p><p>例如： limits.h头文件包含以下类似的代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN -32768</span></span><br><span class="line"><span class="comment">//这些明示常量代表int类型可表示的最大值和最小值。</span></span><br></pre></td></tr></table></figure><h3 id="printf-和scanf"><a href="#printf-和scanf" class="headerlink" title="printf()和scanf()"></a>printf()和scanf()</h3><p>请求printf()函数打印数据的指令要与待打印数据的类型相匹配。 例如，打印整数时使用%d， 打印字符时使用%c。 这些符号被称为转换说明 </p><p>​                        表4.3 转换说明及其打印的输出结果 <img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-26-20.png" alt="Snipaste_2019-02-20_21-26-20"></p><p>scanf()函数所用的转换说明与printf()函数几乎相同。 主要的区别是， 对于float类型和double类型， printf()都使用%f、 %e、 %E、 %g和%G转换说明。 而scanf()只把它们用于float类型， 对于double类型时要使用l修饰符。<br>​                    表4.6 ANSI C中scanf()的转换说明 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-20_21-42-14.png" alt="Snipaste_2019-02-20_21-42-14"></p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式（expression） 由运算符和运算对象组成（前面介绍过， 运算对象是运算符操作的对象） 。 最简单的表达式是一个单独的运算对象， 以此为基础可以建立复杂的表达式。 </p><p>运算对象可以是常量、 变量或二者的组合。 一些表达式由子表达式（subexpression） 组成（子表达式即较小的表达式） 。  </p><p>C 表达式的一个最重要的特性是， 每个表达式都有一个值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">-6</span> </span><br><span class="line"><span class="number">4</span>+<span class="number">21</span></span><br><span class="line">a*(b + c/d)/<span class="number">20</span></span><br><span class="line">q = <span class="number">5</span>*<span class="number">2</span></span><br><span class="line">x = ++q % <span class="number">3</span></span><br><span class="line">q &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>注意：int port /<em> 不是表达式， 没有值 </em>/ </p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句（statement） 是C程序的基本构建块。 一条语句相当于一条完整的计算机指令。 在C中， 大部分语句都以分号结尾。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">legs = <span class="number">4999999999999999999</span>KK</span><br><span class="line">只是一个表达式（它可能是一个较大表达式的一部分）  而下面的代码则是一条语句：</span><br><span class="line">legs = <span class="number">4</span>;</span><br><span class="line">最简单的语句是空语句：</span><br><span class="line">; <span class="comment">//空语句</span></span><br><span class="line">C把末尾加上一个分号的表达式都看作是一条语句（即， 表达式语</span><br><span class="line">句） 。 因此， 像下面这样写也没问题：</span><br><span class="line"><span class="number">3</span> + <span class="number">4</span>；</span><br><span class="line">x = <span class="number">25</span>;</span><br><span class="line">++x;</span><br><span class="line">y = <span class="built_in">sqrt</span>(x);</span><br></pre></td></tr></table></figure><h2 id="第二节：指针和数组"><a href="#第二节：指针和数组" class="headerlink" title="第二节：指针和数组"></a>第二节：指针和数组</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p><h4 id="变量的地址"><a href="#变量的地址" class="headerlink" title="变量的地址"></a>变量的地址</h4><p>int x;  //声明变量，申请整形4bit 的空间</p><p>x=40;  //将40存入整型变量 x 中              </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-03-28.png" alt="Snipaste_2019-02-22_01-03-28">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p><p>上图表示如何用整型变量 x 存储值 40。</p><p>变量 x 什么也不是，仅仅是某些内存地址的存储位置（x对应于地址）。在上述情况下，将值 40存储在 0x00394768 位置（40 存储于x对应地址的空间内），这个位置被变量 x 引用。这也意味着，程序中能使用某些变量引用某些地址。</p><p>内存地址也是数字或值。如果我们要在其他变量中存储这个数字（地址），那将是什么？</p><p>如果我们希望访问或以某个变量存储某个内存地址（如 0x00394768），就必须利用指针这种特殊变量及“取址”操作符。</p><h4 id="取址操作符"><a href="#取址操作符" class="headerlink" title="取址操作符"></a>取址操作符</h4><p>“取址”操作符（&amp;）返回操作数的内存地址。取址操作符是一元操作符，适应于变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr1.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Insert data\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;var_int);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例中，scanf 函数需要知道输入值应该存储的地址。函数 scanf 使用“取址”操作符（&amp;）得到存储用户输入值变量 var_int 的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">源代码 . Ptr2.c</span><br><span class="line">Source code. Ptr2.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var_int = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Address of variable \"var_int\": %p\n"</span>, &amp;var_int);</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Address of variable <span class="string">"var_int"</span>: <span class="number">00394768</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">源代码 Ptr3.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of node = %p\n"</span>,&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable a = %p\n"</span>, &amp;(p.a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address of member variable b = %p\n"</span>, &amp;(p.b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Output:</span><br><span class="line">Address of node = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable a = <span class="number">003</span>AFB00</span><br><span class="line">Address of member variable b = <span class="number">003</span>AFB04</span><br></pre></td></tr></table></figure><h4 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h4><p>现在你知道如何通过“取址”操作符获取地址。接下来让我们使用一个变量来存储这个地址。这个特定变量能存储和操作变量地址，称为指针变量。</p><p>指针（pointer） 是一个值为内存地址的变量（或数据对象） 。 正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址。 </p><p>以下是声明指针变的一般形式 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 * 变量名 ;</span><br><span class="line"><span class="keyword">int</span>* intptr；</span><br><span class="line"><span class="keyword">char</span>* charptr；</span><br></pre></td></tr></table></figure><p>指针变量声明涉及一个名为解引用操作符 (*) ，用于帮助编译器识别他是一个指针变量。</p><h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>指针变量声明时没有指向。程序员必须在解引用它前让其指向有效的内存地址。</p><p>使用两种方式实现指针变量指向特定内存地址。</p><ol><li><p>利用指针地址（&amp;）分配变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = &amp;x; <span class="comment">// 使用取址操作符获取变量 x 的地址</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_01-48-04.png" alt="Snipaste_2019-02-22_01-48-04"></p><p>2.让指针变量指向来自堆的动态分配内存 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line">ptr = ( <span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * count );</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\1550771326720.png" alt="1550771326720"></p></li></ol><p>数组由数据类型相同的一系列元素组成。使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和②这些元素的类型。 编译器根据这些信息正确地创建数组。 普通变量可以使用的类型， 数组元素都可以用。 </p><h4 id="指针的八种操作"><a href="#指针的八种操作" class="headerlink" title="指针的八种操作"></a>指针的八种操作</h4><p>可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作</p><p>程序清单10.13演示了指针变量的 8种基本操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.13</span> ptr_ops.c程序</span><br><span class="line"><span class="comment">// ptr_ops.c -- 指针操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　urn[<span class="number">5</span>]　=　&#123;　<span class="number">100</span>,　<span class="number">200</span>,　<span class="number">300</span>,　<span class="number">400</span>,　<span class="number">500</span>　&#125;;</span><br><span class="line"><span class="keyword">int</span> * ptr1, *ptr2, *ptr3;</span><br><span class="line">ptr1 = urn;　　　　　　　<span class="comment">// 把一个地址赋给指针 </span></span><br><span class="line">ptr2 = &amp;urn[<span class="number">2</span>];　　　　 <span class="comment">// 把一个地址赋给指针</span></span><br><span class="line"><span class="comment">// 解引用指针，以及获得指针的地址 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pointer　value,　dereferenced　pointer,　pointer　address:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line"><span class="comment">// 指针加法</span></span><br><span class="line">    ptr3　=　ptr1　+　<span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nadding　an　int　to　a　pointer:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 + 4 = %p, *(ptr1 + 4) = %d\n"</span>, ptr1 + <span class="number">4</span>, *(ptr1 + <span class="number">4</span>));</span><br><span class="line">ptr1++;　　　　　　　　　<span class="comment">// 递增指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nvalues　after　ptr1++:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class="line">ptr2--;　　　　　　　　　<span class="comment">// 递减指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nvalues　after　--ptr2:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\n"</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class="line">--ptr1;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line">++ptr2;　　　　　　　　　<span class="comment">// 恢复为初始值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nPointers　reset　to　original　values:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr1　=　%p,　ptr2　=　%p\n"</span>,　ptr1,　ptr2);</span><br><span class="line"><span class="comment">// 一个指针减去另一个指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nsubtracting　one　pointer　from　another:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\n"</span>,　</span><br><span class="line">ptr2,　ptr1,　ptr2　-　ptr1);</span><br><span class="line"><span class="comment">// 一个指针减去一个整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nsubtracting　an　int　from　a　pointer:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr3　=　%p,　ptr3　-　2　=　%p\n"</span>,　ptr3,　ptr3　-　<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">pointer value, dereferenced pointer, pointer address:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, *ptr1 =<span class="number">100</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">adding an <span class="keyword">int</span> to a pointer:</span><br><span class="line">ptr1 + <span class="number">4</span> = <span class="number">0x7fff5fbff8e0</span>, *(ptr1 + <span class="number">4</span>) = <span class="number">500</span></span><br><span class="line">values after ptr1++:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d4</span>, *ptr1 =<span class="number">200</span>, &amp;ptr1 = <span class="number">0x7fff5fbff8c8</span></span><br><span class="line">values after --ptr2:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d4</span>, *ptr2 = <span class="number">200</span>, &amp;ptr2 = <span class="number">0x7fff5fbff8c0</span></span><br><span class="line">Pointers reset to original values:</span><br><span class="line">ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 = <span class="number">0x7fff5fbff8d8</span></span><br><span class="line">subtracting one pointer from another:</span><br><span class="line">ptr2 = <span class="number">0x7fff5fbff8d8</span>, ptr1 = <span class="number">0x7fff5fbff8d0</span>, ptr2 - ptr1 = <span class="number">2</span></span><br><span class="line">subtracting an <span class="keyword">int</span> from a pointer:</span><br><span class="line">ptr3 = <span class="number">0x7fff5fbff8e0</span>, ptr3 - <span class="number">2</span> = <span class="number">0x7fff5fbff8d8</span></span><br></pre></td></tr></table></figure><ol><li>解引用：<em>运算符给出指针指向地址上储存的值。因此，</em>ptr1的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。</li><li>取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地址。因此&amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。</li><li>指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 +4与&amp;urn[4]等价。如果相加结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li><li>递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_14-14-32.png" alt="Snipaste_2019-02-22_14-14-32"></p><ol><li>指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2&amp;urn[2]等价，因为ptr3指向的是&amp;arn[4]。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</li><li>递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。</li><li>指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出<br>一个值，或者导致运行时错误。</li><li>比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li></ol><h4 id="使用指针在函数间通信"><a href="#使用指针在函数间通信" class="headerlink" title="使用指针在函数间通信"></a>使用指针在函数间通信</h4><p><strong>函数原型中的形参的两种形式</strong></p><p>直接把变量相关的两类信息（类型及值）传递给函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function1(x);</span><br><span class="line"></span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure><p>把变量的地址传递给函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function2(&amp;x);</span><br><span class="line">例：<span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> * ptr)</span></span></span><br></pre></td></tr></table></figure><p><strong>一个把x,y值交换的例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap3.c -- 使用指针解决交换函数的问题 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Originally x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">interchange(&amp;x, &amp;y); <span class="comment">// 把地址发送给函数</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">temp = *u; <span class="comment">// temp获得 u 所指向对象的值</span></span><br><span class="line">*u = *v;</span><br><span class="line">*v = temp;</span><br><span class="line">    </span><br><span class="line">    输出：Originally x = <span class="number">5</span> <span class="keyword">and</span> y = <span class="number">10.</span></span><br><span class="line"> Now x = <span class="number">10</span> <span class="keyword">and</span> y = <span class="number">5.</span></span><br></pre></td></tr></table></figure><p>分析函数：interchange(&amp;x, &amp;y);</p><p>该函数的声明void interchange (int <em> u, int </em> v)，其u和v是指向整数的指针。因此该函数传递的不是x和y的值，而是它们的地址。</p><p>接下来，在函数体中声明了一个交换值时必需的临时变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br></pre></td></tr></table></figure><p>通过下面的语句把x的值储存在temp中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp = *u;</span><br><span class="line"><span class="comment">//u的值是&amp;x，所以u指向x。即temp = *u=*(&amp;x)这意味着用*u即可表示x的值，</span></span><br><span class="line"><span class="comment">//&amp;运算符访问地址，u=&amp;x即获得下的地址</span></span><br><span class="line"><span class="comment">//*运算符获得地址上的值，*u=*（&amp;x）即获得（&amp;x）地址上的值，即x值。</span></span><br><span class="line"><span class="comment">//所以temp=x；</span></span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line">temp = u; <span class="comment">/* 不要这样做 */</span></span><br></pre></td></tr></table></figure><h4 id="变量：名称、地址和值关系"><a href="#变量：名称、地址和值关系" class="headerlink" title="变量：名称、地址和值关系"></a>变量：名称、地址和值关系</h4><p>变量的名称、地址和变量的值之间关系密切。</p><ul><li>编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。</li><li>在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。</li><li>简而言之，普通变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。</li></ul><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  x=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span>* p;</span><br><span class="line">        p=&amp;x;</span><br><span class="line">                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x的地址p=&amp;x=%p\n"</span>, p);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p地址的值*p=*(&amp;x)=%d"</span>, *p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">x的地址p=&amp;x=<span class="number">0xbf89c298</span></span><br><span class="line">p地址的值*p=*(&amp;x)=<span class="number">100</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">&amp;符号为取址符，可以获得变量的地址</span></span><br><span class="line"><span class="comment">    *指针操作符：能存储和操作变量地址，称为指针变量。同时能够用来读取地址内的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组由数据类型相同的一系列元素组成。 要使用数组时， 通过声明数组告诉编译器数组中内含①多少元素和这些元素的②类型。 编译器根据这些信息正确地创建数组。  </p><p>声明数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一些数组声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; fl</span><br><span class="line">oat candy[<span class="number">365</span>]; <span class="comment">/* 内含365个float类型元素的数组 */</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">12</span>]; <span class="comment">/*内含12个char类型元素的数组*/</span></span><br><span class="line"><span class="keyword">int</span> states[<span class="number">50</span>]; <span class="comment">/*内含50个int类型元素的数组 */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p>数组通常被用来储存程序需要的同一类数据。 例如， 一个内含12个整数元素的数组可以储存12个月的天数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>,<span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br></pre></td></tr></table></figure><p>程序清单10.1演示了一个小程序， 打印每个月的天数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">10.1</span> day_mon1.c程序</span><br><span class="line"><span class="comment">/* day_mon1.c -- 打印每个月的天数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; MONTHS; index++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Month %2d has %2d days.\n"</span>, index + <span class="number">1</span>, days[index]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Month <span class="number">1</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">2</span> has <span class="number">28</span> days.</span><br><span class="line">Month <span class="number">3</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">4</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">5</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">6</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">7</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">8</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">9</span> has <span class="number">30</span> days.</span><br></pre></td></tr></table></figure><h4 id="使用const声明数组"><a href="#使用const声明数组" class="headerlink" title="使用const声明数组"></a>使用const声明数组</h4><p>有时需要把数组设置为只读。 这样， 程序只能从数组中检索值， 不能把新值写入数组。 要创建只读数组， 应该用const声明和初始化数组。  </p><p>因此，程序清单10.1中初始化数组应改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h4><p>指定初始化器（designated initializer） 。 利用该特性可以初始化指定的数组元素。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212</span><br></pre></td></tr></table></figure><h4 id="给数组元素赋值"><a href="#给数组元素赋值" class="headerlink" title="给数组元素赋值"></a>给数组元素赋值</h4><p>声明数组后， 可以借助数组下标（或索引） 给数组元素赋值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给数组的元素赋值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 50</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> counter, evens[SIZE];</span><br><span class="line"><span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; SIZE; counter++)</span><br><span class="line">evens[counter] = <span class="number">2</span> * counter;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码中使用循环给数组的元素依次赋值。</span></span><br></pre></td></tr></table></figure><p><strong>一些错误的数组赋值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">oxen[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 初始化没问题 */</span></span><br><span class="line"><span class="keyword">int</span> yaks[SIZE];</span><br><span class="line">yaks = oxen; <span class="comment">/* 不允许 */</span></span><br><span class="line">yaks[SIZE] = oxen[SIZE]; <span class="comment">/* 数组下标越界 ,下表为0~(SIZE-1)*/</span></span><br><span class="line"> yaks[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;; <span class="comment">/* 不起作用 */</span></span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>例如要分析5年内每个月的降水量数据，要如何表示数据。  </p><ul><li><p>一个方案是创建60个变量， 每个变量储存一个数据项（我们曾经提到过这一笨拙的方案， 和以前一样， 这个方案并不合适） 。</p></li><li><p>二个方案是把各年的数据分开储存会更好， 即创建5个数组， 每个数组12个元素。  </p><p><strong>第二方案该如何实现</strong>？</p><p>处理这种情况应该使用数组的数组。 主数组（master array） 有5个元素（每个元素表示一年） ， 每个元素是内含12个元素的数组（每个元素表示一个月） 。 下面是该数组的声明： </p></li></ul><h4 id="声明二维数组"><a href="#声明二维数组" class="headerlink" title="声明二维数组"></a>声明二维数组</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> rain[<span class="number">5</span>][<span class="number">12</span>]; <span class="comment">// 内含5个数组元素的数组， 每个数组元素内含12个float类型的元素</span></span><br></pre></td></tr></table></figure><p>  <img src="D:\MyBlog\图片\Snipaste_2019-02-21_21-55-01.png" alt="Snipaste_2019-02-21_21-55-01"></p><h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p><strong>初始化的两种方式</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_22-03-42.png" alt="Snipaste_2019-02-21_22-03-42"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12 <span class="comment">// 一年的月份数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YEARS 5 <span class="comment">// 年数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//</span></span><br><span class="line">用<span class="number">2010</span>～<span class="number">2014</span>年的降水量数据初始化数组</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> rain[YEARS][MONTHS] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">4.3</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">2.4</span>, <span class="number">3.5</span>, <span class="number">6.6</span> &#125;,</span><br><span class="line">&#123; <span class="number">8.5</span>, <span class="number">8.2</span>, <span class="number">1.2</span>, <span class="number">1.6</span>, <span class="number">2.4</span>, <span class="number">0.0</span>, <span class="number">5.2</span>, <span class="number">0.9</span>, <span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">1.4</span>, <span class="number">7.3</span> &#125;,</span><br><span class="line">&#123; <span class="number">9.1</span>, <span class="number">8.5</span>, <span class="number">6.7</span>, <span class="number">4.3</span>, <span class="number">2.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">6.1</span>, <span class="number">8.4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.2</span>, <span class="number">9.9</span>, <span class="number">8.4</span>, <span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">0.8</span>, <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.6</span>, <span class="number">1.7</span>, <span class="number">4.3</span>, <span class="number">6.2</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7.6</span>, <span class="number">5.6</span>, <span class="number">3.8</span>, <span class="number">2.8</span>, <span class="number">3.8</span>, <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.3</span>, <span class="number">2.6</span>, <span class="number">5.2</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。</p><p>例子：数组名是数组首元素的地址。如果flizny是一个数组，下面的语句成立：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flizny == &amp;flizny[<span class="number">0</span>]; <span class="comment">// 数组名是该数组首元素的地址</span></span><br><span class="line"><span class="comment">//flizny 和&amp;flizny[0]都表示数组首元素的内存地址（&amp;是地址运算符）。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　4</span></span><br><span class="line"><span class="keyword">short</span>　dates[SIZE];</span><br><span class="line"><span class="keyword">short</span> * pti;</span><br><span class="line"><span class="keyword">short</span>　index;</span><br><span class="line">pti = dates;　<span class="comment">// 把数组地址赋给指针</span></span><br></pre></td></tr></table></figure><p><img src="D:\MyBlog\图片\Snipaste_2019-02-22_13-26-02.png" alt="Snipaste_2019-02-22_13-26-02"></p><h3 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h3><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = sum(marbles); <span class="comment">// 可能的函数调用</span></span><br></pre></td></tr></table></figure><p>该函数的原型是什么？由于数组名marbless是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式<br>参数，即该形参是一个指向int的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span></span>; <span class="comment">// 对应的函数原型</span></span><br></pre></td></tr></table></figure><p>sum()从该参数获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。<br>我们有两种方法让函数获得元素个数这一信息。第一种方法是，在函数代码中写上固定的数组小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span> <span class="comment">// 相应的函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)　　<span class="comment">// 假设数组有10个元素</span></span><br><span class="line">total += ar[i];　　　　<span class="comment">// ar[i] 与 *(ar + i) 相同</span></span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个比较灵活的方法是把数组大小作为第2个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar, <span class="keyword">int</span> n)</span>　　　 <span class="comment">// 更通用的方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)　　 <span class="comment">// 使用 n 个元素</span></span><br><span class="line">total += ar[i];　　　　<span class="comment">// ar[i] 和 *(ar + i) 相同</span></span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数要处理数组必须知道何时开始、何时结束。上面的sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）</p><p>还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　SIZE　10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　marbles[SIZE]　=　&#123;　<span class="number">20</span>,　<span class="number">10</span>,　<span class="number">5</span>,　<span class="number">39</span>,　<span class="number">4</span>,　<span class="number">16</span>,　<span class="number">19</span>,　<span class="number">26</span>,　</span><br><span class="line"><span class="number">31</span>,　<span class="number">20</span>　&#125;;</span><br><span class="line"><span class="keyword">long</span>　answer;</span><br><span class="line">answer　=　sump(marbles,　marbles　+　SIZE);<span class="comment">//marble为数组的首位，而marble+SIZE则为数组结束位置</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The　total　number　of　marbles　is　%ld.\n"</span>,　answer);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用指针算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>　(start　&lt;　end)</span><br><span class="line">&#123;</span><br><span class="line">total += *start;　 <span class="comment">// 把数组元素的值加起来</span></span><br><span class="line">start++;　　　　　　<span class="comment">// 让指针指向下一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。</p><h3 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a>保护数组中的数据</h3><p>编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。(直接传递数值时使用的是原始数据的副本，不会意外修改原始数据。但是传递数值的指针的话使用原始数据，因此这样的函数可能修改原数组。)</p><p>如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p><p>处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的，但是要注意保护数组中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>　<span class="title">add_to</span><span class="params">(<span class="keyword">double</span>　ar[],　<span class="keyword">int</span>　n,　<span class="keyword">double</span>　val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">for</span>　(i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">ar[i]　+=　val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因此，调用该函数后，prices数组中的每个元素的值都增加了2.5：</span></span><br><span class="line">add_to(prices, <span class="number">100</span>, <span class="number">2.50</span>);</span><br><span class="line"><span class="comment">//该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。</span></span><br></pre></td></tr></table></figure><h4 id="对形式参数使用const"><a href="#对形式参数使用const" class="headerlink" title="对形式参数使用const"></a>对形式参数使用const</h4><p>为了避免修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span> <span class="comment">/* 函数定义 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>　i;</span><br><span class="line"><span class="keyword">int</span>　total　=　<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(　i　=　<span class="number">0</span>;　i　&lt;　n;　i++)</span><br><span class="line">total　+=　ar[i];</span><br><span class="line"><span class="keyword">return</span>　total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const的其他内容"><a href="#const的其他内容" class="headerlink" title="const的其他内容"></a>const的其他内容</h4><p>使用const创建过变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><p>虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加<br>灵活。可以创建const数组、const指针和指向const的指针。</p><p>如何使用const关键字保护数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.const数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MONTHS　12</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">days[<span class="number">9</span>] = <span class="number">44</span>;　　 <span class="comment">/* 编译错误 ,程序无法改变数组元素的值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//coon身体指针</span></span><br><span class="line"><span class="keyword">double</span>　rates[<span class="number">5</span>]　=　&#123;<span class="number">88.99</span>,　<span class="number">100.12</span>,　<span class="number">59.45</span>,　<span class="number">183.11</span>,　<span class="number">340.5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pd = rates;　　 <span class="comment">// pd指向数组的首元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：</span></span><br><span class="line">*pd = <span class="number">29.89</span>;　　　<span class="comment">// 不允许</span></span><br><span class="line">pd[<span class="number">2</span>] = <span class="number">222.22</span>;　　<span class="comment">//不允许</span></span><br><span class="line">rates[<span class="number">0</span>] = <span class="number">99.99</span>; <span class="comment">// 允许，因为rates未被const限定</span></span><br></pre></td></tr></table></figure><h2 id="第三节：结构体和其他数据形式"><a href="#第三节：结构体和其他数据形式" class="headerlink" title="第三节：结构体和其他数据形式"></a>第三节：结构体和其他数据形式</h2><p>本章介绍以下内容：</p><p>关键字：</p><p> struct、 union、 typedef</p><p>运算符： .、 -&gt;</p><p>什么是C结构， 如何创建结构模板和结构变量</p><p>如何访问结构的成员， 如何编写处理结构的函数</p><p>联合和指向函数的指针 </p><p>设计程序时， 最重要的步骤之一是选择表示数据的方法。 在许多情况下， 简单变量甚至是数组还不够。 为此， C提供了结构变量（structure variable） 提高你表示数据的能力， 它能让你创造新的形式。  </p><h3 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h3><h4 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h4><p>定义：结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。</p><p>结构声明（structure declaration） 描述了一个结构的组织布局。 声明类似下面这样：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> book &#123;</span><br><span class="line"><span class="built_in">char</span> title[MAXTITL];</span><br><span class="line"><span class="built_in">char</span> author[MAXAUTL];</span><br><span class="line"><span class="built_in">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>该声明描述了一个由两个字符数组和一个float类型变量组成的结构。 该声明并未创建实际的数据对象， 只描述了该对象由什么组成。 〔 有时， 我们把结构声明称为模板， 因为它勾勒出结构是如何储存数据的。 〕</em>  </p><h4 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h4><p>结构体有两层含义。 一层含义是“结构布局”，  结构布局告诉编译器如何表示数据， 但是它并未让编译器为数据分配空间。 下一步是创建一个结构变量， 即是结构的另一层含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span> <span class="comment">//声明结构体变脸。</span></span><br><span class="line"><span class="comment">//这把library声明为一个使用book结构布局的结构体变量。 </span></span><br><span class="line"><span class="comment">//注：关键字 struct， 它表明跟在其后的是一个结构， 后面是一个可选的标记（该例中是 book）</span></span><br></pre></td></tr></table></figure><p> <em>编译器执行这行代码便创建了一个结构变量library。 编译器使用book模板为该变量分配空间： 一个内含MAXTITL个元素的char数组、 一个内含MAXAUTL个元素的char数组和一个float类型的变量。</em> 这些存储空间都与一个名称library结合在一起（见图14.1） </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_15-26-55.png" alt="Snipaste_2019-02-26_15-26-55"></p><p>在结构变量的声明中， struct book所起的作用相当于一般声明中的int或float。 例如， 可以定义两个struct book类型的变量， 或者甚至是指向structbook类型结构的指针： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">doyle</span>, <span class="title">panshin</span>, * <span class="title">ptbook</span>;</span></span><br></pre></td></tr></table></figure><p>结构变量doyle和panshin中都包含title、 author和value部分。 指针ptbook 可以指向doyle、 panshin或任何其他book类型的结构变量。 从本质上看，book结构声明创建了一个名为struct book的新类型。 </p><h4 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h4><p>初始化一个结构变量与初始化数组的语法类似： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line"><span class="string">"The Pious Pirate and the Devious Damsel"</span>,</span><br><span class="line"><span class="string">"Renee Vivotte"</span>,</span><br><span class="line"><span class="number">1.95</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结构体的初始化器"><a href="#结构体的初始化器" class="headerlink" title="结构体的初始化器"></a>结构体的初始化器</h4><p>C99和C11为结构提供了指定初始化器（designated initializer） [1]， 其语<br>法与数组的指定初始化器类似。 但是， 结构的指定初始化器使用点运算符和<br>成员名（而不是方括号和下标） 标识特定的元素 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只初始化book结构 的value成员， 可以这样做：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">surprise</span> = &#123;</span> .value = <span class="number">10.99</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可以按照任意顺序使用指定初始化器：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span> = &#123;</span> .value = <span class="number">25.99</span>,</span><br><span class="line"> .author = <span class="string">"James Broadfool"</span>,</span><br><span class="line"> .title = <span class="string">"Rue for the Toad"</span>,</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h4 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h4><p>使用结构成员运算符——点（.） 访问结构中的成员。  </p><p>例如， library.value即访问library的value部分。 可以像使用任何float类型变量那样使用library.value。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s_gets(library.title, MAXTITL);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;library.value);</span><br></pre></td></tr></table></figure><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>上面结构体只能处理一本书，程序如何扩展成可以处理多本书。 </p><p>显然，每本书的基本信息都可以用一个 book 类型的结构变量来表示。 为描述两本书， 需要使用两个变量， 以此类推。 可以使用这一类型的结构数组来处理多本书。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBKS 100 <span class="comment">/* 书籍的最大数量 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> <span class="comment">/* 简历 book 模板 */</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">/* book 类型结构的数组 */</span></span><br></pre></td></tr></table></figure><h4 id="声明结构数组"><a href="#声明结构数组" class="headerlink" title="声明结构数组"></a>声明结构数组</h4><p>声明结构数组和声明其他类型的数组类似。 下面是一个声明结构数组的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct book library[MAXBKS];</span><br></pre></td></tr></table></figure><p>以上代码把library声明为一个内含MAXBKS个元素的数组。 数组的每个元素都是一个book类型的数组。 因此， library[0]是第1个book类型的结构变量， library[1]是第2个book类型的结构变量， 以此类推。  参看图14.2 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_20-50-51.png" alt="Snipaste_2019-02-26_20-50-51"></p><p><em>注：其实存储形式有点像而为数组</em></p><h4 id="标识结构数组的成员"><a href="#标识结构数组的成员" class="headerlink" title="标识结构数组的成员"></a>标识结构数组的成员</h4><p>为了标识结构数组中的成员， 可以采用访问单独结构的规则： 在结构名后面加一个点运算符， 再在点运算符后面写上成员名。 如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">0</span>].value <span class="comment">/* 第1个数组元素与value 相关联 */</span></span><br><span class="line">library[<span class="number">4</span>].title <span class="comment">/* 第5个数组元素与title 相关联 */</span></span><br></pre></td></tr></table></figure><p><em>注：其实和上面的结构体一样，只是多了下标来识别结构体数组中的第几个。</em></p><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>即在一个结构中包含另一个结构（即嵌套结构） 。 </p><p>例如，Shalala Pirosky创建了一个有关她朋友信息的结构。 显然， 结构中需要一个成员表示朋友的姓名。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.3</span> <span class="keyword">friend</span>.c程序</span><br><span class="line"><span class="comment">// friend.c -- 嵌套结构示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * msgs[<span class="number">5</span>] =</span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">"Thank you for the wonderful evening, "</span>,</span><br><span class="line"><span class="string">"You certainly prove that a "</span>,</span><br><span class="line"><span class="string">"is a special kind of guy.We must get together"</span>,</span><br><span class="line"><span class="string">"over a delicious "</span>,</span><br><span class="line"><span class="string">" and have a few laughs"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span> <span class="comment">// 第1个结构</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span> <span class="comment">// 第2个结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span> <span class="comment">// 嵌套结构</span></span><br><span class="line"><span class="keyword">char</span> favfood[LEN];</span><br><span class="line"><span class="keyword">char</span> job[LEN];</span><br><span class="line"><span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span> = &#123;</span> <span class="comment">// 初始化一个结构变量</span></span><br><span class="line">&#123; <span class="string">"Ewen"</span>, <span class="string">"Villard"</span> &#125;,</span><br><span class="line"><span class="string">"grilled salmon"</span>,</span><br><span class="line"><span class="string">"personality coach"</span>,</span><br><span class="line"><span class="number">68112.00</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Dear %s, \n\n"</span>, fellow.handle.first);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s.\n"</span>, msgs[<span class="number">0</span>], fellow.handle.first);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s\n"</span>, msgs[<span class="number">1</span>], fellow.job);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msgs[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s%s"</span>, msgs[<span class="number">3</span>], fellow.favfood, msgs[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">if</span> (fellow.income &gt; <span class="number">150000.0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"!!"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fellow.income &gt; <span class="number">75000.0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"!"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"See you soon,"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%40s%s\n"</span>, <span class="string">" "</span>, <span class="string">"Shalala"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的输出：</span></span><br><span class="line"><span class="comment">Dear Ewen,</span></span><br><span class="line"><span class="comment">Thank you for the wonderful evening, Ewen.</span></span><br><span class="line"><span class="comment">You certainly prove that a personality coach</span></span><br><span class="line"><span class="comment">is a special kind of guy.We must get together</span></span><br><span class="line"><span class="comment">over a delicious grilled salmon and have a few laughs.</span></span><br><span class="line"><span class="comment">See you soon,</span></span><br><span class="line"><span class="comment">Shalala </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>为什么喜欢使用指向结构的指针。</p><ul><li><p>第一， 就像指向数组的指针比数组本身更容易操控（如， 排序问题） 一样， 指向结构的指针通常比结构本身更容易操控。</p></li><li><p>第二， 在一些早期的C实现中， 结构不能作为参数传递给函数， 但是可以传递指向结构的指针。 </p></li><li><p>第三， 即使能传递一个结构， 传递指针通常更有效率。 </p></li><li><p>第四， 一些用于表示数据的结构中包含指向其他结构的指针。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.4</span> friends.c程序</span><br><span class="line"><span class="comment">/* friends.c -- 使用指向结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">char</span> favfood[LEN];</span><br><span class="line"><span class="keyword">char</span> job[LEN];</span><br><span class="line"><span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2] =</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123; <span class="string">"Ewen"</span>, <span class="string">"Villard"</span> &#125;,</span><br><span class="line"><span class="string">"grilled salmon"</span>,</span><br><span class="line"><span class="string">"personality coach"</span>,</span><br><span class="line"><span class="number">68112.00</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        &#123; <span class="string">"Rodney"</span>, <span class="string">"Swillbelly"</span> &#125;,</span><br><span class="line"><span class="string">"tripe"</span>,</span><br><span class="line"><span class="string">"tabloid editor"</span>,</span><br><span class="line"><span class="number">432400.00</span></span><br><span class="line">&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span> <span class="comment">/* 定义一个指向结构的指针 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address #1: %p #2: %p\n"</span>, &amp;fellow[<span class="number">0</span>], &amp;fellow[<span class="number">1</span>]);</span><br><span class="line">him = &amp;fellow[<span class="number">0</span>]; <span class="comment">/* 告诉编译器该指针指向何处 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"pointer #1: %p #2: %p\n"</span>, him, him + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"him-&gt;income is $%.2f: (*him).income is $%.2f\n"</span>,him-&gt;income,(*him).income);</span><br><span class="line">him++; <span class="comment">/* 指向下一个结构 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"him-&gt;favfood is %s: him-&gt;handle.last is %s\n"</span>,him-&gt;favfood, him-&gt;handle.last);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出如下：</span></span><br><span class="line"><span class="comment">address #1: 0x7fff5fbff820 #2: 0x7fff5fbff874</span></span><br><span class="line"><span class="comment">pointer #1: 0x7fff5fbff820 #2: 0x7fff5fbff874</span></span><br><span class="line"><span class="comment">him-&gt;income is $68112.00: (*him).income is $68112.00</span></span><br><span class="line"><span class="comment">him-&gt;favfood is tripe: him-&gt;handle.last is Swillbelly</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="声明和初始化结构指针"><a href="#声明和初始化结构指针" class="headerlink" title="声明和初始化结构指针"></a>声明和初始化结构指针</h4><p>声明结构指针很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span>  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><p>首先是关键字 struct， 其次是结构标记 guy， 然后是一个星号（*） ， 其后跟着指针名。 这个语法和其他指针声明一样 。</p><p>该声明并未创建一个新的结构， 但是指针him现在可以指向任意现有的guy类型的结构。</p><p> 例如，对于结构体：如果barney是一个guy类型的结构， 可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney; <span class="comment">//初始化jie，</span></span><br></pre></td></tr></table></figure><p>在本例中， 对于结构体数组：fellow 是一个结构数组， 这意味着 fellow[0]是一个结构。 所以， 要让 him 指向fellow[0]， 可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;fellow[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="用指针访问成员"><a href="#用指针访问成员" class="headerlink" title="用指针访问成员"></a>用指针访问成员</h4><p>指针him指向结构变量fellow[0]， 如何通过him获得fellow[0]的成员的值？ </p><p>第1种方法也是最常用的方法： 使用-&gt;运算符。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<em>这里要着重理解him是一个指针， 但是hime-&gt;income是该指针所指向结构的一个成员。 所以在该例中， him-&gt;income是一个float类型的变量。</em> </p><p>第2种方法是， 以这样的顺序指定结构成员的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 总结：如果him是指向guy类型结构barney的指针， 下面的关系恒成立： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即：barney.income == (*him).income == him-&gt;income <span class="comment">// 假设 him == &amp;barney</span></span><br></pre></td></tr></table></figure><h3 id="向函数传递结构的信息"><a href="#向函数传递结构的信息" class="headerlink" title="向函数传递结构的信息"></a>向函数传递结构的信息</h3><p>函数的参数把值传递给函数。 每个值都是一个数字——可能是int类型、float类型， 可能是ASCII字符码， 或者是一个地址。 </p><p>那么C时如何把结构体作为参数使用？</p><p>程序员可以选择是①传递结构本身， 还是②传递指向结构的指针。 如果你只关心结构中的某一部分， 也可以把③结构的成员作为参数。</p><h4 id="传递结构成员"><a href="#传递结构成员" class="headerlink" title="传递结构成员"></a>传递结构成员</h4><p>只知要结构成员是一个具有单个值的数据类型（即， int及其相关类型、char、 float、 double或指针） ， 便可把它作为参数传递给接受该特定类型的函数。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.5</span> funds1.c程序</span><br><span class="line"><span class="comment">/* funds1.c -- 把结构成员作为参数传递 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line"><span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line"><span class="number">4032.27</span>,</span><br><span class="line"><span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line"><span class="number">8543.94</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n</span></span><br><span class="line"><span class="string">sum(stan.bankfund, stan.savefund))</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 两个double类型的数相加 */</span></span><br><span class="line"><span class="string">double sum(double x, double y)</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">    return(x + y);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">运行该程序后输出如下：</span></span><br><span class="line"><span class="string">Stan has a total of $12576.21.</span></span><br></pre></td></tr></table></figure><h4 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h4><p>次把结构的地址作为参数。于函数要处理funds结构， 所以必须声明funds结构。  传递结构本身</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.6</span> funds2.c程序</span><br><span class="line"><span class="comment">/* funds2.c -- 传递指向结构的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>; <span class="comment">/* 参数是一个指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line"><span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line"><span class="number">4032.27</span>,</span><br><span class="line"><span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line"><span class="number">8543.94</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(&amp;stan));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>(money-&gt;bankfund + money-&gt;savefund);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行该程序后输出如下：</span></span><br><span class="line"><span class="comment">Stan has a total of $12576.21</span></span><br></pre></td></tr></table></figure><h4 id="传递结构本身"><a href="#传递结构本身" class="headerlink" title="传递结构本身"></a>传递结构本身</h4><p>对于允许把结构作为参数的编译器， 可以把程序清单14.6重写为程序清单14.7。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.7</span> funds3.c程序</span><br><span class="line"><span class="comment">/* funds3.c -- 传递一个结构 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span>; <span class="comment">/* 参数是一个结构 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line"><span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line"><span class="number">4032.27</span>,</span><br><span class="line"><span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line"><span class="number">8543.94</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(stan));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span>(moolah.bankfund + moolah.savefund);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是运行该程序后的输出：</span></span><br><span class="line"><span class="comment">Stan has a total of $12576.21.</span></span><br></pre></td></tr></table></figure><h4 id="结构和结构指针的选择"><a href="#结构和结构指针的选择" class="headerlink" title="结构和结构指针的选择"></a>结构和结构指针的选择</h4><p>假设要编写一个与结构相关的函数， 是用结构指针作为参数， 还是用结构作为参数和返回值？ 两者各有优缺点。</p><ul><li><p>把指针作为参数有两个优点： 无论是以前还是现在的C实现都能使用这种方法， 而且执行起来很快， 只需要传递一个地址。 缺点是无法保护数据。不过， ANSI C新增的const限定符解决了这个问题。</p></li><li><p>把结构作为参数传递的优点是， 函数处理的是原始数据的副本， 这保护了原始数据。 另外， 代码风格也更清楚。</p></li><li><p>传递结构的两个缺点是： 较老版本的实现可能无法处理这样的代码， 而且传递结构浪费时间和存储空间。 尤其是把大型结构传递给函数， 而它只使用结构中的一两个成员时特别浪费。 这种情况下传递指针或只传递函数所需的成员更合 </p><p>假设定义了下面的结构类型：struct vector {double x; double y;}; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"><span class="function">struct <span class="built_in">vector</span> <span class="title">sum_vect</span><span class="params">(struct <span class="built_in">vector</span>, struct <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">ans = sum_vect(a,b);</span><br><span class="line">对程序员而言， 上面的版本比用指针传递的版本更自然。 指针版本如</span><br><span class="line">下：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_vect</span><span class="params">(<span class="keyword">const</span> struct <span class="built_in">vector</span> *, <span class="keyword">const</span> struct <span class="built_in">vector</span> *, struct <span class="built_in">vector</span> *)</span></span>;</span><br><span class="line">...</span><br><span class="line">sum_vect(&amp;a, &amp;b, &amp;ans);</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体的其他结构特性"><a href="#结构体的其他结构特性" class="headerlink" title="结构体的其他结构特性"></a>结构体的其他结构特性</h3><p>1.许把一个结构赋值给另一个结构， 但是数组不能这样做。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果n_data和o_data都是相同类型的结构， 可以这样做： </span></span><br><span class="line">o_data = n_data; <span class="comment">// 把一个结构赋值给另一个结构</span></span><br><span class="line"><span class="comment">//这条语句把n_data的每个成员的值都赋给o_data的相应成员。 即使成员是数组， 也能完成赋值。</span></span><br></pre></td></tr></table></figure><p>2.还可以构初始化为相同类型的另一个结构 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> = &#123;</span><span class="string">"Ruthie"</span>, <span class="string">"George"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> = <span class="title">right_field</span>;</span> <span class="comment">// 把一个结构初始化为另一个结构</span></span><br></pre></td></tr></table></figure><p>3.函数不仅能把结构本身作为参数传递， 还能把结构作为返回值返回。 把结构作为函数参数可以把结构的信息传送给函数； 把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。 结构指针也允许这种双向通信。</p><h3 id="结构体中的字符数组和字符指针"><a href="#结构体中的字符数组和字符指针" class="headerlink" title="结构体中的字符数组和字符指针"></a>结构体中的字符数组和字符指针</h3><p>到目前为止， 我们在结构中都使用字符数组来储存字符串。 是否可以使用指向 char 的指针来代替字符数组？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.结构体中的字符数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> first[LEN];</span><br><span class="line"><span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.其中的结构声明也可以这样写：结构体中的字符指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * first;</span><br><span class="line"><span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> = &#123;</span><span class="string">"Talia"</span>, <span class="string">"Summers"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> = &#123;</span><span class="string">"Brad"</span>, <span class="string">"Fallingjaw"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s and %s\n"</span>, veep.first, treas.first);</span><br></pre></td></tr></table></figure><ul><li><p>对于struct names类型的结构变量veep， 以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。 </p></li><li><p>对于struct pnames类型的结构变量treas， 以上字符串储存在编译器储存常量的地方。</p></li><li><p>struct pnames结构不用为字符串分配任何存储空间（结构本身只储存了两个地址， 在我们的系统中共占16字节。 ）。 它使用的是储存在别处的字符串（如， 字符串常量或数组中的字符串） 。 简而言之， 在pnames结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。   </p></li></ul><p>（即字符指针 不会自动分配空间，需要在使用前初始化。如果使能赋值的话可能会占用到有效的代码段，如下面所示）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your accountant:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your attorney:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, attorney.last); <span class="comment">/* 这里有一个潜在的危险 */</span></span><br></pre></td></tr></table></figure><ul><li><p>对于会计师（accountant） ， 他的名储存在accountant结构变量的last成员中， 该结构中有一个储存字符串的数组。</p></li><li><p>对于律师（attorney） ， scanf()把字符串放到attorney.last表示的地址上。 由于这是未经初始化的变量， 地址可以是任何值， 因此程序可以把名放在任何地方。 如果走运的话， 程序不会出问题， 至少暂时不会出问题， 否则这一操作会导致程序崩溃。  </p></li></ul><h3 id="结构、-指针和malloc"><a href="#结构、-指针和malloc" class="headerlink" title="结构、 指针和malloc()"></a>结构、 指针和malloc()</h3><p>对于上面的问题，如果使用malloc()分配内存并使用指针储存该地址， 那么在结构中使用指针处理字符串就比较合理。 这种方法的优点是， 可以请求malloc()为字符串分配合适的存储空间。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * fname; <span class="comment">// 用指针代替数组</span></span><br><span class="line"><span class="keyword">char</span> * lname;</span><br><span class="line"><span class="keyword">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinfo</span> <span class="params">(struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har temp[SLEN];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter your first name.\n"</span>);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line"><span class="comment">// 分配内存储存名</span></span><br><span class="line">pst-&gt;fname = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 把名拷贝到已分配的内存</span></span><br><span class="line"><span class="built_in">strcpy</span>(pst-&gt;fname, temp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter your last name.\n"</span>);</span><br><span class="line">s_gets(temp, SLEN);</span><br></pre></td></tr></table></figure><p>要理解这两个字符串都未储存在结构中， 它们储存在 malloc()分配的内<br>存块中。 然而， 结构中储存着这两个字符串的地址， 处理字符串的函数通常<br>都要使用字符串的地址。  </p><p>下面就是一个使用字符指针的结构体对字符串处理的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">程序清单14.10 names3.c程序</span><br><span class="line">// names3.c -- 使用指针和 malloc()</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt; // 提供 strcpy()、 strlen() 的原型</span><br><span class="line">#include &lt;stdlib.h&gt; // 提供 malloc()、 free() 的原型</span><br><span class="line">#define SLEN 81</span><br><span class="line"></span><br><span class="line">struct namect &#123;</span><br><span class="line">char * fname; // 使用指针</span><br><span class="line">char * lname;</span><br><span class="line">int letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void getinfo(struct namect *); // 分配内存</span><br><span class="line">void makeinfo(struct namect *);</span><br><span class="line">void showinfo(const struct namect *);</span><br><span class="line">void cleanup(struct namect *); // 调用该函数时释放内存</span><br><span class="line">char * s_gets(char * st, int n);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123; </span><br><span class="line">    struct namect person;</span><br><span class="line">getinfo(&amp;person);</span><br><span class="line">makeinfo(&amp;person);</span><br><span class="line">showinfo(&amp;person);</span><br><span class="line">cleanup(&amp;person);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getinfo(struct namect * pst)</span><br><span class="line">&#123; </span><br><span class="line">    char temp[SLEN];</span><br><span class="line">printf(&quot;Please enter your first name.\n&quot;);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line"></span><br><span class="line">    // 分配内存以储存名</span><br><span class="line">pst-&gt;fname = (char *) malloc(strlen(temp) + 1);</span><br><span class="line"></span><br><span class="line">    // 把名拷贝到动态分配的内存中</span><br><span class="line">strcpy(pst-&gt;fname, temp);</span><br><span class="line">printf(&quot;Please enter your last name.\n&quot;);</span><br><span class="line">s_gets(temp, SLEN);</span><br><span class="line">pst-&gt;lname = (char *) malloc(strlen(temp) + 1);</span><br><span class="line">strcpy(pst-&gt;lname, temp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void makeinfo(struct namect * pst)</span><br><span class="line">&#123;</span><br><span class="line">    pst-&gt;letters = strlen(pst-&gt;fname) +strlen(pst-&gt;lname);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void showinfo(const struct namect * pst)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s %s, your name contains %d letters.\n&quot;, pst-&gt;fname, pst-&gt;lname, pst-&gt;letters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cleanup(struct namect * pst)</span><br><span class="line">&#123; </span><br><span class="line">    free(pst-&gt;fname);</span><br><span class="line">free(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * s_gets(char * st, int n)</span><br><span class="line">&#123; </span><br><span class="line">    char * ret_val;</span><br><span class="line">char * find;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">        find = strchr(st, &apos;\n&apos;); // 查找换行符</span><br><span class="line">if (find) // 如果地址不是 NULL，</span><br><span class="line">*find = &apos;\0&apos;; // 在此处放置一个空字符</span><br><span class="line">else</span><br><span class="line">while (getchar() != &apos;\n&apos;)</span><br><span class="line">continue; // 处理输入行的剩余部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return ret_val;</span><br><span class="line">&#125; </span><br><span class="line">/*</span><br><span class="line">下面是该程序的输出：</span><br><span class="line">Please enter your first name.</span><br><span class="line">Floresiensis</span><br><span class="line">Please enter your last name.</span><br><span class="line">Mann</span><br><span class="line">Floresiensis Mann, your name contains 16 letters.</span><br></pre></td></tr></table></figure><h3 id="使用结构数组的函数"><a href="#使用结构数组的函数" class="headerlink" title="使用结构数组的函数"></a>使用结构数组的函数</h3><p>假设一个函数要处理一个结构数组。 由于数组名就是该数组的地址， 所以可以把它传递给函数。 </p><p>程序清单14.13把前面的金融程序扩展为两人， 所以需要一个内含两个funds结构的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.13</span> funds4.c程序</span><br><span class="line"><span class="comment">/* funds4.c -- 把结构数组传递给函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> bankfund;</span><br><span class="line"><span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line"><span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money [], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">jones</span>[<span class="title">N</span>] = &#123;</span></span><br><span class="line">&#123; <span class="string">"Garlic-Melon Bank"</span>, <span class="number">4032.27</span>, <span class="string">"Lucky's Savings and Loan"</span>, <span class="number">8543.94</span>&#125;,</span><br><span class="line">&#123; <span class="string">"Honest Jack's Bank"</span>, <span class="number">3620.88</span>, <span class="string">"Party Time Savings"</span>, <span class="number">3802.91</span>&#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The Joneses have a total of $%.2f.\n"</span>,sum(jones, N));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money [], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">double</span> total;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, total = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">total += money[i].bankfund + money[i].savefund;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(total);</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">The Joneses have a total of $<span class="number">20000.00</span>.</span><br></pre></td></tr></table></figure><h3 id="把结构内容保存到文件中"><a href="#把结构内容保存到文件中" class="headerlink" title="把结构内容保存到文件中"></a>把结构内容保存到文件中</h3><p>由于结构可以储存不同类型的信息， 所以它是构建数据库的重要工具。例如， 可以用一个结构储存雇员或汽车零件的相关信息。 最终， 我们要把这些信息储存在文件中， 并且能再次检索。  </p><p>数据库文件可以包含任意数量的此类数据对象。 储存在一个结构中的整套信息被称为记录（record） ， 单独的项被称为字段（field） 。</p><p>例如， 回忆程序book结构： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果pbook标识一个文件流， 那么通过下面这条语句可以把信息储存在struct book类型的结构变量primer中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(pbooks, <span class="string">"%s %s %.2f\n"</span>, primer.title,primer.author, primer.value);</span><br></pre></td></tr></table></figure><p><strong>保存结构的程序示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">14.14</span> booksave.c程序</span><br><span class="line"><span class="comment">/* booksave.c -- 在文件中保存结构中的内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTITL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXAUTL 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBKS 10 <span class="comment">/* 最大书籍数量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> <span class="comment">/* 建立 book 模板 */</span></span><br><span class="line"><span class="keyword">char</span> title[MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">/* 结构数组 */</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index, filecount;</span><br><span class="line">FILE * pbooks;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct book);</span><br><span class="line"><span class="keyword">if</span> ((pbooks = fopen(<span class="string">"book.dat"</span>, <span class="string">"a+b"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line">       <span class="built_in">fputs</span>(<span class="string">"Can't open book.dat file\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">    rewind(pbooks); <span class="comment">/* 定位到文件开始 */</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; MAXBKS &amp;&amp; fread(&amp;library[count], size,<span class="number">1</span>, pbooks) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Current contents of book.dat:"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s by %s: $%.2f\n"</span>, library[count].title,</span><br><span class="line">library[count].author, library[count].value);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">    filecount = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == MAXBKS)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"The book.dat file is full."</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Please add new book titles."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Press [enter] at the start of a line to stop."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count &lt; MAXBKS &amp;&amp; s_gets(library[count].title, MAXTITL) !=<span class="literal">NULL</span>&amp;&amp; library[count].title[<span class="number">0</span>] != <span class="string">'\0'</span>)</span><br><span class="line">&#123; </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Now enter the author."</span>);</span><br><span class="line">s_gets(library[count].author, MAXAUTL);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Now enter the value."</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;library[count++].value);</span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">/* 清理输入行 */</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; MAXBKS)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the next title."</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Here is the list of your books:"</span>);</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; count; index++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s by %s: $%.2f\n"</span>, library[index].title,</span><br><span class="line">library[index].author, library[index].value);</span><br><span class="line">fwrite(&amp;library[filecount], size, count - filecount,pbooks);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"No books? Too bad.\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Bye.\n"</span>);</span><br><span class="line">fclose(pbooks);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">char</span> * find;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">        find = <span class="built_in">strchr</span>(st, <span class="string">'\n'</span>); <span class="comment">// 查找换行符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (find) <span class="comment">// 如果地址不是 NULL，</span></span><br><span class="line">*find = <span class="string">'\0'</span>; <span class="comment">// 在此处放置一个空字符 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 清理输入行</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们先看几个运行示例， 然后再讨论程序中的要点。</span></span><br><span class="line"><span class="comment">$ booksave</span></span><br><span class="line"><span class="comment">Please add new book titles.</span></span><br><span class="line"><span class="comment">Press [enter] at the start of a line to stop.</span></span><br><span class="line"><span class="comment">Metric Merriment</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Polly Poetica</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">18.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">Deadly Farce</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Dudley Forse</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">15.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">[enter]</span></span><br><span class="line"><span class="comment">Here is the list of your books:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">Bye.</span></span><br><span class="line"><span class="comment">$ booksave</span></span><br><span class="line"><span class="comment">Current contents of book.dat:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">Please add new book titles.</span></span><br><span class="line"><span class="comment">The Third Jar</span></span><br><span class="line"><span class="comment">Now enter the author.</span></span><br><span class="line"><span class="comment">Nellie Nostrum</span></span><br><span class="line"><span class="comment">Now enter the value.</span></span><br><span class="line"><span class="comment">22.99</span></span><br><span class="line"><span class="comment">Enter the next title.</span></span><br><span class="line"><span class="comment">[enter]</span></span><br><span class="line"><span class="comment">Here is the list of your books:</span></span><br><span class="line"><span class="comment">Metric Merriment by Polly Poetica: $18.99</span></span><br><span class="line"><span class="comment">Deadly Farce by Dudley Forse: $15.99</span></span><br><span class="line"><span class="comment">The Third Jar by Nellie Nostrum: $22.99</span></span><br><span class="line"><span class="comment">Bye.</span></span><br><span class="line"><span class="comment">$</span></span><br><span class="line"><span class="comment">再次运行booksave.c程序把这3本书作为当前的文件记录打印出来。</span></span><br></pre></td></tr></table></figure><h1 id="第二章：输入与输出"><a href="#第二章：输入与输出" class="headerlink" title="第二章：输入与输出"></a>第二章：输入与输出</h1><h2 id="第一节：单字符输入-输出"><a href="#第一节：单字符输入-输出" class="headerlink" title="第一节：单字符输入/输出"></a>第一节：单字符输入/输出</h2><ol><li>介绍输入、 输出以及缓冲输入和无缓冲输入的区别 </li><li>如何使用重定向把程序和文件相连接</li><li>介绍如何设计与用户交互的界面 </li><li>创建更友好的用户界面 </li><li>演示一些与输入验证相关的问题和解决方案。 </li></ol><p>I/O函数（如printf()、 scanf()、 getchar()、 putchar()等） 负责把信息传送到程序中。  </p><h3 id="单字符I-O：getchar-和putchar"><a href="#单字符I-O：getchar-和putchar" class="headerlink" title="单字符I/O：getchar()和putchar()"></a>单字符I/O：getchar()和putchar()</h3><p>getchar()和 putchar()每次只处理一个字符。 </p><p>程序清单8.1。该程序获取从键盘输入的字符， 并把这些字符发送到屏幕上。 程序使用while 循环， 当读到#字符时停止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">8.1</span> echo.c程序</span><br><span class="line"><span class="comment">/* echo.c -- 重复输入 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'#'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户的交互如下：    </p><p><strong>Hello, there. I would[enter]</strong></p><p>Hello, there. I would</p><p><strong>like a #3 bag of potatoes.[enter]</strong></p><p>like a</p><p>例子中 “#” 作为结束输入， 就无法在文本中使用这个字符， 是否有更好的方法结束输入？， 是否有更好的方法结束输入？  要回答这些问题， 首先要了解 C程序如何处理键盘输入， 尤其是缓冲和标准输入文件的概念。 </p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>在老式系统运行程序清单8.1， 可能显示如下：</p><p>HHeelllloo,, tthheerree..II wwoouulldd[enter]</p><p>lliikkee aa #</p><p> 像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接） 输入， 即正在等待的程序可立即使用输入的字符。</p><p>大部分系统在用户按下Enter键之前不会重复打印刚输入的字符， 这种输入形式属于缓冲输入。 用户输入的字符被收集并储存在一个被称为缓冲区（buffer） 的临时存储区， 按下Enter键后， 程序才可使用用户输入的字符。 图8.1比较了这两种输入。 <img src="D:\MyBlog\图片\Snipaste_2019-02-21_09-53-53.png" alt="Snipaste_2019-02-21_09-53-53"></p><p><strong>为什么要有缓冲区？</strong></p><ul><li>把若干字符作为一个块进行传输比逐个发送这些字符节约时间</li><li>如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时， 传输的是正确的输入。</li></ul><p>虽然缓冲输入好处很多， 但是某些交互式程序也需要无缓冲输入。 例如， 在游戏中， 你希望按下一个键就执行相应的指令。 因此， 缓冲输入和无缓冲输入都有用武之地。 </p><p><strong>缓冲分为两类： 完全缓冲I/O和行缓冲I/O。</strong> </p><ul><li>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地） ， 通常出现在文件输入中。 缓冲区的大小取决于系统， 常见的大小是 512 字节和 4096字节。</li><li>行缓冲I/O指的是在出现换行符时刷新缓冲区。 键盘输入通常是行缓冲输入， 所以在按下Enter键后才刷新缓冲区 。</li></ul><h3 id="文件、流和键盘输入"><a href="#文件、流和键盘输入" class="headerlink" title="文件、流和键盘输入"></a>文件、流和键盘输入</h3><ul><li>文件（file） 是存储器中储存信息的区域。 通常， 文件都保存在某种永久存储器中（如， 硬盘、 U盘或DVD等） 。 </li><li>C可以使用主机操作系统的基本文件工具直接处理文件， 这些直接调用操作系统的函数被称为底层 I/O （low-level I/O） 。</li><li><strong>C程序处理的是流而不是直接处理文件。</strong> 流（stream） 是一个实际输入或输出映射的理想化数据流。 这意味着不同属性和不同种类的输入， 由属性更统一的流来表示。 于是， 打开文件的过程就是把流与文件相关联， 而且读写都通过流来完成。 从而达到屏蔽掉了不同系统的输入输出的差异， 以便用户使用统一的界面。 </li><li>C把输入和输出设备视为存储设备上的普通文件， 尤其是把键盘和显示设备视为每个C程序自动打开的文件。 stdin流表示键盘输入， stdout流表示屏幕输出。 getchar()、 putchar()、printf()和scanf()函数都是标准I/O包的成员， 处理这两个流。 </li></ul><p>总结：可以用处理文件的方式来处理键盘输入。 例如，程序读文件时要能检测文件的末尾才知应在何处停止。 因此， C 的输入函数内置了文件结尾检测器。 既然可以把键盘输入视为文件， 那么也应该能使用文件结尾检测器结束键盘输入。 </p><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><p>计算机操作系统要以某种方式判断文件的开始和结束。</p><ul><li><p>在文件末尾放一个特殊的字符标记文件结尾。 图8.2演示了这种方法</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_10-38-48.png" alt="Snipaste_2019-02-21_10-38-48"></p></li><li><p>另一种方法是储存文件大小的信息。  如果文件有3000字节， 程序在读到3000字节时便达到文件的末尾。 </p></li></ul><p>无论操作系统实际使用何种方法检测文件结尾， 在C语言中， 用getchar()读取文件检测到文件结尾时将返回一个特殊的值， 即EOF（end offile的缩写） 。 scanf()函数检测到文件结尾时也返回EOF。 通常， EOF定义在stdio.h文件中： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure><p>如何在程序中使用EOF？ 把getchar()的返回值和EOF作比较。 如果两值不同， 就说明没有到达文件结尾。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br></pre></td></tr></table></figure><p>绝大部分系统（不是全部） 都有办法通过键盘模拟文件结尾条件（Enter）。完整程序如下</p><p>程序清单8.2 echo_eof.c程序 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* echo_eof.c -- 重复输入， 直到文件结尾 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span></span><br><span class="line">ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h4><p>输入和输出涉及函数、 数据和设备。 例如， 上面 echo_eof.c程序， 该程序使用输入函数 getchar()，输出函putchar()。 输入/输出数据流由字符组成。 输入设备是键盘 ，输出设备是屏幕。</p><p> 假设你希望输入函数和数据类型不变， 仅改变程序查找数据的位置。 那么， 程序如何知道去哪里查找输入？ </p><p>默认情况下， C程序使用标准I/O包查找标准输入作为输入源。 即：stdin流， 它是把数据读入计算机的常用方式。 它可以是键盘或者时一个过时的设备， 如磁带、 穿孔卡或电传打印机， 甚至是一些先进技术， 如语音输入。 然而， 现代计算机非常灵活， 可以让它到别处查找输入。 尤其是， 可以让一个程序从文件中查找输入， 而不是从键盘。 </p><p><strong>程序可以通过两种方式使用文件</strong></p><ul><li>第 1 种方法是， 显式使用特定的函数打开文件、 关闭文件、 读取文件、 写入文件， 诸如此类。 </li><li>第2种方法是， 设计能与键盘和屏幕互动的程序， 通过不同的渠道重定向输入至文件和从文件输出。 换言之， 把stdin流重新赋给文件。 继续使用getchar()函数从输入流中获取数据， 但它并不关心从流的什么位置获取数据。 这种重定向的方法在某些方面有些限制， 但是用起来比较简单， 而且能让读者熟悉普通的文件处理技术。 </li></ul><p>重定向输入让程序使用文件而不是键盘来输入， 重定向输出让程序输出至文件而不是屏幕。 </p><p>重定向输入</p><p> 假设已经编译了echo_eof.c 程序 </p><p>现在要该程序处理名为words的文本文件输出到屏幕上 </p><p>./echo_eof &lt; words  ：&lt;符号是UNIX和DOS/Windows的重定向运算符， words为文本文件保存有“1314”。</p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-07-57.png" alt="Snipaste_2019-02-21_14-07-57"></p><h4 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h4><p>在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。  </p><p>echo_eof&gt;mywords  ：&gt;符号是重定向运算符。 它创建了一个名为mywords的新文件， 然<br>后把echo_eof的输出 重定向至该文件中。  </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-18.png" alt="Snipaste_2019-02-21_14-15-18"></p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-21_14-15-46.png" alt="Snipaste_2019-02-21_14-15-46"></p><p>注：在下一行的开始处按下Ctrl+D（UNIX） 或Ctrl+Z（DOS） 即可结束该程序。 </p><h4 id="组合重定向"><a href="#组合重定向" class="headerlink" title="组合重定向"></a>组合重定向</h4><p>现在， 假设你希望制作一份mywords文件的副本， 并命名为savewords。只需输入以下命令即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_eof &lt; mywords &gt; savewords</span><br><span class="line"><span class="comment">//下面的命令也起作用， 因为命令与重定向运算符的顺序无关：</span></span><br><span class="line">echo_eof &gt; savewords &lt; mywords</span><br></pre></td></tr></table></figure><p>注意： 在一条命令中， 输入文件名和输出文件名不能相同。 </p><p><strong>在UNIX、 Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;） 时， 要遵循以下原则。</strong></p><ul><li><p>重定向运算符连接一个可执行程序（包括标准操作系统命令） 和一个数据文件， 不能用于连接一个数据文件和另一个数据文件， 也不能用于连接一个程序和另一个程序。</p></li><li><p>使用重定向运算符不能读取多个文件的输入， 也不能把输出定向至多个<br>文件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fish &gt; beets ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; count ←违反第<span class="number">1</span>条规则</span><br><span class="line">addup &lt; fish &lt; beets ←违反第<span class="number">2</span>条规则</span><br><span class="line">count &gt; beets fish ←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建更友好的用户界面"><a href="#创建更友好的用户界面" class="headerlink" title="创建更友好的用户界面"></a>创建更友好的用户界面</h3><p>学会避免编写一些中看不中用的程序，并创建更友好的用户界面， 让交互数据输入更方便， 减少错误输入的影响。 </p><p>略</p><h2 id="第二节：字符串符串输入-输出"><a href="#第二节：字符串符串输入-输出" class="headerlink" title="第二节：字符串符串输入/输出"></a>第二节：字符串符串输入/输出</h2><p>本章介绍以下内容：</p><ul><li><p>函数： gets_s()、 fgets()、 puts()、 fputs()、 strcat()、 strncat()、strcmp()、 strncmp()、 strcpy()、 strncpy()、 sprintf()、 strchr() </p></li><li><p>创建并使用字符串 </p></li><li>字符串是以空字符（\0）结尾的char类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过C也提供了许多专门用于处理字符串的函数</li><li>使用C库中的字符和字符串函数， 并创建自定义的字符串函数</li><li>使用命令行参数 </li></ul><p>字符串是以空字符（\0）结尾的char类型数组。 C提供了许多专门用于处理字符串的函数。本节将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。</p><p>程序清单11.1演示了在程序中表示字符串的几种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">//　 strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MSG　<span class="meta-string">"I　am　a　symbolic　string　constant."</span> <span class="comment">//方法一：即字符串常量（字符串常量）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>　MAXLENGTH　81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>　words[MAXLENGTH]　=　<span class="string">"I　am　a　string　in　an　array."</span>; <span class="comment">//方法二：、char类型数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>; <span class="comment">//放法三：指向char的指针</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here　are　some　strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line">    words[<span class="number">8</span>]　=　<span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span>　<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Here are some strings:</span><br><span class="line">I am an old-fashioned symbolic <span class="built_in">string</span> constant.</span><br><span class="line">I am a <span class="built_in">string</span> in an <span class="built_in">array</span>.</span><br><span class="line">Something is pointing at me.</span><br><span class="line">I am a spring in an <span class="built_in">array</span>.</span><br></pre></td></tr></table></figure><p>程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向<br>char的指针）定义字符串。</p><h3 id="如何定义字符串"><a href="#如何定义字符串" class="headerlink" title="如何定义字符串"></a>如何定义字符串</h3><h4 id="1-字符串字面量（字符串常量）"><a href="#1-字符串字面量（字符串常量）" class="headerlink" title="1.字符串字面量（字符串常量）"></a>1.字符串字面量（字符串常量）</h4><p>定义：用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中。</p><p>所以<em>“I am a symbolic stringconstant.”</em>  、<em>“I739am a string in an array.”</em>  、<em>“Something is pointed at me.”</em> 、<em>“Here are somestrings:”</em>都是字符串字面量。</p><p>从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：</p><p><em>char greeting[50] = “Hello, and”</em></p><p><em>“ how are” “ you”</em></p><p><em>“ today!”;</em></p><p>与下面的代码等价：char greeting[50] = “Hello, and how are you today!</p><p><strong>注意：如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\“）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。</p><h4 id="2-字符串数组初始化"><a href="#2-字符串数组初始化" class="headerlink" title="2.字符串数组初始化"></a>2.字符串数组初始化</h4><p>定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种形式的初始化比标准的数组初始化形式简单得多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常，让编译器确定数组的大小很方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。</p><p>##### </p><h4 id="3-指针和字符串"><a href="#3-指针和字符串" class="headerlink" title="3.指针和字符串"></a>3.指针和字符串</h4><p>实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5<br>中的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.5</span> p_and_s.c程序</span><br><span class="line"><span class="comment">/* p_and_s.c -- 指针和字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * mesg = <span class="string">"Don't be a fool!"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * copy;</span><br><span class="line">    copy = mesg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, copy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mesg = %s; &amp;mesg = %p; value = %p\n"</span>, mesg,&amp;mesg, mesg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"copy = %s; &amp;copy = %p; value = %p\n"</span>, copy,&amp;copy, copy);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">        </span><br><span class="line">输出：</span><br><span class="line">Don't be a fool!</span><br><span class="line">mesg = Don't be a fool!; &amp;mesg = <span class="number">0x0012ff48</span>; value =<span class="number">0x0040a000</span></span><br><span class="line">copy = Don't be a fool!; &amp;copy = <span class="number">0x0012ff44</span>; value =<span class="number">0x0040a000</span></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li><p>首先第1项，mesg和copy都以字符串形式输出（%s转换说明）。这里没问题，两个字符串都是”Don’t be a fool!”。</p></li><li><p>第2项，打印两个指针的地址。如上输出所示，指针mesg和copy分别储存在地址为0x0012ff48和0x0012ff44的内存中。</p></li><li><p>意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。<em>语句copy = mesg;把mesg的值赋给copy，即让copy也指向mesg指向的字符。</em></p></li></ul><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。</p><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>字符串输入要做的第 1 件事是分配空间，以储存稍后读入的字符串。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">char</span> *name;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最简单的方法是，在声明时显式指明数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">81</span>];</span><br></pre></td></tr></table></figure><p>假设编写了如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.1</span> strings1.c程序</span><br><span class="line"><span class="comment">// strings1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"I am a symbolic string constant."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLENGTH 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; c</span><br><span class="line">har words[MAXLENGTH] = <span class="string">"I am a string in an array."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointing at me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here are some strings:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(MSG);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(pt1);</span><br><span class="line"> words[<span class="number">8</span>] = <span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的写法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="gets-函数"><a href="#gets-函数" class="headerlink" title="gets()函数"></a>gets()函数</h4><p>在读取字符串时， scanf()和转换说明%s只能读取一个单词。 可是在程序中经常要读取一整行输入， 而不仅仅是一个单词。 程序中读取一整行输入时需要使用gets()函数。</p><p> gets()函数简单易用， 它读取整行输入， 直至遇到换行符， 然后丢弃换行符， 储存其余字符， 并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。  </p><p><em>注：它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。（字符串输出介绍）</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.6</span> getsputs.c程序</span><br><span class="line"><span class="comment">/* getsputs.c -- 使用 gets() 和 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">gets(words); <span class="comment">// 典型用法，用于输入字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, words);</span><br><span class="line"><span class="built_in">puts</span>(words);<span class="comment">//用于输出字符串，效果和print相同。</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">Your <span class="built_in">string</span> twice:</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">I want to learn about <span class="built_in">string</span> theory!</span><br><span class="line">Done.</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// gets整行输入（除了换行符） 都被储存在 words 中， puts(words) 和printf("%s\n, words")的效果相同。</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>gets()唯一的参数是 words，它无法检查数组是否装得下输入行。数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。</p><p>如果输入的字符串过长， 会导致缓冲区溢出（buffer overflow） ， 即多余的字符超出了指定的目标空间。 如果这些多余的字符只是占用了尚未使用的内存， 就不会立即出现问题； 如果它们擦写掉程序中的其他数据， 会导致程序异常中止； 或者还有其他情况。（问题和上面分配空间相似。）</p><h5 id="gets-的替代品"><a href="#gets-的替代品" class="headerlink" title="gets()的替代品"></a>gets()的替代品</h5><p>由于容易出现“Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的。因此C 编程社区的许多人都建议在编程时摒弃 gets()。</p><h5 id="1-fgets-函数"><a href="#1-fgets-函数" class="headerlink" title="1.fgets()函数"></a>1.fgets()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> bufsize, FILE *stream)</span></span>;</span><br><span class="line">参数</span><br><span class="line">*buf: 字符型指针，指向用来存储所得数据的地址。</span><br><span class="line">bufsize: 整型数据，指明存储数据的大小。</span><br><span class="line">*stream: 文件结构体指针，将要读取的文件流。</span><br></pre></td></tr></table></figure><p>fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。 该函数专门设计用于处理文件输入， 所以一般情况下可能不太好用。 </p><p><strong>fgets()和gets()的区别如下</strong></p><ul><li>fgets()函数的第2个参数指明了读入字符的最大数量。 如果该参数的值是n， 那么fgets()将读入n-1个字符， 或者读到遇到的第一个换行符为止。 </li><li>如果fgets()读到一个换行符， 会把它储存在字符串中。 （fgets()会保留换行符， gets()会丢弃换行符。 ）</li><li>fgets()函数的第3 个参数指明要读入的文件。 如果读入从键盘输入的数据， 则以stdin（标准输入） 作为参数。</li></ul><p>因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出） ， 通常要与 fputs()函数（和puts()类似） 配对使用， 除非该函数不在字符串末尾 添加换行符。 </p><p>fputs()函数的第2个参数指明它要写入的文件。 如果要显示在计算机显示器上， 应使用stdout（标准输出） 作为该参数。 （fputs后面介绍）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.7</span> fgets1.c程序</span><br><span class="line"><span class="comment">/* fgets1.c -- 使用 fgets() 和 fputs() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STLEN 14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> words[STLEN];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter a string, please."</span>);</span><br><span class="line">fgets(words, STLEN, <span class="built_in">stdin</span>);<span class="comment">//words为写入内容，STLEN存储数据大小,stdin指向读取文件指针为标准输入。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter another string, please."</span>);</span><br><span class="line">fgets(words, STLEN, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your string twice (puts(), then fputs()):\n"</span>);</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">下面是该程序的输出示例：</span><br><span class="line">Enter a <span class="built_in">string</span>, please.</span><br><span class="line">apple pie</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">apple pie</span><br><span class="line">apple pie</span><br><span class="line">Enter another <span class="built_in">string</span>, please.</span><br><span class="line">strawberry shortcake</span><br><span class="line">Your string twice (puts(), then fputs()):</span><br><span class="line">strawberry sh</span><br><span class="line">strawberry shDone.</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>第1行输入， apple pie， 比fgets()读入的整行输入短， 因此， apple pie\n\0被储存在数组中。 所以当puts()显示该字符串时又在末尾添加了换行符， 因此apple pie后面有一行空行。 因为fputs()不在字符串末尾添加换行符， 所以并未打印出空行。</li><li>第2行输入， strawberry shortcake， 超过了大小的限制， 所以fgets()只读入了13个字符， 并把strawberry sh\0 储存在数组中。 再次提醒读者注意，puts()函数会在待输出字符串末尾添加一个换行符， 而fputs()不会这样做。 </li></ul><h5 id="2-gets-s-函数"><a href="#2-gets-s-函数" class="headerlink" title="2.gets_s()函数"></a>2.gets_s()函数</h5><p>过去通常用fgets()来代替gets()， fgets()函数稍微复杂些， 在处理输入方面与gets()略有不同。 C11标准新增的gets_s()函数也可代替gets()。 该函数与gets()函数更接近， 而且可以替换现有代码中的gets()。 但是， 它是stdio.h输入/输出函数系列中的可选扩展， 所以支持C11的编译器也不一定支持它。 </p><p>C11新增的gets_s()函数（可选） 和fgets()类似， 用一个参数限制读入的字符数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets_s</span><span class="params">(<span class="keyword">char</span> *buffer,<span class="keyword">size_t</span> sizeInCharacters)</span></span>;</span><br></pre></td></tr></table></figure><p>gets_s()与fgets()的区别如下。</p><p>gets_s()只从标准输入中读取数据， 所以不需要第3个参数。</p><p>如果gets_s()读到换行符， 会丢弃它而不是储存它。</p><h5 id="3-s-gets-函数"><a href="#3-s-gets-函数" class="headerlink" title="3.s_gets()函数"></a>3.s_gets()函数</h5><p>程序清单11.9演示了fgets()函数的一种用法： 读取整行输入并用空字符<br>代替换行符， 或者读取一部分输入， 并丢弃其余部分。 既然没有处理这种情<br>况的标准函数， 我们就创建一个， 在后面的程序中会用得上。 程序清单<br>11.10提供了一个这样的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.10</span> s_gets()函数</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>); </span><br><span class="line"> <span class="keyword">if</span> (ret_val) <span class="comment">// 即， ret_val != NULL</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">st[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：如果 fgets()返回 NULL， 说明读到文件结尾或出现读取错误， s_gets()函数跳过了这个过程。 它模仿程序清单11.9的处理方法， 如果字符串中出现换行符， 就用空字符替换它； 如果字符串中出现空字符， 就丢弃该输入行的其余字符， 然后返回与fgets()相同的值。 </p><h4 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h4><p>scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾：scanf()更像是“获取单词”函数， 而不是“获取字符串”函数； 如果预留的存储区装得下输入行， gets()和fgets()会读取第1个换行符之前所有的字符。 </p><p>scanf()函数有两种方法确定输入结束。 无论哪种方法， 都从第1个非空白字符作为字符串的开始。 </p><ul><li>如果使用%s转换说明， 以下一个空白字符（空行、空格、 制表符或换行符） 作为字符串的结束（字符串不包括空白字符） 。</li><li>如果指定了字段宽度， 如%10s， 那么scanf()将读取10 个字符或读到第1个空白<br>字符停止（先满足的条件即是结束输入的条件） ， 见图11.3。 </li></ul><p><img src="D:\MyBlog\图片\Snipaste_2019-02-25_20-49-47.png" alt="Snipaste_2019-02-25_20-49-47"></p><p>scanf()函数返回一个整数值， 该值等于scanf()成功读取的项数或EOF（读到文件结尾时返回EOF） 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.11</span> scan_str.c程序</span><br><span class="line"><span class="comment">/* scan_str.c -- 使用 scanf() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> name1[<span class="number">11</span>], name2[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please enter 2 names.\n"</span>);</span><br><span class="line">count = <span class="built_in">scanf</span>(<span class="string">"%5s %10s"</span>, name1, name2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I read the %d names %s and %s.\n"</span>, count, name1,me2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是该程序的3个输出示例：</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Jesse Jukes</span></span><br><span class="line"><span class="comment">I read the 2 names Jesse and Jukes.</span></span><br><span class="line"><span class="comment">Please enter 2 names.</span></span><br><span class="line"><span class="comment">Portensia Callowit</span></span><br><span class="line"><span class="comment">I read the 2 names Porte and nsia.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>分析：第1个输出示例， 两个名字的字符个数都未超过字段宽度。 第2个输出示例， 只读入了Applebottham的前10个字符Applebotth（因为使用了%10s转换说明） 。 第3个输出示例， Portensia的后4个字符nsia被写入name2中， 因为第2次调用scanf()时， 从上一次调用结束的地方继续读取数据。 在该例中， 读取的仍是Portensia中的字母。 </p><p>scanf()和gets()类似， 也存在一些潜在的缺点。 如果输入行的内容过长，scanf()也会导致数据溢出。 不过， 在%s转换说明中使用字段宽度可防止溢出。 </p><h3 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h3><p>C有3个标准库函数用于打印字符串： put()、 fputs()和printf() 。</p><h4 id="puts-函数"><a href="#puts-函数" class="headerlink" title="puts()函数"></a>puts()函数</h4><p>puts()函数很容易使用， 只需把字符串的地址作为参数传递给它即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.12</span> put_out.c程序</span><br><span class="line"><span class="comment">/* put_out.c -- 使用 puts() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF <span class="meta-string">"I am a #defined string."</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">80</span>] = <span class="string">"An array was initialized to me."</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * str2 = <span class="string">"A pointer was initialized to me."</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"I'm an argument to puts()."</span>);</span><br><span class="line"><span class="built_in">puts</span>(DEF);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="built_in">puts</span>(str2);</span><br><span class="line"><span class="built_in">puts</span>(&amp;str1[<span class="number">5</span>]);</span><br><span class="line"> <span class="built_in">puts</span>(str2 + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">该程序的输出如下：</span><br><span class="line">I'm an argument to puts().</span><br><span class="line">I am a <span class="meta">#defined string.</span></span><br><span class="line">An <span class="built_in">array</span> was initialized to me.</span><br><span class="line">A pointer was initialized to me.</span><br><span class="line">ray was initialized to me.</span><br><span class="line">inter was initialized to me.</span><br></pre></td></tr></table></figure><p>注：每个字符串独占一行， 因为puts()在显示字符串时会自动在其末尾添加一个换行符。 （这点太舒服了，printf()还要自己加换行。）</p><p>puts()如何知道在何处停止？ 该函数在遇到换行符时就停止输出， 所以必须确保有换行符。 不要模仿程序清单11.13中的程序！ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.13</span> nono.c程序</span><br><span class="line"><span class="comment">/* nono.c -- 千万不要模仿！ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> side_a[] = <span class="string">"Side A"</span>;</span><br><span class="line"><span class="keyword">char</span> dont[] = &#123; <span class="string">'W'</span>, <span class="string">'O'</span>, <span class="string">'W'</span>, <span class="string">'!'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> side_b[] = <span class="string">"Side B"</span>;</span><br><span class="line"><span class="built_in">puts</span>(dont); <span class="comment">/* dont 不是一个字符串，是个wow！字节 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于dont缺少一个表示结束的空字符， 所以它不是一个字符串， 因此puts()不知道在何处停止。 它会一直打印dont后面内存中的内容， 直到发现一个空字符为止。 为了让puts()能尽快读到空字符， 我们把dont放在side_a和side_b之间。 下面是该程序的一个运行示例：<br>WOW!Side A </p><h4 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs()函数"></a>fputs()函数</h4><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line">（<span class="number">1</span>）str：这是一个数组，包含了要写入的以空字符终止的字符序列。</span><br><span class="line">（<span class="number">2</span>）stream：指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</span><br><span class="line">返回值：该函数返回一个非负值，如果发生错误则返回 EOF(<span class="number">-1</span>)。</span><br></pre></td></tr></table></figure><p>fputs()函数是puts()针对文件定制的版本。 </p><p>它们的区别如下：</p><ul><li>fputs()函数的第 2 个参数指明要写入数据的文件。 如果要打印在显示器上， 可以用定义在stdio.h中的stdout（标准输出） 作为该参数。  </li><li>与puts()不同， fputs()不会在输出的末尾添加换行符。 </li></ul><p>注意： gets()丢弃输入中的换行符， 但是puts()在输出中添加换行符。 另一方面， fgets()保留输入中的换行符， fputs()不在输出中添加换行符。 （好绕）</p><h3 id="常见字符串处理函数"><a href="#常见字符串处理函数" class="headerlink" title="常见字符串处理函数"></a>常见字符串处理函数</h3><p>C库提供了多个处理字符串的函数， ANSI C把这些函数的原型放在string.h头文件中。 其中最常用的函数strlen()、 strcat()、 strcmp()、strncmp()、 strcpy()和 strncpy()。 另外， 还有sprintf()函数， 其原型在stdio.h头文件中。 </p><p><strong>1.strlen()函数 ：用于统计字符串的长度。</strong> </p><p>略</p><p><strong>2.strcat()函数 ：用于拼接字符串</strong></p><p> 函数接受两个字符串作为参数。 该函数把第2个字符串的备份附加在第1个字符串末尾， 并把拼接后形成的新字符串作为第1个字符串， 第2个字符串不变。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.18</span> str_cat.c程序</span><br><span class="line"><span class="comment">/* str_cat.c -- 拼接两个字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* strcat()函数的原型在该头文件中 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line"><span class="keyword">char</span> addon [] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line"><span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line"><span class="built_in">puts</span>(flower);</span><br><span class="line"><span class="built_in">puts</span>(addon);</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">st[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序的输出示例如下：</span></span><br><span class="line"><span class="comment">What is your favorite flower?</span></span><br><span class="line"><span class="comment">wonderflower</span></span><br><span class="line"><span class="comment">wonderflowers smell like old shoes.</span></span><br><span class="line"><span class="comment">s smell like old shoes.</span></span><br><span class="line"><span class="comment">bye</span></span><br><span class="line"><span class="comment">从以上输出可以看出， flower改变了， 而addon保持不变。</span></span><br></pre></td></tr></table></figure><p><strong>3.strcmp()函数</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line">设这两个字符串为str1，str2，</span><br><span class="line">若str1=str2，则返回零；</span><br><span class="line">若str1&lt;str2，则返回负数；</span><br><span class="line">若str1&gt;str2，则返回正数。</span><br></pre></td></tr></table></figure><p><strong>4.sprintf()函数</strong></p><p> 是字符串格式化命令,主要功能是把格式化的数据写入某个字符串中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原型</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [ argument] … )</span></span>;</span><br><span class="line">参数列表</span><br><span class="line">buffer：<span class="keyword">char</span>型指针，指向将要写入的字符串的缓冲区。</span><br><span class="line">format：格式化字符串。</span><br><span class="line">[argument]...：可选参数，可以是任何类型的数据。nst <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crt_sprintf.c</span></span><br><span class="line"><span class="comment">// compile with: /W3</span></span><br><span class="line"><span class="comment">// This program uses sprintf to format various</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//data and place them in the string named buffer.</span></span><br><span class="line"><span class="comment">// 程序使用sprintf 将各种数据格式化后置于字符数组buffer中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span>  buffer[<span class="number">200</span>], s[] = <span class="string">"computer"</span>, c = <span class="string">'l'</span>;</span><br><span class="line">   <span class="keyword">int</span>   i = <span class="number">35</span>, j;</span><br><span class="line">   <span class="keyword">float</span> fp = <span class="number">1.7320534f</span>;</span><br><span class="line">   <span class="comment">// 格式化并打印各种数据到buffer</span></span><br><span class="line">   j  = <span class="built_in">sprintf</span>( buffer,    <span class="string">"   String:    %s\n"</span>, s ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Character: %c\n"</span>, c ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Integer:   %d\n"</span>, i ); <span class="comment">// C4996</span></span><br><span class="line">   j += <span class="built_in">sprintf</span>( buffer + j, <span class="string">"   Real:      %f\n"</span>, fp );<span class="comment">// C4996</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Output:\n%s\ncharacter count = %d\n"</span>, buffer, j );</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果 [<span class="number">1</span>]  ：</span><br><span class="line">Output:</span><br><span class="line">String: computer </span><br><span class="line">　　</span><br><span class="line">Character: l</span><br><span class="line">Integer: <span class="number">35</span></span><br><span class="line">Real: <span class="number">1.732053</span></span><br><span class="line">character count = <span class="number">79</span></span><br></pre></td></tr></table></figure><p><strong>其他字符串函数</strong> </p><ol><li><p>char <em>strcpy(char </em> restrict s1, const char * restrict s2);</p><p>该函数把s2指向的字符串（包括空字符） 拷贝至s1指向的位置， 返回值是s1。</p></li><li><p>char <em>strncpy(char </em> restrict s1, const char * restrict s2, size_t n);</p><p>该函数把s2指向的字符串拷贝至s1指向的位置， 拷贝的字符数不超过n， 其返回值是s1该函数不会拷贝空字符后面的字符， 如果源字符串的字符少于n个， 目标字符串就以拷贝的空字符尾； 如果源字符串有n个或超过n个字符， 就不拷贝空字符。</p></li><li><p>char <em>strcat(char </em> restrict s1, const char * restrict s2);</p><p>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 该函数返回s1。</p></li><li><p>char <em>strncat(char </em> restrict s1, const char * restrict s2, size_t n);</p><p>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。 s2字符串的第1个字符将覆盖s1字符串末尾的空字符。 不会拷贝s2字符串中空字符和其后的字符， 并在拷贝字符的末尾添加一个空字符。 该函数返回s1。</p></li><li><p>int strcmp(const char <em> s1, const char </em> s2);</p><p>如果s1字符串在机器排序序列中位于s2字符串的后面， 该函数返回一个正数； 如果两个字符串相等， 则返回0； 如果s1字符串在机器排序序列中位于s2字符串的前面， 则返回一个负数。</p></li><li><p>int strncmp(const char <em> s1, const char </em> s2, size_t n);</p><p>该函数的作用和strcmp()类似， 不同的是， 该函数在比较n个字符后或遇到第1个空字符时停止比较。</p></li><li><p>char <em>strchr(const char </em> s, int c);</p><p>如果s字符串中包含c字符， 该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分， 所以在查找范围内） ； 如果在字符串s中  </p></li></ol><h3 id="输入-输出的应用技巧"><a href="#输入-输出的应用技巧" class="headerlink" title="输入/输出的应用技巧"></a>输入/输出的应用技巧</h3><h4 id="自定义输入-输出函数"><a href="#自定义输入-输出函数" class="headerlink" title="自定义输入/输出函数"></a>自定义输入/输出函数</h4><p>实际使用中，不一定非要使用C库中的标准函数， 如果无法使用这些函数或者想扩张输入/输出的某一功能， 完全可以在getchar()和putchar()的基础上自定义所需的函数。 </p><p>下面两个经典的自定义输入/输出函数 </p><p>1.字符串， 不添加\n </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">11.14</span> put1()函数</span><br><span class="line"><span class="comment">/* put1.c -- 打印字符串， 不添加\n */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span><span class="comment">/* 不会改变字符串 */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">string</span> != <span class="string">'\0'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向char的指针string最初指向传入参数的首元素。 因为该函数不会改变<br>传入的字符串， 所以形参使用了const限定符。 打印了首元素的内容后， 指<br>针递增1， 指向下一个元素。 while循环重复这一过程， 直到指针指向包含空<br>字符的元素。  </p><p>++的优先级高于<em>， 因此putchar(</em>string++)打印string指向的值， 递增的是string本身， 而不是递增它所指向的字符。 （即先比较厚打印，当比较到\0时退出）</p><p>2.设计一个类似puts()的函数， 而且该函数还给出待打印字符的个数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* put2.c -- 打印一个字符串， 并统计打印的字符数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">put2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">string</span>) <span class="comment">/* 常规用法 */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(*<span class="built_in">string</span>++);</span><br><span class="line">count++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>); <span class="comment">/* 不统计换行符 */</span></span><br><span class="line"><span class="keyword">return</span>(count);</span><br><span class="line">&#125;</span><br><span class="line">num = put2(<span class="string">"pizza"</span>);<span class="comment">//调用将返回统计的字符数， 并将其赋给num</span></span><br></pre></td></tr></table></figure><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><p>我们来处理一个按字母表顺序排序字符串的实际问题。 准备名单表、 创建索引和许多其他情况下都会用到字符串排序。 该程序主要是用 strcmp()函数来确定两个字符串的顺序。 一般的做法是读取字符串函数、 排序字符串并打印出来。  </p><p>略</p><h4 id="把字符串转换为数字"><a href="#把字符串转换为数字" class="headerlink" title="把字符串转换为数字"></a>把字符串转换为数字</h4><p>数字既能以字符串形式储存， 也能以数值形式储存。 把数字储存为字符串就是储存数字字符。 例如， 数字213以’2’、 ‘1’、 ‘3’、 ‘\0’的形式被储存在字符串数组中。 以数值形式储存213， 储存的是int类型的值。 </p><p>略</p><h2 id="第三节：文件输入-输出"><a href="#第三节：文件输入-输出" class="headerlink" title="第三节：文件输入/输出"></a>第三节：文件输入/输出</h2><p>本章介绍以下内容函数：</p><ul><li>fopen()、 getc()、 putc()、 exit()、 fclose()</li><li>fprintf()、 fscanf()、 fgets()、 fputs()</li><li>rewind()、 fseek()、 ftell()、 fflush()</li><li>fgetpos()、 fsetpos()、 feof()、 ferror()</li><li>ungetc()、 setvbuf()、 fread()、 fwrite()</li></ul><p>如何使用C标准I/O系列的函数处理文件文件模式和二进制模式、 文本和二进制格式、 缓冲和无缓冲I/O<br>使用既可以顺序访问文件也可以随机访问文件的函数文件是当今计算机系统不可或缺的部分。 文件用于储存程序、 文档、 数据、 书信、 表格、 图形、 照片、 视频和许多其他种类的信息。 作为程序员，必须会编写创建文件和从文件读写数据的程序。 本章将介绍相关的内容。</p><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><ol><li><p><strong>文件（file）</strong></p><p>文件（file）： 通常是在磁盘或固态硬盘上的一段已命名的存储区。 对我们而言， stdio.h就是一个文件的名称， 该文件中包含一些有用的信息 。</p><p>C把文件看作是一系列连续的字节， 每个字节都能被单独读取。 C提供两种文件模式： 文本模式和二进制模式。 </p></li><li><p><strong>文本模式和二进制模式</strong> </p><p>所有文件的内容都以二进制形式（0或1） 储存。 但是， 如果文件最初使用二进制编码的字符（例如， ASCII或Unicode） 表示文本（就像C字符串那样） ， 该文件就是文本文件， 其中包含文本内容。 如果文件中的二进制值代<br>表机器语言代码或数值数据（使用相同的内部表示， 假设， 用于long或double类型的值） 或图片或音乐编码， 该文件就是二进制文件， 其中包含二进制内容。 </p></li><li><p><strong>I/O的级别</strong> </p><p>除了选择文件的模式， 大多数情况下， 还可以选择I/O的两个级别（即处理文件访问的两个级别） 。 底I/O（low-level I/O） 使用操作系统提供的基本I/O服务。 标准高级I/O（standard high-level I/O） 使用C库的标准包和stdio.h头文件定义。 </p></li><li><p><strong>标准文件</strong>  </p><p>C程序会自动打开3个文件， 它们被称为标准输入（standard input） 、 标准输出（standard output） 和标准错误输出（standard error output） 。 在默认情况下， 标准输入是系统的普通输入设备， 通常为键盘； 标准输出和标准错误输出是系统的普通输出设备， 通常为显示屏 </p><p>标准输入为程序提供输入， 它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出， 它是putchar()、 puts()和printf()使用的文件。  </p></li></ol><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>与底层I/O相比， 标准I/O包除了可移植以外还有两个好处。 </p><p>第一， 标准I/O有许多专门的函数简化了处理不同I/O的问题。 例如， printf()把不同形式的数据转换成与终端相适应的字符串输出。 </p><p>第二， 输入和输出都是缓冲的。也就是说， 一次转移一大块信息而不是一字节信息（通常至少512字节） 。 例如， 当程序读取文件时， 一块数据被拷贝到缓冲区（一块中介存储区域） 。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.1</span> count.c程序</span><br><span class="line"><span class="comment">/* count.c -- 使用标准 I/O */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // 提供 exit()的原型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ch; <span class="comment">// 读取文件时， 储存每个字符的地方</span></span><br><span class="line">FILE *fp; <span class="comment">// “文件指针”</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s filename\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Can't open %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = getc(fp)) != EOF)</span><br><span class="line">&#123; </span><br><span class="line">        putc(ch, <span class="built_in">stdout</span>); <span class="comment">// 与putchar(ch); 相同</span></span><br><span class="line">count++;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File %s has %lu characters\n"</span>, argv[<span class="number">1</span>], count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查命令行参数"><a href="#检查命令行参数" class="headerlink" title="检查命令行参数"></a>检查命令行参数</h4><p>程序清单中的程序检查argc的值， 查看是否有命令行参数。如果没有， 程序将打印一条消息并退出程序。 字符串 argv[0]是该程序的名称。 显式使用 argv[0]而不是程序名， 错误消息的描述会随可执行文件名的改变而自动改变。</p><p><em>补充：int main(int argc,char</em> argv[ ])</p><ul><li><em>argc：是命令行总的参数个数</em><br>​    argv[]是argc个参数，其中第0个参数是程序的全名，以后的参数命令行后面跟的用户输入的参数，</li><li><em>char </em>argv[]：是一个字符数组,其大小是int argc,<em><br>​       </em>主要用于命令行参数argv[]参数，数组里每个元素代表一个参数;*</li></ul><h4 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h4><p>程序使用fopen()函数打开文件。 该函数声明在stdio.h中。  </p><p>它的第1个参数是待打开文件的名称， 更确切地说是一个包含<br>改文件名的字符串地址。 第 2 个参数是一个字符串， 指定待打开文件的模<br>式。  下表列出了C库提供的一些模式。 </p><p><img src="D:\MyBlog\图片\Snipaste_2019-02-26_10-46-41.png" alt="Snipaste_2019-02-26_10-46-41"></p><p>**</p><p><em>注意：如果使用任何一种”w”模式（不带x字母） 打开一个现有文件， 该文件的内容会被删除， 以便程序在一个空白文件中开始操作。 然而， 如果使用带x字母的任何一种模式， 将无法打开一个现有文件。</em></p><p>序成功打开文件后， fopen()将返回文件指针（file pointer） ， 其他I/O 函数可以使用这个指针指定该文件。  </p><p>文件指针（该例中是fp） 的类型是指向FILE的指针， FILE是一个定义在stdio.h中的派生类型。 文件指针fp并不指向实际的文件， 它指向一个包含文件信息的数据对象， 其中包含操作文件的<br>I/O函数所用的缓冲区信息。</p><p><em>理解：好像是fopen的话 会创建一个FILE的数据结构，用于保存 打开的文件信息 ，然后使用指针指向该数据结构</em></p><h4 id="getc-和putc-函数"><a href="#getc-和putc-函数" class="headerlink" title="getc()和putc()函数"></a>getc()和putc()函数</h4><p>getc()和putc()函数与getchar()和putchar()函数类似。 所不同的是， 要告诉<br>getc()和putc()函数使用哪一个文件。 </p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch = getchar();<span class="comment">//从标准输入中获取一个字符，一般指键盘”： </span></span><br><span class="line">ch = getc(fp); <span class="comment">//从fp指定的文件中获取一个字符</span></span><br><span class="line">putc(ch, fpout);<span class="comment">//把字符ch放入FILE指针fpout指定的文件中</span></span><br><span class="line"><span class="comment">//第1个参数是待写入的字符， 第2个参数是文件指针。</span></span><br></pre></td></tr></table></figure><h4 id="文件结尾-1"><a href="#文件结尾-1" class="headerlink" title="文件结尾"></a>文件结尾</h4><p>读取数据时程序时如何知道文件结尾的，getc()函数在读取一个字符时发现是文件结尾， 它将返回一个特殊值EOF。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(<span class="string">"wacky.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">while</span> (( ch = getc(fp)) != EOF)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">putchar</span>(ch); <span class="comment">//处理输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.fclose()函数   </p><p>fclose(fp)函数关闭fp指定的文件， 必要时刷新缓冲区。 对于较正式的程<br>序， 应该检查是否成功关闭文件。 如果成功关闭， fclose()函数返回0， 否则<br>返回EOF： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error in closing file %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//如果磁盘已满、 移动硬盘被移除或出现I/O错误， 都会导致调用fclose()函数失败。</span></span><br></pre></td></tr></table></figure><h4 id="应用：一个简单的文件压缩程序"><a href="#应用：一个简单的文件压缩程序" class="headerlink" title="应用：一个简单的文件压缩程序"></a>应用：一个简单的文件压缩程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.2</span> reducto.c程序</span><br><span class="line"><span class="comment">// reducto.c –把文件压缩成原来的1/3！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; // 提供 exit()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // 提供 strcpy()、 strcat()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 40</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FILE *in, *out; <span class="comment">// 声明两个指向 FILE 的指针</span></span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">char</span> name[LEN]; <span class="comment">// 储存输出文件名</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s filename\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//设置输入</span></span><br><span class="line"><span class="keyword">if</span> ((in = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"I couldn't open the file \"%s\"\n"</span>,</span><br><span class="line">argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//设置输出</span></span><br><span class="line"><span class="built_in">strncpy</span>(name, argv[<span class="number">2</span>], LEN - <span class="number">5</span>); <span class="comment">// 拷贝文件名</span></span><br><span class="line">name[LEN - <span class="number">5</span>] = <span class="string">'\0'</span>;<span class="comment">//参数LEN-5确保了预留有5个空字符添加.red后缀而不溢出</span></span><br><span class="line"><span class="built_in">strcat</span>(name, <span class="string">".red"</span>); <span class="comment">// 在文件名后添加.red</span></span><br><span class="line"> <span class="keyword">if</span> ((out = fopen(name, <span class="string">"w"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 以写模式打开文件</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create output file.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="comment">//拷贝数据</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getc(in)) != EOF)</span><br><span class="line"><span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">putc(ch, out);<span class="comment">// 打印3个字符中的第1个字符</span></span><br><span class="line"><span class="comment">// 收尾工作</span></span><br><span class="line"><span class="keyword">if</span> (fclose(in) != <span class="number">0</span> || fclose(out) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error in closing files\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设可执行文件名是reducto， 待读取的文件名为eddy， 该文件中包含下面一行内容：</span></span><br><span class="line"><span class="comment">So even Eddy came oven ready.</span></span><br><span class="line"><span class="comment">命令如下：</span></span><br><span class="line"><span class="comment">reducto eddy</span></span><br><span class="line"><span class="comment">待写入的文件名为eddy.red。 该程序把输出显示在eddy.red中， 而不是屏幕上。打开eddy.red， 内容如下：</span></span><br><span class="line"><span class="comment">Send money</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="文件I-O：-fprintf-、-fscanf-、-fgets-和fputs"><a href="#文件I-O：-fprintf-、-fscanf-、-fgets-和fputs" class="headerlink" title="文件I/O： fprintf()、 fscanf()、 fgets()和fputs()"></a>文件I/O： fprintf()、 fscanf()、 fgets()和fputs()</h3><p>文件I/O函数要用FILE指针指定待处理的文件。这些函数都要求用指向 FILE 的指针（如， stdout） 指定一个文件， 或者使用fopen()的返回值   fprintf()和fscanf()函数 </p><h4 id="fprintf-和fscanf-函数"><a href="#fprintf-和fscanf-函数" class="headerlink" title="fprintf()和fscanf()函数"></a>fprintf()和fscanf()函数</h4><p>文件I/O函数fprintf()和fscanf()函数的工作方式与printf()和scanf()类似，区别在于前者需要用第1个参数指定待处理的文件。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">程序清单<span class="number">13.3</span> addaword.c程序</span><br><span class="line"><span class="comment">/* addaword.c -- 使用 fprintf()、 fscanf() 和 rewind() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 41</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">char</span> words[MAX];</span><br><span class="line"><span class="keyword">if</span> ((fp = fopen(<span class="string">"wordy"</span>, <span class="string">"a+"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Can't open \"wordy\" file.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Enter words to add to the file; press the #"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"key at the beginning of a line to terminate."</span>);</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">"%40s"</span>, words) == <span class="number">1</span>) &amp;&amp; (words[<span class="number">0</span>] != <span class="string">'#'</span>))</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"%s\n"</span>, words);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"File contents:"</span>);</span><br><span class="line">rewind(fp); <span class="comment">/* 返回到文件开始处 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, words) == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">puts</span>(words);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error closing file\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fgets-和fputs-函数"><a href="#fgets-和fputs-函数" class="headerlink" title="fgets()和fputs()函数"></a>fgets()和fputs()函数</h4><h4 id="随机访问：-fseek-和ftell"><a href="#随机访问：-fseek-和ftell" class="headerlink" title="随机访问： fseek()和ftell()"></a>随机访问： fseek()和ftell()</h4><p>…待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章：基数知识&quot;&gt;&lt;a href=&quot;#第一章：基数知识&quot; class=&quot;headerlink&quot; title=&quot;第一章：基数知识&quot;&gt;&lt;/a&gt;第一章：基数知识&lt;/h1&gt;&lt;h2 id=&quot;第一节：数据和C&quot;&gt;&lt;a href=&quot;#第一节：数据和C&quot; class=&quot;headerlink&quot; title=&quot;第一节：数据和C&quot;&gt;&lt;/a&gt;第一节：数据和C&lt;/h2&gt;&lt;h3 id=&quot;strlen和sizeof&quot;&gt;&lt;a href=&quot;#strlen和sizeof&quot; class=&quot;headerlink&quot; title=&quot;strlen和sizeof&quot;&gt;&lt;/a&gt;strlen和sizeof&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&quot;stdio.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&quot;string.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; name[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;]=&lt;span class=&quot;string&quot;&gt;&quot;wu&quot;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;strlen= %d,sizeof=%d;&quot;&lt;/span&gt; , &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(name) , &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(name));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回值为：&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注：&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; 运算符， 它以字节为单位给出对象的大小。 &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;()函数给出字符串中的字符长度。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://github.com/SetCalm/setcalm.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>linux环境配置</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/linux环境配置.html</id>
    <published>2018-12-29T09:01:14.000Z</published>
    <updated>2018-12-29T09:01:14.458Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1.移植U-Boot</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/1-%E7%A7%BB%E6%A4%8DU-Boot.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/1-移植U-Boot.html</id>
    <published>2018-12-28T14:52:31.000Z</published>
    <updated>2019-03-03T17:29:14.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移植-U-Boot"><a href="#移植-U-Boot" class="headerlink" title="移植 U-Boot"></a>移植 U-Boot</h2><h3 id="Bootloader-简介"><a href="#Bootloader-简介" class="headerlink" title="Bootloader 简介"></a>Bootloader 简介</h3><a id="more"></a><h4 id="Bootload是什么"><a href="#Bootload是什么" class="headerlink" title="Bootload是什么"></a>Bootload是什么</h4><p>Bootloader是在操作系统运行之前执行的一段小程序。通过这段小程序，我们可以初始化硬件设备（关闭WATCHDOG、改变系统时钟、初始化存储控制器）、建立内存空间的映射表，将更多的代码复制到内存中等，从而建立适当的系统软硬件环境，为最终调用操作系统内核做好准备。 <em>它能将操作系统内核复制到内存中运行，我们将这段程序称为 Bootloader。</em></p><p>①Bootloader 就是这么一小段程序，它在系统上电时开始执行，初始化硬件设备、准备好软件环境，最后调用操作系统</p><p>②我们还可以增强 Bootloader 的功能，比如增加网络功能、从 PC 上通过串口或网络下载文件、烧写文件、将 Flash 上压缩的文件解压后再运行等。</p><p>③Bootloader是基于特定硬件平台来实现的。因此，不可能有一个 Bootloader 支持所有的CPU、所有的电路板。即使是支持 CPU 架构比较多的 U-Boot，也不是一拿来就可以使用的，需要进行一些移植</p><h4 id="Bootloader是如何启动"><a href="#Bootloader是如何启动" class="headerlink" title="Bootloader是如何启动"></a>Bootloader是如何启动</h4><p>CPU 上电后，会从某个地址开始执行。比如 MIPS 结构的 CPU 会从 0xBFC00000 取第一条指令，而 ARM 结构的 CPU 则从地址 0x0000000 开始。嵌入式开发板中，需要把存储器件 ROM 或 Flash 等映射到这个地址，Bootloader 就存放在这个地址开始处，这样一上电就可以执行。<strong><em>(即将Bootloader 存放在0x0000000 这个地址开始处。这样一上电就可以执行Bootloader)</em></strong> </p><p>在开发时，通常可以使用各种命令操作 Bootloader，一般通过串口来连接 PC 和开发板，可以在串口上输入各种命令、观察运行结果等。</p><p>Bootloader 可以分为以下两种操作模式（Operation Mode）。<br>​    （1）启动加载（Boot loading）模式。<br>​    上电后，Bootloader 从板子上的某个固态存储设备上将操作系统加载到 RAM 中运行，整个过程并没有用户的介入。产品发布时，Bootloader 工作在这种模式下。<br>​    （2）下载（Downloading）模式。<br>​    在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（比如内核映象、文件系统映象），将它们直接放在内存运行或是烧入Flash 类固态存储设备中。<br>​    板子与主机间传输文件时，可以使用串口的 xmodem/ymodem/zmodem 协议，它们使用简单，只是速度比较慢；还可以使用网络通过 tftp、nfs 协议来传输，这时，主机上要开启 tftp、nfs 服务；还有其他方法，比如 USB 等。</p><h4 id="Bootloader-在linux中的分区"><a href="#Bootloader-在linux中的分区" class="headerlink" title="Bootloader 在linux中的分区"></a>Bootloader 在linux中的分区</h4><p>嵌入式 Linux 系统从软件的角度通常可以分为以下 4 个层次。</p><p>（1）引导加载程序。</p><p>包括固化在固件（firmware）中的 boot 代码（可选）和 Bootloader两大部分。有些 CPU 在运行 Bootloader 之前先运行一段固化的程序（固件，firmware），比如 x86结构的 CPU 就是先运行 BIOS 中的固件，然后才运行硬盘第一个分区（MBR）中的 Bootloader。在大多嵌入式系统中并没有固件，Bootloader 是上电后执行的第一程序。</p><p>（2）Linux 内核。</p><p>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由 Bootloader 传递给它的。</p><p>（3）文件系统。</p><p>包括根文件系统和建立于 Flash 内存设备之上的文件系统。里面包含了 Linux 系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux 的控制界面的 shell 程序、动态连接的程序运行时需要的 glibc 或 uClibc 库等。</p><p>（4）用户应用程序。<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间 可能还会包括一个嵌入式图形用户界面。常用的嵌入式 GUI 有：Qtopia 和 MiniGUI 等。 </p><p>嵌入系统的典型分区结构如下</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-28_23-39-14.png" alt="Snipaste_2018-12-28_23-39-14"></p><p><strong>“Boot parameters（参数）”</strong>分区中存放一些可设置的参数，比如 IP 地址、串口波特率、要传递给内核的命令行参数等。</p><p>正常启动过程中，Bootloader 首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会挂接（mount）根文件系统（“Root filesystem”），启动文件系统中的应用程序。</p><h4 id="Bootload启动步骤"><a href="#Bootload启动步骤" class="headerlink" title="Bootload启动步骤"></a>Bootload启动步骤</h4><p>汇编阶段 </p><ol><li><p>设置为SVC模式，关闭中断,MMU,看门狗</p></li><li><p>基本硬件设备初始化（初始化时钟，串口，flash,内存等）</p></li><li><p>自搬移到内存</p></li><li><p>设置好栈 跳转到C语言阶段 </p><p>C语言阶段</p></li><li><p>大部分硬件初始化</p></li><li><p>搬移内核到内存后，运行内核</p></li></ol><h4 id="常用-Bootloader-介绍"><a href="#常用-Bootloader-介绍" class="headerlink" title="常用 Bootloader 介绍"></a>常用 Bootloader 介绍</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-29_00-42-38.png" alt="Snipaste_2018-12-29_00-42-38"></p><p>本次使用的 S3C2410 开发板使用的Bootloader为U-Boot 。<br>​    U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p><h3 id="U-Boot-分析与移植"><a href="#U-Boot-分析与移植" class="headerlink" title="U-Boot 分析与移植"></a>U-Boot 分析与移植</h3><h4 id="U-Boot-简介"><a href="#U-Boot-简介" class="headerlink" title="U-Boot 简介"></a>U-Boot 简介</h4><p>U-Boot，全称为 Universal Boot Loader，即通用 Bootloader，是遵循 GPL 条款的开放源代码项目。</p><p><strong>U-Boot 有如下特性</strong></p><p>• 开放源码。</p><p>• 支持多种嵌入式操作系统内核，如 Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS。</p><p>• 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS、XScale。</p><p>• 较高的可靠性和稳定性。</p><p>• 高度灵活的功能设置，适合 U-Boot 调试、操作系统不同引导要求、产品发布等。</p><p>• 丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等。</p><p>• 较为丰富的开发调试文档与强大的网络技术支持。</p><p>• 支持 NFS 挂载、RAMDISK（压缩或非压缩）形式的根文件系统。</p><p>• 支持 NFS 挂载、从 Flash 中引导压缩或非压缩系统内核。</p><p>• 可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对 Linux 支持最为强劲。</p><p>• 支持目标板环境变量多种存储方式，如 Flash、NVRAM、EEPROM。</p><p>• CRC32 校验，可校验 Flash 中内核、RAMDISK 镜像文件是否完好。</p><p>• 上电自检功能：SDRAM、Flash 大小自动检测，SDRAM 故障检测，CPU 型号 。                            </p><p>• 上电自特殊功能：XIP 内核引导 。</p><h4 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h4><p>源码为U-Boot-1.1.6  版本。从 sourceforge 网站下载 U-Boot-1.1.6.tar.bz2后解压即得到全部源码。</p><p>U-Boot-1.1.6 根目录下共有 26 个子目录，可以分为 4 类。</p><p>（1）平台相关的或开发板相关的。<br>​    （2）通用的函数。<br>​    （3）通用的设备驱动程序。<br>​    （4）U-Boot 工具、示例程序、文档 。</p><p>这 26 个子目录的功能与作用如表  </p><p>详细参考：嵌入式Linux应用开发完全手册的15.2.2 U-Boot 源码结构部分</p><h4 id="U-Boot-的配置、编译、连接"><a href="#U-Boot-的配置、编译、连接" class="headerlink" title="U-Boot 的配置、编译、连接"></a>U-Boot 的配置、编译、连接</h4><p>要想了解对于某款开发板，使用哪些文件、哪个文件首先执行、可执行文件占用内存的情况，最好的方法就是阅读它的 Makefile。</p><p>如果要使用开发板 board/&lt;board_name&gt;，就先执行“make &lt;board_name&gt;_config”命令进行配置，然后执行“make all”，就可以生成如下 3个文件。</p><p>• U-Boot.bin：二进制可执行文件，它就是可以直接烧入 ROM、NOR Flash 的文件。<br>​    • U-Boot：ELF 格式的可执行文件。<br>​    • U-Boot.srec：Motorola S-Record 格式的可执行文件。</p><p>例如：S3C2410 的开发板，执行“make smdk2410_config”、“make all”后生成的 U-Boot.bin可以烧入 NOR Flash 中运行</p><h5 id="U-Boot-的配置"><a href="#U-Boot-的配置" class="headerlink" title="U-Boot 的配置"></a>U-Boot 的配置</h5><p>(1). S3C2410 的开发板，执行“make smdk2410_config”</p><p>在顶层 Makefile 中可以看到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SRCTREE := $(CURDIR) </span><br><span class="line">……</span><br><span class="line">MKCONFIG := $(SRCTREE)/mkconfig </span><br><span class="line">……</span><br><span class="line">smdk2410_config : unconfig </span><br><span class="line">  @$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>则其中的 MKCONFIG 就是根目录下的 mkconfig文件。$(@:_config=)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。</p><p>所以“make smdk2410fi”实际上就是执行如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>补充：在 mkconfig 文件开头第 6 行给出了它的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span> # Parameters: Target Architecture CPU Board [VENDOR][SOC]</span><br></pre></td></tr></table></figure><p>对于 S3C2410、S3C2440，它们被称为 SoC(System on Chip)，上面除 CPU 外，还集成了包括 UART、USB 控制器、NAND Flash 控制器等设备（称为片内外设）。S3C2410/S3C2440 中的 CPU 为 ARM920T。</p><p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p><h5 id="U-Boot-的编译、连接"><a href="#U-Boot-的编译、连接" class="headerlink" title="U-Boot 的编译、连接"></a>U-Boot 的编译、连接</h5><p>配置完后，执行“make all”即可编译</p><p><em>详细参考：嵌入式Linux应用开发完全手册的15.2.3 U-Boot 的配置、编译、连接过程部分。</em></p><h5 id="U-Boot-的使用"><a href="#U-Boot-的使用" class="headerlink" title="U-Boot 的使用"></a>U-Boot 的使用</h5><p>U-Boot 则支持大多 CPU，可以烧写 EXT2、JFFS2 文件系统映象，支持串口下载、网络下载，并提供了大量的命令。U-Boot的使用更复杂，但是可以用来更方便地调试程序</p><p>我们知道u-boot，可以运行可是命令，以及支持串口下载、网络下载等功能以方便开发中调式。但这篇文章中并不介绍u-boot 的用法。后续会补充详细 的u-boot常用命令以及开发中如何使用串口和网络下载功能。以及u-boot的实际使用操作。</p><h2 id="移植linux内核"><a href="#移植linux内核" class="headerlink" title="移植linux内核"></a>移植linux内核</h2><p>这部分我们主要了解熟悉linux内核。知道如何给内核打补丁，配置内核及编译内核等内容。</p><p>准备：</p><p>内核源码：2.6.22.6.tar.bz2</p><p>补丁文件：patch-2.6.22.bz2</p><h3 id="内核源码结构分析及Makefile分析"><a href="#内核源码结构分析及Makefile分析" class="headerlink" title="内核源码结构分析及Makefile分析"></a>内核源码结构分析及Makefile分析</h3><h4 id="内核源码结构分析"><a href="#内核源码结构分析" class="headerlink" title="内核源码结构分析"></a>内核源码结构分析</h4><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移植-U-Boot&quot;&gt;&lt;a href=&quot;#移植-U-Boot&quot; class=&quot;headerlink&quot; title=&quot;移植 U-Boot&quot;&gt;&lt;/a&gt;移植 U-Boot&lt;/h2&gt;&lt;h3 id=&quot;Bootloader-简介&quot;&gt;&lt;a href=&quot;#Bootloader-简介&quot; class=&quot;headerlink&quot; title=&quot;Bootloader 简介&quot;&gt;&lt;/a&gt;Bootloader 简介&lt;/h3&gt;
    
    </summary>
    
      <category term="第二阶段" scheme="https://github.com/SetCalm/setcalm.github.io/categories/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>在Linux下写一个简单的驱动程序</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-26-%E5%9C%A8Linux%E4%B8%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-26-在Linux下写一个简单的驱动程序.html</id>
    <published>2018-12-26T15:12:10.000Z</published>
    <updated>2018-12-26T16:46:47.600Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符设备驱动程序之概述</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-25-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%A6%82%E8%BF%B0.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-25-字符设备驱动程序之概述.html</id>
    <published>2018-12-25T13:57:27.000Z</published>
    <updated>2018-12-26T15:11:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux程序启动过程"><a href="#Linux程序启动过程" class="headerlink" title="Linux程序启动过程"></a>Linux程序启动过程</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_22-01-25.png" alt="Snipaste_2018-12-25_22-01-25"></p><p>我们知道：通过U-boot启动内核，内核驱动应用程序。</p><p>应用程序通过open，read，write等API来实现读写文件，点灯，获取按键灯操作。它们是如何实现的呢。</p><p>API与驱动是如何实现对应如下关系的呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open--&gt;led_open</span><br><span class="line">read--&gt;led_read</span><br><span class="line">write--》led_write</span><br></pre></td></tr></table></figure><p>下面简单讨论如何实现的映射关系</p><p>一个简单的应用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   fd=open(<span class="string">"/dev/led"</span>,O_RDWD);</span><br><span class="line">    write(fd1,&amp;val,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    fd2=open(<span class="string">"hello.txt"</span>,O_DWD);</span><br><span class="line">    write(fd2,&amp;va1,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开led的过程</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_22-48-27.png" alt="Snipaste_2018-12-25_22-48-27"></p><p>C库的open是如何进入内核的led.open</p><ol><li><p>open调用实际上是执行一个swi val汇编指令引发异常。当发生异常后，会进入内核的异常处理函数</p></li><li><p>system call Interface（系统调用接口）①根据异常处理函数发生原因val值，调用不同驱动函数（system_open）。</p></li><li><p>VFS(虚拟文件系统)最终根据打开的文件/dev/led）找到相应的驱动程序led_open。</p></li><li><p>执行led_open程序，打开led。</p></li></ol><h2 id="设备调用框架"><a href="#设备调用框架" class="headerlink" title="设备调用框架"></a>设备调用框架</h2><p>   <img src="D:\MyBlog\图片\Snipaste_2018-12-26_00-10-13.png" alt="Snipaste_2018-12-26_00-10-13"></p><ol><li>应用程序调用C库的函数（open，read，write）或直接使用Linux系统调用接口①</li><li>C库函数调(例：open)用实际上是执行一个swi val汇编指令引发异常。当发生异常后，会进入内核的异常处理函数②</li><li>Linux系统调用接口根据异常处理函数发生原因val值，调用VFS中不同驱动函数（system_open）。③</li><li>VFS(虚拟文件系统)最终根据打开文件的属性找到更底层的程序。</li><li>执行驱动程序</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_21-29-57.png" alt="Snipaste_2018-12-26_21-29-57"></p><p>应用层如何调用驱动</p><ol><li><p>应用层：Open(“/dev/xxx”,   )：打开”/dev/xxx”文件，参看属性：字符设备，及主设备号（major）：111。然后根据在VFS找到对应major的结构体;</p></li><li><p>内核层：VFS对应major的结构体保存有入口函数 register_chrdev();信息</p><p>​         register_chrdev()根据major调用相应的file_operations()，</p></li><li><p>驱动层：file调用相应的驱动程序函数led_open();</p></li></ol><p>用户空间</p><p>vfs major</p><p>内核空间</p><p>驱动</p><p>驱动程序：file_open</p><h2 id="驱动程序框架"><a href="#驱动程序框架" class="headerlink" title="驱动程序框架"></a>驱动程序框架</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_23-08-17.png" alt="Snipaste_2018-12-25_23-08-17"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_00-25-20.png" alt="Snipaste_2018-12-26_00-25-20"></p><h3 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h3><p>写出驱动程序led_open，led_write，led_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_leds_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buff, </span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *offp)</span></span>&#123;&#125;</span><br><span class="line">                                         <span class="function"><span class="keyword">static</span> ssize_t <span class="title">s3c24xx_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> * ppos)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>VFS:将驱动程序告诉内核的VFS。</p><p>​    定义一个结构体static struct file_operations()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">s3c24xx_leds_fops</span> = &#123;</span></span><br><span class="line">    .owner  =   THIS_MODULE,    <span class="comment">/* 这是一个宏，推向编译模块时自动创建的__this_module变量 */</span></span><br><span class="line">    .open   =   s3c24xx_leds_open,     </span><br><span class="line">.read=s3c24xx_leds_read,   </span><br><span class="line">.write=s3c24xx_leds_write,   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="system-call-Interface"><a href="#system-call-Interface" class="headerlink" title="system call Interface"></a>system call Interface</h3><p>注册到内核VFS：register_chrdev()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);</span><br></pre></td></tr></table></figure><p>谁调用驱动——&gt;驱动人口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">s3c24xx_leds_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> register_chrdev(LED_MAJOR, DEVICE_NAME, &amp;s3c24xx_leds_fops);<span class="comment">//注册到内核VFS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(s3c24xx_leds_init);<span class="comment">//初始化函数</span></span><br></pre></td></tr></table></figure><p>int register_chrdev（unsigned int major，const char <em> name，struct file_operations </em> fops);</p><p>注册字符设备分配设备名。设备名注册到chrdev结构图内</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-26_01-24-07.png" alt="Snipaste_2018-12-26_01-24-07"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>open(“/dev/led”,O_RDWD);根据设备名major找到驱动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux程序启动过程&quot;&gt;&lt;a href=&quot;#Linux程序启动过程&quot; class=&quot;headerlink&quot; title=&quot;Linux程序启动过程&quot;&gt;&lt;/a&gt;Linux程序启动过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_20
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LS80-UBOOT</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-25-LS80-UBOOT.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-25-LS80-UBOOT.html</id>
    <published>2018-12-24T17:50:08.000Z</published>
    <updated>2018-12-25T13:57:42.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux如何启动"><a href="#linux如何启动" class="headerlink" title="linux如何启动"></a>linux如何启动</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_01-53-36.png" alt="Snipaste_2018-12-25_01-53-36"></p><p>bootload的目的：启动内核</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_04-00-13.png" alt="Snipaste_2018-12-25_04-00-13"></p><ol><li>u-boot功能：</li><li>关看门狗</li><li>初始化时钟</li><li>初始化SDRAM</li><li>从Flash读出内核</li><li>附加功能（开发功能：方便开发）<ul><li>烧写Flash</li><li>网卡</li><li>USB 串口</li></ul></li><li>启动内内核</li></ol><h2 id="u-boot体验"><a href="#u-boot体验" class="headerlink" title="u-boot体验"></a>u-boot体验</h2><p>uboot的四重奏</p><ol><li>解压缩</li><li>打补丁</li><li>配置</li><li>编译</li></ol><h3 id="0-文件"><a href="#0-文件" class="headerlink" title="0.文件"></a>0.文件</h3><p>源文件：u-boot-1.1.6.tar.bz2</p><p>补丁文件：u-boot-1.1.6_jz2440.patch</p><h3 id="1-解压缩"><a href="#1-解压缩" class="headerlink" title="1.解压缩"></a>1.解压缩</h3><p>解压u-boot-1.1.6.tar.bz2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>tar -xjf u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2</span><br><span class="line"><span class="number">2.</span>cd u-boot<span class="number">-1.1</span><span class="number">.6</span></span><br></pre></td></tr></table></figure><h3 id="2-打补丁"><a href="#2-打补丁" class="headerlink" title="2.打补丁"></a>2.打补丁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../u-boot-1.1.6_jz2440.patc</span><br></pre></td></tr></table></figure><ol><li><p>patch：打补丁命令</p></li><li><p>-p1:补丁打在哪里的位置：</p><p>打开u-boot-1.1.6_jz2440.patc</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_02-27-00.png" alt="Snipaste_2018-12-25_02-27-00"></p><p>红色为打补丁位置，因为在u-boot-1.1.6位置所以要忽略u-boot-1.1.6。此时使用-p1表示忽略一级忽略。</p><p>例：-p2：忽略u-boot-1.1.6/board/</p></li><li><p>../u-boot-1.1.6_jz2440.patc为指示补丁文件所在目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ ls<span class="comment">//0.查看源文件，补丁文件</span></span><br><span class="line">u-boot<span class="number">-1.1</span><span class="number">.6</span>_jz2440.patch  u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2</span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ tar -xjf u-boot<span class="number">-1.1</span><span class="number">.6</span>.tar.bz2<span class="comment">//1.解压源文件</span></span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot$ cd u-boot<span class="number">-1.1</span><span class="number">.6</span>/  <span class="comment">//cd 到解压后源文件</span></span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot/u-boot<span class="number">-1.1</span><span class="number">.6</span>$ patch -p1 &lt; ../u-boot<span class="number">-1.1</span><span class="number">.6</span>_jz2440.patch  <span class="comment">//打补丁源文件</span></span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/<span class="number">100</span>ask24x0.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/boot_init.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/config.mk</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/flash.c</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/lowlevel_init.S</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/Makefile</span><br><span class="line">patching file board/<span class="number">100</span>ask24x0/u-boot.lds</span><br><span class="line">patching file board/MAI/bios_emulator/scitech/src/v86bios/lex.l</span><br><span class="line">patching file common/cmd_bootm.c</span><br><span class="line">patching file common/cmd_load.c</span><br><span class="line">patching file common/cmd_menu_bak.c</span><br><span class="line">patching file common/cmd_menu.c</span><br><span class="line">patching file common/cmd_nand.c</span><br><span class="line">patching file common/cmd_nand_legacy.c</span><br><span class="line">patching file common/cmd_suspend.c</span><br><span class="line">patching file common/cmd_usbslave.c</span><br><span class="line">patching file common/env_nand.c</span><br><span class="line">patching file common/main.c</span><br><span class="line">patching file common/Makefile</span><br><span class="line">patching file cpu/arm920t/cpu.c</span><br><span class="line">patching file cpu/arm920t/Makefile</span><br><span class="line">patching file cpu/arm920t/s3c24x0/interrupts.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/Makefile</span><br><span class="line">patching file cpu/arm920t/s3c24x0/nand_flash.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/nand_flash_legacy.c</span><br><span class="line">patching file cpu/arm920t/s3c24x0/speed.c</span><br><span class="line">patching file cpu/arm920t/start.S</span><br><span class="line">patching file cpu/arm920t/suspend.S</span><br><span class="line">patching file doc/README.SBC8560</span><br><span class="line">patching file drivers/cfi_flash.c</span><br><span class="line">patching file drivers/dm9000x.c</span><br><span class="line">patching file drivers/jedec_flash.c</span><br><span class="line">patching file drivers/Makefile</span><br><span class="line">patching file drivers/nand/nand_base.c</span><br><span class="line">patching file drivers/nand/nand_ids.c</span><br><span class="line">patching file drivers/nand/nand_util.c</span><br><span class="line">patching file drivers/nand_legacy/nand_legacy.c</span><br><span class="line">patching file drivers/usb/<span class="number">2440u</span>sb.h</span><br><span class="line">patching file drivers/usb/Makefile</span><br><span class="line">patching file drivers/usb/mrgtmp0</span><br><span class="line">patching file drivers/usb/usb.h</span><br><span class="line">patching file drivers/usb/usbin.c</span><br><span class="line">patching file drivers/usb/usbin.h</span><br><span class="line">patching file drivers/usb/usbinit.c</span><br><span class="line">patching file drivers/usb/usbinit.h</span><br><span class="line">patching file drivers/usb/usblib.c</span><br><span class="line">patching file drivers/usb/usblib.h</span><br><span class="line">patching file drivers/usb/usbmain.c</span><br><span class="line">patching file drivers/usb/usbmain.h</span><br><span class="line">patching file drivers/usb/usbout.c</span><br><span class="line">patching file drivers/usb/usbout.h</span><br><span class="line">patching file drivers/usb/usbsetup.c</span><br><span class="line">patching file drivers/usb/usbsetup.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/mach-types.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/types.h</span><br><span class="line">patching file include/<span class="keyword">asm</span>-arm/u-boot-arm.h</span><br><span class="line">patching file include/configs/<span class="number">100</span>ask24x0.h</span><br><span class="line">patching file include/configs/SBC8560.h</span><br><span class="line">patching file include/def.h</span><br><span class="line">patching file include/flash.h</span><br><span class="line">patching file include/nand.h</span><br><span class="line">patching file include/s3c2410.h</span><br><span class="line">patching file include/s3c24x0.h</span><br><span class="line">patching file include/usb.h</span><br><span class="line">patching file lib_arm/armlinux.c</span><br><span class="line">patching file lib_arm/board.c</span><br><span class="line">patching file Makefile</span><br><span class="line">patching file net/net.c</span><br><span class="line">jeff@ubuntu:~/<span class="number">1.</span>my_code/boot/u-boot<span class="number">-1.1</span><span class="number">.6</span>$</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="number">100</span>ask24x0_config</span><br></pre></td></tr></table></figure><h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>按上面执行即可获得u-boot.bin文件</p><h3 id="设置u-boot环境变量"><a href="#设置u-boot环境变量" class="headerlink" title="设置u-boot环境变量"></a>设置u-boot环境变量</h3><p>如下图4步走：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">100</span>ask Bootloader <span class="keyword">for</span> OpenJTAG #####</span><br><span class="line">[n] Download u-boot to Nand Flash</span><br><span class="line">[o] Download u-boot to Nor Flash</span><br><span class="line">[c] Re-scan Nor Flash</span><br><span class="line">[u] Copy bootloader from nand to nor</span><br><span class="line">[v] Copy bootloader from nor to nand</span><br><span class="line">[k] Download Linux kernel uImage</span><br><span class="line">[j] Download root_jffs2 image</span><br><span class="line">[y] Download root_yaffs image</span><br><span class="line">[d] Download to SDRAM &amp; Run</span><br><span class="line">[z] Download zImage into RAM</span><br><span class="line">[g] Boot linux from RAM</span><br><span class="line">[f] Format the Nand Flash</span><br><span class="line">[s] Set the boot parameters</span><br><span class="line">[b] Boot the system</span><br><span class="line">[r] Reboot u-boot</span><br><span class="line">[q] Quit from menu</span><br><span class="line">Enter your selection: q <span class="comment">//1.退出</span></span><br><span class="line">OpenJTAG&gt; print  <span class="comment">//2.打印Uboot环境</span></span><br><span class="line">bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,<span class="number">115200</span></span><br><span class="line">bootcmd=nand read.jffs2 <span class="number">0x30007FC0</span> kernel; bootm <span class="number">0x30007FC0</span></span><br><span class="line">baudrate=<span class="number">115200</span></span><br><span class="line">ethaddr=<span class="number">08</span>:<span class="number">00</span>:<span class="number">3</span>e:<span class="number">26</span>:<span class="number">0</span>a:<span class="number">5b</span></span><br><span class="line">ipaddr=<span class="number">192.168</span><span class="number">.1</span><span class="number">.17</span></span><br><span class="line">serverip=<span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">netmask=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">mtdids=nand0=nandflash0</span><br><span class="line">mtdparts=mtdparts=nandflash0:<span class="number">256</span>k@<span class="number">0</span>(bootloader),<span class="number">128</span>k(params),<span class="number">2</span>m(kernel),-(root)</span><br><span class="line">bootdelay=<span class="number">5</span></span><br><span class="line"><span class="built_in">stdin</span>=serial</span><br><span class="line"><span class="built_in">stdout</span>=serial</span><br><span class="line"><span class="built_in">stderr</span>=serial</span><br><span class="line">partition=nand0,<span class="number">0</span></span><br><span class="line">mtddevnum=<span class="number">0</span></span><br><span class="line">mtddevname=bootloader</span><br><span class="line"></span><br><span class="line">Environment size: <span class="number">450</span>/<span class="number">131068</span> bytes</span><br><span class="line">OpenJTAG&gt; <span class="built_in">set</span> bootdelay <span class="number">10</span> <span class="comment">//3.重新配置启动计数时间</span></span><br><span class="line">OpenJTAG&gt; save <span class="comment">//4，保存</span></span><br><span class="line">Saving Environment to NAND...</span><br><span class="line">Erasing Nand...Writing to Nand... done</span><br><span class="line">OpenJTAG&gt;</span><br><span class="line">penJTAG&gt; reset<span class="comment">//5.复位重启</span></span><br></pre></td></tr></table></figure><h3 id="分析make-100ask24x0-config"><a href="#分析make-100ask24x0-config" class="headerlink" title="分析make 100ask24x0_config"></a>分析make 100ask24x0_config</h3><p>打开Makefile找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>ask24x0_config:unconfig</span><br><span class="line">@$(MKCONFIG) $(@:_config=) arm arm920t <span class="number">100</span>ask24x0 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure><p>执行：make 100ask24x0_config</p><p>等于执行：@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0脚本语句。</p><p>分析：@$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0</p><ol><li><p>MKCONFIG    := $(SRCTREE)/mkconfig //源文件所在的目录下的mkconfig</p></li><li><p>$(@:_config=)  100ask24x0_config</p><p>$(@   $:当前目标即100ask24x0_config</p><p>:_config= 表示替换空</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_05-15-26.png" alt="Snipaste_2018-12-25_05-15-26"></p></li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-25_05-31-01.png" alt="Snipaste_2018-12-25_05-31-01"></p><p>向mkconfig传递$1~$6参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux如何启动&quot;&gt;&lt;a href=&quot;#linux如何启动&quot; class=&quot;headerlink&quot; title=&quot;linux如何启动&quot;&gt;&lt;/a&gt;linux如何启动&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_2018-12-25
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-12-21-LS7-4-UART</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-LS7-4-UART.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-LS7-4-UART.html</id>
    <published>2018-12-21T13:11:40.000Z</published>
    <updated>2018-12-24T14:30:56.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="usart功能："><a href="#usart功能：" class="headerlink" title="usart功能："></a>usart功能：</h3><p>打印调式信息</p><p>外接各种模块：gps，蓝牙，WiFi….</p><p>结构简单，可靠。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_21-17-33.png" alt="Snipaste_2018-12-21_21-17-33"></p><h3 id="简单协议"><a href="#简单协议" class="headerlink" title="简单协议"></a>简单协议</h3><p>波特率</p><p>数据格式：数据位，停止位，校验位，流量控制。</p><p>如何发送字节</p><p>假如要发送一个字节’A’;</p><p>‘A’ :0x41:0b01000001</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-22-10.png" alt="Snipaste_2018-12-21_22-22-10"></p><p>①双方约定好每一位占据的时间（波特率）</p><p>​    假设每一单位时间ts，（t=1/baud（s））</p><p>②开始时txd为高电平，当开始发送数据时把数据线拉低，计时1t（s）为开始位。</p><p>③写：ARM根据数据’A’驱动TXD的电平</p><p>   读：通过在数据的中间时间段读取电平</p><p>当8位数据发送完毕，再发送一个检验位（奇/偶检验），但随着技术提高现在几乎都为0，不校验。</p><p>④一个字节（8bit）完成后发送一个停止位（高电平，一般设置占据1/1.5/2t（s）时间）。传送完成，此时txd高电平空闲状态，等待开始下个字节发送。</p><h3 id="关于逻辑电平表示"><a href="#关于逻辑电平表示" class="headerlink" title="关于逻辑电平表示"></a>关于逻辑电平表示</h3><p>1.TTL/CMOS表示</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-26-58.png" alt="Snipaste_2018-12-21_22-26-58"></p><p>0~0.7 (y) v表示逻辑“0”，x（2）~5v表示逻辑“1”</p><p>2.RS232表示</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-28-24.png" alt="Snipaste_2018-12-21_22-28-24"></p><p>+3~012v表示逻辑“0”，-3~-12v表示逻辑“1”</p><p>总结：cmos/ttl电平范围（0~5v）小，传输距离近，RS-232电平范围（-12~+12v）大，可以距离远。一般远距离使用RS232。</p><p>cmos/ttl和rs232电平波形相反。</p><h3 id="常见串口接口"><a href="#常见串口接口" class="headerlink" title="常见串口接口"></a>常见串口接口</h3><h4 id="直接引出"><a href="#直接引出" class="headerlink" title="直接引出"></a>直接引出</h4><h4 id="RS232接口、RS485"><a href="#RS232接口、RS485" class="headerlink" title="RS232接口、RS485"></a>RS232接口、RS485</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-44-39.png" alt="Snipaste_2018-12-21_22-44-39"></p><h4 id="usb接口"><a href="#usb接口" class="headerlink" title="usb接口"></a>usb接口</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_22-44-49.png" alt="Snipaste_2018-12-21_22-44-49"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>参考：<a href="https://www.cnblogs.com/Ph-one/p/3994797.html" target="_blank" rel="noopener">USB/232/485/TTL/CMOS（串口通信）</a></p><p>1.USB:电脑的USB口信号时USB信号，为差分信号，电压范围：+400mV~-400mV间变化；直流电压5V 驱动电流500MA</p><p>2.232电平：　　逻辑1(MARK)=-3V～-15V　　逻辑0(SPACE)=+3～+15V</p><p>3.485电平：　　它是<a href="http://www.baidu.com/s?wd=%E5%B7%AE%E5%88%86%E4%BF%A1%E5%8F%B7&amp;hl_tag=textlink&amp;tn=SE_hldp01350_v6v6zkg6" target="_blank" rel="noopener">差分信号</a>，两信号线 ＋2V～＋6V表示“0”，　　- 6V～- 2V表示“1”。</p><p>4.TTL电平：　　一般输出高电平是3.5V，输出低电平是0.2V。</p><p>5.CMOS  ：　　门闩值为0.3VCC和0.7VCC，比如对于5V供电器件，分别为1.5V和3.5V（大概）</p><p>对于TTL器件和CMOS器件相连，如果是CMOS器件输出到TTL器件，这个也是可以直接连的，因为CMOS电平的范围是TTL输入电平范围的子集。但如果反过来就不行，因为TTL电平的输出范围要比CMOS电平的范围大，有可能出现不确定的电平状态,引起电路出现不可预知的混乱。</p><h3 id="UART-结构框图"><a href="#UART-结构框图" class="headerlink" title="UART 结构框图"></a>UART 结构框图</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_23-01-04.png" alt="Snipaste_2018-12-21_23-01-04"></p><p>程序是如何把内存的数据发送到串口？</p><p>程序把内存的数据写入FITO(先进先出)存储器内，uart单元会把FIFI的数据写入移位器（Transmit Shifiter），然后移位器（Transmit Shifiter）按照设置好协议逐位发送给串口。</p><p>当内存接收完毕，uart单元产生中断给CPU</p><p>程序是如何接收串口的数据写到串口？</p><p>uart单元会逐位接收串口的数据，然后把接收到的数据写入移位器（Receiver Shifiter）内，然后程序会把FITO(先进先出)存储器内的数据写入内存。</p><p>当内存接收完毕，uart单元产生中断给CPU</p><h2 id="软件编程"><a href="#软件编程" class="headerlink" title="软件编程"></a>软件编程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>设置引脚用于串口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置引脚用于串口 */</span></span><br><span class="line"><span class="comment">/* GPH2,3用于TxD0, RxD0 */</span></span><br><span class="line">GPHCON&amp;=~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON&amp;=~((<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line"><span class="comment">//上拉</span></span><br><span class="line">GPHUP!=((<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">3</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置波特率</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-11-56.png" alt="Snipaste_2018-12-24_21-11-56"></p></li></ol><p>​    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置波特率 */</span></span><br><span class="line"><span class="comment">/* UBRDIVn = (int)( UART clock / ( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment"> *  UART clock = 50M</span></span><br><span class="line"><span class="comment"> *  UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 设置使用PCLK时钟50MHZ,中断/查询模式 */</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure><p>​    3.设置数据格式 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置数据格式 */</span></span><br><span class="line"></span><br><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure><p>uart0_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 115200,8n1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置引脚用于串口 */</span></span><br><span class="line"><span class="comment">/* GPH2,3用于TxD0, RxD0 */</span></span><br><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置波特率 */</span></span><br><span class="line"><span class="comment">/* UBRDIVn = (int)( UART clock / ( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment"> *  UART clock = 50M</span></span><br><span class="line"><span class="comment"> *  UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* PCLK,中断/查询模式 */</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置数据格式 */</span></span><br><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位, 无较验位, 1个停止位 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-46-03.png" alt="Snipaste_2018-12-24_21-46-03"></p><p><strong>输入字节</strong></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_21-46-15.png" alt="Snipaste_2018-12-24_21-46-15"></p><p>由上可知：判断是否有数据：当上面该位为0，UTXH0寄存器里面有数据，等待发送，为1时：数据发送出去，为空，此时写入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UTRSTAT0 */</span></span><br><span class="line"><span class="comment">/* UTXH0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</span><br></pre></td></tr></table></figure><p>注意在上c2440_soc.h中添加</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_22-11-30.png" alt="Snipaste_2018-12-24_22-11-30"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-24_22-11-12.png" alt="Snipaste_2018-12-24_22-11-12"></p><p>UTXH0地址为0向0000020（L）</p><p>数据格式为byte</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     __REG_BYTE(x)(*(volatile unsigned char *)(x)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     UTXH0                    __REG_BYTE(0x50000020)  <span class="comment">//UART 0 transmission hold</span></span></span><br></pre></td></tr></table></figure><p><strong>输出字节：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出字符串：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">putchar</span>(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* UTRSTAT0 */</span></span><br><span class="line"><span class="comment">/* UTXH0 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;h3 id=&quot;usart功能：&quot;&gt;&lt;a href=&quot;#usart功能：&quot; class=&quot;headerlink&quot; title=&quot;u
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-21-LS7-4-ARM芯片时钟体系</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-2018-12-21-LS7-4-ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-2018-12-21-LS7-4-ARM芯片时钟体系.html</id>
    <published>2018-12-21T13:10:58.000Z</published>
    <updated>2018-12-24T17:48:13.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LS6-3.ARM芯片时钟体系</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-21-LS6-3-ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-21-LS6-3-ARM芯片时钟体系.html</id>
    <published>2018-12-20T16:03:42.000Z</published>
    <updated>2018-12-21T13:13:06.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时钟体系架构"><a href="#时钟体系架构" class="headerlink" title="时钟体系架构"></a>时钟体系架构</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-10-02.png" alt="Snipaste_2018-12-21_00-10-02"></p><p>cpu：fclk</p><p>AHB:高速总线（HCLK）</p><p>APB:低速总线（PCLK）</p><h3 id="时钟最大范围"><a href="#时钟最大范围" class="headerlink" title="时钟最大范围"></a>时钟最大范围</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-14-33.png" alt="Snipaste_2018-12-21_00-14-33"></p><h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>可以通过①外部引脚提供和②晶振提供</p><h2 id="JZ2240开发板时钟选择"><a href="#JZ2240开发板时钟选择" class="headerlink" title="JZ2240开发板时钟选择"></a>JZ2240开发板时钟选择</h2><h3 id="jz2240时钟源"><a href="#jz2240时钟源" class="headerlink" title="jz2240时钟源"></a>jz2240时钟源</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-22-05.png" alt="Snipaste_2018-12-21_00-22-05"></p><p>时钟源可以由外部引脚提供或者12M晶振提供，通过OM[3:2]选择使用哪个作为时钟源，选择方式如下：</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-26-49.png" alt="Snipaste_2018-12-21_00-26-49"></p><h3 id="JZ2240开发板时钟选择-1"><a href="#JZ2240开发板时钟选择-1" class="headerlink" title="JZ2240开发板时钟选择"></a>JZ2240开发板时钟选择</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-28-56.png" alt="Snipaste_2018-12-21_00-28-56"></p><p>图中看出OM[3:2]都为00:注时钟源和USB时钟源都为12M晶振。</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-18-58.png" alt="Snipaste_2018-12-21_00-18-58"></p><p>三者时钟源由12M晶振提供，通过PLL(锁相环)来倍频得到FCLK：400Mhz</p><h3 id="JZ2240时钟分析"><a href="#JZ2240时钟分析" class="headerlink" title="JZ2240时钟分析"></a>JZ2240时钟分析</h3><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-41-25.png" alt="Snipaste_2018-12-21_00-41-25"></p><ul><li><p>由①OM[3,2]选择②MPLL（主时钟源）,③UPLL（USB时钟源）的时钟源，这里OM[3,2]=00，选择MPLL，UPLL时钟为OSC（外部12M晶振）（硬件）。</p></li><li><p>时钟源通过②MPLL锁相环倍频得到⑦FCLK：400Mmz,</p></li><li><p>通过CLKCNTL获的⑤HCLK,⑥PCLK时钟</p><p>FCLK：提供给CPU</p><p>HCLK:AHB(高速总线)</p><p>PCLK:APB(低速总线)</p></li></ul><h2 id="时钟系统总结"><a href="#时钟系统总结" class="headerlink" title="时钟系统总结"></a>时钟系统总结</h2><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_00-53-58.png" alt="Snipaste_2018-12-21_00-53-58"></p><h2 id="软件编程"><a href="#软件编程" class="headerlink" title="软件编程"></a>软件编程</h2><h3 id="时钟设置原理"><a href="#时钟设置原理" class="headerlink" title="时钟设置原理"></a>时钟设置原理</h3><p>通过控制MPLL，HDIV和PDIV</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_01-10-41.png" alt="Snipaste_2018-12-21_01-10-41"></p><ol><li>电源启动，复位引脚维持一段时间等待电源稳定，才输出高电平。（专用复位芯片会使复位脚等待一段时间才会高电平）</li><li>根据OM[3:2]=00,选择FCLK=12Mhz晶振提供时钟，此时CPU未运行。</li><li>等复位脚松开高电平时，cpu开始运行。此时PLL锁存OM[3:2]的值</li><li>设置PLL，此时CPU停止工作，</li><li>PLL开始工作，等待PLL输出稳定频率，CPU 开始运行</li></ol><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_19-53-38.png" alt="Snipaste_2018-12-21_19-53-38"></p><p>我们要设置S3C2440的FCLK=400Mhz，HCLK=100Mhz，PCLK=50Mhz</p><p>1.使  FCLK=400M:通过MPLLCON设置。</p><p>2.使HCLK=100Mhz，PCLK=50Mhz：设置CLKDIV</p><p>HCLK=FCLK/4</p><p>PCLK=FCLK/8=HCLK/2</p><h3 id="如何设置系统设置"><a href="#如何设置系统设置" class="headerlink" title="如何设置系统设置"></a>如何设置系统设置</h3><p>如何通过程序控制MPLL，HDIV和PDIV</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>1.使  FCLK=400M:通过MPLLCON设置</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-22-49.png" alt="Snipaste_2018-12-21_20-22-49"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-27-42.png" alt="Snipaste_2018-12-21_20-27-42"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-24-14.png" alt="Snipaste_2018-12-21_20-24-14"></p><p>从图看出要使FCLK=400M:<strong>MPLLCON=(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</strong></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>2.使HCLK=100Mhz，PCLK=50Mhz：设置CLKDIV</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-10-08.png" alt="Snipaste_2018-12-21_20-10-08"></p><p>HCLK=FCLK/4:CLKDIVN[2:1]=0b10</p><p>PCLK=FCLK/8=HCLK/2:CLKDIVN[0]=1</p><p>即：CLKDIVN=0b101=0x05  FCLK:HCLK:PCLK=1:4：8</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p><img src="D:\MyBlog\图片\Snipaste_2018-12-21_20-46-14.png" alt="Snipaste_2018-12-21_20-46-14"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该命令是使处理器工作在异步模式下，</p><p>HDIV不等于0 ，需要设置在异步模式，否则CPU工作在HCLK=100时钟。</p><h3 id="开编程"><a href="#开编程" class="headerlink" title="开编程"></a>开编程</h3><p>由于时钟使用到汇编的协处理器指令，所以时钟程序使用汇编来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span></span><br><span class="line"><span class="comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000000</span></span><br><span class="line">ldr r1, =<span class="number">0xFFFFFFFF</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000014</span></span><br><span class="line">ldr r1, =<span class="number">0x5</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置CPU工作于异步模式 */</span></span><br><span class="line">mrc p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line">orr r0,r0,#<span class="number">0xc0000000</span>   <span class="comment">//R1_nF:OR:R1_iA</span></span><br><span class="line">mcr p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span></span><br><span class="line"><span class="comment"> *  m = MDIV+8 = 92+8=100</span></span><br><span class="line"><span class="comment"> *  p = PDIV+2 = 1+2 = 3</span></span><br><span class="line"><span class="comment"> *  s = SDIV = 1</span></span><br><span class="line"><span class="comment"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r0, =<span class="number">0x4C000004</span></span><br><span class="line">ldr r1, =(<span class="number">92</span>&lt;&lt;<span class="number">12</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span></span><br><span class="line"><span class="comment"> * 然后CPU工作于新的频率FCLK</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时钟体系架构&quot;&gt;&lt;a href=&quot;#时钟体系架构&quot; class=&quot;headerlink&quot; title=&quot;时钟体系架构&quot;&gt;&lt;/a&gt;时钟体系架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;D:\MyBlog\图片\Snipaste_2018-12-21_00-10-02.pn
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-20-LS5-2.key之led控制.md</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-20-LS5-2-key%E4%B9%8Bled%E6%8E%A7%E5%88%B6.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-20-LS5-2-key之led控制.html</id>
    <published>2018-12-20T09:39:31.000Z</published>
    <updated>2018-12-20T16:01:30.495Z</updated>
    
    <content type="html"><![CDATA[<p>简介：</p><p>通过开发板上的S2,S3,S4控制D10,D11,D12的亮灭</p><ul><li>按下S2，D10亮；松开S2，D10灭。</li><li>按下S3，D11亮；松开S3，D11灭。</li><li>按下S4，D12亮；松开S4，D12灭。</li></ul><p>原理图：</p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-12-16.png" alt="Snipaste_2018-12-20_18-12-16"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-11-19.png" alt="Snipaste_2018-12-20_18-11-19"></p><p><img src="D:\MyBlog\图片\Snipaste_2018-12-20_18-09-17.png" alt="Snipaste_2018-12-20_18-09-17"></p><p>通过原理图看出S2(GPF0)，S3(GPF2)，S4(GPG3)。D10(GPF4)，D11(GPF5)，D12(GPF6).</p><p>当按键松开时为高电平，按下为低电平。</p><p>当D10~D12输出低电平时亮，高电平时，灭</p><p>软件编程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * key控制LED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s3c2440_soc.h"</span><span class="comment">//引入头文件，寄存器定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val1;</span><br><span class="line"><span class="keyword">int</span> val2;</span><br><span class="line"><span class="comment">/*配置GPF4/5/6为输出引脚*/</span></span><br><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">12</span>));</span><br><span class="line">GPFCON |=  ((<span class="number">1</span>&lt;&lt;<span class="number">8</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*配置GPF0/2，GPG3为输入引脚*/</span></span><br><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">val1=GPFDAT;<span class="comment">//保存GPFDAT的值</span></span><br><span class="line">val2=GPGDAT;<span class="comment">//保存GPGDAT的值</span></span><br><span class="line"><span class="keyword">if</span>(val1&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val1&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val2&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>))<span class="comment">//判断val1的4bit是0还是1，是1，松开</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT|=(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPFDAT&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介：&lt;/p&gt;
&lt;p&gt;通过开发板上的S2,S3,S4控制D10,D11,D12的亮灭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按下S2，D10亮；松开S2，D10灭。&lt;/li&gt;
&lt;li&gt;按下S3，D11亮；松开S3，D11灭。&lt;/li&gt;
&lt;li&gt;按下S4，D12亮；松开S4，D12灭。&lt;
      
    
    </summary>
    
      <category term="S3C244裸机开发" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-%E9%98%BF%E9%87%8C%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-阿里图床测试.html</id>
    <published>2018-12-19T20:06:41.821Z</published>
    <updated>2018-12-20T06:21:11.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里图床测试"><a href="#阿里图床测试" class="headerlink" title="阿里图床测试"></a>阿里图床测试</h1><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_23-31-14.png" alt="Snipaste_2018-12-20_03-19-45"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阿里图床测试&quot;&gt;&lt;a href=&quot;#阿里图床测试&quot; class=&quot;headerlink&quot; title=&quot;阿里图床测试&quot;&gt;&lt;/a&gt;阿里图床测试&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://setcalm.oss-cn-zhangjiakou.aliyuncs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018-12-14-LS1-开发之系统安装</title>
    <link href="https://github.com/SetCalm/setcalm.github.io/blog%EF%BC%88%E9%87%8D%E8%A6%81%E4%BF%9D%E7%95%99%EF%BC%89-2018-12-18-LS2-%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <id>https://github.com/SetCalm/setcalm.github.io/blog（重要保留）-2018-12-18-LS2-开发之系统安装.html</id>
    <published>2018-12-18T09:51:48.000Z</published>
    <updated>2018-12-20T06:20:58.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="烧录软件安装"><a href="#烧录软件安装" class="headerlink" title="烧录软件安装"></a>烧录软件安装</h2><h3 id="EasyOpenJTAG介绍及安装程序"><a href="#EasyOpenJTAG介绍及安装程序" class="headerlink" title="EasyOpenJTAG介绍及安装程序"></a>EasyOpenJTAG介绍及安装程序</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><a id="more"></a><p>该部分为win 8,10 系统需要设置，非win 8,10 系统略过。 </p><p>由于 Windows10 的安全机制，安装 EasyOpenJTAG 更麻烦一点： 需要更改 Windows 的<br>启动模式， 禁用“驱动程序签名强制”功能。</p><p>详细教程：<a href="https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/375c8e19c2b25b25f2a229a3.html</a></p><p>点击桌面右下角的通知图标，选择“所有设置”，如图 4.11 所示。然后选择“更新和安全”，如图 4.12 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-50-55.png" alt="Snipaste_2018-12-17_17-50-55"></p><p>(1) 选择左边选项栏中的“恢复”，选择高级启动的“立即重启”，然后选择“更新和安全”，如图 4.13 所示。然后选择“疑难解答”，如图 4.14 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-52-03.png" alt="Snipaste_2018-12-17_17-52-03"></p><p>(2) 接着在“高级选项”里选择“启动设置”，如图 4.15 所示。在“启动设置”里面选择重启，如图 4.16 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-47-16.png" alt="Snipaste_2018-12-17_17-47-16">(3) 此时电脑会重启，重启之后不会直接进入系统界面，而是进入图 4.17 所示的“启<br>动设置“界面，按下键盘的” F7“，禁用驱动程序强制签名。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_17-52-59.png" alt="Snipaste_2018-12-17_17-52-59"></p><p>如下步骤是正常的驱动安装流程，非 win 8,10 系统(比如 winxp,win7 系统)直接从这里开始。 </p><h4 id="2-开始安装-EasyOpenJTAG驱动"><a href="#2-开始安装-EasyOpenJTAG驱动" class="headerlink" title="2.开始安装 EasyOpenJTAG驱动"></a>2.开始安装 EasyOpenJTAG驱动</h4><p>(1) 将 EasyOpenJTAG 插入电脑 USB 口。打开“设备管理器”。在设备管理器可以看到两个感叹号图标的设备，这表示 EasyOpenJTAG 未安装驱动。 选中第一个带感叹号的设备，右键鼠标，在弹出的菜单中选择“更新驱动程序”，如图 所示</p><p> <img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-17_18-07-57.png" alt="Snipaste_2018-12-17_18-07-57"></p><p>(2) 选择“浏览我的计算机以查找驱动程序软件”再选择驱动程序的路径，点击“下一步”，如图 4.21 所示。在弹出的 Windows 安全警告窗口里，选择“始终安装此驱动程序软件”，如图 4.22 所示 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_15-50-26.png" alt="Snipaste_2018-12-18_15-50-26"></p><p>（4）之后看到如图 4.23 所示的安装成功提示信息。同样的方法，点击第二个带感叹号的<br>设备。 这样一共重复三次即可更新完所有驱动，驱动安装好后设备管理器显示:一个“ US B<br>Serial Port” ,一个“100ASK JTAG”，一个“100ASK Serial Port”，如图 4.24 所示。 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_15-52-39.png" alt="Snipaste_2018-12-18_15-52-39"></p><p>（安装完成）</p><h4 id="3-安装-EasyOpenJTAG应用程序-（oflash）"><a href="#3-安装-EasyOpenJTAG应用程序-（oflash）" class="headerlink" title="3.安装 EasyOpenJTAG应用程序 （oflash）"></a>3.安装 EasyOpenJTAG应用程序 （oflash）</h4><p> （1） 双击“01.OpenOCD with GUI setup.exe “一路OK，就完成。【略】</p><p>（2）测试是否安装成功。 </p><p>打开 Windows 命令窗口，如图 4.9 所示。 在窗口输入“oflash”命令即可启动 oflash，如图 4.10 所示即表示安装成功 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_16-05-24.png" alt="Snipaste_2018-12-18_16-05-24"></p><h4 id="4-失败解决方法"><a href="#4-失败解决方法" class="headerlink" title="4.失败解决方法"></a>4.失败解决方法</h4><p>无法找到某环境，配置环境变量。</p><p>找到OpenJTAG的bin 目录，将其按照下面加入环境变量。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_16-21-55.png" alt="Snipaste_2018-12-18_16-21-55"></p><h3 id="EasyOpenJTAG烧录程序"><a href="#EasyOpenJTAG烧录程序" class="headerlink" title="EasyOpenJTAG烧录程序"></a>EasyOpenJTAG烧录程序</h3><ul><li>用于烧录.bin文件（uboot.bin，裸板程序），只能烧小文件，速度极慢。 </li><li>uboot文件可以烧录到–&gt;Nor,Nand。裸板文件只能烧录到–&gt;Nand。</li></ul><h4 id="烧录leds-bin文件（cmd下oflash）"><a href="#烧录leds-bin文件（cmd下oflash）" class="headerlink" title="烧录leds.bin文件（cmd下oflash）"></a>烧录leds.bin文件（cmd下oflash）</h4><ul><li><p>选择启动方式：Nand启动</p></li><li><p>选择要烧录的.bin 文件路径。</p><p>（D:\韦东山\1_ARM裸机1期加强版(新1期)\源码文档图片\源码\源码<em>20180321</em>添加传感器\001_led_on_008_003）</p></li><li><p>开始oflash烧录</p></li></ul><ol><li>打开cmdwindows+R：选择烧录文件盘符：D</li><li>cd 到烧录目录：cd:D:\韦东山\1_ARM裸机1期加强版(新1期)\源码文档图片\源码\源码<em>20180321</em>添加传感器\001_led_on_008_003</li><li>启动oflash并选择烧录.bin文件：oflash led_on.bin</li><li>选择烧录工具：enter the number：0</li><li>选择烧录芯片：enter the number：1</li><li>选择烧录地址：select the function to test：0（裸机文件只能从Nand启动）</li><li>再次确认烧录地址：select the function to test：0</li><li>烧录到第0块：input target block number：0</li></ol><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_17-15-08.png" alt="Snipaste_2018-12-18_17-15-08"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_17-21-51.png" alt="Snipaste_2018-12-18_17-21-51"></p><p>烧录成功ok.</p><p>拔掉OpenJTGA,重启开发板，观察led。</p><p>使用usbshaolu</p><h2 id="如何烧录系统"><a href="#如何烧录系统" class="headerlink" title="如何烧录系统"></a>如何烧录系统</h2><p>我们知道使用OpenJTGA烧录一个Uboot文件用了几分钟，烧写速度非常的慢。在实际开发中经常要修改编译，那有没有更快的烧写方法呢。因此引入使用Uboot通过usb烧写bin 文件。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Windows和linux系统启动比较"><a href="#Windows和linux系统启动比较" class="headerlink" title="Windows和linux系统启动比较"></a>Windows和linux系统启动比较</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-55-36.png" alt="Snipaste_2018-12-18_18-55-36"></p><p>图1-1</p><h4 id="jz2440v3的flash介绍"><a href="#jz2440v3的flash介绍" class="headerlink" title="jz2440v3的flash介绍"></a>jz2440v3的flash介绍</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-58-23.png" alt="Snipaste_2018-12-18_18-58-23"></p><p>图1-2</p><p>　Bootloader 即引导加载程序，是系统加电后运行的第一段<a href="https://www.baidu.com/s?wd=%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">软件代码</a>。简单的说u-boot是bootloader，它们所完成的任务也大同小异。</p><p>uboot可以烧录在Nor，Nand 上，一般u-boot烧录在Nor，用于系统启动引导。</p><p>Nand比较大，内核及文件系统存在于Nand Flash</p><h4 id="jz2440烧录框架"><a href="#jz2440烧录框架" class="headerlink" title="jz2440烧录框架"></a>jz2440烧录框架</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-45-45.png" alt="Snipaste_2018-12-18_18-45-45"></p><ol><li>将启动设置在Nor启动</li><li>将u-boot烧录在到Nor Flsh上</li><li>开机，Nor启动，uboot启动</li><li>使用uboot的usb下载功能，使用pc传文件给开发板（kernel及rootfs）</li><li>uboot收到文件后再烧录到flash</li></ol><h4 id="如何烧录系统-1"><a href="#如何烧录系统-1" class="headerlink" title="如何烧录系统"></a>如何烧录系统</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-59-59.png" alt="Snipaste_2018-12-18_18-59-59"></p><p>图1-3</p><ol><li>通过op、eop烧录U-boot到Nor</li><li>通过usb烧录Kernel和文件系统。</li></ol><h2 id="开始烧录系统"><a href="#开始烧录系统" class="headerlink" title="开始烧录系统"></a>开始烧录系统</h2><h3 id="设置启动方式"><a href="#设置启动方式" class="headerlink" title="设置启动方式"></a>设置启动方式</h3><p>将启动设置在Nor启动</p><h3 id="将u-boot烧录在到Nor-Flsh上"><a href="#将u-boot烧录在到Nor-Flsh上" class="headerlink" title="将u-boot烧录在到Nor Flsh上"></a>将u-boot烧录在到Nor Flsh上</h3><p>参考：上面<strong>EasyOpenJTAG烧录程序</strong></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-12-07.png" alt="Snipaste_2018-12-18_18-12-07"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_18-13-24.png" alt="Snipaste_2018-12-18_18-13-24"></p><p>## </p><h3 id="开机，Nor启动，uboot启动"><a href="#开机，Nor启动，uboot启动" class="headerlink" title="开机，Nor启动，uboot启动"></a>开机，Nor启动，uboot启动</h3><p>拔掉OpenJTAG,设置Nor启动，连接usb及com到pc，使用MobaXterm打开串口，重新启动。</p><p>让开发板运行于 UBOOT，不要让它启动进入内核（在 UBOOT 启动时在串口<br>工具里按下空格【计数三秒内】，阻止它启动 Linux ）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_20-43-46.png" alt="Snipaste_2018-12-18_20-43-46"></p><h3 id="usb传文件给开发板（kernel及rootfs）"><a href="#usb传文件给开发板（kernel及rootfs）" class="headerlink" title="usb传文件给开发板（kernel及rootfs）"></a>usb传文件给开发板（kernel及rootfs）</h3><h4 id="烧录内核"><a href="#烧录内核" class="headerlink" title="烧录内核"></a>烧录内核</h4><p>MobaXterm命令内输入：k</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_20-49-09.png" alt="Snipaste_2018-12-18_20-49-09"></p><p>打开DNW,选择烧录内核</p><p>（usb驱动和DNW安装在下面）</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-08-49.png" alt="Snipaste_2018-12-18_21-08-49"></p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-12-14.png" alt="Snipaste_2018-12-18_21-12-14"></p><h4 id="烧录文件系统"><a href="#烧录文件系统" class="headerlink" title="烧录文件系统"></a>烧录文件系统</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-10-13.png" alt="Snipaste_2018-12-18_21-10-13"></p><h4 id="擦除分区"><a href="#擦除分区" class="headerlink" title="擦除分区"></a>擦除分区</h4><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-17-25.png" alt="Snipaste_2018-12-18_21-17-25"></p><h4 id="完成重启并校准"><a href="#完成重启并校准" class="headerlink" title="完成重启并校准"></a>完成重启并校准</h4><p>启动，重启要求校准，校准失败执行下面命令。会再次校准。</p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-19-50.png" alt="Snipaste_2018-12-18_21-19-50"></p><h3 id="补充：usb驱动和DNW安装"><a href="#补充：usb驱动和DNW安装" class="headerlink" title="补充：usb驱动和DNW安装"></a>补充：usb驱动和DNW安装</h3><p>注意：一定要完成下面连点：</p><ol><li>连接usb线及com线到pc</li><li>使用MobaXterm打开串口，重新启动，让开发板运行于 UBOOT（在开发板启动时在串口<br>工具里按下空格【计数三秒内】，阻止它启动 Linux ）</li></ol><p>3.运行 zadig-2.3.exe，可以看到如下图 4.25 界面： </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-34-47.png" alt="Snipaste_2018-12-18_21-34-47"></p><p>注意，如果上图位置 1 处的下拉框中没有“SEC S3C2410X Text B/D”，可以点击菜单<br>“Options”，选中“List All Device”；再重接 USB线 。</p><p>4.安装好驱动程序， 设备管理器如图 </p><p><img src="https://setcalm.oss-cn-zhangjiakou.aliyuncs.com/%E5%9B%BE%E5%BA%8A/Snipaste_2018-12-18_21-37-32.png" alt="Snipaste_2018-12-18_21-37-32"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;烧录软件安装&quot;&gt;&lt;a href=&quot;#烧录软件安装&quot; class=&quot;headerlink&quot; title=&quot;烧录软件安装&quot;&gt;&lt;/a&gt;烧录软件安装&lt;/h2&gt;&lt;h3 id=&quot;EasyOpenJTAG介绍及安装程序&quot;&gt;&lt;a href=&quot;#EasyOpenJTAG介绍及安装程序&quot; class=&quot;headerlink&quot; title=&quot;EasyOpenJTAG介绍及安装程序&quot;&gt;&lt;/a&gt;EasyOpenJTAG介绍及安装程序&lt;/h3&gt;&lt;h4 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h4&gt;
    
    </summary>
    
      <category term="S3C244入门" scheme="https://github.com/SetCalm/setcalm.github.io/categories/S3C244%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="S3C244" scheme="https://github.com/SetCalm/setcalm.github.io/tags/S3C244/"/>
    
  </entry>
  
</feed>
