<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第一章：Linux 多任务 编程 本章 主要 内容：  简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。">
<meta name="keywords" content="暂时无">
<meta property="og:type" content="article">
<meta property="og:title" content="进程与线程">
<meta property="og:url" content="https://github.com/SetCalm/setcalm.github.io/进程与线程.html">
<meta property="og:site_name" content="Jeff">
<meta property="og:description" content="第一章：Linux 多任务 编程 本章 主要 内容：  简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_19-41-09.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_20-03-41.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_20-33-26.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_20-37-47.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_23-43-25.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_00-28-17.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_00-53-30.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_00-56-22.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_00-59-51.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_01-00-39.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_23-36-05.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-02_23-38-38.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_00-00-11.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_00-09-06.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_00-14-10.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_00-48-00.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_01-37-18.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_01-40-33.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_01-44-13.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_16-13-53.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_16-39-41.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_17-13-26.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_18-06-52.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_18-12-38.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_18-23-38.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_19-11-22.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_19-13-57.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_19-34-36.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_19-40-34.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_19-40-40.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_19-50-30.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_20-07-56.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_20-16-54.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_20-28-23.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_20-34-15.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-20-27.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-22-47.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-23-31.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-36-13.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-40-12.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-40-23.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_21-40-28.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_22-56-29.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_23-13-26.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_23-13-53.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_23-14-04.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-03_23-14-12.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-04_00-01-24.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-04_00-33-34.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-04_00-33-41.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-04_01-09-37.png">
<meta property="og:image" content="d:/MyBlog/图片/Snipaste_2019-03-04_01-14-08.png">
<meta property="og:updated_time" content="2019-03-05T09:59:13.506Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="进程与线程">
<meta name="twitter:description" content="第一章：Linux 多任务 编程 本章 主要 内容：  简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。">
<meta name="twitter:image" content="d:/MyBlog/图片/Snipaste_2019-03-01_19-41-09.png">



  <link rel="alternate" href="/atom.xml" title="Jeff" type="application/atom+xml">




  <link rel="canonical" href="https://github.com/SetCalm/setcalm.github.io/进程与线程.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>进程与线程 | Jeff</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

      <a href="https://github.com/SetCalm" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="https://github.com/SetCalm">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeff</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-student">
    <a href="/student" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-life">
    <a href="/life" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>生活</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-musicbooksfilms">
    <a href="/MusicBooksFilms" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>影音书</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-collect">
    <a href="/collect" rel="section">
      <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>收藏</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/SetCalm/setcalm.github.io/进程与线程.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeff Wu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeff">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">进程与线程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 19:08:20" itemprop="dateCreated datePublished" datetime="2019-03-01T19:08:20+08:00">2019-03-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-05 17:59:13" itemprop="dateModified" datetime="2019-03-05T17:59:13+08:00">2019-03-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章：Linux-多任务-编程"><a href="#第一章：Linux-多任务-编程" class="headerlink" title="第一章：Linux 多任务 编程"></a>第一章：Linux 多任务 编程</h1><p> 本章 主要 内容： </p>
<p>简单的介绍一下什么叫多任务系统？任务、进程、线程分别是什么？它们之间的区别是什么？，从而可以宏观的了解一下这三者。</p>
<a id="more"></a>
<h2 id="Linux下多任务简介"><a href="#Linux下多任务简介" class="headerlink" title="Linux下多任务简介"></a>Linux下多任务简介</h2><p><strong>什么叫多任务系统？</strong></p>
<p>多任务是指用户可以同一时间内运行多个应用程序，每个应用程序被称作一个任务。</p>
<p>多任务 操作系统 使用 某种 调度 策略 支持 多个 任务 并发 执行。由于 任务 会 频繁 地 切换 执行， 因此 给用户 多个 任务 同时 运行 的 感觉。</p>
<p><strong>任务定义:</strong></p>
<p>任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。</p>
<p><strong>进程定义:</strong></p>
<p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的最小单元。</p>
<p><strong>线程定义:</strong></p>
<p>线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以成为轻量级进程。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>任务是一个逻辑概念,指由一个软件完成的任务，或者是一系列共同达到某一目的的操作。通常一个任务是一个程序的一次执行，一个任务包含一个或多个完成独立功能的子任务，这个独立的子任务就是进程或线程。例如，一个杀毒软件的一次运行是一个任务，目的是从各种病毒的侵害中保护计算机系统，这个任务包含多个独立功能的子任务(进程或线程)，包括实时监控功能、定时查杀功能、防火墙功能及用户交互功能等。任务、进程和线程之间的关系如图3.1所示</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_19-41-09.png" alt="Snipaste_2019-03-01_19-41-09"></p>
<p>总结： ①一个操作系统可以执行多个任务（多个应用程序），一个任务指一个程序的一次执行。</p>
<p>​        ②一个任务包含一个或多个完成独立功能的子任务</p>
<p>​        ③子任务就是进程（一个）或线程（一个或多个）</p>
<p>一个任务为一个程序,一个程序由多个进程，每个进程又会有多个线程。而操作系统能运行多个程序（任务）。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程的基本概念</strong></p>
<p>进程是指一个具有独立功能的程序在某个数据集上的一次动态执行过程，它是系统进行资源分配和调度的基本单元。一次任务的运行可以并发激活多个进程，这些进程相互合作来完成该任务的一个最终目标。</p>
<p>进程具有并发性、动态性、交互性、独立性和异步性等主要特性。</p>
<p>进程和程序是有本质区别的：①程序是静态的一段代码，是一些保存在非易失性存储器的指令的有序集合，没有任何执行的概念；②而进程是一个动态的概念，它是程序执行的过程，包括动态创建、调度和消亡的整个过程，它是程序执行和资源管理的最小单位。</p>
<p><strong>Linux下的进程结构</strong></p>
<p>进程不但包括程序的指令和数据，而且包括程序计数器和处理器的所有寄存器及存储临时数据的进程堆栈，因此，正在执行的进程包括处理器当前的一切活动。</p>
<p>因为linux是一个多任务多进程的操作系统，所以其他的进程必须等到系统将处理器使用权分配给自己之后才能运行。当正在运行的进程等待其他的系统资源时，linux内核将取得处理器的控制权，并将处理器分配给其他正在等待的进程，他按照内核中的调度算法决定将处理器分配给哪一个进程，也就是说，内核不会让处理器闲着。</p>
<p>内核将所有进程存放在双向循环链表（进程链表）中，其中链表的头是 init_task 描述符。链表的每一项都是类型为 task_struct，称为进程描述符的结构，该结构包含了一个进程相关的所有信息，定义&lt;include/linux/sched.h&gt;文件中。task_struct内核结构比较大，它能完整的描述一个进程，如进程的状态、进程的基本信息、进程标识符、内存相关信息、父进程相关信息、与进程相关的终端信息、当前工作目录、打开的文件信息、所接收的信号信息等。</p>
<p>下面详细讲解task_struct结构中最为重要的两个域：state（进程状态）和pid（进程标识符）</p>
<p>（1）进程状态</p>
<p>Linux中的进程有以下几种状态。</p>
<p>● 运行状态（TASK_RUNNING）:进程当前正在运行，或者正在运行队列中等待调度。</p>
<p>● 可中断的阻塞状态（TASK_INTERRUPTIBLE）：进程处于阻塞(睡眠)状态，正在等待某些事件发生或能够占用某些资源。处在这种状态下的进程可以被信号中断。接收到信号或被显式的唤醒呼叫（如调用 wake_up 系列宏:wake_up、wake_up_interruptible等）唤醒之后，进程将转变为 TASK_RUNNING 状态。</p>
<p>● 不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）:此进程状态类似于可中断的阻塞状态（TASK_INTERRUPTIBLE），只是它不会处理信号，把信号传递到这种状态下的进程不能改变它的状态。在一些特定的情况下（进程必须等待，直到某些不能被中断的事件发生），这种状态是很有用的。只有在它所等待的事件发生时，进程才被显示的唤醒呼叫唤醒。</p>
<p>● 可终止的阻塞状态（TASK_KILLABLE）:该状态的运行机制类似于TASK_UNINTERRUPTIBLE，只不过处在该状态下的进程可以响应致命信号。它可以替代有效但可能无法终止的不可中断的阻塞状态（TASK_UNINTERRUPTIBLE）,以及易于唤醒但安全性欠佳的可中断的阻塞状态TASK_INTERRUPTIBLE）。</p>
<p>● 暂停状态（TASK_STOPPED）:进程的执行被暂停，当进程收到 SIGSTOP、SIGSTP、SIGTTIN、SIGTTOU等信号时，就会进入暂停状态。</p>
<p>● 跟踪状态（TASK_TRACED）:进程的执行被调试器暂停。当一个进程被另一个监控时（如调试器使用ptrace()系统调用监控测试程序），任何信号都可以把这个进程置于跟踪状态。</p>
<p>● 僵尸状态（EXIT_ZOMBIE）:进程运行结束，父进程尚未使用 wait 函数族(如调用 waitpid()函数)等系统调用来“收尸”，即等待父进程销毁它。处在该状态下的进程“尸体”已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的推出状态等信息供其他进程收集。</p>
<p>● 僵尸撤销状态（EXIT_DEAD）:这是最终状态，父进程调用 wait 函数族“收尸”后，进程彻底由系统删除。</p>
<p>它们之间的转换关系如图2所示：<img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-03-41.png" alt="Snipaste_2019-03-01_20-03-41"></p>
<p>进程可以使用 set_task_state 和 set_current_state 宏来改变指定进程的状态信息和当前进程的状态</p>
<p>（2）进程标识符</p>
<p>Linux内核通过唯一的进程标识符 PID 来标识每个进程(就和文件描述符一样)。PID存放在进程描述符的 pid 字段中，新创建的 PID 通常是前一个进程的 PID 加1，不过PID的值有上限（最大值=PID_MAX_DEFAULT-1，通常为32767），可以查看/proc/sys/kernel/pid_max 来确定该系统的进程数上限。</p>
<p>当系统启动后，内核通常作为某一个进程的代表。一个指向task_struct的宏current用来记录正在运行的进程。current经常作为进程描述符结构指针的形式出现在内核代码中，例如，current-&gt;pid 表示处理器正在执行的进程的PID。当系统需要查看所有的进程时，则调用for_each_process()宏，这将比系统搜索数组的速度要快的多。</p>
<p>在Linux中获得当前进程号的（PID）和父进程号（PPID）的系统调用函数分别为 getpid() 和 getppid()。</p>
<p><strong>进程的创建、执行、终止</strong></p>
<p>（1）进程的创建和执行</p>
<p>Linux 中进程的创建很特别，它把上述的步骤分解到两个单独的函数中去执行：fork()函数和exec函数族。</p>
<ul>
<li>首先，fork()函数通过复制当前进程创建一个子进程(注意此时资源还没有被复制过来，去了解一下写时复制页技术吧)，子进程于父进程的区别仅仅在于不同的PID、PPID和某些资源及统计量。</li>
<li>exec函数族负责读取可执行文件并将其载入地址空间开始运行。</li>
</ul>
<p>（2）进程的终止</p>
<p>进程终结也需要很多繁琐的工作，系统必须保证回收进程所占用的资源，并通知父进程。</p>
<ul>
<li>Linux首先把终止的进程设置为僵尸状态，这时，进程无法投入运行，它的存在只为父进程提供信息，申请死亡。</li>
<li>父进程得到信息后，开始调用 wait 函数族，最后终止子进程，子进程占用的所有资源被全部释放。</li>
</ul>
<p><strong>进程的内存结构</strong></p>
<p>Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该地址空间是大小为 4GB的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统</p>
<p>效果（用户不能直接访问物理地址），而且，更重要的是，用户程序可以使用比实际物理内存更大的地址空间。</p>
<p>4GB的进程地址空间会被分成两个部分：用户空间与内核空间。用户地址空间是从0到3GB(0xC000 0000),内核地址空间占据从3GB到4GB。</p>
<ul>
<li><p>用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。只有用户进程使用系统调用（代表用户进程在内核态执行）时可以访问到内核空间。每当进程切换时，用户空间就跟着变化;而内核空间由内核负责映射，它不会跟着进程改变，是固定的。</p>
</li>
<li><p>内核空间地址有自己对应的页表，用户进程各自有不同的页表。每个进程的用户空间都是完全独立、互不相干的。</p>
</li>
</ul>
<p>  <strong>进程的虚拟内存空间如图3所示，其中用户空间包括以下几个功能区域：</strong></p>
<ul>
<li><p>只读段: 包含程序代码(.init和.text)和只读数据(.rodata)。</p>
</li>
<li><p>数据段: 存放的是全局变量和静态变量。其中可读可写数据段(.data)存放已初始化的全局变量和静态变量，BSS数据段(.bss)存放未初始化的全局变量和静态变量。</p>
</li>
<li><p>堆: 由系统自动分配释放，存放函数的参数值、局部变量的值、返回地址等。</p>
</li>
<li><p>堆栈: 存放动态分配的数据，一般由程序员动态分配和释放。若程序员不释放，程序结束时可能由操作系统回收。</p>
</li>
<li><p>共享库的内存映射区域: 这是Linux动态链接器和其他共享代码库代码的映射区域。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-33-26.png" alt="Snipaste_2019-03-01_20-33-26"></p>
</li>
</ul>
<p>由于在Linux系统中每一个进程都会有/proc文件系统下与之对应的一个目录（如将init进程的相关信息在/proc/1 目录下的文件中描述），因此通过 proc 文件系统可以查看某个进程的地址空间的映射情况。例如，运行一个应用程序,如果它的进程号为13703,则输入“ cat /proc/13703/maps”命令，可以查看该进程的内存映射情况。</p>
<h2 id="进程控制符"><a href="#进程控制符" class="headerlink" title="进程控制符"></a>进程控制符</h2><p>进程控制符（PID），英文全称为Process Identifier。也常被称为进程标识符。顾名思义，它是各进程的身份标识,程序一运行系统就会自动分配给进程一个非 负 整型 表示 的 唯一 进程 ID 。 因为进程 ID标识符总是唯一的， 常将其用作其他标识符的一部分以保证其唯一性。 例如， 应用程序有时就把进程ID作为名字的一部分来创建一个唯一的文件名。</p>
<p>PID代表了各进程的进程ID,也就是说,PID就是各进程的身份标识。只要运行一程序，系统会自动分配一个标识，不过PID只是暂时唯一的，在进程中止后，这个号码就会被回收，并可能被分配给另一个新进程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>前面已经讲到，进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆栈段，这就造成了进程在进行切换等动作时需要较复杂的上下文切换等动作。为了进一步减少处理机的空闲时间，支持多处理器及减少上下文切换开销，进程在演化中出现了另一个概念—线程。</p>
<ul>
<li>线程是进程内独立的一条运行路线，是处理器调度的最小单元，也可以称为轻量级线程。</li>
<li>线程可以对进程的内存空间和资源分配进行访问，并与同一进程中的其他线程共享。因此，线程的上下文切换的开销比创建进程小得多。</li>
</ul>
<p>一个进程可以拥有多个线程，每个线程必须有一个父进程。线程不拥有系统资源，它只具有运行时所必须的一些数据结构，如堆栈/寄存器与线程控制块(TCB)，线程与其父进程的其他进程共享该进程所拥有的全部资源。要注意的是，由于线程共享了进程的资源和地址空间，因此，任何线程对系统资源的操作都会给其他进程带来影响。由此可知，多线程中的同步是一个非常重要的问题。在多线程系统中，进程与线程的关系如图</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_20-37-47.png" alt="Snipaste_2019-03-01_20-37-47"></p>
<h1 id="第二章：进程"><a href="#第二章：进程" class="headerlink" title="第二章：进程"></a>第二章：进程</h1><h2 id="第一节：创建新进程"><a href="#第一节：创建新进程" class="headerlink" title="第一节：创建新进程"></a>第一节：创建新进程</h2><h3 id="函数fork（创建）"><a href="#函数fork（创建）" class="headerlink" title="函数fork（创建）"></a>函数fork（创建）</h3><p>一个现有的进程可以调用fork函数创建一个新进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; unistd. h&gt;</span></span></span><br><span class="line"><span class="function">pid_ t <span class="title">fork</span><span class="params">( <span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 值： 子 进程 返回 0， 父 进程 返回 的是子进程的PID； 若 出错， 返回 − 1</p>
<p>由 fork 创建 的 新 进程 被称为 子 进程（ child process）。 fork 函数 被 调用 一次， 但 返回 两次。 两次 返回 的 区 别是 子 进程 的 返回 值 是 0， 而 父 进程 的 返回 值 则是 新建 子 进程 的 进程 ID。</p>
<p>将 子 进程 ID 返回 给 父 进程 的 理由 是： 因为 一个 进程 的 子 进程 可以 有 多个， 并且 没有 一个 函数 使 一个 进程 可以 获得 其 所有 子 进程 的 进程 ID。 fork 使 子 进程 得到 返回 值 0 的 理由 是： 一个 进程 只会 有一个 父 进程， 所以 子 进程 总是 可以 调用 getppid 以 获得 其父 进程 的 进程 ID（ 进程 ID 0 总是 由 内核 交换 进程 使用， 所以 一个 子 进程 的 进程 ID 不可 能为 0）。(这句话好拗口)</p>
<p>子 进程 和 父 进程 继续 执行 fork 调用 之后 的 指令。 子 进程 是 父 进程 的 副本。 例如， 子 进程 获得 父 进程 数据 空间、 堆 和 栈 的 副本。 注意， 这是 子 进程 所 拥有 的 副本。 父 进程 和 子 进程 并不 共享 这些 存储 空间 部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">pid_t</span> ret;</span><br><span class="line">	ret=fork();</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-01_23-43-25.png" alt="Snipaste_2019-03-01_23-43-25"></p>
<p>分析：子进程的返回值为ret=0，父进程的返回值ret为子进程的pid。且子进程和父进程都为7,因此可见父，子进程不资源共享，子进程只是简单的对父进程复制。子 进程 获得 父 进程 数据 空间、 堆 和 栈 的 副本。</p>
<h3 id="函数-vfork（创建）"><a href="#函数-vfork（创建）" class="headerlink" title="函数 vfork（创建）"></a>函数 vfork（创建）</h3><p>函数 的 调用 序列 和 返回 值 与 fork 相同， 但 两者 的 语义 不同。</p>
<p> vfork 函数 用于 创建 一个 新 进程， 而 该 新 进程 的 目的 是 exec 一个 新 程序（。 vfork 与 fork 一样 都 创建 一个 子 进程， 但是 它 并不 将 父 进程 的 地址 空间 完全 复制 到 子 进程 中， 因为 子 进程 会 立即 调用 exec（ 或 exit）， 于是 也就 不会 引用 该地 址 空间。 不过 在 子 进程 调用 exec 或 exit 之前， 它在 父 进程 的 空间 中 运行。 这种 优化 工作 方式 在 某些 UNIX 系统 的 实现 中 提高 了 效率， 但如 果子 进程 修改 数据（ 除了 用于 存放 vfork 返回 值 的 变量）、 进行 函数 调用、 或者 没有 调用 exec 或 exit 就 返回 都 可能 会 带来 未知 的 结果。</p>
<p>vfork 和 fork 之间 的 另一个 区别 是： vfork 保证 子 进程 先 运行， 在 它 调用 exec 或 exit 之后 父 进程 才可 能被 调度 运行， 当子 进程 调用 这 两个 函数 中的 任意 一个 时， 父 进程 会 恢复 运行。（ 如果 在 调用 这 两个 函数 之前 子 进程 依赖于 父 进程 的 进一步 动作， 则 会 导致 死锁。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> i=<span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line">	<span class="keyword">pid_t</span> ret;</span><br><span class="line">	ret=vfork();</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"parent i=%d,ret=%d,pid=%d\n"</span>,i,ret,getpid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-28-17.png" alt="Snipaste_2019-03-02_00-28-17"></p>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h3><p>提及 用 fork 函数 创建 新的 子 进程 后， 子 进程 往往 要 调用 一种 exec 函数 以 执行 另一个 程序。 当 进程 调用 一种 exec 函数 时， 该 进程 执行 的 程序 完全 替换 为 新 程序， 而 新 程序 则从 其 main 函数 开始 执行。 因为 调用 exec 并不 创建 新 进程， 所以 前后 的 进程 ID 并未 改变。 exec 只是 用 磁盘 上 的 一个 新 程序 替换 了 当前 进程 的 正文 段、 数据 段、 堆 段 和 栈 段。</p>
<p>略</p>
<p>函数 exit（退出）</p>
<p>进程 有 5 种 正常 终止 及 3 种 异常 终止 方式。 5 种 正常 终止 方式 具体 如下。</p>
<ul>
<li>（1） 在 main 函数 内 执行 return 语句， 这 等效 于 调用 exit。 </li>
<li>（2） 调用 exit 函数。  其 操作 包括 调用 各 终止 处理 程序， 然后 关闭 所有 标准 I/ O 流 等。</li>
<li>（3） 调用_ exit 或_ Exit 函数 </li>
<li>（4） 进程 的 最后 一个 线程 在 其 启动 例程 中 执行 return 语句。 但是， 该 线程 的 返回 值 不用 作 进程 的 返回 值。 当 最后 一个 线程 从其 启动 例程 返回 时， 该 进程 以 终止 状态 0 返回。</li>
<li><p>（5） 进程 的 最后 一个 线程 调用 pthread_ exit 函数。 </p>
<p>3 种 异常 终止 具体 如下。</p>
<p>（1） 调用 abort。 它 产生 SIGABRT 信号， 这是 下一 种 异常 终止 的 一种 特例。</p>
<p>（2） 当 进程 接收 到 某些 信号 时。 信号 可由 进程 自身（ 如 调用 abort 函数）、 其他 进程 或 内核 产生。 例如， 若 进程 引用 地址 空间 之外 的 存储 单元、 或者 除以 0， 内核 就 会为 该 进程 产生 相应 的 信号。</p>
<p>（3） 最后 一个 线程 对“ 取消”（ cancellation） 请求 作出 响应。 默认 情况下，“ 取消” 以 延迟 方式 发生： 一个 线程 要求 取消 另一个 线程， 若干 时间 之后， 目标 线程 终止。</p>
</li>
</ul>
<p><strong>exit() 和_ exit() 函数 说明。</strong></p>
<p>exit() 和_ exit() 函数 都是 用来 终止 进程 的。 当 程序 执行 到 exit() 或_ exit() 时， 进程 会 无条件 地 停止 剩下 的 所有 操作， 清除 各种 数据 结构， 并 终止 本 进程 的 运行。 但是， 这 两个 函数 还是 有区别 的， 这 两个 函数 的 调用 过程 如图</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-53-30.png" alt="Snipaste_2019-03-02_00-53-30"></p>
<p>从 图 3. 5 中 可以 看出，_ exit() 函数 的 作用 是 直接 使 进程 停止 运行， 清除 其 使用 的 内存 空间， 并 清除 其 在内 核 中的 各种 数据 结构； exit() 函数 则在 这些 基础上 做了 一些 包装， 在 执行 退出 之前 加了 若干 道 工序。 exit() 函数 与_ exit() 函数 最大 的 区别 就在于 exit() 函数 在 终止 当前 进程 之前 要 检查 该 进程 打开 了 哪些 文件， 并把 文件 缓冲区 中的 内容 写回 文件， 就是 图中 的“ 清理 I/ O 缓冲” 一项。</p>
<p><strong>exit() 和_ exit() 函数 语法。</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-56-22.png" alt="Snipaste_2019-03-02_00-56-22"></p>
<h3 id="函数-wait-和-waitpid（阻塞）"><a href="#函数-wait-和-waitpid（阻塞）" class="headerlink" title="函数 wait 和 waitpid（阻塞）"></a>函数 wait 和 waitpid（阻塞）</h3><p><strong>wait() 和 waitpid() 函数 说明</strong>。</p>
<p> wait() 函数 用于 使 父 进程（ 也就是 调用 wait() 的 进程） 阻塞， 直到 一个 子 进程 结束 或者 该 进程 接到 了 一个 指定 的 信号 为止。 如果 该 父 进程 没有 子 进程 或者 他的 子 进程 已经 结束， 则 wait() 会 立即 返回- 1。 </p>
<p>waitpid() 的 作用 和 wait() 一样， 但它 并不 一定 等待 第一个 终止 的 子 进程。 waitpid() 有若 干 选项， 可 提供 一个 非 阻塞 版本 的 wait() 功能。 实际上 wait() 函数 只是 waitpid() 函数 的 一个 特例， 在 Linux 内部 实现 wait() 函数 时 直接 调用 的 就是 waitpid() 函数。 </p>
<p> <strong>wait() 和 waitpid() 函数 格式 说明。</strong> </p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_00-59-51.png" alt="Snipaste_2019-03-02_00-59-51"></p>
<p><strong>waitpid() 函数 的 语法 规范。</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_01-00-39.png" alt="Snipaste_2019-03-02_01-00-39"></p>
<h2 id="第二节：守护进程"><a href="#第二节：守护进程" class="headerlink" title="第二节：守护进程"></a>第二节：守护进程</h2><p>守护进程（ daemon） 是生存期长的一种进程。 它们 常常在系统引导装入时启动， 仅在系统关闭时才终止。 因为它们没有控制终端， 所以说它们是在后台运行 的。 UNIX系统有很多守护进程， 它们执行日常事务 活动。</p>
<h3 id="编写守护进程"><a href="#编写守护进程" class="headerlink" title="编写守护进程"></a>编写守护进程</h3><p>编写守护进程看似复杂，但实际上也是遵循一个特定的流程。下面就分5个步骤来讲解怎样创建一个简单的守护进程。</p>
<p><strong>1．创建子进程，父进程退出</strong></p>
<p>这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在shell 终端里造成一种程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在shell 终端里则可以执行其<br>他的命令，从而在形式上做到了与控制终端的脱离。</p>
<p>父进程创建了子进程之后退出，父进程会先于子进程退出，会造成子进程没有父进程，从<br>而变成一个孤儿进程。在Linux 中，每当系统发现一个孤儿进程，就会自动由1 号进程（也就是init 进程）<br>收养它，这样，原先的子进程就会变成init 进程的子进程了。</p>
<p>其关键代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/*父进程退出*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2．在子进程中创建新会话</strong></p>
<p>这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用<br>的是系统函数setsid()，在具体介绍setsid()之前，读者首先要了解两个概念：进程组和会话期。</p>
<p><strong>进程组：</strong>进程组是一个或多个进程的集合。进程组由进程组 ID 来惟一标识。除了进程号（PID）之外，进程组ID<br>也是一个进程的必备属性。</p>
<p>每个进程组都有一个组长进程，其组长进程的进程号等于进程组 ID。且该进程ID 不会因组长进程的退出而受到影响。</p>
<p><strong>会话期：</strong> 会话组是一个或多个进程组的集合。通常，一个会话开 始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期，它们之间的关系如图7.6 所示。<br>接下来就可以具体介绍 setsid()的相关内容。<br>（1）setsid()函数作用。<br>setsid()函数用于创建一个新的会话，并担任该会话组的组长。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_23-36-05.png" alt="Snipaste_2019-03-02_23-36-05"></p>
<p><strong>(a) 调用</strong><br><strong>setsid()有下面的3 个作用。</strong></p>
<ul>
<li>让进程摆脱原会话的控制。</li>
<li>让进程摆脱原进程组的控制。</li>
<li>让进程摆脱原控制终端的控制</li>
</ul>
<p><em>那么，在创建守护进程时为什么要调用setsid()函数呢？</em></p>
<p>在创建守护进程的第一步，调用fork()函数来创建子进程后再令父进程退出时。由于在调用fork()函数时，子进程全盘复制了父进程的会<br>话期、进程组和控制终端等，虽然父进程退出了，但原先的会话期、进程组和控制终端等并没有改变，因<br>此，还不是真正意义上的独立，而setsid()函数能够使进程完全独立出来，从而脱离所有其他进程的控制。</p>
<p><strong>(b) setsid()函数格式</strong></p>
<p>当进程是会话的领头进程时setsid()调用失败并返回（-1）。setsid()调用成功后，返回新的会话的ID，调用setsid函数的进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，进程同时与控制终端脱离。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-02_23-38-38.png" alt="Snipaste_2019-03-02_23-38-38"></p>
<p><strong>3．改变当前目录为根目录</strong></p>
<p>这一步也是必要的步骤。使用fork()创建的子进程继承了父进程的当前工作目录。由于在进程运行过程中，<br>当前目录所在的文件系统（比如“/mnt/usb”等）是不能卸载的，这对以后的使用会造成诸多的麻烦（比<br>如系统由于某种原因要进入单用户模式）。因此，通常的做法是让“/”作为守护进程的当前工作目录，这<br>样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变<br>工作目录的常见函数是chdir()。</p>
<p><strong>4．重设文件权限掩码</strong></p>
<p>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有一个文件权限掩码是050，它就屏蔽了文件组拥<br>有者的可读与可执行权限。由于使用fork()函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为 0，可以大大增强该守护进程的灵活性。<br>设置文件权限掩码的函数是umask()。在这里，通常的使用方法为umask(0)。</p>
<p><strong>5．关闭文件描述符</strong></p>
<p>同文件权限掩码一样，用fork()函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打<br>开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法<br>被卸载。<br>在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守<br>护进程，守护进程中用常规方法（如printf()）输出的字符也不可能在终端上显示出来。所以，文件描述符<br>为0、1 和2 的3 个文件（常说的输入、输出和报错这3 个文件）已经失去了存在的价值，也应被关闭。<br>通常按如下方式关闭文件描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXFILE; i++)</span><br><span class="line">&#123;</span><br><span class="line">close(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：第一步让字进程称为孤儿进程，第二步：调用setsid函数使子进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，从而使子进程同时与控制终端脱离。后面主要用于释放从父进程继承过来的紫瑶及从设参数。（第三步。释放子从父进程继承的当前工作目录。第四步：重设文件权限掩码0为umask(0，大大增强该守护进程的灵活性。第五步：关闭文件描述符。如过子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读或写，但是不关闭的它们一样消耗系统资源，而且可能导致所在的文件系统无法<br>被卸载。</p>
<p>这样，一个简单的守护进程就建立起来了，创建守护进程的 流程图如图</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-00-11.png" alt="Snipaste_2019-03-03_00-00-11"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid; </span><br><span class="line">	<span class="keyword">int</span> i, fd; </span><br><span class="line">	<span class="keyword">char</span> *buf= <span class="string">"This is a Daemon\n"</span>;</span><br><span class="line">	pid = fork(); <span class="comment">/* 第一步 */</span> </span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" Error fork\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* 父 进程 退出 */</span> </span><br><span class="line">	&#125;</span><br><span class="line">	setsid(); <span class="comment">/*第 二步*/</span> </span><br><span class="line">	chdir(<span class="string">"/tmp"</span>); <span class="comment">/*第三步*/</span> </span><br><span class="line">	umask(<span class="number">0</span>); <span class="comment">/*第四 步*/</span> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; getdtablesize(); i++) <span class="comment">/*第五 步*/</span> </span><br><span class="line">	&#123; </span><br><span class="line">		close(i);</span><br><span class="line">	&#125; <span class="comment">/*这时 创建 完 守护 进程， 以下 开始 正式 进入 守护 进程 工作*/</span> </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span>((fd = open(<span class="string">"daemon. log"</span>, O_CREAT|O_WRONLY|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Open file error\n"</span>); </span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">		&#125; </span><br><span class="line">			write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">			close(fd);</span><br><span class="line">			sleep(<span class="number">2</span>); </span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="守护进程调式"><a href="#守护进程调式" class="headerlink" title="守护进程调式"></a>守护进程调式</h3><p>由于守护进程完全脱离了控制终端，因此，不能像其<br>他普通进程一样将错误信息输出到控制终端来通知程序员，即使使用gdb 也无法正常调试。那么，守护进<br>程的进程要如何调试呢？一种通用的办法是使用syslog 服务，将程序中的出错信息输入到系统日志文件中</p>
<p>略</p>
<h3 id="实例1：编写多进程程序"><a href="#实例1：编写多进程程序" class="headerlink" title="实例1：编写多进程程序"></a>实例1：编写多进程程序</h3><p>1．实验目的<br>通过编写多进程程序，使读者熟练掌握fork()、exec()、wait()和waitpid()等函数的使用，进一步理解在Linux<br>中多进程编程的步骤。<br>2．实验内容<br>该实验有3 个进程，其中一个为父进程，其余两个是该父进程创建的子进程，其中一个子进程运行“ls -l”<br>指令，另一个子进程在暂停5s 之后异常退出，父进程先用阻塞方式等待第一个子进程的结束，然后用非阻<br>塞方式等待另一个子进程的退出，待收集到第二个子进程结束的信息，父进程就返回。<br>3．实验步骤<br>（1）画出该实验流程图。<br>该实验流程图如图 7.8 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-09-06.png" alt="Snipaste_2019-03-03_00-09-06"></p>
<p>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//略</span></span><br></pre></td></tr></table></figure>
<h3 id="实例2：创建守护进程"><a href="#实例2：创建守护进程" class="headerlink" title="实例2：创建守护进程"></a>实例2：创建守护进程</h3><p>先建立起一个守护进程，然后在该守护进程中新建一个子进程，该子进程暂停10s，<br>然后自动退出，并由守护进程收集子进程退出的消息。在这里， 子进程和<br>守护进程的退出消息都在系统日志文件（ 例如<br>“/var/log/messages”，日志文件的全路径名因版本的不同可能会有所不同）<br>中输出。子进程退出后，守护进程循环暂停，其间隔时间为10s。<br>3．实验步骤<br>（1）画出该实验流程图。<br>该程序流程图如图 7.9 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-14-10.png" alt="Snipaste_2019-03-03_00-14-10"></p>
<p>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<h2 id="第三节：进程间通信"><a href="#第三节：进程间通信" class="headerlink" title="第三节：进程间通信"></a>第三节：进程间通信</h2><p>进程是一个程序的一次执行。这里所说的进程一般是指运行在用户态的进程，<br>而由于处于用户态的不同进程之间是彼此隔离的，它们必须通过某种方式来进<br>行通信。本章就是讲述如何建立这些不同的通话方式。</p>
<p>Linux 下的进程通信手段基本上是从UNIX 平台上的进程通信手段继承而来的。而对UNIX 发展做出重大<br>贡献的两大主力AT&amp;T 的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）。</p>
<ul>
<li><p>前者（AT&amp;T 的贝尔实验室）是对UNIX 早期的进程间通信手段进行了系统的改进和扩充，形成了<br>“system V IPC”，其通信进程主要局限在单个计算机内；</p>
</li>
<li><p>后者（BSD）则跳过了该限制，形成了基于套接口（socket）<br>的进程间通信机制。</p>
<p><strong>Linux则把两者的优势都继承了下来，如图所示。</strong></p>
</li>
</ul>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_00-48-00.png" alt="Snipaste_2019-03-03_00-48-00"></p>
<p>UNIX 进程间通信（IPC）方式：包括管道、FIFO 以及信号。</p>
<p>System V 进程间通信（IPC）包括：System V 消息队列、System V 信号量以及System V 共享内存<br>区。</p>
<p> Posix 进程间通信（IPC）包括：Posix 消息队列、Posix 信号量以及Posix 共享内存区。</p>
<p>现在在Linux 中使用较多的进程间通信方式主要有以下几种。</p>
<p><strong>（1）管道（Pipe）及有名管道（named pipe）：</strong>管道可用于具有亲缘关系进程间的通信，有名管道，除具<br>有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
<p><strong>（2）信号（Signal）：</strong>信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知<br>进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一样的。</p>
<p><strong>（3）消息队列（Messge Queue）：</strong>消息队列是消息的链接表，包括Posix 消息队列SystemV 消息队列。<br>它克服了前两种通信方式中信息量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中<br>添加新消息；对消息队列有读权限的进程则可以从消息队列中读取消息。</p>
<p><strong>（4）共享内存（Shared memory）：</strong>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块<br>内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种通信方式需要依靠某种同步<br>机制，如互斥锁和信号量等。</p>
<p><strong>（5）信号量（Semaphore）：</strong>主要作为进程之间以及同一进程的不同线程之间的同步和互斥手段。</p>
<p><strong>（6）套接字（Socket）：</strong>这是一种更为一般的进程间通信机制，它可用于网络中不同机器之间的进程间通<br>信，应用非常广泛。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><h4 id="管道概述"><a href="#管道概述" class="headerlink" title="管道概述"></a>管道概述</h4><p>管道是Linux中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入。Linux 的管道主要包括两种：无名管道和有名管道。 </p>
<p> <strong>无名管道</strong></p>
<p>无名管道是Linux中管道通信的一种原始方法， 如图 4. 2（ a） 所示， 它具有如下特点。</p>
<ul>
<li>它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）。</li>
<li>它是一个半双工的通信模式，具有固定的读端和写端。</li>
<li>管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的read()和write()等函数。但<br>是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中。</li>
</ul>
<p>有名管道 </p>
<p>有名管道（ FIFO）是对无名管道的一种改进，如图 4.2（ b）所示， 它具有 如下特点。 </p>
<p>（1）它可以使互不相关的两个进程实现彼此通信。</p>
<p>（2）该 管道可以通过路径名来指出，并且在文件系统中是可见 的。在建立 了管道之后，两个进程就可以把它当作普通文件一样进行读写操作，使用 非常方便。 </p>
<p>（3）FIFO严格地遵循先进先出规则，对管道及FIFO的读总是从开始处返回 数据， 对它们的写则把数据添加到末尾。 有名管道不支持如 lseek() 等文件 定位操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-37-18.png" alt="Snipaste_2019-03-03_01-37-18"></p>
<h4 id="无名管道系统编程"><a href="#无名管道系统编程" class="headerlink" title="无名管道系统编程"></a>无名管道系统编程</h4><h5 id="无名管道创建与关闭说明"><a href="#无名管道创建与关闭说明" class="headerlink" title="无名管道创建与关闭说明"></a>无名管道创建与关闭说明</h5><p>无名管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符fds[0]和fds[1]，其中fds[0]<br>固定用于读管道，而fd[1]固定用于写管道，如图8.3 所示，这样就构成了一个半双工的通道。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-40-33.png" alt="Snipaste_2019-03-03_01-40-33"></p>
<p>管道关闭时只需将这两个文件描述符关闭即可，可使用普通的close()函数逐个关闭各个文件描述符。</p>
<p><em>注意：</em>当一个管道共享多对文件描述符时，若将其中的一对读写文件描述符都删除，则该<br>管道就失效。</p>
<h5 id="无名管道创建函数pipe"><a href="#无名管道创建函数pipe" class="headerlink" title="无名管道创建函数pipe()"></a>无名管道创建函数pipe()</h5><p>创建管道可以通过调用pipe()来实现，表8.1 列出了pipe()函数的语法要点。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_01-44-13.png" alt="Snipaste_2019-03-03_01-44-13"></p>
<h5 id="无名管道读写说明"><a href="#无名管道读写说明" class="headerlink" title="无名管道读写说明"></a>无名管道读写说明</h5><p>用pipe()函数创建的管道两端处于一个进程中，由于管道是主要用于在不同进程间通信的，因此这在实际<br>应用中没有太大意义。实际上，通常先是创建一个管道，再通过fork()函数创建一子进程，该子进程会继承<br>父进程所创建的管道，这时，父子进程管道的文件描述符对应关系如图8.4 所示。</p>
<p>此时的关系看似非常复杂，实际上却已经给不同进程之间的读写创造了很好的条件。父子进程分别拥有自己的读写通道，为了实现父子进程之间的读写，只需把无关的读端或写端的文件描述符关闭即可。例如在<br>图8.5 中将父进程的写端fd[1]和子进程的读端fd[0]关闭。此时，父子进程之间就建立起了一条“子进程写“同样，也可以关闭父进程的fd[0]和子进程的fd[1]，这样就可以建立一条“父进程写入子进程读取”的通<br>道。另外，父进程还可以创建多个子进程，各个子进程都继承了相应的fd[0]和fd[1]，这时，只需要关闭<br>相应端口就可以建立其各子进程之间的通道。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_16-13-53.png" alt="Snipaste_2019-03-03_16-13-53"></p>
<p>总结：首先在父进程创建pipe()管道，然后fork()子进程，子进程会继承父进程的pipe()管道，</p>
<p>管道fd[0]为读端,fd[1]为写端。</p>
<p>父进程读入子进程写：将父进程的写端fd[1]和子进程的读端fd[0]关闭即可</p>
<p>父进程写入子进程读：将关闭父进程的读端fd[0]和子进程的写端fd[1]即可</p>
<h5 id="无名管道使用实例"><a href="#无名管道使用实例" class="headerlink" title="无名管道使用实例"></a>无名管道使用实例</h5><p>首先创建管道，之后父进程使用fork()函数创建子进程，之后通过关闭父进程的读描述符和子<br>进程的写描述符，建立起它们之间的父进程写入子进程读管道通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_DATA_LEN 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">char</span> buf[MAX_DATA_LEN];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> data[] = <span class="string">"Pipe Test Program"</span>;</span><br><span class="line">	<span class="keyword">int</span> real_read, real_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span>*)buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建管道 */</span></span><br><span class="line">	<span class="keyword">if</span> (pipe(pipe_fd) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 创建一子进程 */</span></span><br><span class="line">	<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 子进程关闭写描述符，并通过使子进程暂停3s 等待父进程已关闭相应的读描述符 */</span></span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		sleep(DELAY_TIME * <span class="number">3</span>);</span><br><span class="line">		<span class="comment">/* 子进程读取管道内容 */</span></span><br><span class="line">		<span class="keyword">if</span> ((real_read = read(pipe_fd[<span class="number">0</span>], buf, MAX_DATA_LEN)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d bytes read from the pipe is '%s'\n"</span>, real_read, buf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 关闭子进程读描述符 */</span></span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 父进程关闭读描述符，并通过使父进程暂停1s 等待子进程已关闭相应的写描述符 */</span></span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		sleep(DELAY_TIME);</span><br><span class="line">		<span class="keyword">if</span>((real_write = write(pipe_fd[<span class="number">1</span>], data, <span class="built_in">strlen</span>(data))) != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Parent wrote %d bytes : '%s'\n"</span>, real_write, data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*关闭父进程写描述符*/</span></span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">/*收集子进程退出信息*/</span></span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_16-39-41.png" alt="Snipaste_2019-03-03_16-39-41"></p>
<ul>
<li>只有在管道的读端存在时，向管道写入数据才有意义（故上面父进程延时后1s写，子进程3S后读，从而保证管道有写入数据）。否则，向管道写入数据的进程将收到内核<br>传来的SIGPIPE 信号（通常为Broken pipe 错误）。</li>
<li>向管道写入数据时，Linux 将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读取管道缓冲区中的数据，那么写操作将会一直阻塞。</li>
<li>父子进程在运行时，它们的先后次序并不能保证，因此，在这里为了保证父子进程已经关闭了相<br>应的文件描述符，可在两个进程中调用sleep()函数，当然这种调用不是很好的解决方法，在后面<br>学到进程之间的同步与互斥机制。</li>
</ul>
<h4 id="有名管道-FIFO-编程"><a href="#有名管道-FIFO-编程" class="headerlink" title="有名管道(FIFO)编程"></a>有名管道(FIFO)编程</h4><h5 id="有名管道说明"><a href="#有名管道说明" class="headerlink" title="有名管道说明"></a>有名管道说明</h5><p>无名管道它只能用于具有亲缘关系的进程之间，这就大大地限制了管道的使用。有名管道的出现突破了这种限制，它可以使互不相关的两个进程实现彼此通信。该管道可以通过路径名来指出，<br>并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当作普通文件一样进行读写操作，<br>使用非常方便。</p>
<p>不过值得注意的是，FIFO 是严格地遵循先进先出规则的，对管道及FIFO 的读总是从开始<br>处返回数据，对它们的写则把数据添加到末尾，它们不支持如lseek()等文件定位操作。</p>
<p>有名管道的创建可以使用函数mkfifo()，该函数类似文件中的open()操作，可以指定管道的路径和打开的<br>模式。在创建管道成功之后，就可以使用open()、read()和write()这些函数了。</p>
<p>与普通文件的开发设置一样，对于为读而打开的管道可在open()中设置O_RDONLY，对于为写而打开的管道可在open()中设置O_WRONLY，<br>在这里与普通文件不同的是阻塞问题。由于普通文件的读写时不会出现阻塞问题，而在管道的读写中却有<br>阻塞的可能，这里的非阻塞标志可以在open()函数中设定为O_NONBLOCK。下面分别对阻塞打开和非阻<br>塞打开的读写进行讨论。</p>
<p><strong>对于读进程</strong></p>
<ul>
<li>若该管道是阻塞打开，且当前FIFO 内没有数据，则对读进程而言将一直阻塞到有数据写入。</li>
<li>若该管道是非阻塞打开，则不论FIFO 内是否有数据，读进程都会立即执行读操作。即如果FIFO<br>内没有数据，则读函数将立刻返回0。</li>
</ul>
<p><strong>对于写进程</strong></p>
<ul>
<li>若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。</li>
<li>若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。</li>
</ul>
<h5 id="mkfifo-函数格式"><a href="#mkfifo-函数格式" class="headerlink" title="mkfifo()函数格式"></a>mkfifo()函数格式</h5><p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_17-13-26.png" alt="Snipaste_2019-03-03_17-13-26"></p>
<h5 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h5><p>实例包含了两个程序，一个用于读管道，另一个用于写管道。其中在读管道的程序里创建管道，并<br>且作为main()函数里的参数由用户输入要写入的内容。读管道的程序会读出用户写入到管道的内容，这两<br>个程序采用的是阻塞式读写管道模式。</p>
<p>写管道的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_write.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/tmp/myfifo"</span> <span class="comment">/* 有名管道文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF <span class="comment">/*定义在于limits.h 中*/</span></span></span><br><span class="line">i</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> <span class="comment">/*参数为即将写入的字符串*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">int</span> nwrite;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage: ./fifo_write string\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%s"</span>, buff);</span><br><span class="line">	<span class="comment">/* 以只写阻塞方式打开FIFO 管道 */</span></span><br><span class="line">	fd = open(MYFIFO, O_WRONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   	<span class="comment">/*向管道中写入字符串*/</span></span><br><span class="line">	<span class="keyword">if</span> ((nwrite = write(fd, buff, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Write '%s' to FIFO\n"</span>, buff);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读管道程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_read.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFIFO <span class="meta-string">"/tmp/myfifo"</span> <span class="comment">/* 有名管道文件名*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE PIPE_BUF <span class="comment">/*定义在于limits.h 中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> nread;</span><br><span class="line">	<span class="comment">/* 判断有名管道是否已存在，若尚未创建，则以相应的权限创建*/</span></span><br><span class="line">	<span class="keyword">if</span> (access(MYFIFO, F_OK) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((mkfifo(MYFIFO, <span class="number">0666</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Cannot create fifo file\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 以只读阻塞方式打开有名管道 */</span></span><br><span class="line">	fd = open(MYFIFO, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open fifo file error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, buff, MAX_BUFFER_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Read '%s' from FIFO\n"</span>, buff);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-06-52.png" alt="Snipaste_2019-03-03_18-06-52"></p>
<h3 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h3><h4 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h4><p>信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。信号可以直接进行<strong>用户空间进程和内核进程之间的交互</strong>，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。它可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它为止；如果一个<br>信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</p>
<p>信号值在32 之前的则有不同的名称，而信号值在32 以后的都是用“SIGRTMIN”或<br>“SIGRTMAX”开头的，这就是两类典型的信号。前者是从UNIX 系统中继承下来的信号，为不可靠<br>信号（也称为非实时信号）；后者是为了解决前面“不可靠信号”的问题而进行了更改和扩充的信号，<br>称为“可靠信号”（也称为实时信号）。</p>
<p>一个完整的信号生命周期可以分为3 个重要阶段，这3 个阶段由4 个重要事件来刻画的：信号产生、<br>信号在进程中注册、信号在进程中注销、执行信号处理函数，如图8.6 所示。相邻两个事件的时间<br>间隔构成信号生命周期的一个阶段。要注意这里的信号处理有多种方式，一般是由内核完成的，当<br>然也可以由用户进程来完成，故在此没有明确画出</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-12-38.png" alt="Snipaste_2019-03-03_18-12-38"></p>
<p>一个不可靠信号的处理过程是这样的：如果发现该信号已经在进程中注册，那么就忽略该信号。<br>因此，若前一个信号还未注销又产生了相同的信号就会产生信号丢失。而当可靠信号发送给一个进<br>程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号就不会丢失。所有可靠信<br>号都支持排队，而所有不可靠信号都不支持排队。</p>
<p>信号事件的产生有硬件来源（ 比如按下了键盘或者其他硬件故障）和软件来源，常用的信号相关函数 有 kill()、 raise()、 alarm()、 setitimer() 和 sigqueue() 等， 软件来源还包括一些非法 运算等操作。</p>
<p><strong>用户进程对信号的响应（处理）可以有3 种方式。</strong></p>
<ul>
<li>忽略信号，即对信号不做任何处理，但是有两个信号不能忽略，即SIGKILL 及SIGSTOP。</li>
<li>捕捉信号，定义信号处理函数，当信号发生时，执行相应的自定义处理函数。</li>
<li>执行缺省操作，Linux 对每种信号都规定了默认操作。</li>
</ul>
<p>Linux 中的大多数信号是提供给内核的，表8.6 列出了Linux 中最为常见信号的含义及其默认操作。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_18-23-38.png" alt="Snipaste_2019-03-03_18-23-38"></p>
<h4 id="信号发送与捕捉"><a href="#信号发送与捕捉" class="headerlink" title="信号发送与捕捉"></a>信号发送与捕捉</h4><p>发送信号的函数主要有 kill()、raise()、alarm()以及pause()</p>
<h5 id="kill-和raise"><a href="#kill-和raise" class="headerlink" title="kill()和raise()"></a>kill()和raise()</h5><p><strong>函数说明</strong></p>
<p>kill()函数同读者熟知的kill 系统命令一样，可以发送信号给进程或进程组（实际上，kill 系统命令只是kill()<br>函数的一个用户接口）。这里需要注意的是，它不仅可以中止进程（实际上发出SIGKILL 信号），也可以向<br>进程发送其他信号。</p>
<p>与kill()函数所不同的是，raise()函数允许进程向自身发送信号。</p>
<p><strong>kill()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-11-22.png" alt="Snipaste_2019-03-03_19-11-22"></p>
<p><strong>raise()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-13-57.png" alt="Snipaste_2019-03-03_19-13-57"></p>
<h5 id="实例kill-raise-c"><a href="#实例kill-raise-c" class="headerlink" title="实例kill_raise.c"></a>实例kill_raise.c</h5><p>首先使用fork()创建了一个子进程，接着为了保证子进程不在父进程调用kill()之前退出，在<br>子进程中使用raise()函数向自身发送SIGSTOP 信号，使子进程暂停。接下来再在父进程中调用kill()向子<br>进程发送信号，在该示例中使用的是SIGKILL，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kill_raise.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">/* 创建一子进程 */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fork error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 在子进程中使用raise()函数发出SIGSTOP 信号,使子进程暂停 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child(pid : %d) is waiting for any signal\n"</span>, getpid());</span><br><span class="line">		raise(SIGSTOP);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">/* 在父进程中收集子进程发出的信号，并调用kill()函数进行相应的操作 */</span></span><br><span class="line">		<span class="keyword">if</span> ((waitpid(pid, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((ret = kill(pid, SIGKILL)) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Parent kill %d\n"</span>,pid);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-34-36.png" alt="Snipaste_2019-03-03_19-34-36"></p>
<h5 id="alarm-和pause"><a href="#alarm-和pause" class="headerlink" title="alarm()和pause()"></a>alarm()和pause()</h5><p><strong>函数说明</strong></p>
<p>alarm()也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它就向进程发送<br>SIGALARM 信号。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm()之前已设置过闹钟时<br>间，则任何以前的闹钟时间都被新值所代替。</p>
<p>pause()函数是用于将调用进程挂起直至捕捉到信号为止。这个函数很常用，通常可以用于判断信号是否已<br>到。</p>
<p><strong>alarm()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-40-34.png" alt="Snipaste_2019-03-03_19-40-34"></p>
<p><strong>pause()函数格式</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-40-40.png" alt="Snipaste_2019-03-03_19-40-40"></p>
<h5 id="实例：alarm-pause-c"><a href="#实例：alarm-pause-c" class="headerlink" title="实例：alarm_ pause. c"></a>实例：alarm_ pause. c</h5><p>该实例实际上已完成了一个简单的sleep()函数的功能，由于SIGALARM 默认的系统动作为终止该进程，<br>因此程序在打印信息之前，就会被结束了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* alarm_pause.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*调用alarm 定时器函数*/</span></span><br><span class="line">	<span class="keyword">int</span> ret = alarm(<span class="number">5</span>);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"I have been waken up：%d.\n"</span>,ret); <span class="comment">/* 此语句不会被执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_19-50-30.png" alt="Snipaste_2019-03-03_19-50-30"></p>
<p>总结：pause()函数会将进程挂起直至捕捉到信号为止，而aiarm(5)函数会在进程中设置一个定时，5s后它就向进程发送<br>SIGALARM 信号终止进程。因此进程在pause()时会挂机不会打印信息，而5秒后记时到alarm(5)会发送SIGALARM终止进程。</p>
<h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>一个进程可以决定在该进程中需要对哪些信号进行什么样的操作(忽略，捕抓，以及缺省操作)。，另外，一个进程还可以选择如何处理信号(信号的处理)。</p>
<h5 id="函数说明-signal-amp-gaction"><a href="#函数说明-signal-amp-gaction" class="headerlink" title="函数说明(signal&amp;gaction)"></a>函数说明(signal&amp;gaction)</h5><p>使用signal()函数处理时，只需要指出要处理的信号和处理函数即可。它主要是用于前32 种非实时信号的<br>处理，不支持信号传递信息，但是由于使用简单、易于理解，因此也受到很多程序员的欢迎。</p>
<p>Linux 还支持一个更健壮、更新的信号处理函数sigaction()，推荐使用该函数。</p>
<h5 id="函数格式"><a href="#函数格式" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>signal()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-07-56.png" alt="Snipaste_2019-03-03_20-07-56"></p>
<p>这里需要对这个函数原型进行说明。这个函数原型有点复杂。可先用如下的typedef 进行替换说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里需要对这个函数原型进行说明。这个函数原型有点复杂。可先用如下的<span class="keyword">typedef</span> 进行替换说明：</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">sign *<span class="title">signal</span><span class="params">(<span class="keyword">int</span>, handler *)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>gaction()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-16-54.png" alt="Snipaste_2019-03-03_20-16-54"></p>
<p>sigaction()函数中第2 个和第3 个参数中使用到sigaction 结构。这是一个看似非常复杂的结<br>构，要注意初始化。</p>
<p>sigaction 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span> signo);</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="keyword">int</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restore)(<span class="keyword">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sa_handler ：</strong>是一个函数指针，指定信号处理函数，这里除可以是用户自定义的处理函数外，还可以为<br>SIG_DFL（采用缺省的处理方式）或SIG_IGN（忽略信号）。它的处理函数只有一个参数，即信号值(signum)。</p>
<p><strong>sa_mask:</strong> 是一个信号集，它可以指定在信号处理程序执行过程中哪些信号应当被屏蔽，在调用信号捕获函<br>数之前，该信号集要加入到信号的信号屏蔽字中。</p>
<p><strong>sa_flags:</strong> 中包含了许多标志位，是对信号进行处理的各个选择项。它的常见可选值如表8.13 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-28-23.png" alt="Snipaste_2019-03-03_20-28-23"></p>
<h5 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h5><p>第一个实例表明了如何使用signal()函数捕捉相应信号，并做出给定的处理。这里，my_func 就是信号处理<br>的函数指针。读者还可以将其改为SIG_IGN 或SIG_DFL 查看运行结果。第二个实例是用sigaction()函数<br>实现同样的功能。</p>
<p><strong>signal()函数实例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*自定义信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign_no == SIGINT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign_no == SIGQUIT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or 	SIGQUIT...\n"</span>);</span><br><span class="line">	<span class="comment">/* 发出相应的信号，并跳转到信号处理函数处 */</span></span><br><span class="line">	signal(SIGINT, my_func);</span><br><span class="line">	signal(SIGQUIT, my_func);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_20-34-15.png" alt="Snipaste_2019-03-03_20-34-15"></p>
<p>SIGINT （按ctrl-c 组合键触发）</p>
<p>SIGQUIT （按ctrl-\ 组合键触发）</p>
<p>详细参考上面：表8.6 Linux 常见信号的含义及其默认操作</p>
<p>sigaction()函数实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*自定义信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> sign_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign_no == SIGINT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGINT\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sign_no == SIGQUIT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"I have get SIGQUIT\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Waiting for signal SIGINT or 	SIGQUIT...\n"</span>);</span><br><span class="line">	<span class="comment">/* sigaction 结构初始化 */</span></span><br><span class="line">	action.sa_handler = my_func;</span><br><span class="line">	sigemptyset(&amp;action.sa_mask);</span><br><span class="line">	action.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 发出相应的信号，并跳转到信号处理函数处 */</span></span><br><span class="line">	sigaction(SIGINT, &amp;action, <span class="number">0</span>);</span><br><span class="line">	sigaction(SIGQUIT, &amp;action, <span class="number">0</span>);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果同上</p>
<h4 id="信号集函数组"><a href="#信号集函数组" class="headerlink" title="信号集函数组"></a>信号集函数组</h4><p>略</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量的使用主要是用来保护共享资源,使得资源在一个时刻只有一个进程(线程)所拥有，</p>
<h4 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h4><p>　在多线程或者多进程编程中，有一个非常需要关注的东西，那就是同步以及互斥问题。</p>
<p>　　同步是指多个进程之间的协作，而互斥是指多个进程之间，为了争夺有限的资源，而进行的竞争。</p>
<p>​    进程之间的互斥与同步关系存在的根源在于临界资源。临界资源是在同一个时刻只允许有限个（通常只有<br>一个）进程可以访问（读）或修改（写）的资源，通常包括硬件资源（处理器、内存、存储器以及其他外<br>围设备等）和软件资源（共享代码段，共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本<br>身也会成为临界资源。</p>
<p>​    信号量就是用来解决进程之间的同步与互斥问题的一种进程之间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（PV 操作）。其中信号量对应于某一<br>种资源，取一个非负的整型值。<strong>信号量值指的是当前可用的该资源的数量，若它等于0 则意味着目前没有可</strong><br><strong>用的资源。</strong></p>
<p><strong>PV 原子操作的具体定义如下：</strong></p>
<p>P 操作：如果有可用的资源（信号量值&gt;0），则占用一个资源（给信号量值减去一，进入临界区代码）;如<br>果没有可用的资源（信号量值等于0），则被阻塞到，直到系统将资源分配给该进程（进入等待队列，一直<br>等到资源轮到该进程）。</p>
<p>V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程。如果没有进程等待它，<br>则释放一个资源（给信号量值加一）。</p>
<h4 id="信号量的编程"><a href="#信号量的编程" class="headerlink" title="信号量的编程"></a>信号量的编程</h4><h5 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h5><p>在Linux 系统中，使用信号量通常分为以下几个步骤。</p>
<p>​    （1）创建信号量或获得在系统已存在的信号量，此时需要调用semget()函数。不同进程通过使用同一个信<br>号量键值来获得同一个信号量。</p>
<p>​    （2）初始化信号量，此时使用semctl()函数的SETVAL 操作。当使用二维信号量时，通常将信号量初始化<br>为1。</p>
<p>​    （3）进行信号量的PV 操作，此时调用semop()函数。这一步是实现进程之间的同步和互斥的核心工作部<br>分。</p>
<p>​    （4）如果不需要信号量，则从系统中删除它，此时使用semclt()函数的IPC_RMID 操作。此时需要注意，<br>在程序中不应该出现对已经被删除的信号量的操作</p>
<h5 id="函数格式-1"><a href="#函数格式-1" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>semget()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-20-27.png" alt="Snipaste_2019-03-03_21-20-27"></p>
<p><strong>semctl()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-22-47.png" alt="Snipaste_2019-03-03_21-22-47"></p>
<p><strong>semop()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-23-31.png" alt="Snipaste_2019-03-03_21-23-31"></p>
<h5 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><h4 id="共享内存概述"><a href="#共享内存概述" class="headerlink" title="共享内存概述"></a>共享内存概述</h4><p>​    共享内存是一种最为高效的进程间通信方式。因为进程可以直接读写内存，不需要任何数据<br>的复制。为了在多个进程间交换信息，内核专门留出了一块内存区。这段内存区可以由需要访问的进<br>程将其映射到自己的私有地址空间。因此，进程就可以直接读写这一内存区而不需要进行数据的复制，<br>从而大大提高了效率。当然，由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁<br>和信号量等（请参考本章的共享内存实验）。其原理示意图如图8.8 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-36-13.png" alt="Snipaste_2019-03-03_21-36-13"></p>
<h4 id="共享内存编程"><a href="#共享内存编程" class="headerlink" title="共享内存编程"></a>共享内存编程</h4><h5 id="编程步骤-1"><a href="#编程步骤-1" class="headerlink" title="编程步骤"></a>编程步骤</h5><p>共享内存的实现分为两个步骤：</p>
<ul>
<li><p>第一步是创建共享内存，这里用到的函数是shmget()，也就是从内存中获<br>得一段共享内存区域，</p>
</li>
<li><p>第二步映射共享内存，也就是把这段创建的共享内存映射到具体的进程空间中，这<br>里使用的函数是shmat()。</p>
<p>到这里，就可以使用这段共享内存了，也就是可以使用不带缓冲的I/O 读写命令<br>对其进行操作。除此之外，当然还有撤销映射的操作，其函数为shmdt()。这里就主要介绍这3 个函数。</p>
</li>
</ul>
<h5 id="函数格式-2"><a href="#函数格式-2" class="headerlink" title="函数格式"></a>函数格式</h5><p><strong>shmget()函</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-12.png" alt="Snipaste_2019-03-03_21-40-12"></p>
<p><strong>shmat()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-23.png" alt="Snipaste_2019-03-03_21-40-23"></p>
<p><strong>shmdt()函</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_21-40-28.png" alt="Snipaste_2019-03-03_21-40-28"></p>
<h5 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h5><p>该实例说明如何使用基本的共享内存函数。</p>
<p>首先是创建一个共享内存区（采用的共享内存的键值为<br>IPC_PRIVATE，是因为本实例中创建的共享内存是父子进程之间的共用部分），之后创建子进程，在<br>父子两个进程中将共享内存分别映射到各自的进程地址空间之中。<br>父进程先等待用户输入，然后将用户输入的字符串写入到共享内存，之后往共享内存的头部写入<br>“WROTE” 字符串表示父进程已成功写入数据。子进程一直等到共享内存的头部字符串为<br>“WROTE”，然后将共享内存的有效数据（在父进程中用户输入的字符串）在屏幕上打印。父子两<br>个进程在完成以上工作之后，分别解除与共享内存的映射关系。<br>最后在子进程中删除共享内存。因为共享内存自身并不提供同步机制，所以应该额外实现不同进程之间的<br>同步（例如：信号量）。为了简单起见，在本实例中用标志字符串来实现非常简单的父子进程之间的同步。<br>这里要介绍的一个命令是ipcs，这是用于报告进程间通信机制状态的命令。它可以查看共享内存、消息队<br>列等各种进程间通信机制的情况，这里使用了system()函数用于调用shell 命令“ipcs”。</p>
<p>程序源代码如下所<br>示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* shmem.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> shmid;</span><br><span class="line">	<span class="keyword">char</span> *shm_addr;</span><br><span class="line">	<span class="keyword">char</span> flag[] = <span class="string">"WROTE"</span>;</span><br><span class="line">	<span class="keyword">char</span> *buff;</span><br><span class="line">	<span class="comment">/* 创建共享内存 */</span></span><br><span class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, BUFFER_SIZE, <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create shared-memory: %d\n"</span>,shmid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 显示共享内存情况 */</span></span><br><span class="line">	system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"fork"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">/* 子进程处理 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*映射共享内存*/</span></span><br><span class="line">		<span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Child: shmat"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Child: Attach shared-memory: %p\n"</span>, shm_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">		<span class="comment">/* 通过检查在共享内存的头部是否标志字符串"WROTE"来确认</span></span><br><span class="line"><span class="comment">		父进程已经向共享内存写入有效数据 */</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">strncmp</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Child: Wait for enable data...\n"</span>);</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 获取共享内存的有效数据并显示 */</span></span><br><span class="line">		<span class="built_in">strcpy</span>(buff, shm_addr + <span class="built_in">strlen</span>(flag));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Child: Shared-memory :%s\n"</span>, buff);</span><br><span class="line">		<span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">		<span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"shmdt"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Child: Deattach shared-memory\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">		<span class="comment">/* 删除共享内存 */</span></span><br><span class="line">		<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Child: shmctl(IPC_RMID)\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Delete shared-memory\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* 父进程处理 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*映射共享内存*/</span></span><br><span class="line">		<span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"Parent: shmat"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Parent: Attach shared-memory: %p\n"</span>, shm_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\nInput some string:\n"</span>);</span><br><span class="line">		fgets(buff, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">		<span class="built_in">strncpy</span>(shm_addr + <span class="built_in">strlen</span>(flag), buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">		<span class="built_in">strncpy</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag));</span><br><span class="line">		<span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">		<span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		perror(<span class="string">"Parent: shmdt"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Parent: Deattach shared-memory\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Finished\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这章也不是很懂</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>略吧。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>重点，开单独一章讲</p>
<h1 id="第三章：线程"><a href="#第三章：线程" class="headerlink" title="第三章：线程"></a>第三章：线程</h1><h2 id="Linux-线程概述"><a href="#Linux-线程概述" class="headerlink" title="Linux 线程概述"></a>Linux 线程概述</h2><h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><p>​    进程是系统中程序执行和资源分配的基本单位。每个进程都拥有自己的数据段、代码段和堆<br>栈段，这就造成了进程在进行切换等操作时都需要有比较复杂的上下文切换等动作。为了进一步减少处理机<br>的空转时间，支持多处理器以及减少上下文切换开销，进程在演化中出现了另一个概念——线程。</p>
<ul>
<li>线程<br>内独立的一条运行路线，处理器调度的最小单元，也可以称为轻量级进程。</li>
<li>线程可以对进程的内存空间和资<br>源进行访问，并与同一进程中的其他线程共享。因此，线程的上下文切换的开销比创建进程小很多。</li>
<li>同进程一样，线程也将相关的执行状态和存储变量放在线程控制表内。一个进程可以有多个线程，也就是有<br>多个线程控制表及堆栈寄存器，但却共享一个用户地址空间。</li>
</ul>
<p>要注意的是，由于线程共享了进程的资源和地<br>址空间，因此，任何线程对系统资源的操作都会给其他线程带来影响。由此可知，多线程中的同步是非常重要的问题。在多线程系统中，进程与进程的关系如图9.1 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_22-56-29.png" alt="Snipaste_2019-03-03_22-56-29"></p>
<h3 id="线程机制的分类和特性"><a href="#线程机制的分类和特性" class="headerlink" title="线程机制的分类和特性"></a>线程机制的分类和特性</h3><p>线程按照其调度者可以分为用户级线程和核心级线程两种。</p>
<p>（1）用户级线程。<br>用户级线程主要解决的是上下文切换的问题，它的调度算法和调度过程全部由用户自行选择决定，在运行<br>时不需要特定的内核支持。在这里，操作系统往往会提供一个用户空间的<strong>线程库</strong>，该线程库提供了线程的<br>创建、调度和撤销等功能，而内核仍然仅对进程进行管理。如果一个进程中的某一个线程调用了一个阻塞<br>的系统调用函数，那么该进程包括该进程中的其他所有线程也同时被阻塞。这种用户级线程的主要缺点是<br>在一个进程中的多个线程的调度中无法发挥多处理器的优势。</p>
<p>（2）轻量级进程。<br>轻量级进程是内核支持的用户线程，是内核线程的一种抽象对象。每个线程拥有一个或多个轻量级线程，<br>而每个轻量级线程分别被绑定在一个内核线程上。</p>
<p>（3）内核线程。<br>这种线程允许不同进程中的线程按照同一相对优先调度方法进行调度，这样就可以发挥多处理器的并发优<br>势。</p>
<h2 id="Linux-线程编程"><a href="#Linux-线程编程" class="headerlink" title="Linux 线程编程"></a>Linux 线程编程</h2><p>在Linux 中，使用的read 线程库是一套通用的线<br>程库，是由POSIX 提出的，因此具有很好的可移植性。(线程开发并非内核提供，而是由POSIX 提供的线程库支持的。）</p>
<h3 id="线程函数说明"><a href="#线程函数说明" class="headerlink" title="线程函数说明"></a>线程函数说明</h3><p><strong>1. pthread_create()：创建线程</strong></p>
<p>​    创建线程实际上就是确定调用该线程函数的入口点，这里通常使用的函数是 pthread_create()。在线程创建<br>以后，就开始运行相关的线程函数，在该函数运行完之后，该线程也就退出了，这也是线程退出一种方法。<br>另一种退出线程的方法是使用函数pthread_exit()，这是线程的主动行为。</p>
<p><strong>*注意：</strong>在使用线程函<em>
</em>数时，不能随意使用exit()退出函数进行出错处理，由于exit()的作用是使调用进程终止，往往一个进程包<em>
</em>含多个线程，因此，在使用exit()之后，该进程中的所有线程都终止了。因此，在线程中就可以使用<em>
</em>pthread_exit()来代替进程中的exit()。*</p>
<p><strong>2. pthread_join()可以用于将当前线程挂起来等待线程的结束</strong></p>
<p>​    由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放。正如进程之间可以用wait()系统调用来同步终止并释放资源一样，线<br>程之间也有类似机制，那就是pthread_join()函数。</p>
<p>​    pthread_join()可以用于将当前线程挂起来等待线程的结束。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函<br>数返回时，被等待线程的资源就被收回。</p>
<p><strong>3. 线程调用 pthread_exit()函数主动终止自身线程</strong></p>
<p><strong>4.调用pthread_cancel()函数终止另一个线程</strong></p>
<p>​    线程调用 pthread_exit()函数主动终止自身线程。但是在很多线程应用中，经常会遇到在别的线<br>程中要终止另一个线程的执行的问题。此时调用pthread_cancel()函数实现这种功能，但在被取消的线程的<br>内部需要调用pthread_setcancel()函数和pthread_setcanceltype()函数设置自己的取消状态，例如被取消的线<br>程接收到另一个线程的取消请求之后，是接受还是忽略这个请求；如果接受，是立刻进行终止操作还是等<br>待某个函数的调用等。</p>
<h3 id="函数格式-3"><a href="#函数格式-3" class="headerlink" title="函数格式"></a><strong>函数格式</strong></h3><p><strong>pthread_create()</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-13-26.png" alt="Snipaste_2019-03-03_23-13-26"></p>
<p><strong>pthread_exit()</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-13-53.png" alt="Snipaste_2019-03-03_23-13-53"></p>
<p><strong>pthread_join()</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-14-04.png" alt="Snipaste_2019-03-03_23-14-04"></p>
<p><strong>pthread_cancel</strong>()</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-03_23-14-12.png" alt="Snipaste_2019-03-03_23-14-12"></p>
<h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><p>创建最简单对三线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sharedi = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num3</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">pthread_t</span> thrd1, thrd2, thrd3;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;thrd1, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)increse_num1, <span class="literal">NULL</span>);</span><br><span class="line">    ret = pthread_create(&amp;thrd2, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)increse_num2, <span class="literal">NULL</span>);</span><br><span class="line">    ret = pthread_create(&amp;thrd3, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)increse_num3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(thrd1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thrd2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thrd3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num1</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"线程1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num2</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"线程2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increse_num3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"线程3\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下实例中创建了 3 个线程，为了更好地描述线程之间的并行执行，让3 个线程重用同一个执行函数。每<br>个线程都有5 次循环（可以看成5 个小任务），每次循环之间会随机等待1～10s 的时间，意义在于模拟每<br>个任务的到达时间是随机的，并没有任何特定规律。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER 3 <span class="comment">/*线程数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER 5 <span class="comment">/*每个线程中的小任务数*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS 10.0 <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 线程函数例程 */</span></span><br><span class="line">	<span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line">	<span class="keyword">int</span> delay_time = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">		sleep(delay_time);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>,</span><br><span class="line">		thrd_num, count, delay_time);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line">	<span class="keyword">void</span> * thrd_ret;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 创建多线程 */</span></span><br><span class="line">		res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line">			<span class="built_in">exit</span>(res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 等待线程结束 */</span></span><br><span class="line">		res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">		<span class="keyword">if</span> (!res)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：delay_time = (int)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + 1;//随机1~10 的一个数给delay_time</span></span><br></pre></td></tr></table></figure>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-01-24.png" alt="Snipaste_2019-03-04_00-01-24"></p>
<h2 id="线程之间的同步与互斥"><a href="#线程之间的同步与互斥" class="headerlink" title="线程之间的同步与互斥"></a>线程之间的同步与互斥</h2><p>​    由于线程共享进程的资源和地址空间，因此在对这些资源进行操作时，必须考虑到线程间资源访问的同步<br>与互斥问题。这里主要介绍 POSIX 中两种线程同步机制，分别为互斥锁和信号量。这两个同步机制可以互<br>相通过调用对方来实现，<strong>但互斥锁更适合用于同时可用的资源是惟一的情况；信号量更适合用于同时可用</strong><br><strong>的资源为多个的情况。</strong></p>
<h3 id="互斥锁线程控制"><a href="#互斥锁线程控制" class="headerlink" title="互斥锁线程控制"></a>互斥锁线程控制</h3><p>函数说明</p>
<p>​    互斥锁是用一种简单的加锁方法来控制对共享资源的原子操作。这个互斥锁只有两种状态，也就是上锁和<br>解锁，可以把互斥锁看作某种意义上的全局变量。</p>
<p>​    在同一时刻只能有一个线程掌握某个互斥锁，拥有上锁状态的线程能够对共享资源进行操作。若其他线程希望<strong>上锁一个已经被上锁的互斥锁</strong>，则该线程就会挂起，<br>直到上锁的线程释放掉互斥锁为止。可以说，这把互斥锁保证让每个线程对共享资源按顺序进行原子操作</p>
<p>互斥锁机制主要包括下面的基本函数。</p>
<ul>
<li>互斥锁初始化：pthread_mutex_init()</li>
<li>互斥锁上锁：pthread_mutex_lock()</li>
<li>互斥锁判断上锁：pthread_mutex_trylock()</li>
<li>互斥锁解锁：pthread_mutex_unlock()</li>
<li>消除互斥锁：pthread_mutex_destroy()</li>
</ul>
<p>互斥锁可以分为快速互斥锁、递归互斥锁和检错互斥锁。</p>
<p>这3 种锁的区别主要在于其他未占有互斥<br>锁的线程在希望得到互斥锁时是否需要阻塞等待。</p>
<ul>
<li>快速锁是指调用线程会阻塞直至拥有互斥锁的线程解锁<br>为止。</li>
<li>递归互斥锁能够成功地返回，并且增加调用线程在互斥上加锁的次数，</li>
<li>而检错互斥锁则为快速互斥<br>锁的非阻塞版本，它会立即返回并返回一个错误信息。默认属性为快速互斥锁。</li>
</ul>
<p><strong>函数格式</strong></p>
<p><strong>pthread_mutex_init()函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-33-34.png" alt="Snipaste_2019-03-04_00-33-34"></p>
<p><strong>pthread_mutex_lock()等函数</strong></p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_00-33-41.png" alt="Snipaste_2019-03-04_00-33-41"></p>
<h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>下面的实例是在 上面示例代码的基础上增加互斥锁功能，实现原本独立与无序的多个线程能够按顺<br>序执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*thread_mutex.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUMBER 3 <span class="comment">/* 线程数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPEAT_NUMBER 3 <span class="comment">/* 每个线程的小任务数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_TIME_LEVELS 10.0 <span class="comment">/*小任务之间的最大时间间隔*/</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> thrd_num = (<span class="keyword">int</span>)arg;</span><br><span class="line">	<span class="keyword">int</span> delay_time = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="comment">/* 互斥锁上锁 */</span></span><br><span class="line">	res = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Thread %d lock failed\n"</span>, thrd_num);</span><br><span class="line">		pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Thread %d is starting\n"</span>, thrd_num);</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; REPEAT_NUMBER; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		delay_time = (<span class="keyword">int</span>)(rand() * DELAY_TIME_LEVELS/(RAND_MAX)) + <span class="number">1</span>;</span><br><span class="line">		sleep(delay_time);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\tThread %d: job %d delay = %d\n"</span>,</span><br><span class="line">		thrd_num, count, delay_time);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Thread %d finished\n"</span>, thrd_num);</span><br><span class="line">		pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread[THREAD_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> no = <span class="number">0</span>, res;</span><br><span class="line">	<span class="keyword">void</span> * thrd_ret;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">/* 互斥锁初始化 */</span>	</span><br><span class="line">	pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)	</span><br><span class="line">	&#123;	</span><br><span class="line">		res = pthread_create(&amp;thread[no], <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)no);</span><br><span class="line">		<span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Create thread %d failed\n"</span>, no);</span><br><span class="line">			<span class="built_in">exit</span>(res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create treads success\n Waiting for threads to finish...\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (no = <span class="number">0</span>; no &lt; THREAD_NUMBER; no++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = pthread_join(thread[no], &amp;thrd_ret);</span><br><span class="line">		<span class="keyword">if</span> (!res)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d joined\n"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Thread %d join failed\n"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 互斥锁解锁 */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	&#125;	</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>失败：后面线程没信息，原因不明，</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_01-09-37.png" alt="Snipaste_2019-03-04_01-09-37"></p>
<p>正确结果应该：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span>: job <span class="number">0</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">1</span> delay = <span class="number">7</span></span><br><span class="line">Thread <span class="number">0</span>: job <span class="number">2</span> delay = <span class="number">6</span></span><br><span class="line">Thread <span class="number">0</span> finished</span><br><span class="line">Thread <span class="number">0</span> joined</span><br><span class="line">Thread <span class="number">1</span> is starting</span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">0</span> delay = <span class="number">3</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">1</span> delay = <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span>: job <span class="number">2</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">1</span> finished</span><br><span class="line">Thread <span class="number">1</span> joined</span><br><span class="line">Thread <span class="number">2</span> is starting</span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">0</span> delay = <span class="number">6</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">1</span> delay = <span class="number">10</span></span><br><span class="line">Thread <span class="number">2</span>: job <span class="number">2</span> delay = <span class="number">8</span></span><br><span class="line">Thread <span class="number">2</span> finished</span><br><span class="line">Thread <span class="number">2</span> joined</span><br></pre></td></tr></table></figure>
<h3 id="信号量线程控制"><a href="#信号量线程控制" class="headerlink" title="信号量线程控制"></a>信号量线程控制</h3><h4 id="信号量说"><a href="#信号量说" class="headerlink" title="信号量说"></a>信号量说</h4><p>​    信号量也就是操作系统中所用到的PV 原子操作，它广泛用于进程或线程间的同步与互斥。信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。这里先来简单复习一<br>下PV 原子操作的工作原理。<br>PV 原子操作是对整数计数器信号量sem 的操作。一次P 操作使sem 减一，而一次V 操作使sem 加一。<br>进程（或线程）根据信号量的值来判断是否对公共资源具有访问权限。当信号量sem 的值大于等于零<br>时，该进程（或线程）具有公共资源的访问权限；相反，当信号量sem 的值小于零时，该进程（或线<br>程）就将阻塞直到信号量sem 的值大于等于0 为止。<br>PV 原子操作主要用于进程或线程间的同步和互斥这两种典型情况。若用于互斥，几个进程（或线程）往<br>往只设置一个信号量sem，它们的操作流程如图9.2 所示。<br>当信号量用于同步操作时，往往会设置多个信号量，并安排不同的初始值来实现它们之间的顺序执行，它<br>们的操作流程如图9.3 所示。</p>
<p><img src="D:\MyBlog\图片\Snipaste_2019-03-04_01-14-08.png" alt="Snipaste_2019-03-04_01-14-08"></p>
<p>略</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2>
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/unix下输入与输出-I-0.html" rel="next" title="unix下输入与输出(I/0)">
                <i class="fa fa-chevron-left"></i> unix下输入与输出(I/0)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/嵌入式Linux网络编程.html" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jeff Wu">
            
              <p class="site-author-name" itemprop="name">Jeff Wu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/SetCalm" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/calm-16-25/activities" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章：Linux-多任务-编程"><span class="nav-number">1.</span> <span class="nav-text">第一章：Linux 多任务 编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux下多任务简介"><span class="nav-number">1.1.</span> <span class="nav-text">Linux下多任务简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务"><span class="nav-number">1.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">1.3.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制符"><span class="nav-number">1.4.</span> <span class="nav-text">进程控制符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">1.5.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章：进程"><span class="nav-number">2.</span> <span class="nav-text">第二章：进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节：创建新进程"><span class="nav-number">2.1.</span> <span class="nav-text">第一节：创建新进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数fork（创建）"><span class="nav-number">2.1.1.</span> <span class="nav-text">函数fork（创建）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-vfork（创建）"><span class="nav-number">2.1.2.</span> <span class="nav-text">函数 vfork（创建）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execl"><span class="nav-number">2.1.3.</span> <span class="nav-text">execl()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数-wait-和-waitpid（阻塞）"><span class="nav-number">2.1.4.</span> <span class="nav-text">函数 wait 和 waitpid（阻塞）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节：守护进程"><span class="nav-number">2.2.</span> <span class="nav-text">第二节：守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写守护进程"><span class="nav-number">2.2.1.</span> <span class="nav-text">编写守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#守护进程调式"><span class="nav-number">2.2.2.</span> <span class="nav-text">守护进程调式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例1：编写多进程程序"><span class="nav-number">2.2.3.</span> <span class="nav-text">实例1：编写多进程程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例2：创建守护进程"><span class="nav-number">2.2.4.</span> <span class="nav-text">实例2：创建守护进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节：进程间通信"><span class="nav-number">2.3.</span> <span class="nav-text">第三节：进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道通信"><span class="nav-number">2.3.1.</span> <span class="nav-text">管道通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管道概述"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">管道概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无名管道系统编程"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">无名管道系统编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#无名管道创建与关闭说明"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">无名管道创建与关闭说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无名管道创建函数pipe"><span class="nav-number">2.3.1.2.2.</span> <span class="nav-text">无名管道创建函数pipe()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无名管道读写说明"><span class="nav-number">2.3.1.2.3.</span> <span class="nav-text">无名管道读写说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无名管道使用实例"><span class="nav-number">2.3.1.2.4.</span> <span class="nav-text">无名管道使用实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有名管道-FIFO-编程"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">有名管道(FIFO)编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#有名管道说明"><span class="nav-number">2.3.1.3.1.</span> <span class="nav-text">有名管道说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mkfifo-函数格式"><span class="nav-number">2.3.1.3.2.</span> <span class="nav-text">mkfifo()函数格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用实例"><span class="nav-number">2.3.1.3.3.</span> <span class="nav-text">使用实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号通信"><span class="nav-number">2.3.2.</span> <span class="nav-text">信号通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号概述"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">信号概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号发送与捕捉"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">信号发送与捕捉</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#kill-和raise"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">kill()和raise()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例kill-raise-c"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">实例kill_raise.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#alarm-和pause"><span class="nav-number">2.3.2.2.3.</span> <span class="nav-text">alarm()和pause()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例：alarm-pause-c"><span class="nav-number">2.3.2.2.4.</span> <span class="nav-text">实例：alarm_ pause. c</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号的处理"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">信号的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数说明-signal-amp-gaction"><span class="nav-number">2.3.2.3.1.</span> <span class="nav-text">函数说明(signal&amp;gaction)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数格式"><span class="nav-number">2.3.2.3.2.</span> <span class="nav-text">函数格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用实例-1"><span class="nav-number">2.3.2.3.3.</span> <span class="nav-text">使用实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号集函数组"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">信号集函数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">2.3.3.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量概述"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">信号量概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量的编程"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">信号量的编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#编程步骤"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">编程步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数格式-1"><span class="nav-number">2.3.3.2.2.</span> <span class="nav-text">函数格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用实例-2"><span class="nav-number">2.3.3.2.3.</span> <span class="nav-text">使用实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存"><span class="nav-number">2.3.4.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存概述"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">共享内存概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存编程"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">共享内存编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#编程步骤-1"><span class="nav-number">2.3.4.2.1.</span> <span class="nav-text">编程步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数格式-2"><span class="nav-number">2.3.4.2.2.</span> <span class="nav-text">函数格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用实例-3"><span class="nav-number">2.3.4.2.3.</span> <span class="nav-text">使用实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-number">2.3.5.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字"><span class="nav-number">2.3.6.</span> <span class="nav-text">套接字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章：线程"><span class="nav-number">3.</span> <span class="nav-text">第三章：线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-线程概述"><span class="nav-number">3.1.</span> <span class="nav-text">Linux 线程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程概述"><span class="nav-number">3.1.1.</span> <span class="nav-text">线程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程机制的分类和特性"><span class="nav-number">3.1.2.</span> <span class="nav-text">线程机制的分类和特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-线程编程"><span class="nav-number">3.2.</span> <span class="nav-text">Linux 线程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程函数说明"><span class="nav-number">3.2.1.</span> <span class="nav-text">线程函数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数格式-3"><span class="nav-number">3.2.2.</span> <span class="nav-text">函数格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数实例"><span class="nav-number">3.2.3.</span> <span class="nav-text">函数实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程之间的同步与互斥"><span class="nav-number">3.3.</span> <span class="nav-text">线程之间的同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁线程控制"><span class="nav-number">3.3.1.</span> <span class="nav-text">互斥锁线程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用实例-4"><span class="nav-number">3.3.2.</span> <span class="nav-text">使用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量线程控制"><span class="nav-number">3.3.3.</span> <span class="nav-text">信号量线程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量说"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">信号量说</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程属性"><span class="nav-number">3.4.</span> <span class="nav-text">线程属性</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeff Wu</span>

  

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
